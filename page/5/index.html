<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="“你好，我是李帅奇，Android 系统工程师，MineCraft 忠实玩家，设计和绘画爱好者，缺妹纸晚期患者，熬夜星人。”"><meta name="keywords" content=""><meta name="author" content="Coolqi.Li,undefined"><meta name="copyright" content="Coolqi.Li"><title>Every day is always sleepy. | Coolqi`s Blog</title><link rel="shortcut icon" href="/my-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.5.6"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.5.6"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Coolqi.Li</div><div class="author-info__description text-center">“你好，我是李帅奇，Android 系统工程师，MineCraft 忠实玩家，设计和绘画爱好者，缺妹纸晚期患者，熬夜星人。”</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">64</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">14</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">15</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Coolqi`s Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">Coolqi`s Blog</div><div id="site-sub-title">Every day is always sleepy.</div></div></nav><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Coolqi.Li</div><div class="author-info__description text-center">“你好，我是李帅奇，Android 系统工程师，MineCraft 忠实玩家，设计和绘画爱好者，缺妹纸晚期患者，熬夜星人。”</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">64</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">14</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">15</span></a></div></div></div><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2016/08/13/BroadcastReceiver篇 7 - BroadcastReceiver 广播机制总结/">BroadcastReceiver篇 7 - BroadcastReceiver 广播机制总结</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2016-08-13</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/AndroidFramework源码分析/">AndroidFramework源码分析</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/AndroidFramework源码分析/BroadcastReceiver广播接收者/">BroadcastReceiver广播接收者</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/BroadcastReceiver广播接收者/">BroadcastReceiver广播接收者</a></span><div class="content"><p>基于 <code>Android 7.1.1</code> 分析 <code>BroadcastReceiver</code> 组件的机制，本文为作者原创，转载请说明出处！</p>
<h1 id="0-综述"><a href="#0-综述" class="headerlink" title="0 综述"></a>0 综述</h1><p>本篇文章总结一下广播和广播接收者相关的知识点，广播是 Android 组件间的通信方式，本质上是 Intent 意图，可用于以下场景：</p>
<ul>
<li>同一应用内部的同一进程间；</li>
<li>同一应用内部的不同进程间的不同组件的通信；</li>
</ul>
<h1 id="1-广播的使用"><a href="#1-广播的使用" class="headerlink" title="1 广播的使用"></a>1 广播的使用</h1><p><code>Android</code> 系统的广播，本质上就是 <code>Intent</code>，对其熟悉的朋友都知道，<code>Intent</code> 可以携带一些重要的数据，下面，我列举些和广播相关的参数，对于 <code>Intent</code> 的具体分析，请看其他的博文！</p>
<h2 id="1-1-广播的类型"><a href="#1-1-广播的类型" class="headerlink" title="1.1 广播的类型"></a>1.1 广播的类型</h2><p>按照前台和后台来区分，会有前台广播和后台广播，<code>AMS</code> 内部有 <code>2</code> 个队列来管理前台和后台广播：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BroadcastQueue mFgBroadcastQueue;</span><br><span class="line">BroadcastQueue mBgBroadcastQueue;</span><br></pre></td></tr></table></figure></p>
<p>按照有序和无序来区分，分为无序发送广播和有序发送广播，前台和后台队列中都有如下两个列表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">final ArrayList&lt;BroadcastRecord&gt; mParallelBroadcasts = new ArrayList&lt;&gt;();</span><br><span class="line">final ArrayList&lt;BroadcastRecord&gt; mOrderedBroadcasts = new ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure></p>
<p><code>mParallelBroadcasts</code> 是并发发送列表，<code>mOrderedBroadcasts</code> 是有序发送列表；</p>
<p>按照发送的方式来分，又可以分为以下的几种：</p>
<ul>
<li><strong>普通广播</strong></li>
</ul>
<p>发送的接口为：<code>sendBroadcast(intent)</code>，对于普通类型的广播，如果他的目标接收者是动态接收者，那就会添加到 <code>mParallelBroadcasts</code>列表中并发发送，如果他的目标接收者是静态接收者，那就会添加到 <code>mOrderedBroadcasts</code>中有序发送；</p>
<ul>
<li><strong>有序广播</strong></li>
</ul>
<p>发送的接口为：<code>sendOrderedBroadcast(intent)</code>，对于有序类型的广播，不管是静态接收者，还是动态接收者，都会被添加到 <code>mOrderedBroadcasts</code>中有序发送；</p>
<ul>
<li><strong>粘性广播</strong></li>
<li><strong>粘性有序广播</strong></li>
</ul>
<p>粘性广播很特殊，系统会将其保存到一个列表 <code>mStickyBroadcasts</code>中，当还有新的接收者注册后，系统会将其发送给接收者！！但是，在 <code>Android5.0/API level 21</code> 开始粘性广播和粘性有序广播都不再建议使用了，主要还是安全性问题；</p>
<p>除此之外，还有以下类型的广播：</p>
<ul>
<li><strong>系统广播</strong>：安卓系统内置了很多的广播，用于满足系统功能的基本需求，比如：熄屏亮屏广播，开关机广播的等等，都是由系统发送的；</li>
<li><p><strong>本地广播</strong>：本地广播也叫做应用内部广播，为什么会有这种广播呢，主要也是为了安全，防止其他应用通过一些途径平凡的拉起接收者的方法，或者伪装成接收者接收者指定的广播，为了解决这种问题，可以有如下几种方法：</p>
<ul>
<li>将接收者的 <code>android：exported</code> 属性改为 <code>false</code>，但是这样就只能接受来自应用内部的广播了；</li>
<li>发送方和接收者都指定权限信息，权限不匹配，就不能发送和接受；</li>
<li>对于广播可以显示指定包名和组件名；</li>
</ul>
</li>
</ul>
<p>最后一种方式，就是使用本地广播，有一个专门的实现类 <code>LocalBroadcastManager</code>，这个我后面会单独分析！</p>
<h2 id="1-2-Flags-标志位"><a href="#1-2-Flags-标志位" class="headerlink" title="1.2 Flags 标志位"></a>1.2 Flags 标志位</h2><p><code>Android 7.1.1</code> 一共提供了以下几种和 <code>Receiver</code> 相关的 <code>flags</code>，我们来看一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAG_RECEIVER_REGISTERED_ONLY = <span class="number">0x40000000</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAG_RECEIVER_REPLACE_PENDING = <span class="number">0x20000000</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAG_RECEIVER_FOREGROUND = <span class="number">0x10000000</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAG_RECEIVER_NO_ABORT = <span class="number">0x08000000</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT = <span class="number">0x04000000</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAG_RECEIVER_BOOT_UPGRADE = <span class="number">0x02000000</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAG_RECEIVER_INCLUDE_BACKGROUND = <span class="number">0x01000000</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAG_RECEIVER_EXCLUDE_BACKGROUND = <span class="number">0x00800000</span>;</span><br></pre></td></tr></table></figure>
<p>下面我逐个解释一下每个标签的作用，和他们在系统中是如何处理的：</p>
<ul>
<li><strong>FLAG_RECEIVER_REGISTERED_ONLY</strong>：只有动态注册的接收者才能接受该广播，静态接收者无法接受；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Figure out who all will receive this broadcast.</span></span><br><span class="line">List receivers = <span class="keyword">null</span>;</span><br><span class="line">List&lt;BroadcastFilter&gt; registeredReceivers = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// Need to resolve the intent to interested receivers...</span></span><br><span class="line"><span class="keyword">if</span> ((intent.getFlags()&amp;Intent.FLAG_RECEIVER_REGISTERED_ONLY)</span><br><span class="line">         == <span class="number">0</span>) &#123;</span><br><span class="line">    receivers = collectReceiverComponents(intent, resolvedType, callingUid, users);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>AMS</code> 内部会做处理，如果广播设置了 <code>FLAG_RECEIVER_REGISTERED_ONLY</code> 标签，那他就不会收集静态注册的接收者；</p>
<p><br></p>
<ul>
<li><strong>FLAG_RECEIVER_REPLACE_PENDING</strong>：新发送的广播会取代之前的已发送但未处理的相同广播，广播是否相同，是通过 <code>Intent.filterEquals</code> 方法进行匹配的；如果匹配成功，新广播会取代旧广播，但在等待列表中的位置不变，该 <code>flags</code> 常常被粘性广播使用，只保证将最新的广播发送给对应的接收者；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> replacePending =</span><br><span class="line">        (intent.getFlags()&amp;Intent.FLAG_RECEIVER_REPLACE_PENDING) != <span class="number">0</span>;</span><br><span class="line">... ... ...        </span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> ((receivers != <span class="keyword">null</span> &amp;&amp; receivers.size() &gt; <span class="number">0</span>)</span><br><span class="line">        || resultTo != <span class="keyword">null</span>) &#123;</span><br><span class="line">    ... ... ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> replaced = replacePending &amp;&amp; queue.replaceOrderedBroadcastLocked(r);</span><br><span class="line">    <span class="keyword">if</span> (!replaced) &#123;</span><br><span class="line">        queue.enqueueOrderedBroadcastLocked(r);</span><br><span class="line">        queue.scheduleBroadcastsLocked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，省略了一下重要的代码，可以看到，如果广播设置了 <code>FLAG_RECEIVER_REPLACE_PENDING</code>，他会取代之前的旧的未被处理的相同广播，这里就不多说了！！</p>
<p><br></p>
<ul>
<li><strong>FLAG_RECEIVER_FOREGROUND</strong>：设置该标志位后，广播的接收者会以前台的优先级运行，超时时间会变短，正常的接收者是后台优先级的，是不会被自动提升的！<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BroadcastQueue <span class="title">broadcastQueueForIntent</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isFg = (intent.getFlags() &amp; Intent.FLAG_RECEIVER_FOREGROUND) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_BROADCAST_BACKGROUND) Slog.i(TAG_BROADCAST,</span><br><span class="line">            <span class="string">"Broadcast intent "</span> + intent + <span class="string">" on "</span></span><br><span class="line">            + (isFg ? <span class="string">"foreground"</span> : <span class="string">"background"</span>) + <span class="string">" queue"</span>);</span><br><span class="line">    <span class="keyword">return</span> (isFg) ? mFgBroadcastQueue : mBgBroadcastQueue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>在 AMS 中，有两个广播队列：前台队列和后台队列，可以看到，默认情况下，不设置该标志位，广播都是被添加到后台队列中的！！</p>
<p><br></p>
<ul>
<li><strong>FLAG_RECEIVER_NO_ABORT</strong>：设置该标志位后，如果该广播是一个有序发送的广播，不允许接收者过滤不处理该广播；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (resultAbort &amp;&amp; (r.intent.getFlags()&amp;Intent.FLAG_RECEIVER_NO_ABORT) == <span class="number">0</span>) &#123;</span><br><span class="line">    r.resultAbort = resultAbort;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    r.resultAbort = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里，会对该 <code>flags</code> 做一个判断，看是否过滤不处理该广播；</p>
<p><br></p>
<ul>
<li><strong>FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT</strong>：设置该标志位后，当在开机完成之前发送该广播，只有已经被注册的接收者（静态）会被调用；如果是粘性广播，仍然会被系统保留下来，即使没有接收者被调用；如果设置了 <code>FLAG_RECEIVER_REGISTERED_ONLY</code> 标志位，该标志位无效！</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Intent <span class="title">verifyBroadcastLocked</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">    ... ... ... ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】mProcessesReady 表示系统进程是否准备好！</span></span><br><span class="line">    <span class="keyword">if</span> (!mProcessesReady) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((flags&amp;Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// This will be turned into a FLAG_RECEIVER_REGISTERED_ONLY later on if needed.</span></span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((flags&amp;Intent.FLAG_RECEIVER_REGISTERED_ONLY) == <span class="number">0</span>) &#123;</span><br><span class="line">            Slog.e(TAG, <span class="string">"Attempt to launch receivers of broadcast intent "</span> + intent</span><br><span class="line">                    + <span class="string">" before boot completion"</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot broadcast before boot completed"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> intent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，如果在系统进程没有准备好时，如果广播设置了 <code>FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT</code>，但如果此时没有设置 <code>FLAG_RECEIVER_REGISTERED_ONLY</code> 标签，那会报出异常。</p>
<p><br></p>
<ul>
<li><strong>FLAG_RECEIVER_BOOT_UPGRADE</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><br></p>
<ul>
<li><strong>FLAG_RECEIVER_INCLUDE_BACKGROUND</strong>：如果设置了该标签，该广播将<strong>始终发送</strong>给后台（缓存或不运行）应用程序的静态接收者；</li>
</ul>
<p><br></p>
<ul>
<li><strong>FLAG_RECEIVER_EXCLUDE_BACKGROUND</strong>：如果设置了该标签，该广播将<strong>始终不会发送</strong>给后台（缓存或不运行）应用程序的静态接收者，但是如果发送者显示指定了接收者的组件名或者包名，那么后台接收者仍然可以接收到该广播！！</li>
</ul>
<p>这两个标签的处理如下，这里的 <code>info</code> 是静态接收者的数据对象！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!skip) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】判断是否允许后台启动！</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> allowed = mService.checkAllowBackgroundLocked(</span><br><span class="line">            info.activityInfo.applicationInfo.uid, info.activityInfo.packageName, -<span class="number">1</span>,</span><br><span class="line">            <span class="keyword">false</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (allowed != ActivityManager.APP_START_MODE_NORMAL) &#123;</span><br><span class="line">        <span class="comment">//【2】如果是禁止启动，就跳过该应用程序，但 checkAllowBackgroundLocked 不会返回该值；</span></span><br><span class="line">        <span class="keyword">if</span> (allowed == ActivityManager.APP_START_MODE_DISABLED) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Background execution disabled: receiving "</span></span><br><span class="line">                    + r.intent + <span class="string">" to "</span></span><br><span class="line">                    + component.flattenToShortString());</span><br><span class="line"></span><br><span class="line">            skip = <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【3】如果是延迟启动，那其属于一个后台的接收者，那就要判断下标志位；</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (((r.intent.getFlags()&amp;Intent.FLAG_RECEIVER_EXCLUDE_BACKGROUND) != <span class="number">0</span>)</span><br><span class="line">                || (r.intent.getComponent() == <span class="keyword">null</span></span><br><span class="line">                    &amp;&amp; r.intent.getPackage() == <span class="keyword">null</span></span><br><span class="line">                    &amp;&amp; ((r.intent.getFlags()</span><br><span class="line">                            &amp; Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND) == <span class="number">0</span>))) &#123;</span><br><span class="line"></span><br><span class="line">            Slog.w(TAG, <span class="string">"Background execution not allowed: receiving "</span></span><br><span class="line">                    + r.intent + <span class="string">" to "</span></span><br><span class="line">                    + component.flattenToShortString());</span><br><span class="line"></span><br><span class="line">            skip = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Android 系统在发送广播时会判断是否会跳过一些接收者！如果 <code>checkAllowBackgroundLocked</code> 返回值，返回值为 <code>ActivityManager.APP_START_MODE_DELAYED</code>，表示接收者是需要后台启动的！</p>
<p>这种情况下：</p>
<ul>
<li>如果设置了 <code>FLAG_RECEIVER_EXCLUDE_BACKGROUND</code> 标签，那就会逃过该后台的静态接收者；</li>
<li>如果没设置 <code>FLAG_RECEIVER_INCLUDE_BACKGROUND</code> 标签，且没有设置 <code>Component</code> 或者 <code>Package</code>，那就会跳过该后台的静态接收者；</li>
</ul>
<p><br></p>
<p>对于标志位的分析，我们就简单的提一下，详细的分析，大家可以去看 <code>sendBroadcast</code> 过程！！</p>
<h2 id="1-3-广播的发送方法"><a href="#1-3-广播的发送方法" class="headerlink" title="1.3 广播的发送方法"></a>1.3 广播的发送方法</h2><p>对于广播的发送，很简单，有很多的方法，来发送不同类型的广播：</p>
<ul>
<li><p>普通广播：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>有序广播：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>粘性广播：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>粘性有序广播：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="2-接收者的使用"><a href="#2-接收者的使用" class="headerlink" title="2 接收者的使用"></a>2 接收者的使用</h1><p>广播接收者分为 <code>2</code> 种，静态接收者，动态接收者：</p>
<ul>
<li>动态注册的接收者不是常驻型，也就是说广播跟随 <code>Activity</code> 的生命周期。注意在 <code>Activity</code> 结束前，移除广播接收器。</li>
<li>静态注册的接收者不是常驻型，也就是说当应用程序关闭后，如果有信息广播来，程序也会被系统调用自动运行。</li>
</ul>
<p>下面我们来看看他们的使用方法：</p>
<h2 id="2-1-静态注册的接收者"><a href="#2-1-静态注册的接收者" class="headerlink" title="2.1 静态注册的接收者"></a>2.1 静态注册的接收者</h2><p>静态接收者需要单独存在于一个 <code>.java</code> 文件：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstallResultReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (intent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            OppoLog.i (TAG, <span class="string">"ota intent is null!"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>并且在 <code>AndroidManifest.xml</code> 需要说明该组件的存在：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;receiver</span><br><span class="line">    android:name=<span class="string">".install.InstallResultReceiver"</span></span><br><span class="line">    android:exported=<span class="string">"true"</span>&gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name=<span class="string">"coolqi.intent.action.package_install_success"</span> /&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/receiver&gt;</span><br></pre></td></tr></table></figure>
<p><code>AndroidManifest.xml</code> 可以对接收者配置很多的属性，这里列举几个比较重要的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">android:name=<span class="string">".install.InstallResultReceiver"</span></span><br><span class="line">android:singleUser=<span class="string">"true"</span></span><br><span class="line">android:process=<span class="string">"com.demo.coolqi"</span></span><br><span class="line">android:enabled=<span class="string">"true"</span></span><br><span class="line">android:permission=<span class="string">"coolqi.send.package_install_success"</span></span><br><span class="line">android:exported=<span class="string">"true"</span>&gt;</span><br></pre></td></tr></table></figure>
<p>解释说明下：</p>
<ul>
<li><strong>name</strong>：接收者的全名；</li>
<li><strong>singleUser</strong>：该接收者是否在所有；</li>
<li><strong>process</strong>：该接收者所在的进程名；</li>
<li><strong>enabled</strong>：该接收者是否为单用户模式，如果为 <code>true</code>，所有用户使用的 <code>BroadcastReceiver</code> 是同一个；</li>
<li><strong>permission</strong>：该接收者指定发送者应具有的权限；</li>
<li><strong>exported</strong>：该接收者是否对其他应用暴露；</li>
</ul>
<p>初次之外：<code>intent-filter</code> 也可以设置一些属性，这里列举一些重要的属性：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:priority=<span class="string">""</span></span><br></pre></td></tr></table></figure></p>
<p>解释说明下：</p>
<ul>
<li><strong>priority</strong>：表示接收者的优先级，对于有序发送的广播，接收者优先级越高，越先接受到广播；</li>
</ul>
<p>关于优先级对于广播接受的影响，我们后面会谈到；</p>
<h2 id="2-2-动态注册的接收者"><a href="#2-2-动态注册的接收者" class="headerlink" title="2.2 动态注册的接收者"></a>2.2 动态注册的接收者</h2><p>动态接收者不能单独存在于一个独立的 <code>.java</code> 文件中，他需要最为其他类的内部类来定义，它依附于其他的类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class InstallResultReceiver extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    private InstallResultReceiver resultReceiver;</span><br><span class="line">    </span><br><span class="line">    class InstallResultReceiver extends BroadcastReceiver&#123;</span><br><span class="line">  </span><br><span class="line">        @Override</span><br><span class="line">        public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line">     </span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要在代码中实时注册：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IntentFilter filter = new IntentFilter();</span><br><span class="line">filter.addAction(&quot;coolqi.intent.action.package_install_success&quot;);</span><br><span class="line">reReceiver = new InstallResultReceiver();</span><br><span class="line"></span><br><span class="line">registerReceiver(reReceiver, filter);</span><br></pre></td></tr></table></figure>
<p>同时在不需要该接收者时，需要动态取消注册：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unregisterReceiver(reReceiver);</span><br></pre></td></tr></table></figure>
<p>对于动态注册的接收者，也可以设置他的优先级：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filter.setPriority(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<h1 id="3-广播的发送和处理"><a href="#3-广播的发送和处理" class="headerlink" title="3 广播的发送和处理"></a>3 广播的发送和处理</h1><p>接下来，总结一下，广播的发送和处理流程！</p>
<h2 id="3-1-接收者的收集流程"><a href="#3-1-接收者的收集流程" class="headerlink" title="3.1 接收者的收集流程"></a>3.1 接收者的收集流程</h2><p>我们先通过一张图来看看广播接收者的收集流程：</p>
<p><img src="http://static.zybuluo.com/Coolqi/pmg9s76kvyeuzoggcthzf7i8/%E5%B9%BF%E6%92%AD%E7%9A%84%E5%8F%91%E9%80%81%E6%B5%81%E7%A8%8B.png" alt="广播的发送流程.png-84kB"></p>
<p>我们可以看到，发送过程中，首先会发送目标为动态注册的接收者的普通广播，发送方式是并发！</p>
<p>接下来会收集静态接收者和动态接收者，注意如果是普通广播，这里只收集静态注册的接收者，然后根据优先级对接收者进行排序，排序的算法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (it &lt; NT &amp;&amp; ir &lt; NR) &#123;</span><br><span class="line">    <span class="keyword">if</span> (curt == <span class="keyword">null</span>) &#123;</span><br><span class="line">        curt = (ResolveInfo)receivers.get(it); <span class="comment">// 静态</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (curr == <span class="keyword">null</span>) &#123;</span><br><span class="line">        curr = registeredReceivers.get(ir); <span class="comment">// 动态</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (curr.getPriority() &gt;= curt.priority) &#123;</span><br><span class="line">        receivers.add(it, curr);</span><br><span class="line">        ir++;</span><br><span class="line">        curr = <span class="keyword">null</span>;</span><br><span class="line">        it++;</span><br><span class="line">        NT++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        it++;</span><br><span class="line">        curt = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中：<code>NT</code> 是静态接收者的数量， <code>NR</code> 是动态注册的接收者的数量!</p>
<p>对于普通广播，由于 <code>NR</code> 是 0，目标接收者只有静态接收者，所以这里是不会进行优先级排序的；</p>
<p>对于有序广播，由于其既存在动态接收者，又存在静态接收者，所以这会进行优先级排序，排序的方式如下：</p>
<ul>
<li>如果动态接收者的优先级 <code>Priority</code> 大于等于静态接收者的优先级，动态接收者排在前面；</li>
<li>否则，静态接收者在前！</li>
</ul>
<p>通过上面，我们可以看出：</p>
<ul>
<li>对于普通广播，动态接收者是要比静态接收者先接受到广播的，无视优先级！</li>
<li>对于有序广播，则是按照优先级来处理！</li>
</ul>
<h2 id="3-2-广播发送流程"><a href="#3-2-广播发送流程" class="headerlink" title="3.2 广播发送流程"></a>3.2 广播发送流程</h2><p>接下来，我们来分析下广播的发送过程！</p>
<p>在发送的过程中，我们需要注意一些细节问题：</p>
<ul>
<li>发送的广播 <code>Intent</code> 会被强制添加 <code>Intent.FLAG_EXCLUDE_STOPPED_PACKAGES</code>，禁止广播发送给被强制停止的接收者！该标志位是从 <code>Android 3.1</code> 开始新增了：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAG_EXCLUDE_STOPPED_PACKAGES = <span class="number">0x00000010</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAG_INCLUDE_STOPPED_PACKAGES = <span class="number">0x00000020</span>;</span><br></pre></td></tr></table></figure>
<p>下面我来解释一下：</p>
<ul>
<li><code>FLAG_EXCLUDE_STOPPED_PACKAGES</code>：如果设置了该标志位，该 <code>Intent</code> 将不会匹配那些被强制停止的应用中的组件，如果不设置该标志位，默认是会匹配被强制停止的应用的组件的！</li>
<li><code>FLAG_INCLUDE_STOPPED_PACKAGES</code>：：如果设置了该标志位，该 <code>Intent</code> 将会匹配那些被强制停止的应用中的组件，如果不设置 <code>FLAG_EXCLUDE_STOPPED_PACKAGES</code> 标志位，将会默认设置该标志位，如果两个标志位都被设置了，该标志位才生效！</li>
</ul>
<p>对于系统广播，一般是无法更改标志位的，当然，系统开发者除外；对于应用的自定义的广播，可以设置 <code>FLAG_INCLUDE_STOPPED_PACKAGES</code>，使其能够发送给被停止的接收者！</p>
<p>这里简单提一下，有 <code>2</code> 种情况，应用会处于停止状态：</p>
<ul>
<li>应用第一次安装并且没有被启动过；</li>
<li>用户在应用管理中强制停止了该应用；</li>
</ul>
<p>在收集完接收者后，就会创建对应的广播，封装接收者列表，然后，将广播添加到指定队列的列表中，触发发送，我们来简单的回顾下；</p>
<p><img src="http://static.zybuluo.com/Coolqi/evfvxiy8cvrflkg1jzq2tk5m/%E6%94%B6%E9%9B%86%E6%8E%A5%E6%94%B6%E8%80%85%E5%9B%BE%E7%A4%BA.png" alt="收集接收者图示.png-71.7kB"></p>
<p>广播分发的调用链如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">queue.scheduleBroadcastsLocked(); -&gt; send BROADCAST_INTENT_MSG -&gt; processNextBroadcast();</span><br></pre></td></tr></table></figure></p>
<p>我们用一张图来直观的看一下:</p>
<p><img src="http://static.zybuluo.com/Coolqi/7qk2sd0r3ldxvj9w7elmn6ps/%E5%B9%BF%E6%92%AD%E7%9A%84%E5%8F%91%E9%80%81%E6%B5%81%E7%A8%8B2.png" alt="广播的发送流程2.png-65.3kB"></p>
<p>可以看到，每次分发，都会率先的处理 <code>BroadcastQueue</code> 队列中的并发集合 <code>mParallelBroadcasts</code>  中的所有广播：目标为动态接收者的普通广播，直到 <code>mParallelBroadcasts</code> 为空！</p>
<p>然后，接着是，处理那些正在等待目标进程启动的广播 <code>mPendingBroadcast</code>，如果目标进程没有启动完成或者没有死亡，那就不能继续发送广播，因为需要的等待进程启动后处理该广播！</p>
<p>接着是，处理有序列表 <code>mOrderedBroadcasts</code> 中的广播，首先会遍历 <code>mOrderedBroadcasts</code>，移除那些没有接收者 / 接收者都已经接收完成 / 被终止 / 超时的广播，定位到下一次需要发送的广播，进行分发；</p>
<blockquote>
<p>这里要重点说一下：mOrderedBroadcasts 中的广播有 2 中：一种是目标是静态接收者的普通广播；另一种是有序广播，这二种广播都采用的是有序的发送方式；</p>
</blockquote>
<h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h1></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2016/08/11/Serivce 篇 6 - startForeground 和 stopForeground 分析/">Serivce 篇 6 - startForeground 和 stopForeground 分析</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2016-08-11</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/AndroidFramework源码分析/">AndroidFramework源码分析</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/AndroidFramework源码分析/Service服务/">Service服务</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Service服务/">Service服务</a></span><div class="content"><p>本文基于 Android 7.1.1 源码分析，转载请说明出处！</p>
<h1 id="0-综述"><a href="#0-综述" class="headerlink" title="0 综述"></a>0 综述</h1><p>我们可以通过 startForeground 方法来将一个服务设置成前台服务，具体的使用如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initNotification</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Notification.Builder builder = <span class="keyword">new</span> Notification.Builder(context);</span><br><span class="line">    builder.setOngoing(<span class="keyword">true</span>).setSmallIcon(R.drawable.ic_launcher)</span><br><span class="line">            .setContentTitle(context.getResources().getText(R.string.ticker_text))</span><br><span class="line">            .setContentText(context.getResources().getText(R.string.ticker_text));</span><br><span class="line">    builder.setPriority(Notification.PRIORITY_HIGH);</span><br><span class="line">    mNotification = builder.build();</span><br><span class="line">    mNotification.flags = mNotification.flags | Notification.FLAG_AUTO_CANCEL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">    OppoLog.d(TAG, <span class="string">"onStartCommand"</span>);</span><br><span class="line">    initNotification(<span class="keyword">this</span>);</span><br><span class="line">    </span><br><span class="line">    startForeground(ID, mNotification);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onStartCommand(intent, flags, startId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onDestroy();</span><br><span class="line">    OppoLog.d(TAG, <span class="string">"onDestroy"</span>);</span><br><span class="line">    </span><br><span class="line">    stopForeground(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中，涉及到的方法有如下几个：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将服务设置到前台，如果 id 为 0，那就取消设置前台服务；</span></span><br><span class="line">startForeground(<span class="keyword">int</span> id, Notification notification) </span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消前台设置，removeNotification 表示是否移除通知；</span></span><br><span class="line">stopForeground(<span class="keyword">boolean</span> removeNotification)</span><br><span class="line"><span class="comment">// 取消前台设置，flags 可选 STOP_FOREGROUND_REMOVE 或者 STOP_FOREGROUND_DETACH</span></span><br><span class="line">stopForeground(<span class="keyword">int</span> flags)</span><br></pre></td></tr></table></figure></p>
<p>我们来具体分析下，startForeground 方法的处理流程！</p>
<h1 id="1-服务所在进程"><a href="#1-服务所在进程" class="headerlink" title="1 服务所在进程"></a>1 服务所在进程</h1><h2 id="1-1-Service-startForeground"><a href="#1-1-Service-startForeground" class="headerlink" title="1.1 Service.startForeground"></a>1.1 Service.startForeground</h2><p>我们先来看看 startForeground 方法！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">startForeground</span><span class="params">(<span class="keyword">int</span> id, Notification notification)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用 AMS 的 setServiceForeground 方法！</span></span><br><span class="line">        mActivityManager.setServiceForeground(</span><br><span class="line">                <span class="keyword">new</span> ComponentName(<span class="keyword">this</span>, mClassName), mToken, id,</span><br><span class="line">                notification, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的 mToken，在之前 Service 的创建时，系统进程赋给 Service 的，是一个 IBinder 对象，是 ServiceRecord 对象的引用！</p>
<p>这里的 mActivityManager 也是 Service 在创建后，内部保存的 AMS 的代理对象！</p>
<p>接着进入 ActivityManagerProxy 代理对象中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setServiceForeground</span><span class="params">(ComponentName className, IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> id, Notification notification, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Parcel data = Parcel.obtain();</span><br><span class="line">    Parcel reply = Parcel.obtain();</span><br><span class="line">    data.writeInterfaceToken(IActivityManager.descriptor);</span><br><span class="line">    ComponentName.writeToParcel(className, data);</span><br><span class="line">    data.writeStrongBinder(token);</span><br><span class="line">    data.writeInt(id);</span><br><span class="line">    <span class="keyword">if</span> (notification != <span class="keyword">null</span>) &#123;</span><br><span class="line">        data.writeInt(<span class="number">1</span>);</span><br><span class="line">        notification.writeToParcel(data, <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        data.writeInt(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    data.writeInt(flags);</span><br><span class="line"></span><br><span class="line">    mRemote.transact(SET_SERVICE_FOREGROUND_TRANSACTION, data, reply, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    reply.readException();</span><br><span class="line">    data.recycle();</span><br><span class="line">    reply.recycle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接着进入系统进程！</p>
<h1 id="2-系统进程"><a href="#2-系统进程" class="headerlink" title="2 系统进程"></a>2 系统进程</h1><h2 id="2-1-ActivityManagerN-onTransact"><a href="#2-1-ActivityManagerN-onTransact" class="headerlink" title="2.1 ActivityManagerN.onTransact"></a>2.1 ActivityManagerN.onTransact</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> SET_SERVICE_FOREGROUND_TRANSACTION: &#123;</span><br><span class="line">    data.enforceInterface(IActivityManager.descriptor);</span><br><span class="line">    ComponentName className = ComponentName.readFromParcel(data);</span><br><span class="line">    IBinder token = data.readStrongBinder();</span><br><span class="line">    <span class="keyword">int</span> id = data.readInt();</span><br><span class="line">    Notification notification = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (data.readInt() != <span class="number">0</span>) &#123;</span><br><span class="line">        notification = Notification.CREATOR.createFromParcel(data);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 传入 0；</span></span><br><span class="line">    <span class="keyword">int</span> sflags = data.readInt();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 进入 AMS！</span></span><br><span class="line">    setServiceForeground(className, token, id, notification, sflags);</span><br><span class="line">    reply.writeNoException();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着，进入 AMS:</p>
<h2 id="2-2-ActivityManagerS-setServiceForeground"><a href="#2-2-ActivityManagerS-setServiceForeground" class="headerlink" title="2.2 ActivityManagerS.setServiceForeground"></a>2.2 ActivityManagerS.setServiceForeground</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setServiceForeground</span><span class="params">(ComponentName className, IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> id, Notification notification, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 进入 AS!</span></span><br><span class="line">        mServices.setServiceForegroundLocked(className, token, id, notification, flags);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着，进入 ActiveServices:</p>
<h2 id="2-3-ActiveServices-setServiceForegroundLocked"><a href="#2-3-ActiveServices-setServiceForegroundLocked" class="headerlink" title="2.3 ActiveServices.setServiceForegroundLocked"></a>2.3 ActiveServices.setServiceForegroundLocked</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setServiceForegroundLocked</span><span class="params">(ComponentName className, IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> id, Notification notification, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> userId = UserHandle.getCallingUserId();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【1】根据传入的 className，token 和 userId，找到对应的 ServiceRecord 对象！</span></span><br><span class="line">        ServiceRecord r = findServiceLocked(className, token, userId);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (id != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (notification == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 如果 notification 为 null，抛出异常！</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"null notification"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//【2】如果服务的 foregroundId 和传入的 id 不一样，就取消 foregroundId 对应的旧的 notification</span></span><br><span class="line">                <span class="comment">// 将 foregroundId 设置为本次传入的新的 id</span></span><br><span class="line">                <span class="keyword">if</span> (r.foregroundId != id) &#123;</span><br><span class="line">                    cancelForegroudNotificationLocked(r);</span><br><span class="line">                    r.foregroundId = id;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                notification.flags |= Notification.FLAG_FOREGROUND_SERVICE;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 设置服务 r.foregroundNoti 为创建的 notification；</span></span><br><span class="line">                <span class="comment">// 设置服务 r.isForeground 为 true，表示该服务为前台服务；</span></span><br><span class="line">                r.foregroundNoti = notification;</span><br><span class="line">                r.isForeground = <span class="keyword">true</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//【3】显示 notification！</span></span><br><span class="line">                r.postNotification();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//【4】这里是重点，更新服务的优先级和 oomAdj，设置服务为前台服务！！</span></span><br><span class="line">                <span class="keyword">if</span> (r.app != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    updateServiceForegroundLocked(r.app, <span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//【5】让服务不再后台执行，同时也不让服务延迟启动！</span></span><br><span class="line">                getServiceMap(r.userId).ensureNotStartingBackground(r);</span><br><span class="line">                mAm.notifyPackageUse(r.serviceInfo.packageName,</span><br><span class="line">                                     PackageManager.NOTIFY_PACKAGE_USE_FOREGROUND_SERVICE);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (r.isForeground) &#123;</span><br><span class="line">                    r.isForeground = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (r.app != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        mAm.updateLruProcessLocked(r.app, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">                        updateServiceForegroundLocked(r.app, <span class="keyword">true</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> ((flags &amp; Service.STOP_FOREGROUND_REMOVE) != <span class="number">0</span>) &#123;</span><br><span class="line">                    cancelForegroudNotificationLocked(r);</span><br><span class="line">                    r.foregroundId = <span class="number">0</span>;</span><br><span class="line">                    r.foregroundNoti = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.appInfo.targetSdkVersion &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">                    r.stripForegroundServiceFlagFromNotification();</span><br><span class="line">                    <span class="keyword">if</span> ((flags &amp; Service.STOP_FOREGROUND_DETACH) != <span class="number">0</span>) &#123;</span><br><span class="line">                        r.foregroundId = <span class="number">0</span>;</span><br><span class="line">                        r.foregroundNoti = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-1-ActiveServices-findServiceLocked"><a href="#2-3-1-ActiveServices-findServiceLocked" class="headerlink" title="2.3.1 ActiveServices.findServiceLocked"></a>2.3.1 ActiveServices.findServiceLocked</h3><p>找到对应的 ServiceRecord 对象！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> ServiceRecord <span class="title">findServiceLocked</span><span class="params">(ComponentName name,</span></span></span><br><span class="line"><span class="function"><span class="params">        IBinder token, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    ServiceRecord r = getServiceByName(name, userId);</span><br><span class="line">    <span class="keyword">return</span> r == token ? r : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>根据组件名和设别用户id，在 ActiveServices 的 mServiceMap 稀疏数组中，找到对应的 ServiceRecord 对象，然后和 Service 进程传递过来的 token，二者必须相等才行！</p>
<p>这里就不多说了！</p>
<h3 id="2-3-2-ActiveServices-cancelForegroudNotificationLocked"><a href="#2-3-2-ActiveServices-cancelForegroudNotificationLocked" class="headerlink" title="2.3.2 ActiveServices.cancelForegroudNotificationLocked"></a>2.3.2 ActiveServices.cancelForegroudNotificationLocked</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelForegroudNotificationLocked</span><span class="params">(ServiceRecord r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r.foregroundId != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        ServiceMap sm = getServiceMap(r.userId);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = sm.mServicesByName.size()-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                ServiceRecord other = sm.mServicesByName.valueAt(i);</span><br><span class="line">                <span class="keyword">if</span> (other != r &amp;&amp; other.foregroundId == r.foregroundId</span><br><span class="line">                        &amp;&amp; other.packageName.equals(r.packageName)) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Found one!  Abort the cancel.</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        r.cancelNotification();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ServiceRecord r 是本次需要设置为前台的服务，r.foregroundId 为前台 notification 的 id，这个函数的主要作用是，判断本次需要设置为前台的服务所属的应用是否有其他服务的 foregroundId 和 r.foregroundId 相同，如果相同，那就不能取消这个通知！</p>
<p>如果只有当前服务在使用这个通知的 id，那就取消这个旧的通知：</p>
<h4 id="2-3-2-1-ServiceRecord-cancelNotification"><a href="#2-3-2-1-ServiceRecord-cancelNotification" class="headerlink" title="2.3.2.1 ServiceRecord.cancelNotification"></a>2.3.2.1 ServiceRecord.cancelNotification</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancelNotification</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do asynchronous communication with notification manager to</span></span><br><span class="line">    <span class="comment">// avoid deadlocks.</span></span><br><span class="line">    <span class="keyword">final</span> String localPackageName = packageName;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> localForegroundId = foregroundId;</span><br><span class="line">    ams.mHandler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            INotificationManager inm = NotificationManager.getService();</span><br><span class="line">            <span class="keyword">if</span> (inm == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 调用 NotificationManager 取消这个通知！</span></span><br><span class="line">                inm.cancelNotificationWithTag(localPackageName, <span class="keyword">null</span>,</span><br><span class="line">                        localForegroundId, userId);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Error canceling notification for service"</span>, e);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用 NotificationManager 取消这个通知！</p>
<h3 id="2-3-3-ServiceRecord-postNotification"><a href="#2-3-3-ServiceRecord-postNotification" class="headerlink" title="2.3.3 ServiceRecord.postNotification"></a>2.3.3 ServiceRecord.postNotification</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postNotification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> appUid = appInfo.uid;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> appPid = app.pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (foregroundId != <span class="number">0</span> &amp;&amp; foregroundNoti != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Do asynchronous communication with notification manager to</span></span><br><span class="line">        <span class="comment">// avoid deadlocks.</span></span><br><span class="line">        <span class="keyword">final</span> String localPackageName = packageName;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> localForegroundId = foregroundId;</span><br><span class="line">        <span class="keyword">final</span> Notification _foregroundNoti = foregroundNoti;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通过 AMS.MainHandler，在系统进程主线程执行任务！</span></span><br><span class="line">        ams.mHandler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                NotificationManagerInternal nm = LocalServices.getService(</span><br><span class="line">                        NotificationManagerInternal.class);</span><br><span class="line">                <span class="keyword">if</span> (nm == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Notification localForegroundNoti = _foregroundNoti;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (localForegroundNoti.getSmallIcon() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        Slog.v(TAG, <span class="string">"Attempted to start a foreground service ("</span></span><br><span class="line">                                + name</span><br><span class="line">                                + <span class="string">") with a broken notification (no icon: "</span></span><br><span class="line">                                + localForegroundNoti</span><br><span class="line">                                + <span class="string">")"</span>);</span><br><span class="line"></span><br><span class="line">                        CharSequence appName = appInfo.loadLabel(</span><br><span class="line">                                ams.mContext.getPackageManager());</span><br><span class="line">                        <span class="keyword">if</span> (appName == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            appName = appInfo.packageName;</span><br><span class="line">                        &#125;</span><br><span class="line">                        Context ctx = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">//【1】创建一个上下文运行环境 Context，用于创建通知！</span></span><br><span class="line">                            ctx = ams.mContext.createPackageContextAsUser(</span><br><span class="line">                                    appInfo.packageName, <span class="number">0</span>, <span class="keyword">new</span> UserHandle(userId));</span><br><span class="line">                            </span><br><span class="line">                            <span class="comment">//【2】创建通知建造者，并设置通知相关属性！</span></span><br><span class="line">                            Notification.Builder notiBuilder = <span class="keyword">new</span> Notification.Builder(ctx);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// it's ugly, but it clearly identifies the app</span></span><br><span class="line">                            notiBuilder.setSmallIcon(appInfo.icon);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 设置 notification 的标志位 Notification.FLAG_FOREGROUND_SERVICE！</span></span><br><span class="line">                            <span class="comment">// 表示该通知代表一个在前台运行的服务！</span></span><br><span class="line">                            notiBuilder.setFlag(Notification.FLAG_FOREGROUND_SERVICE, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 设置通知的优先级为 Notification.PRIORITY_MIN！</span></span><br><span class="line">                            notiBuilder.setPriority(Notification.PRIORITY_MIN);</span><br><span class="line"></span><br><span class="line">                            Intent runningIntent = <span class="keyword">new</span> Intent(</span><br><span class="line">                                    Settings.ACTION_APPLICATION_DETAILS_SETTINGS);</span><br><span class="line">                            runningIntent.setData(Uri.fromParts(<span class="string">"package"</span>,</span><br><span class="line">                                    appInfo.packageName, <span class="keyword">null</span>));</span><br><span class="line">                            PendingIntent pi = PendingIntent.getActivity(ams.mContext, <span class="number">0</span>,</span><br><span class="line">                                    runningIntent, PendingIntent.FLAG_UPDATE_CURRENT);</span><br><span class="line">                            notiBuilder.setColor(ams.mContext.getColor(</span><br><span class="line">                                    com.android.internal</span><br><span class="line">                                            .R.color.system_notification_accent_color));</span><br><span class="line">                            notiBuilder.setContentTitle(</span><br><span class="line">                                    ams.mContext.getString(</span><br><span class="line">                                            com.android.internal.R.string</span><br><span class="line">                                                    .app_running_notification_title,</span><br><span class="line">                                            appName));</span><br><span class="line">                            notiBuilder.setContentText(</span><br><span class="line">                                    ams.mContext.getString(</span><br><span class="line">                                            com.android.internal.R.string</span><br><span class="line">                                                    .app_running_notification_text,</span><br><span class="line">                                            appName));</span><br><span class="line">                            notiBuilder.setContentIntent(pi);</span><br><span class="line"></span><br><span class="line">                            localForegroundNoti = notiBuilder.build();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//【3】校验 notification 的 SmallIcon 是否仍然为 null，如果仍然为 null</span></span><br><span class="line">                    <span class="comment">// 抛出运行时异常！</span></span><br><span class="line">                    <span class="keyword">if</span> (localForegroundNoti.getSmallIcon() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"invalid service notification: "</span></span><br><span class="line">                                + foregroundNoti);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">int</span>[] outId = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//【4】显示 notification！</span></span><br><span class="line">                    nm.enqueueNotification(localPackageName, localPackageName,</span><br><span class="line">                            appUid, appPid, <span class="keyword">null</span>, localForegroundId, localForegroundNoti,</span><br><span class="line">                            outId, userId);</span><br><span class="line"></span><br><span class="line">                    foregroundNoti = localForegroundNoti; <span class="comment">// save it for amending next time</span></span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">                    Slog.w(TAG, <span class="string">"Error showing notification for service"</span>, e);</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 如果出现异常，就不会设置服务为前台服务，同时抛出 Crash 异常！</span></span><br><span class="line">                    ams.setServiceForeground(name, ServiceRecord.<span class="keyword">this</span>,</span><br><span class="line">                            <span class="number">0</span>, <span class="keyword">null</span>, <span class="number">0</span>);</span><br><span class="line">                    ams.crashApplication(appUid, appPid, localPackageName,</span><br><span class="line">                            <span class="string">"Bad notification for startForeground: "</span> + e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法的主要作用是显示 notification！</p>
<h3 id="2-3-4-ActiveServices-updateServiceForegroundLocked"><a href="#2-3-4-ActiveServices-updateServiceForegroundLocked" class="headerlink" title="2.3.4 ActiveServices.updateServiceForegroundLocked"></a>2.3.4 ActiveServices.updateServiceForegroundLocked</h3><p>这里是重点，更新服务的优先级和 oomAdj，设置服务为前台服务，参数分析：</p>
<ul>
<li>ProcessRecord proc：服务所在的进程！</li>
<li>boolean oomAdj：传入 true，表示需要更新 oomAdj 值！</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateServiceForegroundLocked</span><span class="params">(ProcessRecord proc, <span class="keyword">boolean</span> oomAdj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> anyForeground = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历进程，如果该进程中有服务 sr.isForeground 为 true 了，</span></span><br><span class="line">    <span class="comment">// 表示该进程存在前台服务，所以 anyForeground 为 true，跳出循环！</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=proc.services.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">        ServiceRecord sr = proc.services.valueAt(i);</span><br><span class="line">        <span class="keyword">if</span> (sr.isForeground) &#123;</span><br><span class="line">            anyForeground = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 进入这里进行进程的优先级和 oomAdj 的设置！</span></span><br><span class="line">    mAm.updateProcessForegroundLocked(proc, anyForeground, oomAdj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然，根据前面的属性设置 anyForeground 为 true ！</p>
<p>下面就是更新服务所在进程的优先级和 oomAdj 的值了！</p>
<h3 id="2-3-5-ServiceMap-ensureNotStartingBackground"><a href="#2-3-5-ServiceMap-ensureNotStartingBackground" class="headerlink" title="2.3.5 ServiceMap.ensureNotStartingBackground"></a>2.3.5 ServiceMap.ensureNotStartingBackground</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ensureNotStartingBackground</span><span class="params">(ServiceRecord r)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】从 AS.mStartingBackground 中尝试删除该服务，不让服务在后台运行！</span></span><br><span class="line">    <span class="keyword">if</span> (mStartingBackground.remove(r)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE,</span><br><span class="line">                <span class="string">"No longer background starting: "</span> + r);</span><br><span class="line">        </span><br><span class="line">        rescheduleDelayedStarts();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【2】从 AS.mDelayedStartList 中尝试删除该服务，不让服务延迟启动！ </span></span><br><span class="line">    <span class="keyword">if</span> (mDelayedStartList.remove(r)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE, <span class="string">"No longer delaying start: "</span> + r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里和 startService 中的一样的，目的是将当前服务从 mStartingBackground 和 mDelayedStartList 中删除，因为服务被设置成了前台服务，如果当前服务从 mStartingBackground 中删除成功了，就要调用 rescheduleDelayedStarts 方法，继续发送 MSG_BG_START_TIMEOUT 消息！</p>
<p>这里具体的分析，<strong>请去看 startService 博文的第 2.3 节</strong>！</p>
<p>通过上面的分析，关键的地方是这里：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateServiceForegroundLocked</span><span class="params">(ProcessRecord proc, <span class="keyword">boolean</span> oomAdj)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    ... ... ... ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 进入这里进行进程的优先级和 oomAdj 的设置！</span></span><br><span class="line">    mAm.updateProcessForegroundLocked(proc, anyForeground, oomAdj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里调用了 AMS 的 updateProcessForegroundLocked 方法来更新 Service 的进程优先级和 oomAdj 的值。我们继续来看！</p>
<h2 id="2-4-ActivityManagerS-updateProcessForegroundLocked"><a href="#2-4-ActivityManagerS-updateProcessForegroundLocked" class="headerlink" title="2.4 ActivityManagerS.updateProcessForegroundLocked"></a>2.4 ActivityManagerS.updateProcessForegroundLocked</h2><p>参数传递：</p>
<ul>
<li>ProcessRecord proc：服务所在的进程；</li>
<li>boolean isForeground：传入 true；</li>
<li>boolean oomAdj：传入 true；</li>
</ul>
<p>这里我们假设之前服务所在进程没有运行任何的前台服务！！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">updateProcessForegroundLocked</span><span class="params">(ProcessRecord proc, <span class="keyword">boolean</span> isForeground,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> oomAdj)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// proc.foregroundServices 表示进程是否运行前台服务！</span></span><br><span class="line">    <span class="comment">// 如果 isForeground 不等于 proc.foregroundServices，说明进程的</span></span><br><span class="line">    <span class="keyword">if</span> (isForeground != proc.foregroundServices) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将 proc.foregroundServices 设置为 isForeground 的值！</span></span><br><span class="line">        proc.foregroundServices = isForeground;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// mForegroundPackages 集合用来保存所有当前正在运行着前台服务的应用程序包信息</span></span><br><span class="line">        <span class="comment">// curProcs 则是运行着前台服务的进程对象 ProcessRecord!</span></span><br><span class="line">        ArrayList&lt;ProcessRecord&gt; curProcs = mForegroundPackages.get(proc.info.packageName,</span><br><span class="line">                proc.info.uid);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 因为我们现在是设置服务为前台服务，所以 isForeground 是 true！</span></span><br><span class="line">        <span class="keyword">if</span> (isForeground) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将进程所属的应用程序包，添加到 mForegroundPackages 集合中；</span></span><br><span class="line">            <span class="comment">// 并将服务所在的进程也添加到 mForegroundPackages 中；</span></span><br><span class="line">            <span class="keyword">if</span> (curProcs == <span class="keyword">null</span>) &#123;</span><br><span class="line">                curProcs = <span class="keyword">new</span> ArrayList&lt;ProcessRecord&gt;();</span><br><span class="line">                mForegroundPackages.put(proc.info.packageName, proc.info.uid, curProcs);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!curProcs.contains(proc)) &#123;</span><br><span class="line">                curProcs.add(proc);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 通知 BatteryStatsService 服务，有应用在前台执行服务！</span></span><br><span class="line">                mBatteryStatsService.noteEvent(BatteryStats.HistoryItem.EVENT_FOREGROUND_START,</span><br><span class="line">                        proc.info.packageName, proc.info.uid);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (curProcs != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (curProcs.remove(proc)) &#123;</span><br><span class="line">                    mBatteryStatsService.noteEvent(</span><br><span class="line">                            BatteryStats.HistoryItem.EVENT_FOREGROUND_FINISH,</span><br><span class="line">                            proc.info.packageName, proc.info.uid);</span><br><span class="line">                    <span class="keyword">if</span> (curProcs.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        mForegroundPackages.remove(proc.info.packageName, proc.info.uid);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这里为 true，更新进程的 oomAdj 的值！</span></span><br><span class="line">        <span class="keyword">if</span> (oomAdj) &#123;</span><br><span class="line">            updateOomAdjLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里有一些数据结构，我们来简单是说一下：</p>
<p><code>ProcessRecord.foregroundServices</code> 表示该进程中是否在运行前台服务；</p>
<p>初次之外，还有一个 mForegroundPackages，用来保存运行着前台服务的应用程序包信息：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ProcessMap&lt;ArrayList&lt;ProcessRecord&gt;&gt; mForegroundPackages</span><br><span class="line">        = <span class="keyword">new</span> ProcessMap&lt;ArrayList&lt;ProcessRecord&gt;&gt;();</span><br></pre></td></tr></table></figure></p>
<p>他是 ProcessMap 类的对象，ProcessMap 是一个模板类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessMap</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ArrayMap&lt;String, SparseArray&lt;E&gt;&gt; mMap</span><br><span class="line">            = <span class="keyword">new</span> ArrayMap&lt;String, SparseArray&lt;E&gt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(String name, <span class="keyword">int</span> uid)</span> </span>&#123;</span><br><span class="line">        SparseArray&lt;E&gt; uids = mMap.get(name);</span><br><span class="line">        <span class="keyword">if</span> (uids == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> uids.get(uid);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">put</span><span class="params">(String name, <span class="keyword">int</span> uid, E value)</span> </span>&#123;</span><br><span class="line">        SparseArray&lt;E&gt; uids = mMap.get(name);</span><br><span class="line">        <span class="keyword">if</span> (uids == <span class="keyword">null</span>) &#123;</span><br><span class="line">            uids = <span class="keyword">new</span> SparseArray&lt;E&gt;(<span class="number">2</span>);</span><br><span class="line">            mMap.put(name, uids);</span><br><span class="line">        &#125;</span><br><span class="line">        uids.put(uid, value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    ... ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ProcessMap 的内部变量 mMap 是一个 ArrayMap 类型的集合，其中 key 是应用程序的报名，而 value 是 SparseArray<processrecord> 类型的稀疏数组，其中数组下标是应用在指定设备用户下的 uid，而下标对应的值是 uid 对应的运行着前台服务的进程对象 ProcessRecord，这里就不多说了！！</processrecord></p>
<p>这里我们就先看到这里，关于 updateOomAdjLocked 的逻辑处理，请去看。。。。</p>
<h1 id="3-stopForeground-分析"><a href="#3-stopForeground-分析" class="headerlink" title="3 stopForeground 分析"></a>3 stopForeground 分析</h1><p>上面分析了一些 startForeground 方法的主要流程，下面分析下 stopForeground 方法，stopForeground 方法一共有两个：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">stopForeground</span><span class="params">(<span class="keyword">boolean</span> removeNotification)</span> </span>&#123;</span><br><span class="line">    stopForeground(removeNotification ? STOP_FOREGROUND_REMOVE : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">stopForeground</span><span class="params">(<span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mActivityManager.setServiceForeground(</span><br><span class="line">                <span class="keyword">new</span> ComponentName(<span class="keyword">this</span>, mClassName), mToken, <span class="number">0</span>, <span class="keyword">null</span>, flags);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第一个方法最后还是会调用第二个方法！<br>这里我们先来解释两个参数变量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP_FOREGROUND_REMOVE = <span class="number">1</span>&lt;&lt;<span class="number">0</span>;</span><br></pre></td></tr></table></figure></p>
<p>如果设置了这个标志位，取消前台服务的同时，还会移除对应的通知，但是如果同一个应用中有其他前台服务关联着相同的通知，就不会移除该通知；</p>
<p>如果不设置这个标志位，通知只能通过 startForeground(int, Notification) 或者 stopForeground(int)，或者服务被销毁的方式移除！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP_FOREGROUND_DETACH = <span class="number">1</span>&lt;&lt;<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>如果设置了这个标志位，取消前台服务的同时，不会移除对应的通知，但是会将通知和服务完全解除绑定，这时通知只有通过 NotificationManager 才能被取消！该标志位不能和 STOP_FOREGROUND_REMOVE 混合使用哦！</p>
<p>方法调用和 startForeground 方法很类似，最后会进入 ActiveSerivces 中去：</p>
<h2 id="3-1-ActiveSerivces-setServiceForegroundLocked"><a href="#3-1-ActiveSerivces-setServiceForegroundLocked" class="headerlink" title="3.1 ActiveSerivces.setServiceForegroundLocked"></a>3.1 ActiveSerivces.setServiceForegroundLocked</h2><p>参数传递：</p>
<ul>
<li>ComponentName className：服务的类名；</li>
<li>IBinder token；服务的 ServiceRecord 对象；</li>
<li>int id：传入 0；</li>
<li>Notification notification：传入 null；</li>
<li>int flags：传入具体的 flags；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setServiceForegroundLocked</span><span class="params">(ComponentName className, IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> id, Notification notification, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> userId = UserHandle.getCallingUserId();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【1】根据传入的 className，token 和 userId，找到对应的 ServiceRecord 对象！</span></span><br><span class="line">        ServiceRecord r = findServiceLocked(className, token, userId);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (id != <span class="number">0</span>) &#123;</span><br><span class="line">               </span><br><span class="line">               ... ... ... ...<span class="comment">// 这里不进入该分支；</span></span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果服务 r.isForeground 为 true，就设置 r.isForeground 为 false；</span></span><br><span class="line">                <span class="comment">// 同时调用 AMS.updateLruProcessLocked 和 updateServiceForegroundLocked </span></span><br><span class="line">                <span class="comment">// 更新进程状态！</span></span><br><span class="line">                <span class="keyword">if</span> (r.isForeground) &#123;</span><br><span class="line">                    r.isForeground = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (r.app != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        mAm.updateLruProcessLocked(r.app, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">                        updateServiceForegroundLocked(r.app, <span class="keyword">true</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果 flags 设置了 STOP_FOREGROUND_REMOVE 标志位，就移除通知！！</span></span><br><span class="line">                <span class="keyword">if</span> ((flags &amp; Service.STOP_FOREGROUND_REMOVE) != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 尝试移除该通知，如果当前服务所属的应用程序有其他前台服务</span></span><br><span class="line">                    <span class="comment">// 也关联着同一个通知，那就不移除通知！</span></span><br><span class="line">                    cancelForegroudNotificationLocked(r);</span><br><span class="line"></span><br><span class="line">                    r.foregroundId = <span class="number">0</span>;</span><br><span class="line">                    r.foregroundNoti = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.appInfo.targetSdkVersion &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 将服务和通知解除绑定！！</span></span><br><span class="line">                    r.stripForegroundServiceFlagFromNotification();</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 如果 flags 设置了 STOP_FOREGROUND_DETACH 标志位，</span></span><br><span class="line">                    <span class="comment">// 就清除服务的 r.foregroundId 和 r.foregroundNoti；</span></span><br><span class="line">                    <span class="keyword">if</span> ((flags &amp; Service.STOP_FOREGROUND_DETACH) != <span class="number">0</span>) &#123;</span><br><span class="line">                        r.foregroundId = <span class="number">0</span>;</span><br><span class="line">                        r.foregroundNoti = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就先分析这么多，其他内容后续在补充！</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2016/07/13/BroadcastReceiver篇 6 - LocalBroadcastManager 分析/">BroadcastReceiver篇 6 - LocalBroadcastManager 分析</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2016-07-13</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/AndroidFramework源码分析/">AndroidFramework源码分析</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/AndroidFramework源码分析/BroadcastReceiver广播接收者/">BroadcastReceiver广播接收者</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/BroadcastReceiver广播接收者/">BroadcastReceiver广播接收者</a></span><div class="content"><p>[toc]</p>
<p>本文基于 Android 7.1.1 源码，分析 LocalBroadcastManager 机制！</p>
<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言</h1><p>BroadcastReceiver 是基于 Binder 通信的，其可以用于跨进程的通信，而 LocalBroadcastManager 是基于 Handler 的，其适用于进程内的通信，在进程内进行局部广播发送与注册。</p>
<p>相比 BroadcastReceiver 的广播，LocalBroadcastManager 有以下几点优点。</p>
<ul>
<li>广播数据只在本应用内传播，不用担心数据泄露；</li>
<li>广播数据不用担心别的应用伪造广播，更加安全；</li>
<li>因为只在应用内广播，所以更加的高效；</li>
</ul>
<p>LocalBroadcastManager 位于 android.support.v4.content 包中，适用于动态注册的广播：</p>
<h1 id="1-基本使用"><a href="#1-基本使用" class="headerlink" title="1 基本使用"></a>1 基本使用</h1><p>注册接收者到 LocalBroadcastManager：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">filter = <span class="keyword">new</span> IntentFilter();</span><br><span class="line">filter.addAction(action);</span><br><span class="line">mLocalBroadcastManager = LocalBroadcastManager.getInstance(<span class="keyword">this</span>); <span class="comment">// 获得实例；</span></span><br><span class="line">mLocalBroadcastManager.registerReceiver(receiver, filter); <span class="comment">// 注册监听；</span></span><br></pre></td></tr></table></figure>
<p>解除注册：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mLocalBroadcastManager.unregisterReceiver(receiver); <span class="comment">// 取消监听；</span></span><br></pre></td></tr></table></figure>
<p>然后就是发送广播：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mLocalBroadcastManager.sendBroadcast(intent); <span class="comment">// 发送广播；</span></span><br></pre></td></tr></table></figure>
<h1 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2 源码分析"></a>2 源码分析</h1><h2 id="2-1-LocalBroadcastManager-getInstance-创建单例"><a href="#2-1-LocalBroadcastManager-getInstance-创建单例" class="headerlink" title="2.1 LocalBroadcastManager.getInstance - 创建单例"></a>2.1 LocalBroadcastManager.getInstance - 创建单例</h2><p>LocalBroadcastManager 采用的是单例模式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LocalBroadcastManager <span class="title">getInstance</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//【2.1.1】创建单例！</span></span><br><span class="line">            mInstance = <span class="keyword">new</span> LocalBroadcastManager(context.getApplicationContext());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getInstance 方法中会调用 LocalBroadcastManager 构造器：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">LocalBroadcastManager</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    mAppContext = context;</span><br><span class="line">    <span class="comment">//【1】创建主线程对应的 Handler！</span></span><br><span class="line">    mHandler = <span class="keyword">new</span> Handler(context.getMainLooper()) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="comment">//【1.2】接收到  MSG_EXEC_PENDING_BROADCASTS 消息！</span></span><br><span class="line">                <span class="keyword">case</span> MSG_EXEC_PENDING_BROADCASTS:</span><br><span class="line">                    <span class="comment">//【2.6】触发 executePendingBroadcasts 方法！</span></span><br><span class="line">                    executePendingBroadcasts();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>context.getMainLooper() 会返回当前进程主线程的 Looper 对象！</p>
<p>继续分析！</p>
<h2 id="2-2-LocalBroadcastManager-registerReceiver-注册"><a href="#2-2-LocalBroadcastManager-registerReceiver-注册" class="headerlink" title="2.2 LocalBroadcastManager.registerReceiver - 注册"></a>2.2 LocalBroadcastManager.registerReceiver - 注册</h2><p>注册接收者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerReceiver</span><span class="params">(BroadcastReceiver receiver, IntentFilter filter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mReceivers) &#123;</span><br><span class="line">        <span class="comment">//【2.2.1】创建了一个 ReceiverRecord 实例，封装注册的接收者的信息！</span></span><br><span class="line">        ReceiverRecord entry = <span class="keyword">new</span> ReceiverRecord(filter, receiver);</span><br><span class="line">        <span class="comment">//【1】添加 receiver 和 intentfilter 的映射关系！</span></span><br><span class="line">        ArrayList&lt;IntentFilter&gt; filters = mReceivers.get(receiver);</span><br><span class="line">        <span class="keyword">if</span> (filters == <span class="keyword">null</span>) &#123;</span><br><span class="line">            filters = <span class="keyword">new</span> ArrayList&lt;IntentFilter&gt;(<span class="number">1</span>);</span><br><span class="line">            mReceivers.put(receiver, filters);</span><br><span class="line">        &#125;</span><br><span class="line">        filters.add(filter);</span><br><span class="line">        <span class="comment">//【2】解析该 filter 能过滤处理的 action，并添加 action 和 receiver 的映射关系！</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;filter.countActions(); i++) &#123;</span><br><span class="line">            String action = filter.getAction(i);</span><br><span class="line">            ArrayList&lt;ReceiverRecord&gt; entries = mActions.get(action);</span><br><span class="line">            <span class="keyword">if</span> (entries == <span class="keyword">null</span>) &#123;</span><br><span class="line">                entries = <span class="keyword">new</span> ArrayList&lt;ReceiverRecord&gt;(<span class="number">1</span>);</span><br><span class="line">                mActions.put(action, entries);</span><br><span class="line">            &#125;</span><br><span class="line">            entries.add(entry);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 LocalBroadcastManager 有如下两个 hash 表：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 存储 BroadcastReceiver 和其 IntentFilter 的映射关系！</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;BroadcastReceiver, ArrayList&lt;IntentFilter&gt;&gt; mReceivers</span><br><span class="line">        = <span class="keyword">new</span> HashMap&lt;BroadcastReceiver, ArrayList&lt;IntentFilter&gt;&gt;();</span><br><span class="line"><span class="comment">// 存储 filter action 和  BroadcastReceiver 的映射关系！</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String, ArrayList&lt;ReceiverRecord&gt;&gt; mActions</span><br><span class="line">        = <span class="keyword">new</span> HashMap&lt;String, ArrayList&lt;ReceiverRecord&gt;&gt;();</span><br></pre></td></tr></table></figure>
<p>不多说了！</p>
<h3 id="2-2-1-new-ReceiverRecord"><a href="#2-2-1-new-ReceiverRecord" class="headerlink" title="2.2.1 new ReceiverRecord"></a>2.2.1 new ReceiverRecord</h3><p>ReceiverRecord 的代码很简单，不多说了！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiverRecord</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> IntentFilter filter; <span class="comment">// intent filter</span></span><br><span class="line">    <span class="keyword">final</span> BroadcastReceiver receiver;  <span class="comment">// 接收者</span></span><br><span class="line">    <span class="keyword">boolean</span> broadcasting;  <span class="comment">// 表示 receiver 是否被收集到目标列表中！</span></span><br><span class="line"></span><br><span class="line">    ReceiverRecord(IntentFilter _filter, BroadcastReceiver _receiver) &#123;</span><br><span class="line">        filter = _filter;</span><br><span class="line">        receiver = _receiver;</span><br><span class="line">    &#125;</span><br><span class="line">    ... ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-3-LocalBroadcastManager-unregisterReceiver-取消注册"><a href="#2-3-LocalBroadcastManager-unregisterReceiver-取消注册" class="headerlink" title="2.3 LocalBroadcastManager.unregisterReceiver - 取消注册"></a>2.3 LocalBroadcastManager.unregisterReceiver - 取消注册</h2><p>取消注册：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unregisterReceiver</span><span class="params">(BroadcastReceiver receiver)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mReceivers) &#123;</span><br><span class="line">        <span class="comment">//【1】移除 receiver 以及和 intentfilter 的映射关系！</span></span><br><span class="line">        ArrayList&lt;IntentFilter&gt; filters = mReceivers.remove(receiver);</span><br><span class="line">        <span class="keyword">if</span> (filters == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【2】处理 filter 能够过滤的所有 action！</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;filters.size(); i++) &#123;</span><br><span class="line">            IntentFilter filter = filters.get(i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;filter.countActions(); j++) &#123;</span><br><span class="line">                String action = filter.getAction(j);</span><br><span class="line">                <span class="comment">//【2.1】移除 action 和该 BroadcastReceiver 的映射关系！</span></span><br><span class="line">                ArrayList&lt;ReceiverRecord&gt; receivers = mActions.get(action);</span><br><span class="line">                <span class="keyword">if</span> (receivers != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;receivers.size(); k++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (receivers.get(k).receiver == receiver) &#123;</span><br><span class="line">                            receivers.remove(k);</span><br><span class="line">                            k--;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//【2.2】如果没有 receiver 接收该 action，那就移除映射集合！</span></span><br><span class="line">                    <span class="keyword">if</span> (receivers.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        mActions.remove(action);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不多说了！</p>
<h2 id="2-4-LocalBroadcastManager-sendBroadcast-异步广播"><a href="#2-4-LocalBroadcastManager-sendBroadcast-异步广播" class="headerlink" title="2.4 LocalBroadcastManager.sendBroadcast - 异步广播"></a>2.4 LocalBroadcastManager.sendBroadcast - 异步广播</h2><p>sendBroadcast 用于发送异步的广播，该方法在调用会后立刻返回！！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendBroadcast</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mReceivers) &#123;</span><br><span class="line">        <span class="comment">//【1】解析 intent 的相关属性！</span></span><br><span class="line">        <span class="keyword">final</span> String action = intent.getAction();</span><br><span class="line">        <span class="keyword">final</span> String type = intent.resolveTypeIfNeeded(</span><br><span class="line">                mAppContext.getContentResolver());</span><br><span class="line">        <span class="keyword">final</span> Uri data = intent.getData();</span><br><span class="line">        <span class="keyword">final</span> String scheme = intent.getScheme();</span><br><span class="line">        <span class="keyword">final</span> Set&lt;String&gt; categories = intent.getCategories();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> debug = DEBUG ||</span><br><span class="line">                ((intent.getFlags() &amp; Intent.FLAG_DEBUG_LOG_RESOLUTION) != <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (debug) Log.v(</span><br><span class="line">                TAG, <span class="string">"Resolving type "</span> + type + <span class="string">" scheme "</span> + scheme</span><br><span class="line">                + <span class="string">" of intent "</span> + intent);</span><br><span class="line">                </span><br><span class="line">        <span class="comment">//【2】从 mActions 映射表中找到能够处理该 intent 的接收者列表！</span></span><br><span class="line">        ArrayList&lt;ReceiverRecord&gt; entries = mActions.get(intent.getAction());</span><br><span class="line">        <span class="keyword">if</span> (entries != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (debug) Log.v(TAG, <span class="string">"Action list: "</span> + entries);</span><br><span class="line"></span><br><span class="line">            ArrayList&lt;ReceiverRecord&gt; receivers = <span class="keyword">null</span>; <span class="comment">// 保存目标 receiver 实例；</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;entries.size(); i++) &#123;</span><br><span class="line">                <span class="comment">//【2.1】处理每一个 ReceiverRecord 实例；</span></span><br><span class="line">                ReceiverRecord receiver = entries.get(i);</span><br><span class="line">                <span class="keyword">if</span> (debug) Log.v(TAG, <span class="string">"Matching against filter "</span> + receiver.filter);</span><br><span class="line">                <span class="comment">//【2.2】如果 receiver.broadcasting 为 true，说明目标 receiver 已经添加到目标集合中了；</span></span><br><span class="line">                <span class="keyword">if</span> (receiver.broadcasting) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (debug) &#123;</span><br><span class="line">                        Log.v(TAG, <span class="string">"  Filter's target already added"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//【2.3】匹配 receiver！</span></span><br><span class="line">                <span class="keyword">int</span> match = receiver.filter.match(action, type, scheme, data,</span><br><span class="line">                        categories, <span class="string">"LocalBroadcastManager"</span>);</span><br><span class="line">                        </span><br><span class="line">                <span class="comment">//【2.4】匹配成功，将目标 receiver 加入到目标列表中！</span></span><br><span class="line">                <span class="keyword">if</span> (match &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (debug) Log.v(TAG, <span class="string">"  Filter matched!  match=0x"</span> +</span><br><span class="line">                            Integer.toHexString(match));</span><br><span class="line">                    <span class="keyword">if</span> (receivers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        receivers = <span class="keyword">new</span> ArrayList&lt;ReceiverRecord&gt;();</span><br><span class="line">                    &#125;</span><br><span class="line">                    receivers.add(receiver);</span><br><span class="line">                    receiver.broadcasting = <span class="keyword">true</span>; <span class="comment">// 设置 broadcasting 为 true！</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (debug) &#123;</span><br><span class="line">                        String reason;</span><br><span class="line">                        <span class="keyword">switch</span> (match) &#123;</span><br><span class="line">                            <span class="keyword">case</span> IntentFilter.NO_MATCH_ACTION: reason = <span class="string">"action"</span>; <span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">case</span> IntentFilter.NO_MATCH_CATEGORY: reason = <span class="string">"category"</span>; <span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">case</span> IntentFilter.NO_MATCH_DATA: reason = <span class="string">"data"</span>; <span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">case</span> IntentFilter.NO_MATCH_TYPE: reason = <span class="string">"type"</span>; <span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">default</span>: reason = <span class="string">"unknown reason"</span>; <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        Log.v(TAG, <span class="string">"  Filter did not match: "</span> + reason);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//【3】收集完所有匹配的 receiver，开始发送广播！</span></span><br><span class="line">            <span class="keyword">if</span> (receivers != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//【3.1】将所有 receiver 的 broadcasting 置为 false；</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;receivers.size(); i++) &#123;</span><br><span class="line">                    receivers.get(i).broadcasting = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//【2.4.1】创建 BroadcastRecord 实例，将其添加到 mPendingBroadcasts 列表中！</span></span><br><span class="line">                mPendingBroadcasts.add(<span class="keyword">new</span> BroadcastRecord(intent, receivers));</span><br><span class="line">                <span class="keyword">if</span> (!mHandler.hasMessages(MSG_EXEC_PENDING_BROADCASTS)) &#123;</span><br><span class="line">                    <span class="comment">//【3.1】发送 MSG_EXEC_PENDING_BROADCASTS，处理广播！</span></span><br><span class="line">                    mHandler.sendEmptyMessage(MSG_EXEC_PENDING_BROADCASTS);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 LocalBroadcastManager 还有如下的一个 list 表：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存所有等待发送的 broadcast！</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;BroadcastRecord&gt; mPendingBroadcasts</span><br><span class="line">        = <span class="keyword">new</span> ArrayList&lt;BroadcastRecord&gt;();</span><br></pre></td></tr></table></figure></p>
<p>其实，sendBroadcast 方法，本质上是将 BroadcastRecord 添加到内部的 mPendingBroadcasts 集合中，然后发送 MSG_EXEC_PENDING_BROADCASTS 消息，处理广播！</p>
<p>之所以是异步的原因是，sendBroadcast 方法只是将广播加入到了 mPendingBroadcasts 中后，会立刻返回；</p>
<p>而广播的分发是在主线程，如果我们在子线程中 sendBroadcast 的话，整个过程显然是异步的！</p>
<p>继续分析：</p>
<h3 id="2-4-1-new-BroadcastRecord"><a href="#2-4-1-new-BroadcastRecord" class="headerlink" title="2.4.1 new BroadcastRecord"></a>2.4.1 new BroadcastRecord</h3><p>用于表示一个广播实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BroadcastRecord</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Intent intent; <span class="comment">// 意图 </span></span><br><span class="line">    <span class="keyword">final</span> ArrayList&lt;ReceiverRecord&gt; receivers; <span class="comment">// 目标 receiver 列表；</span></span><br><span class="line"></span><br><span class="line">    BroadcastRecord(Intent _intent, ArrayList&lt;ReceiverRecord&gt; _receivers) &#123;</span><br><span class="line">        intent = _intent;</span><br><span class="line">        receivers = _receivers;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不用多说了！</p>
<h2 id="2-5-LocalBroadcastManager-sendBroadcastSync-同步广播"><a href="#2-5-LocalBroadcastManager-sendBroadcastSync-同步广播" class="headerlink" title="2.5 LocalBroadcastManager.sendBroadcastSync - 同步广播"></a>2.5 LocalBroadcastManager.sendBroadcastSync - 同步广播</h2><p>sendBroadcastSync 用于同步发送广播：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendBroadcastSync</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【2.4】将广播添加到 mPendingBroadcasts 列表中！</span></span><br><span class="line">    <span class="keyword">if</span> (sendBroadcast(intent)) &#123;</span><br><span class="line">        <span class="comment">//【2.6】立刻触发广播的接收！</span></span><br><span class="line">        executePendingBroadcasts();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sendBroadcastSync 方法之所以是同步的是因为，当我们 sendBroadcast 将广播加入到 mPendingBroadcasts 列表中后，会立刻调用 executePendingBroadcasts 分发广播，整个流程都是在同一个线程中执行的！</p>
<p><strong>注意</strong>：</p>
<blockquote>
<p><strong>按照以往认知</strong>：BroadcastReceiver 的 onReceive 应该是在主线程中调用的，但是在这里，BroadcastReceiver 的 onReceive 方法却可以在非主线程中调用！</p>
</blockquote>
<blockquote>
<p><strong>主要差别是</strong>：两种情况下的实现方式不同，前者是跨进程通信，所以 onReceive 始终是在主线程中拉起的；而后者由于实质上只是一个回调，所以可以在任何线程中拉起！</p>
</blockquote>
<h2 id="2-6-LocalBroadcastManager-executePendingBroadcasts-接收广播"><a href="#2-6-LocalBroadcastManager-executePendingBroadcasts-接收广播" class="headerlink" title="2.6 LocalBroadcastManager.executePendingBroadcasts - 接收广播"></a>2.6 LocalBroadcastManager.executePendingBroadcasts - 接收广播</h2><p>executePendingBroadcasts 用于分发和接收广播！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">executePendingBroadcasts</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">//【1】将 mPendingBroadcasts 中待处理的广播拷贝到临时分发数组 brs 中</span></span><br><span class="line">        <span class="comment">// 并清空 mPendingBroadcasts；</span></span><br><span class="line">        BroadcastRecord[] brs = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">synchronized</span> (mReceivers) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> N = mPendingBroadcasts.size();</span><br><span class="line">            <span class="keyword">if</span> (N &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// 如果 mPendingBroadcasts 为 null，那就结束发送；</span></span><br><span class="line">            &#125;</span><br><span class="line">            brs = <span class="keyword">new</span> BroadcastRecord[N];</span><br><span class="line">            mPendingBroadcasts.toArray(brs);</span><br><span class="line">            mPendingBroadcasts.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【2】拉起所有 receiver 的 onReceive 方法，处理广播；</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;brs.length; i++) &#123;</span><br><span class="line">            BroadcastRecord br = brs[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;br.receivers.size(); j++) &#123;</span><br><span class="line">                br.receivers.get(j).receiver.onReceive(mAppContext, br.intent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>逻辑也很清楚！</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2016/06/23/Serivce 篇 5 - unbindService 流程分析/">Serivce 篇 5 - unbindService 流程分析</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2016-06-23</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/AndroidFramework源码分析/">AndroidFramework源码分析</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/AndroidFramework源码分析/Service服务/">Service服务</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Service服务/">Service服务</a></span><div class="content"><p>本文基于 Android 7.1.1 源码分析，转载请说明出处！</p>
<h1 id="0-综述"><a href="#0-综述" class="headerlink" title="0 综述"></a>0 综述</h1><p>我们通过 bindService 绑定的服务，需要通过 unbindService 来解除绑定：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.unbindService(conn);</span><br></pre></td></tr></table></figure>
<p>以前我们只是会调用，但是其底层的调用到底是什么样的呢？知其然知其所以然，今天我们就来学习下 unbindService 的过程！</p>
<h1 id="1-发起端进程"><a href="#1-发起端进程" class="headerlink" title="1 发起端进程"></a>1 发起端进程</h1><h2 id="1-1-ContextWrapper-unbindService"><a href="#1-1-ContextWrapper-unbindService" class="headerlink" title="1.1 ContextWrapper.unbindService"></a>1.1 ContextWrapper.unbindService</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unbindService</span><span class="params">(ServiceConnection conn)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    mBase.unbindService(conn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ContextWrapper</code> 提供了两个方法来启动 <code>Service</code>，其中一个是隐藏方法：<code>startServiceAsUser</code>！</p>
<p><code>mBase</code> 是 <code>ContextImpl</code> 对象，继续看！</p>
<h2 id="1-2-ContextImpl-unbindService"><a href="#1-2-ContextImpl-unbindService" class="headerlink" title="1.2 ContextImpl.unbindService"></a>1.2 ContextImpl.unbindService</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContextImpl</span> <span class="keyword">extends</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unbindService</span><span class="params">(ServiceConnection conn)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (conn == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"connection is null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mPackageInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//【1】这里的 mPackageInfo 是 LoadedApk 类型的！</span></span><br><span class="line">            <span class="comment">// 获得 ServiceConnection 对应的 InnerConnection</span></span><br><span class="line">            IServiceConnection sd = mPackageInfo.forgetServiceDispatcher(</span><br><span class="line">                    getOuterContext(), conn);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//【2】进入系统进程！</span></span><br><span class="line">                ActivityManagerNative.getDefault().unbindService(sd);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Not supported in system context"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ContextImpl</code> 和 <code>ContextWrapper</code> 的具体关系，请来看另一博文：<code>Android</code> 系统的 <code>Context</code> 分析，这里我们不再详细说明！</p>
<p><code>mUser</code>：表示的是当前的设备 <code>user</code>！</p>
<h3 id="1-2-1-LoadedApk-forgetServiceDispatcher"><a href="#1-2-1-LoadedApk-forgetServiceDispatcher" class="headerlink" title="1.2.1 LoadedApk.forgetServiceDispatcher"></a>1.2.1 LoadedApk.forgetServiceDispatcher</h3><p>参数传入：</p>
<ul>
<li><code>ServiceConnection c</code>：应用程序的链接对象！</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> IServiceConnection <span class="title">forgetServiceDispatcher</span><span class="params">(Context context,</span></span></span><br><span class="line"><span class="function"><span class="params">        ServiceConnection c)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mServices) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【1】获得当前进程中 Context 运行环境对应的连接映射关系集合！</span></span><br><span class="line">        ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt; map</span><br><span class="line">                = mServices.get(context);</span><br><span class="line"></span><br><span class="line">        LoadedApk.ServiceDispatcher sd = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">//【2】获得当前 ServiceConnection 对应的 ServiceDispatcher 服务分发对象！</span></span><br><span class="line">            sd = map.get(c);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (sd != <span class="keyword">null</span>) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 移除对应 ServiceDispatcher 服务分发对象！</span></span><br><span class="line">                map.remove(c);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//【2.1】设置 mForgotten 的值为 true！</span></span><br><span class="line">                sd.doForget();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (map.size() == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 当 Context 运行环境下已经没有连接映射，那就从 LoadkedApk.mServices 移除！</span></span><br><span class="line">                    mServices.remove(context);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// Context.BIND_DEBUG_UNBIND 标志是在 bindService 时设置的，用于 unbind 的 debug 调试！</span></span><br><span class="line">                <span class="comment">// 这里我们不看！</span></span><br><span class="line">                <span class="keyword">if</span> ((sd.getFlags()&amp;Context.BIND_DEBUG_UNBIND) != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt; holder</span><br><span class="line">                            = mUnboundServices.get(context);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        holder = <span class="keyword">new</span> ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt;();</span><br><span class="line">                        mUnboundServices.put(context, holder);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    RuntimeException ex = <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                            <span class="string">"Originally unbound here:"</span>);</span><br><span class="line"></span><br><span class="line">                    ex.fillInStackTrace();</span><br><span class="line">                    sd.setUnbindLocation(ex);</span><br><span class="line">                    holder.put(c, sd);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 返回 InnerConnection 对象！</span></span><br><span class="line">                <span class="keyword">return</span> sd.getIServiceConnection();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt; holder</span><br><span class="line">                = mUnboundServices.get(context);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (holder != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sd = holder.get(c);</span><br><span class="line">            <span class="keyword">if</span> (sd != <span class="keyword">null</span>) &#123;</span><br><span class="line">                RuntimeException ex = sd.getUnbindLocation();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                        <span class="string">"Unbinding Service "</span> + c</span><br><span class="line">                        + <span class="string">" that was already unbound"</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (context == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unbinding Service "</span> + c</span><br><span class="line">                    + <span class="string">" from Context that is no longer in use: "</span> + context);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Service not registered: "</span> + c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里逻辑很简单，其中，调用了 <code>ServiceDispatcher.doForget</code> 方法！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doForget</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;mActiveConnections.size(); i++) &#123;</span><br><span class="line">            ServiceDispatcher.ConnectionInfo ci = mActiveConnections.valueAt(i);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//【1】取消死亡监控器</span></span><br><span class="line">            ci.binder.unlinkToDeath(ci.deathMonitor, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 清楚这个连接对应的 mActiveConnections 集合！</span></span><br><span class="line">        mActiveConnections.clear();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 置 mForgotten 为 true！</span></span><br><span class="line">        mForgotten = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们继续看！！</p>
<p>接着，调用 <code>ActivityManagerNative.getDefault()</code> 方法，获得 <code>AMS</code> 的代理对象 <code>ActivityManagerProxy</code>！</p>
<p><code>ActivityManagerProxy</code> 是 <code>ActivityManagerN</code> 的内部类，通过 <code>getDefault</code> 方法创建了对应的单例模式，保存在 <code>ActivityManagerNative</code> 的类变量 <code>getDefault</code> 中！</p>
<h2 id="1-3-ActivityManagerP-unbindService"><a href="#1-3-ActivityManagerP-unbindService" class="headerlink" title="1.3 ActivityManagerP.unbindService"></a>1.3 ActivityManagerP.unbindService</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">unbindService</span><span class="params">(IServiceConnection connection)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    Parcel data = Parcel.obtain();</span><br><span class="line">    Parcel reply = Parcel.obtain();</span><br><span class="line">    data.writeInterfaceToken(IActivityManager.descriptor);</span><br><span class="line">    data.writeStrongBinder(connection.asBinder());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】传递 UNBIND_SERVICE_TRANSACTION，flags 为 0，是阻塞式通信！</span></span><br><span class="line">    mRemote.transact(UNBIND_SERVICE_TRANSACTION, data, reply, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    reply.readException();</span><br><span class="line">    <span class="keyword">boolean</span> res = reply.readInt() != <span class="number">0</span>;</span><br><span class="line">    data.recycle();</span><br><span class="line">    reply.recycle();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 <code>binder</code> 进程间通信，进入系统进程，参数分析：</p>
<ul>
<li><code>IServiceConnection connection</code>：<code>InnerConnection</code> 对象！</li>
</ul>
<h1 id="2-系统进程"><a href="#2-系统进程" class="headerlink" title="2 系统进程"></a>2 系统进程</h1><p>首先，进入 <code>ActivityManagerN</code> 中去看看：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> UNBIND_SERVICE_TRANSACTION: &#123;</span><br><span class="line">    data.enforceInterface(IActivityManager.descriptor);</span><br><span class="line">    IBinder b = data.readStrongBinder();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【1】这里是转换为 IServiceConnection.proxy 对象！</span></span><br><span class="line">    IServiceConnection conn = IServiceConnection.Stub.asInterface(b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> res = unbindService(conn);</span><br><span class="line"></span><br><span class="line">    reply.writeNoException();</span><br><span class="line">    reply.writeInt(res ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-1-ActivityManagerP-unbindService"><a href="#2-1-ActivityManagerP-unbindService" class="headerlink" title="2.1 ActivityManagerP.unbindService"></a>2.1 ActivityManagerP.unbindService</h2><p>继续来看：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">unbindService</span><span class="params">(IServiceConnection connection)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【1】进入 ActiveServices 方法！</span></span><br><span class="line">        <span class="keyword">return</span> mServices.unbindServiceLocked(connection);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-2-ActiveServices-unbindServiceLocked"><a href="#2-2-ActiveServices-unbindServiceLocked" class="headerlink" title="2.2 ActiveServices.unbindServiceLocked"></a>2.2 ActiveServices.unbindServiceLocked</h2><p>解除服务 <code>bind</code>，参数传入如下：</p>
<ul>
<li><code>IServiceConnection connection</code>：是 <code>IServiceConnection.Proxy</code> 类型的对象，是 <code>InnerConnection</code> 在系统进程中的 <code>Binder</code>实体对象！<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">unbindServiceLocked</span><span class="params">(IServiceConnection connection)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    IBinder binder = connection.asBinder();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">"unbindService: conn="</span> + binder);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】从 mServiceConnections 中获得对应的 ConnectionRecord 集合！</span></span><br><span class="line">    <span class="comment">// 表示 IServiceConnection 对象对应的所有连接对象！</span></span><br><span class="line">    ArrayList&lt;ConnectionRecord&gt; clist = mServiceConnections.get(binder);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (clist == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        Slog.w(TAG, <span class="string">"Unbind failed: could not find connection for "</span></span><br><span class="line">              + connection.asBinder());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (clist.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历 ConnectionRecord 列表！</span></span><br><span class="line">            ConnectionRecord r = clist.get(<span class="number">0</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//【2】移除连接，并拉起被绑定服务的 unbind 方法，这个我们后面看！</span></span><br><span class="line">            removeConnectionLocked(r, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (clist.size() &gt; <span class="number">0</span> &amp;&amp; clist.get(<span class="number">0</span>) == r) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// removeConnectionLocked 中会移除这个 ConnectionRecord 对象，这里是异常判断；</span></span><br><span class="line">                <span class="comment">// 如果 removeConnectionLocked 移除失败，这里会再次移除！</span></span><br><span class="line">                Slog.wtf(TAG, <span class="string">"Connection "</span> + r + <span class="string">" not removed for binder "</span> + binder);</span><br><span class="line">                clist.remove(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果绑定的服务的进程已经启动，进入该分支！</span></span><br><span class="line">            <span class="keyword">if</span> (r.binding.service.app != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (r.binding.service.app.whitelistManager) &#123;</span><br><span class="line">                    updateWhitelistManagerLocked(r.binding.service.app);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// This could have made the service less important.</span></span><br><span class="line">                <span class="keyword">if</span> ((r.flags&amp;Context.BIND_TREAT_LIKE_ACTIVITY) != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    r.binding.service.app.treatLikeActivity = <span class="keyword">true</span>;</span><br><span class="line">                    mAm.updateLruProcessLocked(r.binding.service.app,</span><br><span class="line">                            r.binding.service.app.hasClientActivities</span><br><span class="line">                            || r.binding.service.app.treatLikeActivity, <span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 更新服务的 adj 的值！</span></span><br><span class="line">                mAm.updateOomAdjLocked(r.binding.service.app);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong><code>ActiveServices</code></strong> 的 <strong><code>mServiceConnections</code></strong> 用来封装所有服务的连接对象 <code>IServiceConnection.proxy</code> 和<br><code>ConnectionRecord</code> 的映射关系，二者是一对多的关系！</p>
<p>继续来看！</p>
<h2 id="2-3-ActiveServices-removeConnectionLocked"><a href="#2-3-ActiveServices-removeConnectionLocked" class="headerlink" title="2.3 ActiveServices.removeConnectionLocked"></a>2.3 ActiveServices.removeConnectionLocked</h2><p>这个方法是 <code>unbindService</code> 整个流程中的关键！</p>
<ul>
<li><code>ConnectionRecord c</code>：连接信息对象；</li>
<li><code>ProcessRecord skipApp</code>：传入为 <code>null</code>；</li>
<li><code>ActivityRecord skipAct</code>：传入为 <code>null</code>；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeConnectionLocked</span><span class="params">(ConnectionRecord c, ProcessRecord skipApp, ActivityRecord skipAct)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里的 c.conn 是 IServiceConnection.Proxy 代理对象，映射着应用进程中的一个连接对象；</span></span><br><span class="line">    IBinder binder = c.conn.asBinder();</span><br><span class="line">    <span class="comment">// 获得 ConnectionRecord 对象所属的进程绑定信息对象 AppBindRecord；</span></span><br><span class="line">    AppBindRecord b = c.binding;</span><br><span class="line">    <span class="comment">// 获得所绑定的服务对象 ServiceRecord；</span></span><br><span class="line">    ServiceRecord s = b.service;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】删除 bindService 时创建的数据结构和引用关系!</span></span><br><span class="line">    <span class="comment">// 从 ServiceRecord.connections 中获得 IServiceConnection.Proxy 对应的 ArrayList&lt;ConnectionRecord&gt; 集合！</span></span><br><span class="line">    <span class="comment">// 并中删除当前的 ConnectionRecord 对象！</span></span><br><span class="line">    ArrayList&lt;ConnectionRecord&gt; clist = s.connections.get(binder);</span><br><span class="line">    <span class="keyword">if</span> (clist != <span class="keyword">null</span>) &#123;</span><br><span class="line">        clist.remove(c);</span><br><span class="line">        <span class="keyword">if</span> (clist.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果 ArrayList&lt;ConnectionRecord&gt; 长度为 0，就移除</span></span><br><span class="line">            <span class="comment">// IServiceConnection.Proxy 和 ArrayList&lt;ConnectionRecord&gt; 映射！</span></span><br><span class="line">            s.connections.remove(binder);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 AppBindRecord.connections 中移除 ConnectionRecord！</span></span><br><span class="line">    b.connections.remove(c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c.activity != <span class="keyword">null</span> &amp;&amp; c.activity != skipAct) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c.activity.connections != <span class="keyword">null</span>) &#123;</span><br><span class="line">            c.activity.connections.remove(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// AppBindRecord.client 是 ProcessRecord 对象，表示绑定者所在的进程，</span></span><br><span class="line">    <span class="comment">// 这里是从 ProcessRecord.connections 集合中删除当前的 ConnectionRecord！</span></span><br><span class="line">    <span class="keyword">if</span> (b.client != skipApp) &#123;</span><br><span class="line">        b.client.connections.remove(c);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((c.flags&amp;Context.BIND_ABOVE_CLIENT) != <span class="number">0</span>) &#123;</span><br><span class="line">            b.client.updateHasAboveClientLocked();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((c.flags&amp;Context.BIND_ALLOW_WHITELIST_MANAGEMENT) != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            s.updateWhitelistManager();</span><br><span class="line">            <span class="keyword">if</span> (!s.whitelistManager &amp;&amp; s.app != <span class="keyword">null</span>) &#123;</span><br><span class="line">                updateWhitelistManagerLocked(s.app);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s.app != <span class="keyword">null</span>) &#123;</span><br><span class="line">            updateServiceClientActivitiesLocked(s.app, c, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 ActiveServices.mServiceConnections 获得 IServiceConnection.Proxy 对应的 ArrayList&lt;ConnectionRecord&gt;！</span></span><br><span class="line">    <span class="comment">// 并从 ArrayList&lt;ConnectionRecord&gt; 中删除 ConnectionRecord！</span></span><br><span class="line">    clist = mServiceConnections.get(binder);</span><br><span class="line">    <span class="keyword">if</span> (clist != <span class="keyword">null</span>) &#123;</span><br><span class="line">        clist.remove(c);</span><br><span class="line">        <span class="keyword">if</span> (clist.size() == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果 ArrayList&lt;ConnectionRecord&gt; 长度为 0，就移除</span></span><br><span class="line">            <span class="comment">// IServiceConnection.Proxy 和 ArrayList&lt;ConnectionRecord&gt; 映射！</span></span><br><span class="line">            mServiceConnections.remove(binder);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mAm.stopAssociationLocked(b.client.uid, b.client.processName, s.appInfo.uid, s.name);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 AppBindRecord.connections 的元素个数为 0，表示该进程中已经没有连接对象了！</span></span><br><span class="line">    <span class="comment">// 就删除 AppBindRecord.IntentBindRecord.apps 中调用者进程 ProcessRecord 和 AppBindRecord 的映射！</span></span><br><span class="line">    <span class="keyword">if</span> (b.connections.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        b.intent.apps.remove(b.client);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此时，服务没有死亡，进入这个分支！！</span></span><br><span class="line">    <span class="keyword">if</span> (!c.serviceDead) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">"Disconnecting binding "</span> + b.intent</span><br><span class="line">                + <span class="string">": shouldUnbind="</span> + b.intent.hasBound);</span><br><span class="line">                </span><br><span class="line">        <span class="comment">// 当服务所在进程没有被销毁，且已经没有任何进程通过该 intent 绑定该服务了，就进入这里！</span></span><br><span class="line">        <span class="keyword">if</span> (s.app != <span class="keyword">null</span> &amp;&amp; s.app.thread != <span class="keyword">null</span> &amp;&amp; b.intent.apps.size() == <span class="number">0</span></span><br><span class="line">                &amp;&amp; b.intent.hasBound) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            </span><br><span class="line">                <span class="comment">// 【2】设置拉起 onunbind 方法超时处理任务，这里不多说了，逻辑类似！</span></span><br><span class="line">                bumpServiceExecutingLocked(s, <span class="keyword">false</span>, <span class="string">"unbind"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (b.client != s.app &amp;&amp; (c.flags&amp;Context.BIND_WAIVE_PRIORITY) == <span class="number">0</span></span><br><span class="line">                        &amp;&amp; s.app.setProcState &lt;= ActivityManager.PROCESS_STATE_RECEIVER) &#123;</span><br><span class="line">                    mAm.updateLruProcessLocked(s.app, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                mAm.updateOomAdjLocked(s.app);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 设置 IntentBindRecord.hasBound 为 false，表示绑定解除！</span></span><br><span class="line">                b.intent.hasBound = <span class="keyword">false</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 设置 IntentBindRecord.doRebind 为 false，后面会根据 onUnbind 的返回值来设置 doRebind！</span></span><br><span class="line">                b.intent.doRebind = <span class="keyword">false</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 【3】通过 binder 通信，进入被绑定服务所在的进程，拉起其 onUnbind 方法</span></span><br><span class="line">                <span class="comment">// 采用的是 IBinder.FLAG_ONEWAY 的方式，非阻塞式！！</span></span><br><span class="line">                s.app.thread.scheduleUnbindService(s, b.intent.intent.getIntent());</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">                Slog.w(TAG, <span class="string">"Exception when unbinding service "</span> + s.shortName, e);</span><br><span class="line">                serviceProcessGoneLocked(s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果接触绑定的时候，服务正在启动,那就将服务从 mPendingServices 中删除！</span></span><br><span class="line">        mPendingServices.remove(s);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【4】如果服务之前 bind 时，flags 设置了 Context.BIND_AUTO_CREATE，就尝试停止服务！ </span></span><br><span class="line">        <span class="keyword">if</span> ((c.flags&amp;Context.BIND_AUTO_CREATE) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> hasAutoCreate = s.hasAutoCreateConnections();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!hasAutoCreate) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s.tracker != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    s.tracker.setBound(<span class="keyword">false</span>, mAm.mProcessStats.getMemFactorLocked(),</span><br><span class="line">                            SystemClock.uptimeMillis());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 【4.1】尝试停止服务！</span></span><br><span class="line">            bringDownServiceIfNeededLocked(s, <span class="keyword">true</span>, hasAutoCreate);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码最开始是解除 <code>bindService</code> 时创建的数据结构和引用关系！然后拉起了被绑定服务的 <code>unbind</code> 方法，最后尝试停止服务！</p>
<p>注意：</p>
<p>如果之前对应的 <code>bindService</code> 使用了 <code>Context.BIND_AUTO_CREATE</code> 的 <code>flags</code>，这里就会尝试把服务停止，但是如果之前对应的 <code>bindService</code> 没有设置 <code>Context.BIND_AUTO_CREATE</code> 标志位，从前面的 <code>bindService</code> 流程中，可以看出，只会把之前 <code>bind</code> 时的绑定信息删除即可！</p>
<p>下面我们来一个一个分析！</p>
<h3 id="2-3-1-ApplicationThreadP-scheduleUnbindService"><a href="#2-3-1-ApplicationThreadP-scheduleUnbindService" class="headerlink" title="2.3.1 ApplicationThreadP.scheduleUnbindService"></a>2.3.1 ApplicationThreadP.scheduleUnbindService</h3><p>首先，来看看拉起 onUnbind 方法的逻辑！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleUnbindService</span><span class="params">(IBinder token, Intent intent)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    Parcel data = Parcel.obtain();</span><br><span class="line">    data.writeInterfaceToken(IApplicationThread.descriptor);</span><br><span class="line"></span><br><span class="line">    data.writeStrongBinder(token);</span><br><span class="line">    intent.writeToParcel(data, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】binder 通信，采用的是 IBinder.FLAG_ONEWAY 的方式，非阻塞式！</span></span><br><span class="line">    mRemote.transact(SCHEDULE_UNBIND_SERVICE_TRANSACTION, data, <span class="keyword">null</span>,</span><br><span class="line">            IBinder.FLAG_ONEWAY);</span><br><span class="line"></span><br><span class="line">    data.recycle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里通过 binder 通信，进入服务所在的应用进程中！我们在第三部分详细讨论！！</p>
<h3 id="2-3-2-ActiveServices-bringDownServiceIfNeededLocked"><a href="#2-3-2-ActiveServices-bringDownServiceIfNeededLocked" class="headerlink" title="2.3.2 ActiveServices.bringDownServiceIfNeededLocked"></a>2.3.2 ActiveServices.bringDownServiceIfNeededLocked</h3><p>拉起了服务的 <code>onUnbind</code> 方法后，对于 <code>bindService</code> 时，如果设置了 <code>Context.BIND_AUTO_CREATE</code> 的 <code>flags</code>，还要尝试停止服务！</p>
<p>我们来看一下具体的逻辑！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">bringDownServiceIfNeededLocked</span><span class="params">(ServiceRecord r, <span class="keyword">boolean</span> knowConn,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> hasConn)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【1】如果这个服务还被需要，就不能停止！</span></span><br><span class="line">    <span class="keyword">if</span> (isServiceNeeded(r, knowConn, hasConn)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】服务正在被启动，就不能停止！</span></span><br><span class="line">    <span class="keyword">if</span> (mPendingServices.contains(r)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【3】继续停止服务！ </span></span><br><span class="line">    bringDownServiceLocked(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果这个服务仍然被需要，或者服务所在的进程正在启动，这两种情况下，不能停止服务！</p>
<h4 id="2-3-2-1-ActiveServices-isServiceNeeded"><a href="#2-3-2-1-ActiveServices-isServiceNeeded" class="headerlink" title="2.3.2.1 ActiveServices.isServiceNeeded"></a>2.3.2.1 ActiveServices.isServiceNeeded</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isServiceNeeded</span><span class="params">(ServiceRecord r, <span class="keyword">boolean</span> knowConn, <span class="keyword">boolean</span> hasConn)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】服务已经通过 startService 启动了，返回 true！</span></span><br><span class="line">    <span class="keyword">if</span> (r.startRequested) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】仍然有应用通过 auto create 的方式绑定该服务，通过前面的分析，这里的自动创建的服务链接被移除了！！</span></span><br><span class="line">    <span class="keyword">if</span> (!knowConn) &#123;</span><br><span class="line">        hasConn = r.hasAutoCreateConnections();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasConn) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>hasAutoCreateConnections</code> 方法遍历 <code>ServiceRecord.connections</code> 集合：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in ServiceRecord</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasAutoCreateConnections</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> conni=connections.size()-<span class="number">1</span>; conni&gt;=<span class="number">0</span>; conni--) &#123;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;ConnectionRecord&gt; cr = connections.valueAt(conni);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;cr.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((cr.get(i).flags&amp;Context.BIND_AUTO_CREATE) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>判断一个服务是否仍被需要，有两种情况：</p>
<ul>
<li>服务已经通过 <code>startService</code> 被请求启动了；</li>
<li>服务仍然被一些应用通过自动创建的方式绑定，即 <code>bindService</code> 时，<code>flags</code> 为 <code>Context.BIND_AUTO_CREATE</code>；</li>
</ul>
<p>如果满足上面的任何一个条件，<code>isServiceNeeded</code> 返回的是 <code>true</code>，那么，就不会停止这个任务了！</p>
<p>通过我们上面的分析，当我们调用 <code>unbindService</code>后，会将之前 <code>bind</code> 时的创建的连接对象从集合中移除，所以<code>hasConn</code>为<code>false</code>，但是如果服务之前被<code>startService</code>启动了，并没有<code>stopService</code>，那么<code>unbindService</code>不会继续执行！</p>
<p>下面，我们继续来看：</p>
<h4 id="2-3-2-2-ActiveServices-bringDownServiceLocked"><a href="#2-3-2-2-ActiveServices-bringDownServiceLocked" class="headerlink" title="2.3.2.2 ActiveServices.bringDownServiceLocked"></a>2.3.2.2 ActiveServices.bringDownServiceLocked</h4><p>如果没有其他的应用通过 <code>BIND_AUTO_CREATE</code> 的方式来绑定这个服务，那么就要调用 <code>bringDownServiceLocked</code> 方法，来停止服务，这里我们假设没有其他的绑定信息！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">bringDownServiceLocked</span><span class="params">(ServiceRecord r)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先，遍历 r.connections 集合，终止所有的 bind 连接！</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> conni=r.connections.size()-<span class="number">1</span>; conni&gt;=<span class="number">0</span>; conni--) &#123;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;ConnectionRecord&gt; c = r.connections.valueAt(conni);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;c.size(); i++) &#123;</span><br><span class="line">            ConnectionRecord cr = c.get(i);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 设置每一个 ConnectionRecord.serviceDead 为 true，表示服务要被 stop 掉，连接断开！</span></span><br><span class="line">            <span class="comment">// 因为这里设置了每一个 ConnectionRecord，所以前面只有第一次调用才会进入！</span></span><br><span class="line">            cr.serviceDead = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//【1】Binder 调用，进入应用进程触发 ServiceConnection 的 onServiceDisconnected，这是非阻塞的！</span></span><br><span class="line">                <span class="comment">// 这里第二个参数，为 null，所以会触发 onServiceDisconnected！</span></span><br><span class="line">                cr.conn.connected(r.name, <span class="keyword">null</span>);</span><br><span class="line">                </span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Failure disconnecting service "</span> + r.name +</span><br><span class="line">                      <span class="string">" to connection "</span> + c.get(i).conn.asBinder() +</span><br><span class="line">                      <span class="string">" (in "</span> + c.get(i).binding.client.processName + <span class="string">")"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理所有的 ServiceRecord.bindings 集合中的 IntentBindRecord 对象！</span></span><br><span class="line">    <span class="comment">// 因为绑定该服务的不止一个，现在要停止服务了，所以要解除所有的绑定！</span></span><br><span class="line">    <span class="keyword">if</span> (r.app != <span class="keyword">null</span> &amp;&amp; r.app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=r.bindings.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line"></span><br><span class="line">            IntentBindRecord ibr = r.bindings.valueAt(i);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">"Bringing down binding "</span> + ibr</span><br><span class="line">                    + <span class="string">": hasBound="</span> + ibr.hasBound);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 显然是 hasBound 是 true 的！        </span></span><br><span class="line">            <span class="keyword">if</span> (ibr.hasBound) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 设置 unbind 超时处理</span></span><br><span class="line">                    bumpServiceExecutingLocked(r, <span class="keyword">false</span>, <span class="string">"bring down unbind"</span>);</span><br><span class="line">                    mAm.updateOomAdjLocked(r.app);</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 置 IntentBindRecord 对象的 hasBound 为 false，表示 bind 断开；</span></span><br><span class="line">                    ibr.hasBound = <span class="keyword">false</span>;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//【2】通过 binder 通信，进入绑定了服务的应用进程，调用 AT.scheduleUnbindService 方法</span></span><br><span class="line">                    <span class="comment">// ，拉起服务的 onUnbind 方法！</span></span><br><span class="line">                    r.app.thread.scheduleUnbindService(r,</span><br><span class="line">                            ibr.intent.getIntent());</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    Slog.w(TAG, <span class="string">"Exception when unbinding service "</span></span><br><span class="line">                            + r.shortName, e);</span><br><span class="line"></span><br><span class="line">                    serviceProcessGoneLocked(r);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">"Bringing down "</span> + r + <span class="string">" "</span> + r.intent);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置服务的销毁时间</span></span><br><span class="line">    r.destroyTime = SystemClock.uptimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (LOG_SERVICE_START_STOP) &#123;</span><br><span class="line">        EventLogTags.writeAmDestroyService(</span><br><span class="line">                r.userId, System.identityHashCode(r), (r.app != <span class="keyword">null</span>) ? r.app.pid : -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ServiceMap smap = getServiceMap(r.userId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 ActiveServices 的 mServiceMap 中移除服务 ServiceRecord 对象！</span></span><br><span class="line">    smap.mServicesByName.remove(r.name);</span><br><span class="line">    smap.mServicesByIntent.remove(r.intent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重启参数置为 0</span></span><br><span class="line">    r.totalRestartCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取消重启任务</span></span><br><span class="line">    unscheduleServiceRestartLocked(r, <span class="number">0</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 mPendingServices 列表中移除！</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=mPendingServices.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mPendingServices.get(i) == r) &#123;</span><br><span class="line">            mPendingServices.remove(i);</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">"Removed pending: "</span> + r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 取消前台的通知！</span></span><br><span class="line">    cancelForegroudNotificationLocked(r);</span><br><span class="line">    </span><br><span class="line">    r.isForeground = <span class="keyword">false</span>;</span><br><span class="line">    r.foregroundId = <span class="number">0</span>;</span><br><span class="line">    r.foregroundNoti = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理启动项集合！</span></span><br><span class="line">    r.clearDeliveredStartsLocked();</span><br><span class="line">    r.pendingStarts.clear();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.app != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (r.stats.getBatteryStats()) &#123;</span><br><span class="line">            r.stats.stopLaunchedLocked();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将服务从其所在进程的 app.services 集合中删除！</span></span><br><span class="line">        r.app.services.remove(r);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (r.whitelistManager) &#123;</span><br><span class="line">            updateWhitelistManagerLocked(r.app);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果服务所在的进程没有被杀掉，进入这个分支！</span></span><br><span class="line">        <span class="keyword">if</span> (r.app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            updateServiceForegroundLocked(r.app, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                 </span><br><span class="line">                <span class="comment">// 设置 destroy 超时处理！                   </span></span><br><span class="line">                bumpServiceExecutingLocked(r, <span class="keyword">false</span>, <span class="string">"destroy"</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 将其添加到 AS 的 mDestroyingServices 机和中，表示服务正在销毁！</span></span><br><span class="line">                mDestroyingServices.add(r);</span><br><span class="line">                r.destroying = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                mAm.updateOomAdjLocked(r.app);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//【3】通过 binder 通信，回调 AT 的 scheduleStopService 方法！</span></span><br><span class="line">                r.app.thread.scheduleStopService(r);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Exception when destroying service "</span></span><br><span class="line">                        + r.shortName, e);</span><br><span class="line"></span><br><span class="line">                serviceProcessGoneLocked(r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(</span><br><span class="line">                TAG_SERVICE, <span class="string">"Removed service that has no process: "</span> + r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(</span><br><span class="line">            TAG_SERVICE, <span class="string">"Removed service that is not running: "</span> + r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空服务的 bindings 集合！</span></span><br><span class="line">    <span class="keyword">if</span> (r.bindings.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        r.bindings.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将服务的重启任务对象置空！</span></span><br><span class="line">    <span class="keyword">if</span> (r.restarter <span class="keyword">instanceof</span> ServiceRestarter) &#123;</span><br><span class="line">       ((ServiceRestarter)r.restarter).setService(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> memFactor = mAm.mProcessStats.getMemFactorLocked();</span><br><span class="line">    <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.tracker != <span class="keyword">null</span>) &#123;</span><br><span class="line">        r.tracker.setStarted(<span class="keyword">false</span>, memFactor, now);</span><br><span class="line">        r.tracker.setBound(<span class="keyword">false</span>, memFactor, now);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (r.executeNesting == <span class="number">0</span>) &#123;</span><br><span class="line">            r.tracker.clearCurrentOwner(r, <span class="keyword">false</span>);</span><br><span class="line">            r.tracker = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    smap.ensureNotStartingBackground(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码很简单，主要逻辑如下：</p>
<ul>
<li>首先进入绑定服务的应用进程，回调 <code>ServiceConnection</code> 的 <code>onServiceDisconnected</code> 方法，取消所有进程对该服务的绑定；</li>
<li>接着，进入服务所在的进程，拉起服务的 <code>onUnbind</code> 方法；</li>
<li>最后，拉起服务的 <code>onDestroy</code> 方法，销毁服务；</li>
</ul>
<p>整个过程，还会清空和重置一些关键变量！！</p>
<p>下面我们重点分析一下上面的三个过程！</p>
<h1 id="3-服务所在进程"><a href="#3-服务所在进程" class="headerlink" title="3 服务所在进程"></a>3 服务所在进程</h1><p>首先要进入 ApplicationThreadN.onTransact 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> SCHEDULE_UNBIND_SERVICE_TRANSACTION: &#123;</span><br><span class="line">    data.enforceInterface(IApplicationThread.descriptor);</span><br><span class="line">    IBinder token = data.readStrongBinder();</span><br><span class="line">    Intent intent = Intent.CREATOR.createFromParcel(data);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【1】执行 unbind 方法！</span></span><br><span class="line">    scheduleUnbindService(token, intent);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>继续来看：</p>
<p>进入 ApplicationThread 中！</p>
<h2 id="3-1-ApplicationThread-scheduleUnbindService"><a href="#3-1-ApplicationThread-scheduleUnbindService" class="headerlink" title="3.1 ApplicationThread.scheduleUnbindService"></a>3.1 ApplicationThread.scheduleUnbindService</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleUnbindService</span><span class="params">(IBinder token, Intent intent)</span> </span>&#123;</span><br><span class="line">    BindServiceData s = <span class="keyword">new</span> BindServiceData();</span><br><span class="line">    s.token = token;</span><br><span class="line">    s.intent = intent;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【1】发送 UNBIND_SERVICE 给主线程 Handler！</span></span><br><span class="line">    sendMessage(H.UNBIND_SERVICE, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进入 H！</p>
<h3 id="3-1-1-ActivityThread-H"><a href="#3-1-1-ActivityThread-H" class="headerlink" title="3.1.1 ActivityThread.H"></a>3.1.1 ActivityThread.H</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">H</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">case</span> UNBIND_SERVICE:</span><br><span class="line">                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"serviceUnbind"</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//【2】继续调用 handleUnbindService！</span></span><br><span class="line">                handleUnbindService((BindServiceData)msg.obj);</span><br><span class="line"></span><br><span class="line">                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续来看！！</p>
<h3 id="3-1-2-ActivityThread-handleUnbindService"><a href="#3-1-2-ActivityThread-handleUnbindService" class="headerlink" title="3.1.2 ActivityThread.handleUnbindService"></a>3.1.2 ActivityThread.handleUnbindService</h3><p>接着，这里是关键地方！：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleUnbindService</span><span class="params">(BindServiceData data)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Service s = mServices.get(data.token);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            data.intent.setExtrasClassLoader(s.getClassLoader());</span><br><span class="line">            data.intent.prepareToEnterProcess();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【3】拉起服务的 onUnbind 方法，并获得返回值！</span></span><br><span class="line">            <span class="keyword">boolean</span> doRebind = s.onUnbind(data.intent);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (doRebind) &#123;</span><br><span class="line">                    <span class="comment">// 如果 doRebind 值为 true，进入该分支！</span></span><br><span class="line">                    ActivityManagerNative.getDefault().unbindFinished(</span><br><span class="line">                            data.token, data.intent, doRebind);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                </span><br><span class="line">                    <span class="comment">// 如果返回 false（默认），就会执行 serviceDoneExecuting 方法！</span></span><br><span class="line">                    ActivityManagerNative.getDefault().serviceDoneExecuting(</span><br><span class="line">                            data.token, SERVICE_DONE_EXECUTING_ANON, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mInstrumentation.onException(s, e)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                        <span class="string">"Unable to unbind to service "</span> + s</span><br><span class="line">                        + <span class="string">" with "</span> + data.intent + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果 <code>doRebind</code> 为 <code>true</code>，调用 <code>AMS</code> 的 <code>unbindFinished</code> 方法；<br>如果 <code>doRebind</code> 为 <code>false</code>，调用 <code>AMS</code> 的 <code>serviceDoneExecuting</code> 方法；</p>
<p>拉起了 <code>onUnbind</code> 方法后，需要根据返回值做相应的处理，接下来进入系统进程，具体逻辑见第四部分！！</p>
<h2 id="3-2-InnerConnection-connected"><a href="#3-2-InnerConnection-connected" class="headerlink" title="3.2 InnerConnection.connected"></a>3.2 InnerConnection.connected</h2><p>系统进程会调用 <code>IServiceConnection.Proxy</code> 代理对象的 <code>connected</code> 方法，通过 <code>binder</code> 调用，进入绑定服务的应用进程，这个是异步调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cr.conn.connected(r.name, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<p>我们去看看！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerConnection</span> <span class="keyword">extends</span> <span class="title">IServiceConnection</span>.<span class="title">Stub</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> WeakReference&lt;LoadedApk.ServiceDispatcher&gt; mDispatcher;</span><br><span class="line"></span><br><span class="line">    InnerConnection(LoadedApk.ServiceDispatcher sd) &#123;</span><br><span class="line">        mDispatcher = <span class="keyword">new</span> WeakReference&lt;LoadedApk.ServiceDispatcher&gt;(sd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connected</span><span class="params">(ComponentName name, IBinder service)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line"></span><br><span class="line">        LoadedApk.ServiceDispatcher sd = mDispatcher.get();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sd != <span class="keyword">null</span>) &#123;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">//【1】调用 mDispatcher 对象的 connected，这里的 service 为 null；</span></span><br><span class="line">            sd.connected(name, service);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续来看：</p>
<h3 id="3-2-1-ServiceDispatcher-connected"><a href="#3-2-1-ServiceDispatcher-connected" class="headerlink" title="3.2.1 ServiceDispatcher.connected"></a>3.2.1 ServiceDispatcher.connected</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mActivityThread != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mActivityThread.post(<span class="keyword">new</span> RunConnection(name, service, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        doConnected(name, service);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后都会调用 <code>doConnected</code> 方法：</p>
<h3 id="3-2-2-ServiceDispatcher-doConnected"><a href="#3-2-2-ServiceDispatcher-doConnected" class="headerlink" title="3.2.2 ServiceDispatcher.doConnected"></a>3.2.2 ServiceDispatcher.doConnected</h3><p>参数 <code>service</code> 这里为 <code>null</code>！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    ServiceDispatcher.ConnectionInfo old;</span><br><span class="line">    ServiceDispatcher.ConnectionInfo info;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// mForgotten 在最开始就被设置成了 true，所以这里就会直接返回的！</span></span><br><span class="line">        <span class="comment">//  ServiceConnection.onServiceDisconnected 方法不会被调用！</span></span><br><span class="line">        <span class="keyword">if</span> (mForgotten) &#123;</span><br><span class="line">            <span class="comment">// We unbound before receiving the connection; ignore</span></span><br><span class="line">            <span class="comment">// any connection received.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获得已有的活跃的 connection 对象！</span></span><br><span class="line">        old = mActiveConnections.get(name);</span><br><span class="line">        <span class="keyword">if</span> (old != <span class="keyword">null</span> &amp;&amp; old.binder == service) &#123; <span class="comment">// 因为 service 为 null，所以这里不会进入该分支！</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (service != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// A new service is being connected... set it all up.</span></span><br><span class="line">            info = <span class="keyword">new</span> ConnectionInfo();</span><br><span class="line">            info.binder = service;</span><br><span class="line">            info.deathMonitor = <span class="keyword">new</span> DeathMonitor(name, service);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                service.linkToDeath(info.deathMonitor, <span class="number">0</span>);</span><br><span class="line">                mActiveConnections.put(name, info);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// This service was dead before we got it...  just</span></span><br><span class="line">                <span class="comment">// don't do anything with it.</span></span><br><span class="line">                mActiveConnections.remove(name);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// service 为 null，说明是解除绑定，所以要从 mActiveConnections 中移除绑定对象！</span></span><br><span class="line">            mActiveConnections.remove(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取消死亡通知监控器</span></span><br><span class="line">        <span class="keyword">if</span> (old != <span class="keyword">null</span>) &#123;</span><br><span class="line">            old.binder.unlinkToDeath(old.deathMonitor, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 之前是有连接的，所以会进入这分支！！</span></span><br><span class="line">    <span class="keyword">if</span> (old != <span class="keyword">null</span>) &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 拉起服务的 onServiceDisconnected 方法！</span></span><br><span class="line">        mConnection.onServiceDisconnected(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不进入这个分支！</span></span><br><span class="line">    <span class="keyword">if</span> (service != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mConnection.onServiceConnected(name, service);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里，最后会进入应用的 <code>ServiceConnection</code> 对象！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ServiceConnection mConnection = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意：<code>onServiceDisconnected</code> 方法是非阻塞的，即，系统进程不会等 <code>onServiceDisconnected</code> 执行完才继续执行！！</p>
<h1 id="4-系统进程"><a href="#4-系统进程" class="headerlink" title="4 系统进程"></a>4 系统进程</h1><p>首先会进入 <code>ActivityManagerNative</code> 的 <code>onTransact</code> 方法中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> UNBIND_FINISHED_TRANSACTION: &#123;</span><br><span class="line"></span><br><span class="line">    data.enforceInterface(IActivityManager.descriptor);</span><br><span class="line">    IBinder token = data.readStrongBinder();</span><br><span class="line">    Intent intent = Intent.CREATOR.createFromParcel(data);</span><br><span class="line">    <span class="keyword">boolean</span> doRebind = data.readInt() != <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 继续来看！</span></span><br><span class="line">    unbindFinished(token, intent, doRebind);</span><br><span class="line"></span><br><span class="line">    reply.writeNoException();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> SERVICE_DONE_EXECUTING_TRANSACTION: &#123;</span><br><span class="line"></span><br><span class="line">    data.enforceInterface(IActivityManager.descriptor);</span><br><span class="line">    IBinder token = data.readStrongBinder();</span><br><span class="line">    <span class="keyword">int</span> type = data.readInt();</span><br><span class="line">    <span class="keyword">int</span> startId = data.readInt();</span><br><span class="line">    <span class="keyword">int</span> res = data.readInt();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 继续来看！</span></span><br><span class="line">    serviceDoneExecuting(token, type, startId, res);</span><br><span class="line"></span><br><span class="line">    reply.writeNoException();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来，进入 <code>AMS</code>！</p>
<h2 id="4-1-ActivityManagerS-unbindFinished"><a href="#4-1-ActivityManagerS-unbindFinished" class="headerlink" title="4.1 ActivityManagerS.unbindFinished"></a>4.1 ActivityManagerS.unbindFinished</h2><p>如果 <code>onUnbind</code> 方法返回的是 <code>true</code>，进入该方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unbindFinished</span><span class="params">(IBinder token, Intent intent, <span class="keyword">boolean</span> doRebind)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 不能通过 intent 传递文件描述符！</span></span><br><span class="line">    <span class="keyword">if</span> (intent != <span class="keyword">null</span> &amp;&amp; intent.hasFileDescriptors() == <span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"File descriptors passed in Intent"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 进入 ActiveServices！</span></span><br><span class="line">        mServices.unbindFinishedLocked((ServiceRecord)token, intent, doRebind);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="4-1-1-ActiveServices-unbindFinishedLocked"><a href="#4-1-1-ActiveServices-unbindFinishedLocked" class="headerlink" title="4.1.1 ActiveServices.unbindFinishedLocked"></a>4.1.1 ActiveServices.unbindFinishedLocked</h3><p>继续来看，<code>doRebind</code> 是服务的 <code>onUnbind</code> 方法的返回值！！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unbindFinishedLocked</span><span class="params">(ServiceRecord r, Intent intent, <span class="keyword">boolean</span> doRebind)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Intent.FilterComparison filter</span><br><span class="line">                    = <span class="keyword">new</span> Intent.FilterComparison(intent);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 获得绑定 Serivce 的 intent 对应的 IntentBindRecord 对象！</span></span><br><span class="line">            IntentBindRecord b = r.bindings.get(filter);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">"unbindFinished in "</span> + r</span><br><span class="line">                    + <span class="string">" at "</span> + b + <span class="string">": apps="</span></span><br><span class="line">                    + (b != <span class="keyword">null</span> ? b.apps.size() : <span class="number">0</span>));</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 这里的 inDestroying 的值为 false，因为还没有添加！</span></span><br><span class="line">            <span class="keyword">boolean</span> inDestroying = mDestroyingServices.contains(r);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 显然，这里不会为 null！</span></span><br><span class="line">            <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (b.apps.size() &gt; <span class="number">0</span> &amp;&amp; !inDestroying) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Applications have already bound since the last</span></span><br><span class="line">                    <span class="comment">// unbind, so just rebind right here.</span></span><br><span class="line">                    <span class="keyword">boolean</span> inFg = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i=b.apps.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">                        ProcessRecord client = b.apps.valueAt(i).client;</span><br><span class="line">                        <span class="keyword">if</span> (client != <span class="keyword">null</span> &amp;&amp; client.setSchedGroup</span><br><span class="line">                                != ProcessList.SCHED_GROUP_BACKGROUND) &#123;</span><br><span class="line">                            inFg = <span class="keyword">true</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                        requestServiceBindingLocked(r, b, inFg, <span class="keyword">true</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (TransactionTooLargeException e) &#123;</span><br><span class="line">                        <span class="comment">// Don't pass this back to ActivityThread, it's unrelated.</span></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 将 doRebind 置为 true！</span></span><br><span class="line">                    b.doRebind = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 最后进入 serviceDoneExecutingLocked 方法！</span></span><br><span class="line">            serviceDoneExecutingLocked(r, inDestroying, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接着来看！</p>
<h3 id="4-1-2-ActiveServices-serviceDoneExecutingLocked"><a href="#4-1-2-ActiveServices-serviceDoneExecutingLocked" class="headerlink" title="4.1.2 ActiveServices.serviceDoneExecutingLocked"></a>4.1.2 ActiveServices.serviceDoneExecutingLocked</h3><p>参数传递：</p>
<ul>
<li><code>boolean inDestroying</code>：传入 <code>false</code>；</li>
<li><code>boolean finishing</code>：传入 <code>false</code>；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">serviceDoneExecutingLocked</span><span class="params">(ServiceRecord r, <span class="keyword">boolean</span> inDestroying,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> finishing)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">"&lt;&lt;&lt; DONE EXECUTING "</span> + r</span><br><span class="line">            + <span class="string">": nesting="</span> + r.executeNesting</span><br><span class="line">            + <span class="string">", inDestroying="</span> + inDestroying + <span class="string">", app="</span> + r.app);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (DEBUG_SERVICE_EXECUTING) Slog.v(TAG_SERVICE_EXECUTING,</span><br><span class="line">            <span class="string">"&lt;&lt;&lt; DONE EXECUTING "</span> + r.shortName);</span><br><span class="line"></span><br><span class="line">    r.executeNesting--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.executeNesting &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (r.app != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE,</span><br><span class="line">                    <span class="string">"Nesting at 0 of "</span> + r.shortName);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 从所在进程的 executingServices 中删除该服务！</span></span><br><span class="line">            r.app.execServicesFg = <span class="keyword">false</span>;</span><br><span class="line">            r.app.executingServices.remove(r);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (r.app.executingServices.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_SERVICE || DEBUG_SERVICE_EXECUTING) Slog.v(TAG_SERVICE_EXECUTING,</span><br><span class="line">                        <span class="string">"No more executingServices of "</span> + r.shortName);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 如果进程中没有在执行指定代码逻辑的服务了，就取消超市任务！</span></span><br><span class="line">                mAm.mHandler.removeMessages(ActivityManagerService.SERVICE_TIMEOUT_MSG, r.app);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.executeFg) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果进程还有在执行指定代码逻辑的服务，并且有服务在前台执行，那就要将进程的 execServicesFg 置为 ture</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=r.app.executingServices.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (r.app.executingServices.valueAt(i).executeFg) &#123;</span><br><span class="line">                        r.app.execServicesFg = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (inDestroying) &#123; <span class="comment">// 不进入！</span></span><br><span class="line">                <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE,</span><br><span class="line">                        <span class="string">"doneExecuting remove destroying "</span> + r);</span><br><span class="line">                mDestroyingServices.remove(r);</span><br><span class="line">                r.bindings.clear();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 更新 oomAdj 值！</span></span><br><span class="line">            mAm.updateOomAdjLocked(r.app);</span><br><span class="line">        &#125;</span><br><span class="line">　　　　</span><br><span class="line">　　　　<span class="comment">// 置服务的 executeFg 为 false；</span></span><br><span class="line">        r.executeFg = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (r.tracker != <span class="keyword">null</span>) &#123;</span><br><span class="line">            r.tracker.setExecuting(<span class="keyword">false</span>, mAm.mProcessStats.getMemFactorLocked(),</span><br><span class="line">                    SystemClock.uptimeMillis());</span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                r.tracker.clearCurrentOwner(r, <span class="keyword">false</span>);</span><br><span class="line">                r.tracker = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (finishing) &#123; <span class="comment">// 不进入这个分支！</span></span><br><span class="line">            <span class="keyword">if</span> (r.app != <span class="keyword">null</span> &amp;&amp; !r.app.persistent) &#123;</span><br><span class="line">                r.app.services.remove(r);</span><br><span class="line">                <span class="keyword">if</span> (r.whitelistManager) &#123;</span><br><span class="line">                    updateWhitelistManagerLocked(r.app);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            r.app = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就不再详细说了！！</p>
<h2 id="4-2-ActivityManagerS-serviceDoneExecuting"><a href="#4-2-ActivityManagerS-serviceDoneExecuting" class="headerlink" title="4.2 ActivityManagerS.serviceDoneExecuting"></a>4.2 ActivityManagerS.serviceDoneExecuting</h2><p>对于拉起 <code>onDestroy</code> 方法，最后会调用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serviceDoneExecuting</span><span class="params">(IBinder token, <span class="keyword">int</span> type, <span class="keyword">int</span> startId, <span class="keyword">int</span> res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!(token <span class="keyword">instanceof</span> ServiceRecord)) &#123;</span><br><span class="line">            Slog.e(TAG, <span class="string">"serviceDoneExecuting: Invalid service token="</span> + token);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid service token"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 最后，进入 AS！</span></span><br><span class="line">        mServices.serviceDoneExecutingLocked((ServiceRecord)token, type, startId, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接着，进入 <code>ActiveServices</code>！</p>
<h3 id="4-2-1-ActiveServices-serviceDoneExecutingLocked"><a href="#4-2-1-ActiveServices-serviceDoneExecutingLocked" class="headerlink" title="4.2.1 ActiveServices.serviceDoneExecutingLocked"></a>4.2.1 ActiveServices.serviceDoneExecutingLocked</h3><p>根据参数传递：</p>
<ul>
<li><strong><code>int type</code></strong>：传入 <code>ActivityThread.SERVICE_DONE_EXECUTING_STOP</code>；</li>
<li><strong><code>int startId</code></strong>：传入 <code>0</code>；</li>
<li><strong><code>int res</code></strong>：传入<code>0</code>；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serviceDoneExecutingLocked</span><span class="params">(ServiceRecord r, <span class="keyword">int</span> type, <span class="keyword">int</span> startId, <span class="keyword">int</span> res)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里的 inDestroying 为 true，因为我们之前已经将该服务添加到 mDestroyingServices！</span></span><br><span class="line">    <span class="keyword">boolean</span> inDestroying = mDestroyingServices.contains(r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (type == ActivityThread.SERVICE_DONE_EXECUTING_START) &#123;</span><br><span class="line">            </span><br><span class="line">            ... ... ... <span class="comment">// 这里是和 startService 服务有关，我们这里不看！</span></span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == ActivityThread.SERVICE_DONE_EXECUTING_STOP) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// This is the final call from destroying the service...  we should</span></span><br><span class="line">            <span class="comment">// actually be getting rid of the service at this point.  Do some</span></span><br><span class="line">            <span class="comment">// validation of its state, and ensure it will be fully removed.</span></span><br><span class="line">            <span class="keyword">if</span> (!inDestroying) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Not sure what else to do with this...  if it is not actually in the</span></span><br><span class="line">                <span class="comment">// destroying list, we don't need to make sure to remove it from it.</span></span><br><span class="line">                <span class="comment">// If the app is null, then it was probably removed because the process died,</span></span><br><span class="line">                <span class="comment">// otherwise wtf</span></span><br><span class="line">                <span class="keyword">if</span> (r.app != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Slog.w(TAG, <span class="string">"Service done with onDestroy, but not inDestroying: "</span></span><br><span class="line">                            + r + <span class="string">", app="</span> + r.app);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.executeNesting != <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">                Slog.w(TAG, <span class="string">"Service done with onDestroy, but executeNesting="</span></span><br><span class="line">                        + r.executeNesting + <span class="string">": "</span> + r);</span><br><span class="line">                <span class="comment">// Fake it to keep from ANR due to orphaned entry.</span></span><br><span class="line">                r.executeNesting = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 最后，再次调用 serviceDoneExecutingLocked！</span></span><br><span class="line">        serviceDoneExecutingLocked(r, inDestroying, inDestroying);</span><br><span class="line"></span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"Done executing unknown service from pid "</span></span><br><span class="line">                + Binder.getCallingPid());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-2-ActiveServices-serviceDoneExecutingLocked"><a href="#4-2-2-ActiveServices-serviceDoneExecutingLocked" class="headerlink" title="4.2.2 ActiveServices.serviceDoneExecutingLocked"></a>4.2.2 ActiveServices.serviceDoneExecutingLocked</h3><p>参数传递：</p>
<ul>
<li><code>boolean inDestroying</code>：传入<code>true</code>；</li>
<li><code>boolean finishing</code>：传入 <code>true</code>；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">serviceDoneExecutingLocked</span><span class="params">(ServiceRecord r, <span class="keyword">boolean</span> inDestroying,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> finishing)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">"&lt;&lt;&lt; DONE EXECUTING "</span> + r</span><br><span class="line">            + <span class="string">": nesting="</span> + r.executeNesting</span><br><span class="line">            + <span class="string">", inDestroying="</span> + inDestroying + <span class="string">", app="</span> + r.app);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (DEBUG_SERVICE_EXECUTING) Slog.v(TAG_SERVICE_EXECUTING,</span><br><span class="line">            <span class="string">"&lt;&lt;&lt; DONE EXECUTING "</span> + r.shortName);</span><br><span class="line"></span><br><span class="line">    r.executeNesting--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.executeNesting &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (r.app != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE,</span><br><span class="line">                    <span class="string">"Nesting at 0 of "</span> + r.shortName);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 从所在进程的 executingServices 中删除该服务！</span></span><br><span class="line">            r.app.execServicesFg = <span class="keyword">false</span>;</span><br><span class="line">            r.app.executingServices.remove(r);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (r.app.executingServices.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_SERVICE || DEBUG_SERVICE_EXECUTING) Slog.v(TAG_SERVICE_EXECUTING,</span><br><span class="line">                        <span class="string">"No more executingServices of "</span> + r.shortName);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 如果进程中没有在执行指定代码逻辑的服务了，就取消超时任务！</span></span><br><span class="line">                mAm.mHandler.removeMessages(ActivityManagerService.SERVICE_TIMEOUT_MSG, r.app);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.executeFg) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果进程还有在执行指定代码逻辑的服务，并且有服务在前台执行，那就要将进程的 execServicesFg 置为 ture</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=r.app.executingServices.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (r.app.executingServices.valueAt(i).executeFg) &#123;</span><br><span class="line">                        r.app.execServicesFg = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (inDestroying) &#123; <span class="comment">// inDestroying 为 true 进入！</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE,</span><br><span class="line">                        <span class="string">"doneExecuting remove destroying "</span> + r);</span><br><span class="line">                        </span><br><span class="line">                <span class="comment">// 从 mDestroyingServices 中删除 ServiceRecord！</span></span><br><span class="line">                mDestroyingServices.remove(r);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 清空其 bindings 集合！</span></span><br><span class="line">                r.bindings.clear();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 更新 oomAdj 值！</span></span><br><span class="line">            mAm.updateOomAdjLocked(r.app);</span><br><span class="line">        &#125;</span><br><span class="line">　　　　</span><br><span class="line">　　　　<span class="comment">// 置服务的 executeFg 为 false；</span></span><br><span class="line">        r.executeFg = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (r.tracker != <span class="keyword">null</span>) &#123;</span><br><span class="line">            r.tracker.setExecuting(<span class="keyword">false</span>, mAm.mProcessStats.getMemFactorLocked(),</span><br><span class="line">                    SystemClock.uptimeMillis());</span><br><span class="line">                    </span><br><span class="line">            <span class="comment">// 取消对服务的监控！</span></span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                r.tracker.clearCurrentOwner(r, <span class="keyword">false</span>);</span><br><span class="line">                r.tracker = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (finishing) &#123; <span class="comment">// finishing 为 true ，进入这个分支！</span></span><br><span class="line">            <span class="keyword">if</span> (r.app != <span class="keyword">null</span> &amp;&amp; !r.app.persistent) &#123;</span><br><span class="line">            </span><br><span class="line">                <span class="comment">// 如果服务所在的进程不是常驻进程，从进程的 services 中移除这个服务！</span></span><br><span class="line">                r.app.services.remove(r);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (r.whitelistManager) &#123;</span><br><span class="line">                    updateWhitelistManagerLocked(r.app);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            r.app = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h1><p>这里我们来总结一下，接触绑定的流程！</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2016/06/13/Process篇 6 - 从 dumpsys meminfo 看进程的优先级/">Process篇 6 - 从 dumpsys meminfo 看进程的优先级</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2016-06-13</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/AndroidFramework源码分析/">AndroidFramework源码分析</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/AndroidFramework源码分析/Process进程/">Process进程</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Process进程/">Process进程</a></span><div class="content"><h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言</h1><p>基于 android 7.1.1 源码，分析和总结 Process 相关知识！</p>
<h1 id="1-dumpsys-meminfo-–oom"><a href="#1-dumpsys-meminfo-–oom" class="headerlink" title="1 dumpsys meminfo –oom"></a>1 dumpsys meminfo –oom</h1><p><code>dumpsys meminfo</code> 可以来看系统的内存使用情况，这里我们重点关注：<code>Total PSS by OOM adjustment</code>:</p>
<p>默认的 <code>dumpsys meminfo</code> 是出了可以看 <code>Total PSS by OOM adjustment</code>，还可以看 <code>Total PSS by process</code> 等等详细的信息，这里我们只关注第一种，这里有一个很方便的指令：</p>
<p><code>adb shell dumpsys meminfo --oom</code> </p>
<p>下面是该指令的输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Applications Memory <span class="title">Usage</span> <span class="params">(in Kilobytes)</span>:</span></span><br><span class="line"><span class="function">Uptime: 37282469 Realtime: 62579406</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">     ... ... ... ...</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Total PSS by OOM adjustment:</span></span><br><span class="line"><span class="function">    304,190K: Native</span></span><br><span class="line"><span class="function">         38,170K: android.hardware.camera.provider@2.4-<span class="title">service</span> <span class="params">(pid <span class="number">683</span>)</span></span></span><br><span class="line"><span class="function">         17,815K: <span class="title">logd</span> <span class="params">(pid <span class="number">539</span>)</span></span></span><br><span class="line"><span class="function">         15,833K: vendor.oppo.hardware.biometrics.face@1.0-<span class="title">service</span> <span class="params">(pid <span class="number">1109</span>)</span></span></span><br><span class="line"><span class="function">         15,014K: <span class="title">surfaceflinger</span> <span class="params">(pid <span class="number">721</span>)</span></span></span><br><span class="line"><span class="function">          7,927K: android.hardware.audio@2.0-<span class="title">service</span> <span class="params">(pid <span class="number">681</span>)</span></span></span><br><span class="line"><span class="function">          7,318K: <span class="title">webview_zygote32</span> <span class="params">(pid <span class="number">2635</span>)</span></span></span><br><span class="line"><span class="function">          7,105K: <span class="title">rild</span> <span class="params">(pid <span class="number">1083</span>)</span></span></span><br><span class="line"><span class="function">          6,857K: media.<span class="title">codec</span> <span class="params">(pid <span class="number">1082</span>)</span></span></span><br><span class="line"><span class="function">          ... ... ... ...</span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function">    119,314K: System</span></span><br><span class="line"><span class="function">        119,314K: <span class="title">system</span> <span class="params">(pid <span class="number">1703</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    168,951K: Persistent</span></span><br><span class="line"><span class="function">         94,755K: com.android.<span class="title">systemui</span> <span class="params">(pid <span class="number">2598</span>)</span></span></span><br><span class="line"><span class="function">         23,766K: com.android.<span class="title">phone</span> <span class="params">(pid <span class="number">2738</span>)</span></span></span><br><span class="line"><span class="function">         11,445K: .<span class="title">dataservices</span> <span class="params">(pid <span class="number">2706</span>)</span></span></span><br><span class="line"><span class="function">          7,254K: com.oppo.multimedia.<span class="title">dirac</span> <span class="params">(pid <span class="number">3493</span>)</span></span></span><br><span class="line"><span class="function">          ... ... ... ...</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">     95,474K: Foreground</span></span><br><span class="line"><span class="function">         33,792K: com.coloros.safecenter:<span class="title">clear_filter</span> <span class="params">(pid <span class="number">2514</span>)</span></span></span><br><span class="line"><span class="function">         26,509K: com.oppo.ota:<span class="title">ui</span> <span class="params">(pid <span class="number">15668</span> / activities)</span></span></span><br><span class="line"><span class="function">         13,879K: com.coloros.<span class="title">securitypermission</span> <span class="params">(pid <span class="number">3140</span>)</span></span></span><br><span class="line"><span class="function">         12,447K: com.oppo.<span class="title">ota</span> <span class="params">(pid <span class="number">15686</span>)</span></span></span><br><span class="line"><span class="function">          8,847K: com.nearme.<span class="title">romupdate</span> <span class="params">(pid <span class="number">2491</span>)</span></span></span><br><span class="line"><span class="function">          ... ... ... ...</span></span><br><span class="line"><span class="function">          </span></span><br><span class="line"><span class="function">    524,433K: Visible</span></span><br><span class="line"><span class="function">        105,184K: com.tencent.mm:<span class="title">push</span> <span class="params">(pid <span class="number">7125</span>)</span></span></span><br><span class="line"><span class="function">        100,550K: com.tencent.mm:<span class="title">exdevice</span> <span class="params">(pid <span class="number">5237</span>)</span></span></span><br><span class="line"><span class="function">         62,929K: com.oppo.<span class="title">launcher</span> <span class="params">(pid <span class="number">3325</span> / activities)</span></span></span><br><span class="line"><span class="function">         27,815K: android.process.<span class="title">contacts</span> <span class="params">(pid <span class="number">4085</span>)</span></span></span><br><span class="line"><span class="function">         24,425K: com.coloros.<span class="title">safecenter</span> <span class="params">(pid <span class="number">3708</span>)</span></span></span><br><span class="line"><span class="function">         23,279K: com.coloros.<span class="title">mcs</span> <span class="params">(pid <span class="number">4122</span>)</span></span></span><br><span class="line"><span class="function">         21,670K: android.process.<span class="title">acore</span> <span class="params">(pid <span class="number">4310</span>)</span></span></span><br><span class="line"><span class="function">         20,998K: com.coloros.<span class="title">recents</span> <span class="params">(pid <span class="number">3267</span> / activities)</span></span></span><br><span class="line"><span class="function">         ... ... ... ...</span></span><br><span class="line"><span class="function">          </span></span><br><span class="line"><span class="function">     39,159K: Perceptible</span></span><br><span class="line"><span class="function">         31,468K: com.sohu.inputmethod.<span class="title">sogouoem</span> <span class="params">(pid <span class="number">2584</span>)</span></span></span><br><span class="line"><span class="function">          7,691K: com.amap.android.<span class="title">location</span> <span class="params">(pid <span class="number">4132</span>)</span></span></span><br><span class="line"><span class="function">          </span></span><br><span class="line"><span class="function">    103,667K: A Services</span></span><br><span class="line"><span class="function">         72,943K: com.kuaikan.comic:<span class="title">monitorService</span> <span class="params">(pid <span class="number">4938</span>)</span></span></span><br><span class="line"><span class="function">         30,724K: com.kuaikan.comic:<span class="title">QS</span> <span class="params">(pid <span class="number">5207</span>)</span></span></span><br><span class="line"><span class="function">         </span></span><br><span class="line"><span class="function">    174,752K: Previous</span></span><br><span class="line"><span class="function">        147,972K: com.tencent.<span class="title">mm</span> <span class="params">(pid <span class="number">7318</span>)</span></span></span><br><span class="line"><span class="function">         26,780K: com.android.<span class="title">settings</span> <span class="params">(pid <span class="number">13815</span> / activities)</span></span></span><br><span class="line"><span class="function">         </span></span><br><span class="line"><span class="function">    489,783K: B Services</span></span><br><span class="line"><span class="function">        370,782K: com.kuaikan.<span class="title">comic</span> <span class="params">(pid <span class="number">4869</span> / activities)</span></span></span><br><span class="line"><span class="function">         28,757K: com.android.<span class="title">mms</span> <span class="params">(pid <span class="number">5120</span>)</span></span></span><br><span class="line"><span class="function">         27,198K: com.kuaikan.comic:<span class="title">QALSERVICE</span> <span class="params">(pid <span class="number">5063</span>)</span></span></span><br><span class="line"><span class="function">         15,458K: com.coloros.<span class="title">selfcheck</span> <span class="params">(pid <span class="number">15626</span> / activities)</span></span></span><br><span class="line"><span class="function">         15,422K: com.tencent.mobileqq:<span class="title">MSF</span> <span class="params">(pid <span class="number">10558</span>)</span></span></span><br><span class="line"><span class="function">         14,523K: com.nearme.statistics.<span class="title">rom</span> <span class="params">(pid <span class="number">2556</span>)</span></span></span><br><span class="line"><span class="function">          9,211K: com.coloros.<span class="title">gallery3d</span> <span class="params">(pid <span class="number">16053</span>)</span></span></span><br><span class="line"><span class="function">          4,513K: com.coloros.<span class="title">activation</span> <span class="params">(pid <span class="number">5301</span>)</span></span></span><br><span class="line"><span class="function">          3,919K: com.coloros.<span class="title">usbselection</span> <span class="params">(pid <span class="number">16123</span>)</span></span></span><br><span class="line"><span class="function">          </span></span><br><span class="line"><span class="function">     76,443K: Cached</span></span><br><span class="line"><span class="function">         39,483K: com.coloros.<span class="title">aiservice</span> <span class="params">(pid <span class="number">7038</span>)</span></span></span><br><span class="line"><span class="function">         17,041K: android.process.<span class="title">media</span> <span class="params">(pid <span class="number">13010</span>)</span></span></span><br><span class="line"><span class="function">         10,643K: com.android.providers.<span class="title">downloads</span> <span class="params">(pid <span class="number">3251</span>)</span></span></span><br><span class="line"><span class="function">          4,979K: com.coloros.<span class="title">securepay</span> <span class="params">(pid <span class="number">9412</span>)</span></span></span><br><span class="line"><span class="function">          4,297K: com.android.<span class="title">defcontainer</span> <span class="params">(pid <span class="number">15323</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">Total RAM: 3,831,972<span class="title">K</span> <span class="params">(status normal)</span></span></span><br><span class="line"><span class="function"> Free RAM: 1,734,943<span class="title">K</span> <span class="params">(   <span class="number">76</span>,<span class="number">527</span>K cached pss + <span class="number">1</span>,<span class="number">319</span>,<span class="number">364</span>K cached kernel +    <span class="number">24</span>,<span class="number">584</span>K ion cached +   <span class="number">314</span>,<span class="number">468</span>K free)</span></span></span><br><span class="line"><span class="function"> Used RAM: 2,459,876<span class="title">K</span> <span class="params">(<span class="number">2</span>,<span class="number">083</span>,<span class="number">100</span>K used pss +   <span class="number">376</span>,<span class="number">776</span>K kernel)</span></span></span><br><span class="line"><span class="function"> Lost RAM:  -979,823K</span></span><br><span class="line"><span class="function">     ZRAM:   616,976K physical used <span class="keyword">for</span> 1,361,056K in <span class="title">swap</span> <span class="params">(<span class="number">2</span>,<span class="number">097</span>,<span class="number">148</span>K total swap)</span></span></span><br><span class="line"><span class="function">   Tuning: 384 <span class="params">(large <span class="number">512</span>)</span>, oom   322,560K, restore limit   107,520<span class="title">K</span> <span class="params">(high-end-gfx)</span></span></span><br></pre></td></tr></table></figure>
<p>我们可以看到，这部分，系统是根据进程的 <code>adj</code> 将其分类，然后根据不同的分类，显示出了不同类别进程的内存使用情况！</p>
<p>这里我们关心的是 <code>adb shell dumpsys meminfo --oom</code>  是如何归类不同类型的进程的！</p>
<h1 id="2-dumpApplicationMemoryUsage"><a href="#2-dumpApplicationMemoryUsage" class="headerlink" title="2 dumpApplicationMemoryUsage"></a>2 dumpApplicationMemoryUsage</h1><p><code>adb shell dumpsys meminfo --oom</code> 最终会调用 <code>dumpApplicationMemoryUsage</code> 函数，这里我们重点关注和 <code>--oom</code> 相关的逻辑：</p>
<p>这里我们先来看几个和该指令相关的常量;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[] DUMP_MEM_OOM_ADJ = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;</span><br><span class="line">        ProcessList.NATIVE_ADJ,</span><br><span class="line">        ProcessList.SYSTEM_ADJ, ProcessList.PERSISTENT_PROC_ADJ,</span><br><span class="line">        ProcessList.PERSISTENT_SERVICE_ADJ, ProcessList.FOREGROUND_APP_ADJ,</span><br><span class="line">        ProcessList.VISIBLE_APP_ADJ, ProcessList.PERCEPTIBLE_APP_ADJ,</span><br><span class="line">        ProcessList.BACKUP_APP_ADJ, ProcessList.HEAVY_WEIGHT_APP_ADJ,</span><br><span class="line">        ProcessList.SERVICE_ADJ, ProcessList.HOME_APP_ADJ,</span><br><span class="line">        ProcessList.PREVIOUS_APP_ADJ, ProcessList.SERVICE_B_ADJ, ProcessList.CACHED_APP_MIN_ADJ</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String[] DUMP_MEM_OOM_LABEL = <span class="keyword">new</span> String[] &#123;</span><br><span class="line">        <span class="string">"Native"</span>,</span><br><span class="line">        <span class="string">"System"</span>, <span class="string">"Persistent"</span>, <span class="string">"Persistent Service"</span>, <span class="string">"Foreground"</span>,</span><br><span class="line">        <span class="string">"Visible"</span>, <span class="string">"Perceptible"</span>,</span><br><span class="line">        <span class="string">"Heavy Weight"</span>, <span class="string">"Backup"</span>,</span><br><span class="line">        <span class="string">"A Services"</span>, <span class="string">"Home"</span>,</span><br><span class="line">        <span class="string">"Previous"</span>, <span class="string">"B Services"</span>, <span class="string">"Cached"</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>DUMP_MEM_OOM_ADJ</code> 中封装的是 <code>oom adj</code>，<code>DUMP_MEM_OOM_LABEL</code> 中封装的是 <code>lebal</code>，这个看命令输出，很容易猜到是什么意思！</p>
<p>下面我们来重点分析方法！！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">dumpApplicationMemoryUsage</span><span class="params">(FileDescriptor fd,</span></span></span><br><span class="line"><span class="function"><span class="params">        PrintWriter pw, String prefix, String[] args, <span class="keyword">boolean</span> brief, PrintWriter categoryPw)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    ... ... ... ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解析指令，因为我们有 `--oom`，所以 oomOnly 为 true！</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"--oom"</span>.equals(opt)) &#123;</span><br><span class="line">            oomOnly = <span class="keyword">true</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        ... ... ... ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> uptime = SystemClock.uptimeMillis();</span><br><span class="line">    <span class="keyword">long</span> realtime = SystemClock.elapsedRealtime();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span>[] tmpLong = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 收集进程，返回的就是 mLruProcesses 的拷贝！</span></span><br><span class="line">    ArrayList&lt;ProcessRecord&gt; procs = collectProcesses(pw, opti, packages, args);</span><br><span class="line"></span><br><span class="line">    ... ... ... ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一些数组，用于封装信息，数组长度均是 DUMP_MEM_OOM_LABEL.length: 14！</span></span><br><span class="line">    <span class="keyword">long</span> oomPss[] = <span class="keyword">new</span> <span class="keyword">long</span>[DUMP_MEM_OOM_LABEL.length];</span><br><span class="line">    <span class="keyword">long</span> oomSwapPss[] = <span class="keyword">new</span> <span class="keyword">long</span>[DUMP_MEM_OOM_LABEL.length];</span><br><span class="line">    ArrayList&lt;MemItem&gt;[] oomProcs = (ArrayList&lt;MemItem&gt;[])</span><br><span class="line">            <span class="keyword">new</span> ArrayList[DUMP_MEM_OOM_LABEL.length];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> totalPss = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> totalSwapPss = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> cachedPss = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> cachedSwapPss = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> hasSwapPss = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    Debug.MemoryInfo mi = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 逆序遍历进程集合！</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = procs.size() - <span class="number">1</span> ; i &gt;= <span class="number">0</span> ; i--) &#123;</span><br><span class="line">        <span class="comment">// 获得进程对象！</span></span><br><span class="line">        <span class="keyword">final</span> ProcessRecord r = procs.get(i);</span><br><span class="line">        <span class="keyword">final</span> IApplicationThread thread;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> pid;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> oomAdj;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> hasActivities;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            thread = r.thread;</span><br><span class="line">            pid = r.pid; <span class="comment">// 收集 pid！</span></span><br><span class="line">            oomAdj = r.getSetAdjWithServices(); <span class="comment">// 获得该进程的 oomAdj！</span></span><br><span class="line">            hasActivities = r.activities.size() &gt; <span class="number">0</span>; <span class="comment">// 该进程是否正在运行 activity！</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ... ... ... ...</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!isCheckinRequest &amp;&amp; mi != <span class="keyword">null</span>) &#123;</span><br><span class="line">                totalPss += myTotalPss;</span><br><span class="line">                totalSwapPss += myTotalSwapPss;</span><br><span class="line">                MemItem pssItem = <span class="keyword">new</span> MemItem(r.processName + <span class="string">" (pid "</span> + pid +</span><br><span class="line">                        (hasActivities ? <span class="string">" / activities)"</span> : <span class="string">")"</span>), r.processName, myTotalPss,</span><br><span class="line">                        myTotalSwapPss, pid, hasActivities);</span><br><span class="line"></span><br><span class="line">               ... ... ... ...</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//【1】便利 oomPss 数组，匹配 oomAdj！</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> oomIndex = <span class="number">0</span>; oomIndex &lt; oomPss.length; oomIndex++) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//【1.1】当此时已经到了 oomPss 的最后一个元素，或者</span></span><br><span class="line">                    <span class="comment">// 该进程的 oomAdj 处于 [ DUMP_MEM_OOM_ADJ[oomIndex], DUMP_MEM_OOM_ADJ[oomIndex + 1] ) 之间！</span></span><br><span class="line">                    <span class="comment">// 这是我们匹配到了合适的 oomAdj，进入以下逻辑！</span></span><br><span class="line">                    <span class="keyword">if</span> (oomIndex == (oomPss.length - <span class="number">1</span>)</span><br><span class="line">                            || (oomAdj &gt;= DUMP_MEM_OOM_ADJ[oomIndex]</span><br><span class="line">                                    &amp;&amp; oomAdj &lt; DUMP_MEM_OOM_ADJ[oomIndex + <span class="number">1</span>])) &#123;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// oomPss[oomIndex] 累加上 myTotalPss！</span></span><br><span class="line">                        oomPss[oomIndex] += myTotalPss;</span><br><span class="line">                        <span class="comment">// oomSwapPss[oomIndex] 累加上 myTotalSwapPss！</span></span><br><span class="line">                        oomSwapPss[oomIndex] += myTotalSwapPss;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 创建一个 ArrayList 列表，用于封装进程的内存对象！</span></span><br><span class="line">                        <span class="keyword">if</span> (oomProcs[oomIndex] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oomProcs[oomIndex] = <span class="keyword">new</span> ArrayList&lt;MemItem&gt;();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 将 pssItem 添加爱到该 ArrayList 中去！</span></span><br><span class="line">                        oomProcs[oomIndex].add(pssItem);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 下面这段逻辑很重要，决定了 adb shell dumpsys meminfo --oom 是如何对进程划分的！</span></span><br><span class="line">    <span class="keyword">if</span> (!isCheckinRequest &amp;&amp; procs.size() &gt; <span class="number">1</span> &amp;&amp; !packages) &#123;</span><br><span class="line">        ... ... ... ...</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;MemItem&gt; oomMems = <span class="keyword">new</span> ArrayList&lt;MemItem&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历 oomPss 数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oomPss.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (oomPss[j] != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 获得 label ，因为 isCompact 为 false，所以为 UMP_MEM_OOM_LABEL[j]！</span></span><br><span class="line">                String label = isCompact ? DUMP_MEM_OOM_COMPACT_LABEL[j]</span><br><span class="line">                        : DUMP_MEM_OOM_LABEL[j];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 创建总的 MemItem 对象，用于封装每种类型下的进程的信息；</span></span><br><span class="line">                <span class="comment">// oomPss[j] 表示这个 label 下的总物理内存；</span></span><br><span class="line">                <span class="comment">// oomSwapPss[j] 表示该 label 下的总交换物理内存；</span></span><br><span class="line">                <span class="comment">// DUMP_MEM_OOM_ADJ[j] 表示该进程类别的起始 oom adj；</span></span><br><span class="line">                MemItem item = <span class="keyword">new</span> MemItem(label, label, oomPss[j], oomSwapPss[j],</span><br><span class="line">                        DUMP_MEM_OOM_ADJ[j]);</span><br><span class="line">                        </span><br><span class="line">                <span class="comment">// subitems 则用来表示属于该类别的所有进程信息！</span></span><br><span class="line">                item.subitems = oomProcs[j];</span><br><span class="line">                oomMems.add(item);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ... ... ... ...</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!isCompact) &#123;</span><br><span class="line">            pw.println(<span class="string">"Total PSS by OOM adjustment:"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 显示出最终的信息！！</span></span><br><span class="line">        dumpMemItems(pw, <span class="string">"  "</span>, <span class="string">"oom"</span>, oomMems, <span class="keyword">false</span>, isCompact, dumpSwapPss);</span><br><span class="line"> </span><br><span class="line">        ... ... ... ... </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的逻辑是和 <code>Total PSS by OOM adjustment</code> 相关的！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ArrayList&lt;ProcessRecord&gt; <span class="title">collectProcesses</span><span class="params">(PrintWriter pw, <span class="keyword">int</span> start, <span class="keyword">boolean</span> allPkgs,</span></span></span><br><span class="line"><span class="function"><span class="params">        String[] args)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;ProcessRecord&gt; procs;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (args != <span class="keyword">null</span> &amp;&amp; args.length &gt; start</span><br><span class="line">                &amp;&amp; args[start].charAt(<span class="number">0</span>) != <span class="string">'-'</span>) &#123;</span><br><span class="line">            procs = <span class="keyword">new</span> ArrayList&lt;ProcessRecord&gt;();</span><br><span class="line">            <span class="keyword">int</span> pid = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                pid = Integer.parseInt(args[start]);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=mLruProcesses.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">                ProcessRecord proc = mLruProcesses.get(i);</span><br><span class="line">                <span class="keyword">if</span> (proc.pid == pid) &#123; <span class="comment">// 按照 pid 收集；</span></span><br><span class="line">                    procs.add(proc);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (allPkgs &amp;&amp; proc.pkgList != <span class="keyword">null</span></span><br><span class="line">                        &amp;&amp; proc.pkgList.containsKey(args[start])) &#123; <span class="comment">// 按照 packageName 收集；</span></span><br><span class="line">                    procs.add(proc);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (proc.processName.equals(args[start])) &#123; <span class="comment">// 按照 processName 收集！</span></span><br><span class="line">                    procs.add(proc);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (procs.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 不指定 pid，processName，packageName 的话，就返回 mLruProcesses！</span></span><br><span class="line">            procs = <span class="keyword">new</span> ArrayList&lt;ProcessRecord&gt;(mLruProcesses);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> procs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实，我们可以看出 <code>adb shell dumpsys meminfo --oom</code> 没有传入任何参数，所以返回的就是 <code>mLruProcesses</code> 的拷贝！</p>
<h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h1><p>分析了 adb shell dumpsys meminfo –oom 方法的执行流程，我们来总结下，进程的分类：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>进程 Label</th>
<th>起始 oom adj 值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>1</code></td>
<td><code>Native</code></td>
<td><code>ProcessList.NATIVE_ADJ : -1000</code></td>
</tr>
<tr>
<td><code>2</code></td>
<td><code>System</code></td>
<td><code>ProcessList.SYSTEM_ADJ : -900</code></td>
</tr>
<tr>
<td><code>3</code></td>
<td><code>Persistent</code></td>
<td><code>ProcessList.PERSISTENT_PROC_ADJ : -800</code></td>
</tr>
<tr>
<td><code>4</code></td>
<td><code>Persistent Service</code></td>
<td><code>ProcessList.PERSISTENT_SERVICE_ADJ : -700</code></td>
</tr>
<tr>
<td><code>5</code></td>
<td><code>Foreground</code></td>
<td><code>ProcessList.FOREGROUND_APP_ADJ : 0</code></td>
</tr>
<tr>
<td><code>6</code></td>
<td><code>Visible</code></td>
<td><code>ProcessList.VISIBLE_APP_ADJ : 100</code></td>
</tr>
<tr>
<td><code>7</code></td>
<td><code>Perceptible</code></td>
<td><code>ProcessList.PERCEPTIBLE_APP_ADJ : 200</code></td>
</tr>
<tr>
<td><code>8</code></td>
<td><code>Backup</code></td>
<td><code>ProcessList.BACKUP_APP_ADJ : 300</code></td>
</tr>
<tr>
<td><code>9</code></td>
<td><code>Heavy Weight</code></td>
<td><code>ProcessList.HEAVY_WEIGHT_APP_ADJ : 400</code></td>
</tr>
<tr>
<td><code>10</code></td>
<td><code>A Services</code></td>
<td><code>ProcessList.SERVICE_ADJ : 500</code></td>
</tr>
<tr>
<td><code>11</code></td>
<td><code>Home</code></td>
<td><code>ProcessList.HOME_APP_ADJ : 600</code></td>
</tr>
<tr>
<td><code>12</code></td>
<td><code>Previous</code></td>
<td><code>ProcessList.PREVIOUS_APP_ADJ : 700</code></td>
</tr>
<tr>
<td><code>13</code></td>
<td><code>B Services</code></td>
<td><code>ProcessList.SERVICE_B_ADJ : 800</code></td>
</tr>
<tr>
<td><code>14</code></td>
<td><code>Cached</code></td>
<td><code>ProcessList.CACHED_APP_MIN_ADJ : 900</code></td>
</tr>
</tbody>
</table>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2016/05/31/Serivce 篇 4 - bindService 流程分析/">Serivce 篇 4 - bindService 流程分析</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2016-05-31</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/AndroidFramework源码分析/">AndroidFramework源码分析</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/AndroidFramework源码分析/Service服务/">Service服务</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Service服务/">Service服务</a></span><div class="content"><p>本文基于 Android 7.1.1 源码分析，转载请说明出处！</p>
<h1 id="0-综述"><a href="#0-综述" class="headerlink" title="0 综述"></a>0 综述</h1><p>我们在应用中经常会启动 Service：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.bindService(intent, mConnection, Service.BIND_AUTO_CREATE);</span><br></pre></td></tr></table></figure>
<p>以前我们只是会调用，但是其底层的调用到底是什么样的呢？知其然知其所以然，今天我们就来学习下 bindService 的过程！</p>
<p>如果之前并不了解这块逻辑的话，那该如何去学习呢？ follow the funtion path！</p>
<h1 id="1-绑定者进程"><a href="#1-绑定者进程" class="headerlink" title="1 绑定者进程"></a>1 绑定者进程</h1><h2 id="1-1-ContextWrapper-bindService"><a href="#1-1-ContextWrapper-bindService" class="headerlink" title="1.1 ContextWrapper.bindService"></a>1.1 ContextWrapper.bindService</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextWrapper</span> <span class="keyword">extends</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    Context mBase;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ContextWrapper</span><span class="params">(Context base)</span> </span>&#123;</span><br><span class="line">        mBase = base;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">bindService</span><span class="params">(Intent service, ServiceConnection conn,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mBase.bindService(service, conn, flags);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">bindServiceAsUser</span><span class="params">(Intent service, ServiceConnection conn, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">            UserHandle user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mBase.bindServiceAsUser(service, conn, flags, user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ContextWrapper 提供了两个方法来绑定 Service，其中一个是隐藏方法：bindServiceAsUser！</p>
<p>bindService 的第三个参数 flags 一般都会传 0 或 BIND_AUTO_CREATE，<strong>跨进程调用 bindService 会引起组件间的依赖</strong>，比如 A 进程的 Activity 中 bindService 调用 B 进程 service，则 B 进程的 service 的 oom_adj 值依赖于 A 进程 Activity 的 oom_adj 值，这个我们后面在说，这些 flags 也可以通过按位或的方式，进行搭配使用！！</p>
<p>接着来说 flags，这里的 flags 可以取值如下，Android 7.1.1 内置了如下的几个标志位：</p>
<table>
<thead>
<tr>
<th>标志位</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>0</strong></td>
<td>无意义</td>
</tr>
<tr>
<td><strong>BIND_AUTO_CREATE</strong> (0x0001)</td>
<td>绑定服务时候，如果服务尚未创建，服务会自动创建，在 API LEVEL 14 以前的版本不支持这个标志，使用 Context.BIND_WAIVE_PRIORITY 可以达到同样效果</td>
</tr>
<tr>
<td><strong>BIND_DEBUG_UNBIND</strong> (0x0002)</td>
<td>通常用于 Debug，在 unbindService 时候，会将服务信息保存并打印出来，这个标记很容易造成内存泄漏，应该准备用于 debugging</td>
</tr>
<tr>
<td><strong>BIND_NOT_FOREGROUND</strong> (0x0002)</td>
<td>表示不允许绑定操作将服务所在进程的优先级提升到前台进程优先级</td>
</tr>
<tr>
<td><strong>BIND_ABOVE_CLIENT</strong> (0x0008)</td>
<td>设置服务的进程优先级高于客户端的优先级，只有当需要服务晚于客户端被销毁这种情况才这样设置。</td>
</tr>
<tr>
<td><strong>BIND_ALLOW_OOM_MANAGEMENT</strong> (0x0010)</td>
<td>保持服务受默认的服务管理器管理，当内存不足时候，会销毁服务</td>
</tr>
<tr>
<td><strong>BIND_WAIVE_PRIORITY</strong> (0x0020)</td>
<td>绑定操作不会影响到服务所在进程的优先级</td>
</tr>
<tr>
<td><strong>BIND_IMPORTANT</strong> (0x0040)</td>
<td>标识服务对客户端是非常重要的，会将服务提升至前台进程优先级，通常情况下，即时客户端是前台优先级，服务最多也只能被提升至可见进程优先级</td>
</tr>
<tr>
<td><strong>BIND_ADJUST_WITH_ACTIVITY</strong> (0x0080)</td>
<td>如果绑定来自 Activity，服务优先级的提高取决于Activity的进程优先级，使用这个标识后，会无视其他标识</td>
</tr>
<tr>
<td><strong>BIND_ALLOW_WHITELIST_MANAGEMENT</strong> (0x01000000)</td>
<td></td>
</tr>
<tr>
<td><strong>BIND_FOREGROUND_SERVICE_WHILE_AWAKE</strong> (0x02000000)</td>
<td></td>
</tr>
<tr>
<td><strong>BIND_FOREGROUND_SERVICE</strong> (0x04000000)</td>
<td></td>
</tr>
<tr>
<td><strong>BIND_TREAT_LIKE_ACTIVITY</strong> (0x08000000)</td>
<td></td>
</tr>
<tr>
<td><strong>BIND_VISIBLE</strong> (0x10000000)</td>
<td></td>
</tr>
<tr>
<td><strong>BIND_SHOWING_UI</strong> (0x20000000)</td>
<td>这种绑定方式会让目标服务所在进程显示出 UI 界面，当 UI 界面退出后会触发 UI_HIDDEN 类型的内存回收操作</td>
</tr>
<tr>
<td><strong>BIND_NOT_VISIBLE</strong> (0x40000000)</td>
<td></td>
</tr>
<tr>
<td><strong>BIND_EXTERNAL_SERVICE</strong> (0x80000000)</td>
<td><strong>1、</strong>通过这种方式绑定的服务是属于隔离的外部服务，服务将会被绑定到调用者应用的包内，而不是服务所在的应用包内！<br><strong>2、</strong>使用这个标签进行绑定，服务的代码将会在调用者应用的包名和 uid 下执行！因为服务所在的进程是一个隔离进程，隔离进程是不能直接访问应用程序的数据的！</td>
</tr>
</tbody>
</table>
<p>具体标志位对于 Service 进程有什么影响，请看进程的优先级调度！！！</p>
<p>这里有一点，对于 BIND_AUTO_CREATE，如果服务没有被创建，会自动创建，而对于其他的 flags，是不会自动创建服务的！所以说我们从 Service 的生命周期的角度来说，可以把这些 flags 分为两大类，自动创建和非自动创建类！！</p>
<p>mBase 是 ContextImpl 对象，继续看！</p>
<h2 id="1-2-ContextImpl-bindService"><a href="#1-2-ContextImpl-bindService" class="headerlink" title="1.2 ContextImpl.bindService"></a>1.2 ContextImpl.bindService</h2><p>mMainThread 是应用进程主线程的 Handler！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContextImpl</span> <span class="keyword">extends</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">bindService</span><span class="params">(Intent service, ServiceConnection conn,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">        warnIfCallingFromSystemProcess();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bindServiceCommon(service, conn, flags, mMainThread.getHandler(),</span><br><span class="line">                Process.myUserHandle());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">bindServiceAsUser</span><span class="params">(Intent service, ServiceConnection conn, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">            UserHandle user)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bindServiceCommon(service, conn, flags, mMainThread.getHandler(), user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">bindServiceAsUser</span><span class="params">(Intent service, ServiceConnection conn, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">            Handler handler, UserHandle user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"handler must not be null."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> bindServiceCommon(service, conn, flags, handler, user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ContextImpl 和 ContextWrapper 的具体关系，请来看另一博文：Android 系统的 Context 分析，这里我们不再详细说明！</p>
<p>mUser：表示的是当前的设备 user！</p>
<p>最终，调用了 bindServiceCommon 方法；</p>
<h2 id="1-3-ContextImpl-bindServiceCommon"><a href="#1-3-ContextImpl-bindServiceCommon" class="headerlink" title="1.3 ContextImpl.bindServiceCommon"></a>1.3 ContextImpl.bindServiceCommon</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">bindServiceCommon</span><span class="params">(Intent service, ServiceConnection conn, <span class="keyword">int</span> flags, Handler</span></span></span><br><span class="line"><span class="function"><span class="params">        handler, UserHandle user)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    IServiceConnection sd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (conn == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"connection is null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mPackageInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得本次连接的 InnerConnection 对象！</span></span><br><span class="line">        sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(), handler, flags);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Not supported in system context"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    validateServiceIntent(service);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得 ActivityClientRecord 对象！</span></span><br><span class="line">        IBinder token = getActivityToken();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里的意思是对于 Android 版本小于 android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH</span></span><br><span class="line">        <span class="comment">// BIND_AUTO_CREATE 是不使用的，用 BIND_WAIVE_PRIORITY替换！</span></span><br><span class="line">        <span class="keyword">if</span> (token == <span class="keyword">null</span> &amp;&amp; (flags&amp;BIND_AUTO_CREATE) == <span class="number">0</span> &amp;&amp; mPackageInfo != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; mPackageInfo.getApplicationInfo().targetSdkVersion</span><br><span class="line">                &lt; android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH) &#123;</span><br><span class="line"></span><br><span class="line">            flags |= BIND_WAIVE_PRIORITY;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        service.prepareToLeaveProcess(<span class="keyword">this</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// bind 通信，进入 ActivityManagerService！</span></span><br><span class="line">        <span class="keyword">int</span> res = ActivityManagerNative.getDefault().bindService(</span><br><span class="line">            mMainThread.getApplicationThread(), getActivityToken(), service,</span><br><span class="line">            service.resolveTypeIfNeeded(getContentResolver()),</span><br><span class="line">            sd, flags, getOpPackageName(), user.getIdentifier());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(</span><br><span class="line">                    <span class="string">"Not allowed to bind to service "</span> + service);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getActivityToken 方法获得的是 ActivityClientRecord 对象，具体为什么是它，请去看 startActivity 相关的博文！！</p>
<h3 id="1-3-1-LoadedApk-getServiceDispatcher"><a href="#1-3-1-LoadedApk-getServiceDispatcher" class="headerlink" title="1.3.1 LoadedApk.getServiceDispatcher"></a>1.3.1 LoadedApk.getServiceDispatcher</h3><p>mPackageInfo 是 LoadedApk 类的实例，每一个进程都会有一个，这里调用了 LoadedApk 的 getServiceDispatcher 方法来获得一个 IServiceConnection 类型的对象，这里我们只需要知道，ServiceConnection 是应用进程中的创建的连接对象，ServiceDispatcher 用来托管 ServiceConnection 对象和 ServiceDispatcher.InnerConnection 对象的映射关系，InnerConnection 能够进行 binder 通信！！</p>
<p>这里会涉及一个集合：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayMap&lt;Context, ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt;&gt; mServices</span><br><span class="line">    = <span class="keyword">new</span> ArrayMap&lt;Context, ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt;&gt;();</span><br></pre></td></tr></table></figure></p>
<p>这个是 LoadedApk 的内部实例集合，每一个进程在创建后，都会有一个 LoadedApk 对象， mServices 集合的 key 值为 Context 对象，表示上下文运行环境，大家可以理解为特定的组件，value 是一个 ArrayMap 集合，封装了特定的组件所持有的所有服务连接对象 ServiceConnection 和服务分发对象 ServiceDispatcher！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> IServiceConnection <span class="title">getServiceDispatcher</span><span class="params">(ServiceConnection c,</span></span></span><br><span class="line"><span class="function"><span class="params">        Context context, Handler handler, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mServices) &#123;</span><br><span class="line"></span><br><span class="line">        LoadedApk.ServiceDispatcher sd = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt; map = mServices.get(context);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果有的话，就直接返回！</span></span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sd = map.get(c);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (sd == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【1】不然就创建新的 ServiceDispatcher，然后返回，内部会创建 InnerConnection 对象！</span></span><br><span class="line">            sd = <span class="keyword">new</span> ServiceDispatcher(c, context, handler, flags);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (map == <span class="keyword">null</span>) &#123;</span><br><span class="line">                map = <span class="keyword">new</span> ArrayMap&lt;ServiceConnection, LoadedApk.ServiceDispatcher&gt;();</span><br><span class="line">                mServices.put(context, map);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【2】添加到对应的 map 集合中！</span></span><br><span class="line">            map.put(c, sd);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sd.validate(context, handler);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回 InnerConnection 对象，其继承了 IServiceConnection.Stub！</span></span><br><span class="line">        <span class="keyword">return</span> sd.getIServiceConnection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看看 ServiceDispatcher 对象的创建：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ServiceDispatcher(ServiceConnection conn,</span><br><span class="line">        Context context, Handler activityThread, <span class="keyword">int</span> flags) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】创建 InnerConnection 对象，用于跨进程调用！</span></span><br><span class="line">    mIServiceConnection = <span class="keyword">new</span> InnerConnection(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化内部 ServiceConnection 对象！</span></span><br><span class="line">    mConnection = conn;</span><br><span class="line">    mContext = context;</span><br><span class="line">    mActivityThread = activityThread;</span><br><span class="line">    mLocation = <span class="keyword">new</span> ServiceConnectionLeaked(<span class="keyword">null</span>);</span><br><span class="line">    mLocation.fillInStackTrace();</span><br><span class="line">    mFlags = flags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接着再看看 InnerConnection 对象的创建！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">InnerConnection(LoadedApk.ServiceDispatcher sd) &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//【1】持有 ServiceDispatcher 的弱引用！</span></span><br><span class="line">    mDispatcher = <span class="keyword">new</span> WeakReference&lt;LoadedApk.ServiceDispatcher&gt;(sd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里就看这么多！！</p>
<p>我们来他通过一张图看看绑定者进程的数据结构之间的关系：</p>
<p><img src="http://static.zybuluo.com/Coolqi/p0gzyjijwj4mo5gc29oqj3ar/%E7%BB%91%E5%AE%9A%E8%80%85%E8%BF%9B%E7%A8%8B%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%B3%E7%B3%BB.png" alt="绑定者进程中的数据结构关系.png-164.8kB"></p>
<p>其中，mActiveConnections 表示的是处于活跃中的连接信息，这个我们后面再看！</p>
<p>接着，调用 ActivityManagerNative.getDefault() 方法，获得 AMS 的代理对象 ActivityManagerProxy，调用代理的 bindService 方法！</p>
<h2 id="1-5-ActivityManagerP-bindService"><a href="#1-5-ActivityManagerP-bindService" class="headerlink" title="1.5 ActivityManagerP.bindService"></a>1.5 ActivityManagerP.bindService</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bindService</span><span class="params">(IApplicationThread caller, IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">        Intent service, String resolvedType, IServiceConnection connection,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> flags,  String callingPackage, <span class="keyword">int</span> userId)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Parcel data = Parcel.obtain();</span><br><span class="line">    Parcel reply = Parcel.obtain();</span><br><span class="line">    data.writeInterfaceToken(IActivityManager.descriptor);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里的 caller 是 ApplicationThread 对象！</span></span><br><span class="line">    data.writeStrongBinder(caller != <span class="keyword">null</span> ? caller.asBinder() : <span class="keyword">null</span>);</span><br><span class="line">    data.writeStrongBinder(token);</span><br><span class="line"></span><br><span class="line">    service.writeToParcel(data, <span class="number">0</span>);</span><br><span class="line">    data.writeString(resolvedType);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里的 connection 是 InnerConnection 对象！</span></span><br><span class="line">    data.writeStrongBinder(connection.asBinder());</span><br><span class="line"></span><br><span class="line">    data.writeInt(flags);</span><br><span class="line">    data.writeString(callingPackage);</span><br><span class="line">    data.writeInt(userId);</span><br><span class="line"></span><br><span class="line">    mRemote.transact(BIND_SERVICE_TRANSACTION, data, reply, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    reply.readException();</span><br><span class="line">    <span class="keyword">int</span> res = reply.readInt();</span><br><span class="line">    data.recycle();</span><br><span class="line">    reply.recycle();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 binder 进程间通信，进入系统进程，参数分析：</p>
<ul>
<li>IApplicationThread caller：调用者进程的 ApplicationThread 对象，实现了 IApplicationThread 接口；</li>
<li>IBinder token：应用端的 mActivityToken；</li>
<li>Intent service：启动的 intent</li>
<li>String resolvedType：这个 intent 的 MIME 类型；</li>
<li>IServiceConnection connection：服务连接对象 InnerConnection；</li>
<li>String callingPackage：启动者所属包名；</li>
<li>int userId：设备用户 id；</li>
</ul>
<p>下面会进入系统进程！</p>
<h1 id="2-系统进程"><a href="#2-系统进程" class="headerlink" title="2 系统进程"></a>2 系统进程</h1><p>首先要进入 ActivityManagerN.onTransact 方法！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> BIND_SERVICE_TRANSACTION: &#123;</span><br><span class="line"></span><br><span class="line">    data.enforceInterface(IActivityManager.descriptor);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【1】获得 ApplicationThreadProxy 对象！</span></span><br><span class="line">    IBinder b = data.readStrongBinder();</span><br><span class="line">    IApplicationThread app = ApplicationThreadNative.asInterface(b);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【2】Activity 句柄！</span></span><br><span class="line">    IBinder token = data.readStrongBinder();</span><br><span class="line"></span><br><span class="line">    Intent service = Intent.CREATOR.createFromParcel(data);</span><br><span class="line">    String resolvedType = data.readString();</span><br><span class="line">    b = data.readStrongBinder();</span><br><span class="line">    <span class="keyword">int</span> fl = data.readInt();</span><br><span class="line">    String callingPackage = data.readString();</span><br><span class="line">    <span class="keyword">int</span> userId = data.readInt();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【3】获得 InnerConnection 的代理对象！</span></span><br><span class="line">    IServiceConnection conn = IServiceConnection.Stub.asInterface(b);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 进入 AMS!</span></span><br><span class="line">    <span class="keyword">int</span> res = bindService(app, token, service, resolvedType, conn, fl,</span><br><span class="line">            callingPackage, userId);</span><br><span class="line"></span><br><span class="line">    reply.writeNoException();</span><br><span class="line">    reply.writeInt(res);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>继续看！</p>
<h2 id="2-1-ActivityManagerS-bindService"><a href="#2-1-ActivityManagerS-bindService" class="headerlink" title="2.1 ActivityManagerS.bindService"></a>2.1 ActivityManagerS.bindService</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bindService</span><span class="params">(IApplicationThread caller, IBinder token, Intent service,</span></span></span><br><span class="line"><span class="function"><span class="params">        String resolvedType, IServiceConnection connection, <span class="keyword">int</span> flags, String callingPackage,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> userId)</span> <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line"></span><br><span class="line">    enforceNotIsolatedCaller(<span class="string">"bindService"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (service != <span class="keyword">null</span> &amp;&amp; service.hasFileDescriptors() == <span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"File descriptors passed in Intent"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (callingPackage == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"callingPackage cannot be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 进入 ActiveServices 中！！</span></span><br><span class="line">        <span class="keyword">return</span> mServices.bindServiceLocked(caller, token, service,</span><br><span class="line">                resolvedType, connection, flags, callingPackage, userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-ActiveServices-bindServiceLocked"><a href="#2-2-ActiveServices-bindServiceLocked" class="headerlink" title="2.2 ActiveServices.bindServiceLocked"></a>2.2 ActiveServices.bindServiceLocked</h2><p>这个方法的逻辑比较长，我们来仔细看看！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bindServiceLocked</span><span class="params">(IApplicationThread caller, IBinder token, Intent service,</span></span></span><br><span class="line"><span class="function"><span class="params">        String resolvedType, <span class="keyword">final</span> IServiceConnection connection, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">        String callingPackage, <span class="keyword">final</span> <span class="keyword">int</span> userId)</span> <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">"bindService: "</span> + service</span><br><span class="line">            + <span class="string">" type="</span> + resolvedType + <span class="string">" conn="</span> + connection.asBinder()</span><br><span class="line">            + <span class="string">" flags=0x"</span> + Integer.toHexString(flags));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获得调用者进程 ProcessRecord 对象！</span></span><br><span class="line">    <span class="keyword">final</span> ProcessRecord callerApp = mAm.getRecordForAppLocked(caller);</span><br><span class="line">    <span class="keyword">if</span> (callerApp == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(</span><br><span class="line">                <span class="string">"Unable to find app for caller "</span> + caller</span><br><span class="line">                + <span class="string">" (pid="</span> + Binder.getCallingPid()</span><br><span class="line">                + <span class="string">") when binding service "</span> + service);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 token 不为 null 的话，就获得其对应的 ActivityRecord 对象！</span></span><br><span class="line">    ActivityRecord activity = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (token != <span class="keyword">null</span>) &#123;</span><br><span class="line">        activity = ActivityRecord.isInStackLocked(token);</span><br><span class="line">        <span class="keyword">if</span> (activity == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Binding with unknown activity: "</span> + token);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> clientLabel = <span class="number">0</span>;</span><br><span class="line">    PendingIntent clientIntent = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断是否是系统进程！</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isCallerSystem = callerApp.info.uid == Process.SYSTEM_UID;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isCallerSystem) &#123;</span><br><span class="line">    </span><br><span class="line">        service.setDefusable(<span class="keyword">true</span>);</span><br><span class="line">        clientIntent = service.getParcelableExtra(Intent.EXTRA_CLIENT_INTENT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (clientIntent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            clientLabel = service.getIntExtra(Intent.EXTRA_CLIENT_LABEL, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (clientLabel != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                service = service.cloneFilter();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果设置了 Context.BIND_TREAT_LIKE_ACTIVITY 的标签，</span></span><br><span class="line">    <span class="comment">// 必须有权限 android.Manifest.permission.MANAGE_ACTIVITY_STACKS；</span></span><br><span class="line">    <span class="keyword">if</span> ((flags&amp;Context.BIND_TREAT_LIKE_ACTIVITY) != <span class="number">0</span>) &#123;</span><br><span class="line">        mAm.enforceCallingPermission(android.Manifest.permission.MANAGE_ACTIVITY_STACKS,</span><br><span class="line">                <span class="string">"BIND_TREAT_LIKE_ACTIVITY"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非系统进程不能设置 BIND_ALLOW_WHITELIST_MANAGEMENT 的 flags！</span></span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; Context.BIND_ALLOW_WHITELIST_MANAGEMENT) != <span class="number">0</span> &amp;&amp; !isCallerSystem) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(</span><br><span class="line">                <span class="string">"Non-system caller "</span> + caller + <span class="string">" (pid="</span> + Binder.getCallingPid()</span><br><span class="line">                + <span class="string">") set BIND_ALLOW_WHITELIST_MANAGEMENT when binding service "</span> + service);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// callerFg 表示的是前台调用或者是后台调用！</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> callerFg = callerApp.setSchedGroup != ProcessList.SCHED_GROUP_BACKGROUND;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 表示是否 bind 的是 isolated， external 类型的服务！</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isBindExternal = (flags &amp; Context.BIND_EXTERNAL_SERVICE) != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】检索要 bind 的服务信息！</span></span><br><span class="line">    ServiceLookupResult res =</span><br><span class="line">        retrieveServiceLocked(service, resolvedType, callingPackage, Binder.getCallingPid(),</span><br><span class="line">                Binder.getCallingUid(), userId, <span class="keyword">true</span>, callerFg, isBindExternal);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (res.record == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获得服务的信息对象 ServiceRecord！</span></span><br><span class="line">    ServiceRecord s = res.record;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> permissionsReviewRequired = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果编译时，指定需要检测权限，那就先要通过权限的检测！</span></span><br><span class="line">    <span class="keyword">if</span> (Build.PERMISSIONS_REVIEW_REQUIRED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mAm.getPackageManagerInternalLocked().isPermissionsReviewRequired(</span><br><span class="line">                s.packageName, s.userId)) &#123;</span><br><span class="line"></span><br><span class="line">            permissionsReviewRequired = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对于前台调用才要校验权限！</span></span><br><span class="line">            <span class="keyword">if</span> (!callerFg) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"u"</span> + s.userId + <span class="string">" Binding to a service in package"</span></span><br><span class="line">                        + s.packageName + <span class="string">" requires a permissions review"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> ServiceRecord serviceRecord = s;</span><br><span class="line">            <span class="keyword">final</span> Intent serviceIntent = service;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 校验权限后的回调！</span></span><br><span class="line">            RemoteCallback callback = <span class="keyword">new</span> RemoteCallback(</span><br><span class="line">                    <span class="keyword">new</span> RemoteCallback.OnResultListener() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResult</span><span class="params">(Bundle result)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">synchronized</span>(mAm) &#123;</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">long</span> identity = Binder.clearCallingIdentity();</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (!mPendingServices.contains(serviceRecord)) &#123;</span><br><span class="line">                                <span class="keyword">return</span>;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (!mAm.getPackageManagerInternalLocked()</span><br><span class="line">                                    .isPermissionsReviewRequired(</span><br><span class="line">                                            serviceRecord.packageName,</span><br><span class="line">                                            serviceRecord.userId)) &#123;</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    </span><br><span class="line">                                    <span class="comment">//</span></span><br><span class="line">                                    bringUpServiceLocked(serviceRecord,</span><br><span class="line">                                            serviceIntent.getFlags(),</span><br><span class="line">                                            callerFg, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">                                &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                                    <span class="comment">/* ignore - local call */</span></span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                unbindServiceLocked(connection);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            Binder.restoreCallingIdentity(identity);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 创建 intent，启动 PackageInstaller，来校验权限！</span></span><br><span class="line">            <span class="keyword">final</span> Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_REVIEW_PERMISSIONS);</span><br><span class="line">            intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK</span><br><span class="line">                    | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);</span><br><span class="line">            intent.putExtra(Intent.EXTRA_PACKAGE_NAME, s.packageName);</span><br><span class="line">            intent.putExtra(Intent.EXTRA_REMOTE_CALLBACK, callback);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (DEBUG_PERMISSIONS_REVIEW) &#123;</span><br><span class="line">                Slog.i(TAG, <span class="string">"u"</span> + s.userId + <span class="string">" Launching permission review for package "</span></span><br><span class="line">                        + s.packageName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mAm.mHandler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                </span><br><span class="line">                    <span class="comment">// 启动权限校验界面！</span></span><br><span class="line">                    mAm.mContext.startActivityAsUser(intent, <span class="keyword">new</span> UserHandle(userId));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【2】取消服务的重启任务！</span></span><br><span class="line">        <span class="keyword">if</span> (unscheduleServiceRestartLocked(s, callerApp.info.uid, <span class="keyword">false</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">"BIND SERVICE WHILE RESTART PENDING: "</span> + s);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果启动 flags 设置了 Context.BIND_AUTO_CREATE 标签！</span></span><br><span class="line">        <span class="keyword">if</span> ((flags&amp;Context.BIND_AUTO_CREATE) != <span class="number">0</span>) &#123;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">// 更新服务的活跃时间！</span></span><br><span class="line">            s.lastActivity = SystemClock.uptimeMillis();</span><br><span class="line">            <span class="keyword">if</span> (!s.hasAutoCreateConnections()) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 这是第一次 bind，通知服务状态监控器！</span></span><br><span class="line">                ServiceState stracker = s.getTracker();</span><br><span class="line">                <span class="keyword">if</span> (stracker != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    stracker.setBound(<span class="keyword">true</span>, mAm.mProcessStats.getMemFactorLocked(),</span><br><span class="line">                            s.lastActivity);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mAm.startAssociationLocked(callerApp.uid, callerApp.processName, callerApp.curProcState,</span><br><span class="line">                s.appInfo.uid, s.name, s.processName);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【3】创建 AppBindRecord 对象，用来记录绑定到这个服务的应用的信息！</span></span><br><span class="line">        <span class="comment">// s 是要绑定的 ServiceRecord!</span></span><br><span class="line">        AppBindRecord b = s.retrieveAppBindingLocked(service, callerApp);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建 ConnectionRecord 对象，用来记本次的绑定连接！</span></span><br><span class="line">        ConnectionRecord c = <span class="keyword">new</span> ConnectionRecord(b, activity,</span><br><span class="line">                connection, flags, clientLabel, clientIntent);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// connection 是一个从应用进程传过来的 InnerConnection 对象！</span></span><br><span class="line">        IBinder binder = connection.asBinder();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// s.connections 记录了这个服务的 IServiceConnection 对象和 ConnectionRecord 对象的对应关系！</span></span><br><span class="line">        ArrayList&lt;ConnectionRecord&gt; clist = s.connections.get(binder);</span><br><span class="line">        <span class="keyword">if</span> (clist == <span class="keyword">null</span>) &#123;</span><br><span class="line">            clist = <span class="keyword">new</span> ArrayList&lt;ConnectionRecord&gt;();</span><br><span class="line">            s.connections.put(binder, clist);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将 ConnectionRecord 保存到 s.connections 中！</span></span><br><span class="line">        clist.add(c);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将 ConnectionRecord 对象添加到对应的 AppBindRecord 的 connections 中！</span></span><br><span class="line">        b.connections.add(c);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果 activity 不为 null，说明是 Activity 执行的 bind，所以要把 ConnectionRecord 添加到其 connections 中;</span></span><br><span class="line">        <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (activity.connections == <span class="keyword">null</span>) &#123;</span><br><span class="line">                activity.connections = <span class="keyword">new</span> HashSet&lt;ConnectionRecord&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            activity.connections.add(c);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将 ConnectionRecord 保存到调用者进程的 connections 列表中！</span></span><br><span class="line">        b.client.connections.add(c);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((c.flags&amp;Context.BIND_ABOVE_CLIENT) != <span class="number">0</span>) &#123;</span><br><span class="line">            b.client.hasAboveClient = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((c.flags&amp;Context.BIND_ALLOW_WHITELIST_MANAGEMENT) != <span class="number">0</span>) &#123;</span><br><span class="line">            s.whitelistManager = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s.app != <span class="keyword">null</span>) &#123;</span><br><span class="line">            updateServiceClientActivitiesLocked(s.app, c, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// mServiceConnections 是 AS 的成员变量，记录着 IServiceConnection 和其 ConnectionRecord 的对应关系！</span></span><br><span class="line">        clist = mServiceConnections.get(binder);</span><br><span class="line">        <span class="keyword">if</span> (clist == <span class="keyword">null</span>) &#123;</span><br><span class="line">            clist = <span class="keyword">new</span> ArrayList&lt;ConnectionRecord&gt;();</span><br><span class="line">            mServiceConnections.put(binder, clist);</span><br><span class="line">        &#125;</span><br><span class="line">        clist.add(c);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果启动的 flags 设置了 Context.BIND_AUTO_CREATE 标志位，那么就进入这个分支，</span></span><br><span class="line">        <span class="comment">// 如果服务没有被创建，就会自动创建服务！</span></span><br><span class="line">        <span class="keyword">if</span> ((flags&amp;Context.BIND_AUTO_CREATE) != <span class="number">0</span>) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 再次更新服务的活跃时间！</span></span><br><span class="line">            s.lastActivity = SystemClock.uptimeMillis();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//【4】启动该服务，如果服务所在进程未启动，还要启动相应进程，其返回值为 null，说明启动成功！</span></span><br><span class="line">            <span class="keyword">if</span> (bringUpServiceLocked(s, service.getFlags(), callerFg, <span class="keyword">false</span>,</span><br><span class="line">                    permissionsReviewRequired) != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果服务所在进程的 ProcessRecord 不为 null，就要更新服务的优先级以及 oomAdj 的值！</span></span><br><span class="line">        <span class="keyword">if</span> (s.app != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((flags&amp;Context.BIND_TREAT_LIKE_ACTIVITY) != <span class="number">0</span>) &#123;</span><br><span class="line">                s.app.treatLikeActivity = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s.whitelistManager) &#123;</span><br><span class="line">                s.app.whitelistManager = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mAm.updateLruProcessLocked(s.app, s.app.hasClientActivities</span><br><span class="line">                    || s.app.treatLikeActivity, b.client);</span><br><span class="line">            mAm.updateOomAdjLocked(s.app);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 【*】接着进入这个分支，这里我们在下面分析：</span></span><br><span class="line">        <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">"Bind "</span> + s + <span class="string">" with "</span> + b</span><br><span class="line">                + <span class="string">": received="</span> + b.intent.received</span><br><span class="line">                + <span class="string">" apps="</span> + b.intent.apps.size()</span><br><span class="line">                + <span class="string">" doRebind="</span> + b.intent.doRebind);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 第一次自动创建方式的绑定，两个分支都不进入，多次自动创建方式的绑定，只会进入第二个分支！</span></span><br><span class="line">        <span class="keyword">if</span> (s.app != <span class="keyword">null</span> &amp;&amp; b.intent.received) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//【5】服务已经在运行中了，那就尝试完成连接，会判断是否已经已有连接</span></span><br><span class="line">                <span class="comment">// 如果有，就不会创建连接！</span></span><br><span class="line">                c.conn.connected(s.name, b.intent.binder);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Failure sending service "</span> + s.shortName</span><br><span class="line">                        + <span class="string">" to connection "</span> + c.conn.asBinder()</span><br><span class="line">                        + <span class="string">" (in "</span> + c.binding.client.processName + <span class="string">")"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If this is the first app connected back to this binding,</span></span><br><span class="line">            <span class="comment">// and the service had previously asked to be told when</span></span><br><span class="line">            <span class="comment">// rebound, then do so.</span></span><br><span class="line">            <span class="comment">// 【6】尝试拉起服务的 onRebind 方法！</span></span><br><span class="line">            <span class="keyword">if</span> (b.intent.apps.size() == <span class="number">1</span> &amp;&amp; b.intent.doRebind) &#123;</span><br><span class="line">                requestServiceBindingLocked(s, b.intent, callerFg, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!b.intent.requested) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 【7】尝试拉起服务的 onBind 方法！</span></span><br><span class="line">            requestServiceBindingLocked(s, b.intent, callerFg, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        getServiceMap(s.userId).ensureNotStartingBackground(s);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法的逻辑很长，我们来简单总结一下重点！！</p>
<p><strong>注意</strong>：</p>
<p>对于 Context.BIND_AUTO_CREATE 的方式，bringUpServiceLocked 方法中拉起 onCreate 和 onBind 方法的 Binder 通信是 IBinder.FLAGS_ONEWAY 方式，所以 Binder 服务端系统进程在触发方法后，无需等待，会立即向下执行！</p>
<p><strong>这里来重点说下最后的分支部分</strong>：</p>
<p>这部分内容会涉及到下面的章节！！</p>
<ul>
<li><p>对于 BIND_AUTO_CREATE 的这种 bindService 方式：</p>
<ul>
<li>第一次绑定时，进入该分支前， received 为 false 而 requested 为 true（requested 是在 bringUpServiceLocked -&gt; requestServiceBindingLocked 被置为 true 的），所以下面 <code>IF</code> 和 <code>ELSE</code> 分支都不会进入！</li>
<li>多次绑定时，因为第一次绑定连接已经生成，所以 received 和 requested 都会为 true，这里会进入第一个 <code>IF</code> 分支，尝试执行 ServiceConnection.onServiceConnected 方法，因为之前绑定已经存在，就不会执行！！！</li>
</ul>
</li>
<li><p>对于非 BIND_AUTO_CREATE 的这种 bindService 方式：</p>
<ul>
<li>如果服务之前没有启动，那么不管绑定几次，都只是将绑定所数据绑定到相应的集合中，但 received 和 requested 都为 false！，所以会进入第二个 <code>ELSE</code> 分支，尝试拉起 onbind 方法，但是由于服务没有被创建和运行，r.app 和 r.app.thread 都为 null，所以不会继续执行！</li>
<li>如果服务之前已经被启动了，我们知道对于这种情况，如果之前进行了 bindService 的操作， 因为系统已经保存了绑定信息，所以会立刻拉起服务的 onbind 方法，并执行 ServiceConnection.onServiceConnected 方法！</li>
<li>如果服务之前已经被启动了，这是我们再执行 bindService 操作：<ul>
<li>第一次绑定，进入该分支前， received 和 requested 均为 false（这个第一种情况不同），这样会进入第二个 <code>ELSE</code> 分支，拉起服务的 onBind 方法，并执行 ServiceConnection.onServiceConnected 方法！</li>
<li>多次绑定，进入该分支前， received 和 requested 均为 true，所以会进入第一个 <code>IF</code> 分支，尝试执行 ServiceConnection.onServiceConnected 方法，因为之前绑定已经存在，就不会执行！！！</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>整个流程看起来复杂，但是体现在生命周期上很简单，这里就不说了！！</p>
<p>然后，我们来看下这个方法中的重点！！</p>
<h3 id="2-2-1-ActiveServices-retrieveServiceLocked"><a href="#2-2-1-ActiveServices-retrieveServiceLocked" class="headerlink" title="2.2.1 ActiveServices.retrieveServiceLocked"></a>2.2.1 ActiveServices.retrieveServiceLocked</h3><p>根据 intent 来查询被启动服务的 ServiceRecord 对象，参数传递：</p>
<ul>
<li>boolean createIfNeeded：传入的是 true；</li>
<li>boolean callingFromFg：表示是从前台调用，还是后台调用；</li>
<li>boolean isBindExternal：表示 bind 的是否是 isolated, external 类型的服务，我们这里默认为 false；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ServiceLookupResult <span class="title">retrieveServiceLocked</span><span class="params">(Intent service,</span></span></span><br><span class="line"><span class="function"><span class="params">        String resolvedType, String callingPackage, <span class="keyword">int</span> callingPid, <span class="keyword">int</span> callingUid, <span class="keyword">int</span> userId,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> createIfNeeded, <span class="keyword">boolean</span> callingFromFg, <span class="keyword">boolean</span> isBindExternal)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 被绑定的服务！</span></span><br><span class="line">    ServiceRecord r = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG_SERVICE)</span><br><span class="line">        Slog.v(TAG_SERVICE, <span class="string">"retrieveServiceLocked: "</span> + service</span><br><span class="line">            + <span class="string">" type="</span> + resolvedType + <span class="string">" callingUid="</span> + callingUid);</span><br><span class="line"></span><br><span class="line">    userId = mAm.mUserController.handleIncomingUser(callingPid, callingUid, userId, <span class="keyword">false</span>,</span><br><span class="line">            ActivityManagerService.ALLOW_NON_FULL_IN_PROFILE, <span class="string">"service"</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 ActiveServices 的 mServiceMap 中获得设备用户 userId 下的所有服务列表！</span></span><br><span class="line">    ServiceMap smap = getServiceMap(userId);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果 intent 有设置组件名，就从 smap.mServicesByName 中获取！</span></span><br><span class="line">    <span class="keyword">final</span> ComponentName comp = service.getComponent();</span><br><span class="line">    <span class="keyword">if</span> (comp != <span class="keyword">null</span>) &#123;</span><br><span class="line">        r = smap.mServicesByName.get(comp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 intent 没有设置组件名，就从 smap.mServicesByIntent 通过 filter 获得！</span></span><br><span class="line">    <span class="keyword">if</span> (r == <span class="keyword">null</span> &amp;&amp; !isBindExternal) &#123;</span><br><span class="line">        Intent.FilterComparison filter = <span class="keyword">new</span> Intent.FilterComparison(service);</span><br><span class="line">        r = smap.mServicesByIntent.get(filter);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对于 external 类型的服务，只能限制其应用程序自己 bind！</span></span><br><span class="line">    <span class="keyword">if</span> (r != <span class="keyword">null</span> &amp;&amp; (r.serviceInfo.flags &amp; ServiceInfo.FLAG_EXTERNAL_SERVICE) != <span class="number">0</span></span><br><span class="line">            &amp;&amp; !callingPackage.equals(r.packageName)) &#123;</span><br><span class="line">        r = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 通过 PMS，查询能够匹配 intent 的服务！</span></span><br><span class="line">            ResolveInfo rInfo = AppGlobals.getPackageManager().resolveService(service,</span><br><span class="line">                    resolvedType, ActivityManagerService.STOCK_PM_FLAGS</span><br><span class="line">                            | PackageManager.MATCH_DEBUG_TRIAGED_MISSING,</span><br><span class="line">                    userId);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 获得服务信息！</span></span><br><span class="line">            ServiceInfo sInfo =</span><br><span class="line">                rInfo != <span class="keyword">null</span> ? rInfo.serviceInfo : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (sInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">                Slog.w(TAG_SERVICE, <span class="string">"Unable to start service "</span> + service + <span class="string">" U="</span> + userId +</span><br><span class="line">                      <span class="string">": not found"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ComponentName name = <span class="keyword">new</span> ComponentName(</span><br><span class="line">                    sInfo.applicationInfo.packageName, sInfo.name);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果服务类型是 external 的，那么 bind 时必须加 BIND_EXTERNAL_SERVICE 的标志！</span></span><br><span class="line">            <span class="comment">// 不然会抛出安全异常！</span></span><br><span class="line">            <span class="keyword">if</span> ((sInfo.flags &amp; ServiceInfo.FLAG_EXTERNAL_SERVICE) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isBindExternal) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!sInfo.exported) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 对于 external  类型的服务，必须要设置 android:exported 的值为 true，不然抛异常！</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"BIND_EXTERNAL_SERVICE failed, "</span> + name +</span><br><span class="line">                                <span class="string">" is not exported"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 对于 external 类型的服务，必须运行在隔离进程中！</span></span><br><span class="line">                    <span class="keyword">if</span> ((sInfo.flags &amp; ServiceInfo.FLAG_ISOLATED_PROCESS) == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"BIND_EXTERNAL_SERVICE failed, "</span> + name +</span><br><span class="line">                                <span class="string">" is not an isolatedProcess"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 获得调用者应用的 ApplicationInfo 信息</span></span><br><span class="line">                    ApplicationInfo aInfo = AppGlobals.getPackageManager().getApplicationInfo(</span><br><span class="line">                            callingPackage, ActivityManagerService.STOCK_PM_FLAGS, userId);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (aInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"BIND_EXTERNAL_SERVICE failed, "</span> +</span><br><span class="line">                                <span class="string">"could not resolve client package "</span> + callingPackage);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    sInfo = <span class="keyword">new</span> ServiceInfo(sInfo);</span><br><span class="line">                    sInfo.applicationInfo = <span class="keyword">new</span> ApplicationInfo(sInfo.applicationInfo);</span><br><span class="line">                    sInfo.applicationInfo.packageName = aInfo.packageName;</span><br><span class="line">                    sInfo.applicationInfo.uid = aInfo.uid;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 设置 intent 的 ComponentName 对象！</span></span><br><span class="line">                    name = <span class="keyword">new</span> ComponentName(aInfo.packageName, name.getClassName());</span><br><span class="line">                    service.setComponent(name);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"BIND_EXTERNAL_SERVICE required for "</span> +</span><br><span class="line">                            name);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isBindExternal) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"BIND_EXTERNAL_SERVICE failed, "</span> + name +</span><br><span class="line">                        <span class="string">" is not an externalService"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理多用户的情况！</span></span><br><span class="line">            <span class="keyword">if</span> (userId &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mAm.isSingleton(sInfo.processName, sInfo.applicationInfo,</span><br><span class="line">                        sInfo.name, sInfo.flags)</span><br><span class="line">                        &amp;&amp; mAm.isValidSingletonCall(callingUid, sInfo.applicationInfo.uid)) &#123;</span><br><span class="line"></span><br><span class="line">                    userId = <span class="number">0</span>;</span><br><span class="line">                    smap = getServiceMap(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                sInfo = <span class="keyword">new</span> ServiceInfo(sInfo);</span><br><span class="line">                sInfo.applicationInfo = mAm.getAppInfoForUser(sInfo.applicationInfo, userId);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 根据 ComponentName 获得 ServiceRecord 对象！</span></span><br><span class="line">            r = smap.mServicesByName.get(name);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (r == <span class="keyword">null</span> &amp;&amp; createIfNeeded) &#123;</span><br><span class="line"></span><br><span class="line">                Intent.FilterComparison filter</span><br><span class="line">                        = <span class="keyword">new</span> Intent.FilterComparison(service.cloneFilter());</span><br><span class="line">                        </span><br><span class="line">                <span class="comment">// 创建服务重启对象，这是一个 Runnable 对象！！</span></span><br><span class="line">                ServiceRestarter res = <span class="keyword">new</span> ServiceRestarter();</span><br><span class="line">                BatteryStatsImpl.Uid.Pkg.Serv ss = <span class="keyword">null</span>;</span><br><span class="line">                BatteryStatsImpl stats = mAm.mBatteryStatsService.getActiveStatistics();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span> (stats) &#123;</span><br><span class="line">                    ss = stats.getServiceStatsLocked(</span><br><span class="line">                            sInfo.applicationInfo.uid, sInfo.packageName,</span><br><span class="line">                            sInfo.name);</span><br><span class="line">                &#125;</span><br><span class="line">                 </span><br><span class="line">                <span class="comment">// 创建新的 ServiceRecord 对象！</span></span><br><span class="line">                r = <span class="keyword">new</span> ServiceRecord(mAm, ss, name, filter, sInfo, callingFromFg, res);</span><br><span class="line">                res.setService(r);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 将新的 ServiceRecord 添加到 smap.mServicesByName 和 smap.mServicesByIntent 中！</span></span><br><span class="line">                smap.mServicesByName.put(name, r);</span><br><span class="line">                smap.mServicesByIntent.put(filter, r);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 从 mPendingServices 中移除这个 ServiceRecord！</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=mPendingServices.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">                    ServiceRecord pr = mPendingServices.get(i);</span><br><span class="line">                    <span class="keyword">if</span> (pr.serviceInfo.applicationInfo.uid == sInfo.applicationInfo.uid</span><br><span class="line">                            &amp;&amp; pr.name.equals(name)) &#123;</span><br><span class="line">                        mPendingServices.remove(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">            <span class="comment">// pm is in same process, this will never happen.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面对查询的数据进行封装！</span></span><br><span class="line">    <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mAm.checkComponentPermission(r.permission,</span><br><span class="line">                callingPid, callingUid, r.appInfo.uid, r.exported)</span><br><span class="line">                != PackageManager.PERMISSION_GRANTED) &#123; <span class="comment">// 检查权限如果不授予！</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!r.exported) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Permission Denial: Accessing service "</span> + r.name</span><br><span class="line">                        + <span class="string">" from pid="</span> + callingPid</span><br><span class="line">                        + <span class="string">", uid="</span> + callingUid</span><br><span class="line">                        + <span class="string">" that is not exported from uid "</span> + r.appInfo.uid);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 异常返回，_record 为 null，无法启动！</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ServiceLookupResult(<span class="keyword">null</span>, <span class="string">"not exported from uid "</span></span><br><span class="line">                        + r.appInfo.uid);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Slog.w(TAG, <span class="string">"Permission Denial: Accessing service "</span> + r.name</span><br><span class="line">                    + <span class="string">" from pid="</span> + callingPid</span><br><span class="line">                    + <span class="string">", uid="</span> + callingUid</span><br><span class="line">                    + <span class="string">" requires "</span> + r.permission);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 异常返回，_record 为 null，无法启动！</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ServiceLookupResult(<span class="keyword">null</span>, r.permission);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.permission != <span class="keyword">null</span> &amp;&amp; callingPackage != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> opCode = AppOpsManager.permissionToOpCode(r.permission);</span><br><span class="line">            <span class="keyword">if</span> (opCode != AppOpsManager.OP_NONE &amp;&amp; mAm.mAppOpsService.noteOperation(</span><br><span class="line">                    opCode, callingUid, callingPackage) != AppOpsManager.MODE_ALLOWED) &#123;</span><br><span class="line">                    </span><br><span class="line">                Slog.w(TAG, <span class="string">"Appop Denial: Accessing service "</span> + r.name</span><br><span class="line">                        + <span class="string">" from pid="</span> + callingPid</span><br><span class="line">                        + <span class="string">", uid="</span> + callingUid</span><br><span class="line">                        + <span class="string">" requires appop "</span> + AppOpsManager.opToName(opCode));</span><br><span class="line">                        </span><br><span class="line">                <span class="comment">// 异常返回，无法启动！</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!mAm.mIntentFirewall.checkService(r.name, service, callingUid, callingPid,</span><br><span class="line">                resolvedType, r.appInfo)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 异常返回，无法启动！</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回最终的服务封装类！！</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ServiceLookupResult(r, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法的最终目的是返回要启动的服务的信息封装对象 ServiceLookupResult！</p>
<h3 id="2-2-2-ActiveServices-unscheduleServiceRestartLocked"><a href="#2-2-2-ActiveServices-unscheduleServiceRestartLocked" class="headerlink" title="2.2.2 ActiveServices.unscheduleServiceRestartLocked"></a>2.2.2 ActiveServices.unscheduleServiceRestartLocked</h3><p>如果服务此时已经在重启列表中了，就要取消这个任务！</p>
<p>参数传入：</p>
<ul>
<li>boolean force：传入 false<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">unscheduleServiceRestartLocked</span><span class="params">(ServiceRecord r, <span class="keyword">int</span> callingUid,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> force)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!force &amp;&amp; r.restartDelay == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove from the restarting list; if the service is currently on the</span></span><br><span class="line">    <span class="comment">// restarting list, or the call is coming from another app, then this</span></span><br><span class="line">    <span class="comment">// service has become of much more interest so we reset the restart interval.</span></span><br><span class="line">    <span class="keyword">boolean</span> removed = mRestartingServices.remove(r);</span><br><span class="line">    <span class="keyword">if</span> (removed || callingUid != r.appInfo.uid) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 重置重启计数！</span></span><br><span class="line">        r.resetRestartCounter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (removed) &#123;</span><br><span class="line">        clearRestartingIfNeededLocked(r);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从 mAm.mHandler 中移除对一个的 ServiceStarter 对象！</span></span><br><span class="line">    c.removeCallbacks(r.restarter);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>因为当前服务要重新启动，所以之前的重启就要重置！</p>
<h3 id="2-2-3-ServiceRecord-retrieveAppBindingLocked"><a href="#2-2-3-ServiceRecord-retrieveAppBindingLocked" class="headerlink" title="2.2.3 ServiceRecord.retrieveAppBindingLocked"></a>2.2.3 ServiceRecord.retrieveAppBindingLocked</h3><p>这里是很关键的一段逻辑，创建了很多的对象，并相互引用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3、创建 AppBindRecord 对象，用来记录绑定到这个服务的应用的信息！</span></span><br><span class="line">AppBindRecord b = s.retrieveAppBindingLocked(service, callerApp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 ConnectionRecord 对象，用来记录一个连接！</span></span><br><span class="line">ConnectionRecord c = <span class="keyword">new</span> ConnectionRecord(b, activity,</span><br><span class="line">        connection, flags, clientLabel, clientIntent);</span><br><span class="line"></span><br><span class="line"><span class="comment">// connection 是一个绑定者进程的 IServiceConnection.proxy 对象，和 InnerConnection 对应！！</span></span><br><span class="line">IBinder binder = connection.asBinder();</span><br><span class="line"></span><br><span class="line"><span class="comment">// s.connections 记录了这个服务的 IServiceConnection 和 ConnectionRecord 的对应关系！</span></span><br><span class="line">ArrayList&lt;ConnectionRecord&gt; clist = s.connections.get(binder);</span><br><span class="line"><span class="keyword">if</span> (clist == <span class="keyword">null</span>) &#123;</span><br><span class="line">    clist = <span class="keyword">new</span> ArrayList&lt;ConnectionRecord&gt;();</span><br><span class="line">    s.connections.put(binder, clist);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 ConnectionRecord 保存到 s.connections 中！</span></span><br><span class="line">clist.add(c);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 ConnectionRecord 对象添加到对应的 AppBindRecord 的 connections 中！</span></span><br><span class="line">b.connections.add(c);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果 activity 不为 null，说明是 Activity 执行的 bind，所以要把</span></span><br><span class="line"><span class="comment">// 添加到其 connections 中;</span></span><br><span class="line"><span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (activity.connections == <span class="keyword">null</span>) &#123;</span><br><span class="line">        activity.connections = <span class="keyword">new</span> HashSet&lt;ConnectionRecord&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    activity.connections.add(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 ConnectionRecord 保存到调用者进程的 connections 列表中！</span></span><br><span class="line">b.client.connections.add(c);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((c.flags&amp;Context.BIND_ABOVE_CLIENT) != <span class="number">0</span>) &#123;</span><br><span class="line">    b.client.hasAboveClient = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((c.flags&amp;Context.BIND_ALLOW_WHITELIST_MANAGEMENT) != <span class="number">0</span>) &#123;</span><br><span class="line">    s.whitelistManager = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (s.app != <span class="keyword">null</span>) &#123;</span><br><span class="line">    updateServiceClientActivitiesLocked(s.app, c, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mServiceConnections 是 AS 的成员变量，记录着 IServiceConnection 和其 ConnectionRecord 的对应关系！</span></span><br><span class="line">clist = mServiceConnections.get(binder);</span><br><span class="line"><span class="keyword">if</span> (clist == <span class="keyword">null</span>) &#123;</span><br><span class="line">    clist = <span class="keyword">new</span> ArrayList&lt;ConnectionRecord&gt;();</span><br><span class="line">    mServiceConnections.put(binder, clist);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">clist.add(c);</span><br></pre></td></tr></table></figure></p>
<p>这里调用了 ServiceRecord 的 retrieveAppBindingLocked 方法，参数 ProcessRecord app 表示绑定者所在的进程！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in ServiceRecord</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AppBindRecord <span class="title">retrieveAppBindingLocked</span><span class="params">(Intent intent,</span></span></span><br><span class="line"><span class="function"><span class="params">        ProcessRecord app)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先，创建 FilterComparison 来封装启动 Intent！</span></span><br><span class="line">    <span class="comment">// 并获得其对应的 IntentBindRecord 对象，这里可以看到，多次 bindService，只会保存第一次的信息！</span></span><br><span class="line">    Intent.FilterComparison filter = <span class="keyword">new</span> Intent.FilterComparison(intent);</span><br><span class="line">    IntentBindRecord i = bindings.get(filter);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建对应的 IntentBindRecord 对象，将 FilterComparison 和 IntentBindRecord 的映射保存到 SR.bindings 中！</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="keyword">null</span>) &#123;</span><br><span class="line">        i = <span class="keyword">new</span> IntentBindRecord(<span class="keyword">this</span>, filter);</span><br><span class="line">        bindings.put(filter, i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建 AppBindRecord 对象！</span></span><br><span class="line">    AppBindRecord a = i.apps.get(app);</span><br><span class="line">    <span class="keyword">if</span> (a != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    a = <span class="keyword">new</span> AppBindRecord(<span class="keyword">this</span>, i, app);</span><br><span class="line">    i.apps.put(app, a);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里会创建了一下如下对象 AppBindRecord，<strong>用来表示被绑定的 Service 和 bind 它的应用进程 ProcessRecord  的关系</strong>！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AppBindRecord</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ServiceRecord service;  <span class="comment">// 被 bind 的服务！</span></span><br><span class="line">    <span class="keyword">final</span> IntentBindRecord intent;    <span class="comment">// IntentBindRecord 对象</span></span><br><span class="line">    <span class="keyword">final</span> ProcessRecord client;  <span class="comment">// bind 发起端的进程！</span></span><br><span class="line">    <span class="keyword">final</span> ArraySet&lt;ConnectionRecord&gt; connections = <span class="keyword">new</span> ArraySet&lt;&gt;(); <span class="comment">// 连接到这个服务的所有 ConnectionRecord！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以及 IntentBindRecord 对象，<strong>用来表示绑定 Service 的 intent 的信息</strong>！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">IntentBindRecord</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ServiceRecord service;  <span class="comment">// 被 bind 的服务！</span></span><br><span class="line">    <span class="keyword">final</span> Intent.FilterComparison intent; <span class="comment">// intent 封装类，等价于 intent！</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用来托管所有使用这个 intent 来绑定服务的进程 ProcessRecord 和其 AppBindRecord 的映射关系！</span></span><br><span class="line">    <span class="keyword">final</span> ArrayMap&lt;ProcessRecord, AppBindRecord&gt; apps = <span class="keyword">new</span> ArrayMap&lt;ProcessRecord, AppBindRecord&gt;(); </span><br><span class="line">    IBinder binder; <span class="comment">// 当绑定 Service 成功后，onBind 会返回 Service 的“桩”，而这个 binder 是“桩”的客户端代理！</span></span><br><span class="line">    <span class="keyword">boolean</span> requested;</span><br><span class="line">    <span class="keyword">boolean</span> received;</span><br><span class="line">    <span class="keyword">boolean</span> hasBound;</span><br><span class="line">    <span class="keyword">boolean</span> doRebind;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以及 ConnectionRecord 对象，<strong>用来表示绑定 Service 的 intent 的信息</strong>！！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionRecord</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AppBindRecord binding;    <span class="comment">// AppBindRecord 对象！</span></span><br><span class="line">    <span class="keyword">final</span> ActivityRecord activity;  <span class="comment">// bind 服务的 activity</span></span><br><span class="line">    <span class="keyword">final</span> IServiceConnection conn;  <span class="comment">// 来自 bind 端的 IServiceConnection.proxy 对象！</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> flags;                <span class="comment">// bindService 的第三个参数！</span></span><br><span class="line">    <span class="keyword">final</span> PendingIntent clientIntent; <span class="comment">// 发送的 intent！</span></span><br><span class="line">    <span class="keyword">boolean</span> serviceDead;            <span class="comment">// 表示服务是否死亡！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>除此之外，在 ServiceRecord 中:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有活跃的 intent 和其对应的 IntentBindRecord 对象！</span></span><br><span class="line"><span class="keyword">final</span> ArrayMap&lt;Intent.FilterComparison, IntentBindRecord&gt; bindings</span><br><span class="line">        = <span class="keyword">new</span> ArrayMap&lt;Intent.FilterComparison, IntentBindRecord&gt;();</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 所有 IServiceConnection 对象和其对应的 ArrayList&lt;ConnectionRecord&gt;&gt; 列表！                   </span></span><br><span class="line"><span class="keyword">final</span> ArrayMap&lt;IBinder, ArrayList&lt;ConnectionRecord&gt;&gt; connections</span><br><span class="line">        = <span class="keyword">new</span> ArrayMap&lt;IBinder, ArrayList&lt;ConnectionRecord&gt;&gt;();</span><br><span class="line">                        <span class="comment">// IBinder -&gt; ConnectionRecord of all bound clients</span></span><br></pre></td></tr></table></figure></p>
<p>以及在 ActiveServices 中:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ArrayMap&lt;IBinder, ArrayList&lt;ConnectionRecord&gt;&gt; mServiceConnections = <span class="keyword">new</span> ArrayMap&lt;&gt;();</span><br></pre></td></tr></table></figure></p>
<p>这里我们用一张图来看下这几个数据结构间的关系；</p>
<p><img src="http://static.zybuluo.com/Coolqi/slum6gwlc12agci9vhvk0ula/%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%B3%E7%B3%BB.png" alt="系统进程中的数据结构关系.png-467.2kB"></p>
<p>可以看到，引用关系很复杂，这也是方便 AMS 在调度时，更快的查询到数据！！</p>
<h2 id="2-3-AServices-bringUpServiceLocked"><a href="#2-3-AServices-bringUpServiceLocked" class="headerlink" title="2.3 AServices.bringUpServiceLocked"></a>2.3 AServices.bringUpServiceLocked</h2><p>上面的代码中， <strong>如果 flags 有设置 hasAutoCreateConnections 的话</strong>，会进入 bringUpServiceLocked 这个方法，这里和前面的 startService 很类似了，启动服务！</p>
<p>参数分析：</p>
<ul>
<li><strong>ServiceRecord r</strong>：服务的 ServiceRecord 对象；</li>
<li><strong>int intentFlags</strong>：启动服务的 intent 的 flag，通过 getFlags 获得；</li>
<li><strong>boolean execInFg</strong>：传入 callFg，表示本次启动是前台调用还是后台调用；</li>
<li><strong>boolean whileRestarting</strong>：表示是否是正在重启，传入 false；</li>
<li><strong>boolean permissionsReviewRequired</strong>：是否需要校验权限；</li>
</ul>
<p>我们这里<strong>假设 Service 所在的进程没有启动</strong>！</p>
<p>bringUpServiceLocked 的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">bringUpServiceLocked</span><span class="params">(ServiceRecord r, <span class="keyword">int</span> intentFlags, <span class="keyword">boolean</span> execInFg,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> whileRestarting, <span class="keyword">boolean</span> permissionsReviewRequired)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果服务所在的进程已经被启动，那就进入 sendServiceArgsLocked 方法，</span></span><br><span class="line">    <span class="comment">// 但对于 bind，这个方法是不会拉起 onStartCommand 方法的，原因下面说！</span></span><br><span class="line">    <span class="comment">// 对于 bindService，如果服务所在进程已经被拉起，条件为 true，这里不会继续往下执行！</span></span><br><span class="line">    <span class="keyword">if</span> (r.app != <span class="keyword">null</span> &amp;&amp; r.app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">        sendServiceArgsLocked(r, execInFg, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!whileRestarting &amp;&amp; r.restartDelay &gt; <span class="number">0</span>) &#123; <span class="comment">// 如果正在等待重启，就退出！</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">"Bringing up "</span> + r + <span class="string">" "</span> + r.intent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务要被启动了，所以要从重启 mRestartingServices 列表中移除它，并清除内部的启动计数！</span></span><br><span class="line">    <span class="keyword">if</span> (mRestartingServices.remove(r)) &#123;</span><br><span class="line"></span><br><span class="line">        r.resetRestartCounter();</span><br><span class="line">        clearRestartingIfNeededLocked(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果这个服务是被延迟启动，即 delayed 为 true，那就立刻启动它，从 mDelayedStartList 中移除它，并置 delayed 为 false；</span></span><br><span class="line">    <span class="keyword">if</span> (r.delayed) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE, <span class="string">"REM FR DELAY LIST (bring up): "</span> + r);</span><br><span class="line">        getServiceMap(r.userId).mDelayedStartList.remove(r);</span><br><span class="line">        r.delayed = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果这个服务所在的设备用户没有被启动，那就不允许启动这个服务！</span></span><br><span class="line">    <span class="keyword">if</span> (!mAm.mUserController.hasStartedUserState(r.userId)) &#123;</span><br><span class="line">        String msg = <span class="string">"Unable to launch app "</span></span><br><span class="line">                + r.appInfo.packageName + <span class="string">"/"</span></span><br><span class="line">                + r.appInfo.uid + <span class="string">" for service "</span></span><br><span class="line">                + r.intent.getIntent() + <span class="string">": user "</span> + r.userId + <span class="string">" is stopped"</span>;</span><br><span class="line">        Slog.w(TAG, msg);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 执行 bringDown 这个服务！</span></span><br><span class="line">        bringDownServiceLocked(r);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 服务将要被启动，所以要设置其 package 的停止状态为 false；</span></span><br><span class="line">        AppGlobals.getPackageManager().setPackageStoppedState(</span><br><span class="line">                r.packageName, <span class="keyword">false</span>, r.userId);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"Failed trying to unstop package "</span></span><br><span class="line">                + r.packageName + <span class="string">": "</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断这个服务是否属于隔离进程；</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isolated = (r.serviceInfo.flags&amp;ServiceInfo.FLAG_ISOLATED_PROCESS) != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得要启动的服务的所在进程名；</span></span><br><span class="line">    <span class="keyword">final</span> String procName = r.processName;</span><br><span class="line">    ProcessRecord app;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isolated) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对于非隔离进程，先获得所在进程的 ProcessRecord 对象；</span></span><br><span class="line">        app = mAm.getProcessRecordLocked(procName, r.appInfo.uid, <span class="keyword">false</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (DEBUG_MU) Slog.v(TAG_MU, <span class="string">"bringUpServiceLocked: appInfo.uid="</span> + r.appInfo.uid</span><br><span class="line">                    + <span class="string">" app="</span> + app);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (app != <span class="keyword">null</span> &amp;&amp; app.thread != <span class="keyword">null</span>) &#123; <span class="comment">// 如果进程已经启动；</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                app.addPackage(r.appInfo.packageName, r.appInfo.versionCode, mAm.mProcessStats);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//【1】启动指定服务！</span></span><br><span class="line">                realStartServiceLocked(r, app, execInFg);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (TransactionTooLargeException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Exception when starting service "</span> + r.shortName, e);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        app = r.isolatedProc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果服务所在的进程没有启动！</span></span><br><span class="line">    <span class="keyword">if</span> (app == <span class="keyword">null</span> &amp;&amp; !permissionsReviewRequired) &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//【2】首先要启动服务所在的进程，这里请去看进程启动和创建的博文！</span></span><br><span class="line">        <span class="keyword">if</span> ((app=mAm.startProcessLocked(procName, r.appInfo, <span class="keyword">true</span>, intentFlags,</span><br><span class="line">                <span class="string">"service"</span>, r.name, <span class="keyword">false</span>, isolated, <span class="keyword">false</span>)) == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            String msg = <span class="string">"Unable to launch app "</span></span><br><span class="line">                    + r.appInfo.packageName + <span class="string">"/"</span></span><br><span class="line">                    + r.appInfo.uid + <span class="string">" for service "</span></span><br><span class="line">                    + r.intent.getIntent() + <span class="string">": process is bad"</span>;</span><br><span class="line">            Slog.w(TAG, msg);</span><br><span class="line"></span><br><span class="line">            bringDownServiceLocked(r); <span class="comment">// 进程启动失败；</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> msg;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果服务要运行在隔离进程中，就把创建的 ProcessRecord 保存到 r.isolatedProc 中！</span></span><br><span class="line">        <span class="keyword">if</span> (isolated) &#123;</span><br><span class="line">            r.isolatedProc = app;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将这个服务加入到 mPendingServices 中，表示该服务正在其所在的进程启动；</span></span><br><span class="line">    <span class="keyword">if</span> (!mPendingServices.contains(r)) &#123;</span><br><span class="line">        mPendingServices.add(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.delayedStop) &#123; <span class="comment">// 如果服务需要被延迟停止，</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Oh and hey we've already been asked to stop!</span></span><br><span class="line">        r.delayedStop = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (r.startRequested) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE,</span><br><span class="line">                    <span class="string">"Applying delayed stop (in bring up): "</span> + r);</span><br><span class="line">            stopServiceLocked(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong></p>
<p>bindService 时候，如果设置了 Context.BIND_AUTO_CREATE 标志，就会调用 bringUpServiceLocked 方法！</p>
<p>然而对应 bind 来说，是不会执行 sendServiceArgsLocked 方法中的逻辑，不会拉起服务的 onStartCommand 方法的！</p>
<p>因为只有 start 的方式，才会将启动项目 StartItem 添加到  ServiceRecord 的 pendingStarts 集合中，而对于 bind，pendingStarts 集合的大小始终为 0，所以不会继续执行的！！</p>
<p>同时，对于 bindService，如果服务所在的进程已经被拉起，那么 bringUpServiceLocked 方法会在 sendServiceArgsLocked 只会返回，不会执行下面的逻辑，而是返回 bindServiceLocked ，继续往下执行！！</p>
<p><strong>方法流程总结</strong></p>
<p>1、如果已经启动，就会进入 realStartServiceLocked 方法，启动服务！<br>2、如果没有启动，就会 startProcessLocked 先启动服务所在进程，，最后进入 attachApplicationLocked 方法。然后还是会进入 realStartServiceLocked ！</p>
<p>所以最终调用的是 realStartServiceLocked 方法，它会拉起 Service 的 onCreate、onBind 方法！</p>
<p>这里我们先假设，服务所在的进程，还没有被启动！！！！</p>
<h2 id="2-4-ActivityManagerS-attachApplicationLocked"><a href="#2-4-ActivityManagerS-attachApplicationLocked" class="headerlink" title="2.4 ActivityManagerS.attachApplicationLocked"></a>2.4 ActivityManagerS.attachApplicationLocked</h2><p>当应用进程启动后，会通过 Binder 通信，调用 AMS.attachApplicationLocked，我们去看看：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">attachApplicationLocked</span><span class="params">(IApplicationThread thread,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> pid)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ... ... ... ...</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这里会回到应用进程中，创建 Applicaiton 对象，并调用其 onCreate 方法，这里我们不看！</span></span><br><span class="line">        thread.bindApplication(processName, appInfo, providers, app.instrumentationClass,</span><br><span class="line">                profilerInfo, app.instrumentationArguments, app.instrumentationWatcher,</span><br><span class="line">                app.instrumentationUiAutomationConnection, testMode,</span><br><span class="line">                mBinderTransactionTrackingEnabled, enableTrackAllocation,</span><br><span class="line">                isRestrictedBackupMode || !normalMode, app.persistent,</span><br><span class="line">                <span class="keyword">new</span> Configuration(mConfiguration), app.compat,</span><br><span class="line">                getCommonServicesLocked(app.isolated),</span><br><span class="line">                mCoreSettingsObserver.getCoreSettingsLocked());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新进程 LRU 队列！</span></span><br><span class="line">        updateLruProcessLocked(app, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        app.lastRequestedGc = app.lastLowMemory = SystemClock.uptimeMillis();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        app.resetPackageList(mProcessStats);</span><br><span class="line">        app.unlinkDeathRecipient();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每当 bindApplication 操作失败，则重新启动进程, 此处有可能会导致进程无限重启。</span></span><br><span class="line">        startProcessLocked(app, <span class="string">"bind fail"</span>, processName);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前已经被启动的新进程的 ProcessRecord 从正在启动的进程集合 mPersistentStartingProcesses</span></span><br><span class="line">    <span class="comment">// 和等待启动的进程集合 mProcessesOnHold 中移除！</span></span><br><span class="line">    mPersistentStartingProcesses.remove(app);</span><br><span class="line">    mProcessesOnHold.remove(app);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> badApp = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> didSomething = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    ... ... ... ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!badApp) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 检查是否有 service 组件要在这个新进程中运行！</span></span><br><span class="line">            didSomething |= mServices.attachApplicationLocked(app, processName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Slog.wtf(TAG, <span class="string">"Exception thrown starting services in "</span> + app, e);</span><br><span class="line">            badApp = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ... ... ... ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (badApp) &#123; <span class="comment">// badApp 为 true，就杀掉这个进程</span></span><br><span class="line">        app.kill(<span class="string">"error during init"</span>, <span class="keyword">true</span>);</span><br><span class="line">        handleAppDiedLocked(app, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!didSomething) &#123; <span class="comment">// 检查后发现，没有任何组件要运行在新进程，更新 OomAdj 的值！</span></span><br><span class="line">        updateOomAdjLocked();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>bindApplication 方法会回到应用进程中，创建 Applicaiton 对象，并调用其 onCreate 方法，这里我们不关注！！</p>
<p>这里会调用 ActiveServices 的 attachApplicationLocked 方法！</p>
<h2 id="2-5-ActiveServices-attachApplicationLocked"><a href="#2-5-ActiveServices-attachApplicationLocked" class="headerlink" title="2.5 ActiveServices.attachApplicationLocked"></a>2.5 ActiveServices.attachApplicationLocked</h2><p>当应用进程启动成功，并且 Application 对象已经创建，其 onCreate 方法已经调用后，就要启动指定的服务了！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">attachApplicationLocked</span><span class="params">(ProcessRecord proc, String processName)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> didSomething = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 还记得 mPendingServices 吗？这里面保存着所有正在等待其所在的进程启动的服务！</span></span><br><span class="line">    <span class="keyword">if</span> (mPendingServices.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ServiceRecord sr = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历 mPendingServices 集合中的所有服务，启动属于这个进程的所有服务！</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;mPendingServices.size(); i++) &#123;</span><br><span class="line">                sr = mPendingServices.get(i);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (proc != sr.isolatedProc &amp;&amp; (proc.uid != sr.appInfo.uid</span><br><span class="line">                        || !processName.equals(sr.processName))) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                mPendingServices.remove(i);</span><br><span class="line"></span><br><span class="line">                i--;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 将服务的包名，版本号以及 AMS 的进程状态对象保存到进程对象中！</span></span><br><span class="line">                proc.addPackage(sr.appInfo.packageName, sr.appInfo.versionCode,</span><br><span class="line">                        mAm.mProcessStats);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//【1】启动服务，这里又回到了之前的方法中！</span></span><br><span class="line">                realStartServiceLocked(sr, proc, sr.createdFromFg);</span><br><span class="line"></span><br><span class="line">                didSomething = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!isServiceNeeded(sr, <span class="keyword">false</span>, <span class="keyword">false</span>)) &#123;</span><br><span class="line"></span><br><span class="line">                    bringDownServiceLocked(sr);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Exception in new application when starting service "</span></span><br><span class="line">                    + sr.shortName, e);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接着启动那些需要重启的服务，重启的服务都会保存到 mRestartingServices 服务中！</span></span><br><span class="line">    <span class="comment">// 因为重启的时间可能还没有到，所以这里并不是立刻启动它们，而是启动了一个任务，交给了 AMS 的 MainHandler 去做！</span></span><br><span class="line">    <span class="keyword">if</span> (mRestartingServices.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ServiceRecord sr;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;mRestartingServices.size(); i++) &#123;</span><br><span class="line">            sr = mRestartingServices.get(i);</span><br><span class="line">            <span class="keyword">if</span> (proc != sr.isolatedProc &amp;&amp; (proc.uid != sr.appInfo.uid</span><br><span class="line">                    || !processName.equals(sr.processName))) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mAm.mHandler.removeCallbacks(sr.restarter);</span><br><span class="line">            mAm.mHandler.post(sr.restarter);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> didSomething;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里最终又回到了 realStartServiceLocked 方法！</p>
<h2 id="2-6-AS-realStartServiceLocked"><a href="#2-6-AS-realStartServiceLocked" class="headerlink" title="2.6 AS.realStartServiceLocked"></a>2.6 AS.realStartServiceLocked</h2><p>对于非隔离的进程，最后都会通过调用 realStartServiceLocked 方法来启动进程中的指定服务：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">realStartServiceLocked</span><span class="params">(ServiceRecord r,</span></span></span><br><span class="line"><span class="function"><span class="params">        ProcessRecord app, <span class="keyword">boolean</span> execInFg)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (app.thread == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RemoteException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG_MU)</span><br><span class="line">        Slog.v(TAG_MU, <span class="string">"realStartServiceLocked, ServiceRecord.uid = "</span> + r.appInfo.uid</span><br><span class="line">                + <span class="string">", ProcessRecord.uid = "</span> + app.uid);</span><br><span class="line">                </span><br><span class="line">    <span class="comment">// 跟新活跃时间！</span></span><br><span class="line">    r.app = app;</span><br><span class="line">    r.restartTime = r.lastActivity = SystemClock.uptimeMillis();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将被启动服务的 ServiceRecord 对象添加到所属进程的 app.services 中！</span></span><br><span class="line">    <span class="comment">// 如果本次启动的是一个新的服务，newService 值为 true！</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> newService = app.services.add(r);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 针对 onCreate 方法，设置超时处理！</span></span><br><span class="line">    bumpServiceExecutingLocked(r, execInFg, <span class="string">"create"</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 更新 LruProcess 和 OomAdj！</span></span><br><span class="line">    mAm.updateLruProcessLocked(app, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">    mAm.updateOomAdjLocked();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> created = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (LOG_SERVICE_START_STOP) &#123; <span class="comment">// log 相关！</span></span><br><span class="line">            String nameTerm;</span><br><span class="line">            <span class="keyword">int</span> lastPeriod = r.shortName.lastIndexOf(<span class="string">'.'</span>);</span><br><span class="line">            nameTerm = lastPeriod &gt;= <span class="number">0</span> ? r.shortName.substring(lastPeriod) : r.shortName;</span><br><span class="line">            EventLogTags.writeAmCreateService(</span><br><span class="line">                    r.userId, System.identityHashCode(r), nameTerm, r.app.uid, r.app.pid);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (r.stats.getBatteryStats()) &#123;</span><br><span class="line">            r.stats.startLaunchedLocked();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mAm.notifyPackageUse(r.serviceInfo.packageName,</span><br><span class="line">                             PackageManager.NOTIFY_PACKAGE_USE_SERVICE);</span><br><span class="line"></span><br><span class="line">        app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【1】通过 binder 通信，拉起服务的 onCreate 方法！</span></span><br><span class="line">        app.thread.scheduleCreateService(r, r.serviceInfo,</span><br><span class="line">                mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),</span><br><span class="line">                app.repProcState);</span><br><span class="line"></span><br><span class="line">        r.postNotification();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 启动成功的话，置 created 为 true 方法；</span></span><br><span class="line">        created = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (DeadObjectException e) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"Application dead when creating service "</span> + r);</span><br><span class="line">        mAm.appDiedLocked(app); <span class="comment">// 如果在服务启动时，应用进程死了，调用 appDiedLocked 通知死亡仆告对象！</span></span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!created) &#123; <span class="comment">// 如果启动失败，并且不是一个被销毁的服务，那就尝试重启他！</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> inDestroying = mDestroyingServices.contains(r);</span><br><span class="line">            serviceDoneExecutingLocked(r, inDestroying, inDestroying);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (newService) &#123;</span><br><span class="line">                app.services.remove(r);</span><br><span class="line">                r.app = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!inDestroying) &#123;</span><br><span class="line">                scheduleServiceRestartLocked(r, <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.whitelistManager) &#123;</span><br><span class="line">        app.whitelistManager = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】执行 bind 操作，这里会拉起服务的 onBind 方法！！</span></span><br><span class="line">    requestServiceBindingsLocked(r, execInFg);</span><br><span class="line"></span><br><span class="line">    updateServiceClientActivitiesLocked(app, <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意 startRequested 只有在 startService 的情况下被置为 true，所以这里是不会添加启动项的！</span></span><br><span class="line">    <span class="comment">// 即：r.pendingStarts 的大小为 0！！</span></span><br><span class="line">    <span class="keyword">if</span> (r.startRequested &amp;&amp; r.callStart &amp;&amp; r.pendingStarts.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        r.pendingStarts.add(<span class="keyword">new</span> ServiceRecord.StartItem(r, <span class="keyword">false</span>, r.makeNextStartId(),</span><br><span class="line">                <span class="keyword">null</span>, <span class="keyword">null</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里也不会拉起 Service 的 onSrartCommand 方法，原因是 ：r.pendingStarts 的大小为 0，找不到启动项！！</span></span><br><span class="line">    sendServiceArgsLocked(r, execInFg, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.delayed) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE, <span class="string">"REM FR DELAY LIST (new proc): "</span> + r);</span><br><span class="line">        getServiceMap(r.userId).mDelayedStartList.remove(r);</span><br><span class="line">        r.delayed = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.delayedStop) &#123;</span><br><span class="line">        r.delayedStop = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (r.startRequested) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE,</span><br><span class="line">                    <span class="string">"Applying delayed stop (from start): "</span> + r);</span><br><span class="line">            stopServiceLocked(r);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意</strong>：<br>startRequested 只有在 startService 的情况下被置为 true，所以这里是不会添加启动项的！所以 sendServiceArgsLocked 也不会拉起  Service 的 onSrartCommand 方法，原因是 ：r.pendingStarts 的大小为 0，找不到启动项！！</p>
<p>这就要进入 requestServiceBindingsLocked 方法了！！！</p>
<h3 id="2-6-1-ApplicationThreadP-scheduleCreateService"><a href="#2-6-1-ApplicationThreadP-scheduleCreateService" class="headerlink" title="2.6.1 ApplicationThreadP.scheduleCreateService"></a>2.6.1 ApplicationThreadP.scheduleCreateService</h3><p>这里首先会拉起 Serivce 的 onCreate 方法！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApplicationThreadProxy</span> <span class="keyword">implements</span> <span class="title">IApplicationThread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleCreateService</span><span class="params">(IBinder token, ServiceInfo info,</span></span></span><br><span class="line"><span class="function"><span class="params">            CompatibilityInfo compatInfo, <span class="keyword">int</span> processState)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Parcel data = Parcel.obtain();</span><br><span class="line">        data.writeInterfaceToken(IApplicationThread.descriptor);</span><br><span class="line">        data.writeStrongBinder(token);</span><br><span class="line">        info.writeToParcel(data, <span class="number">0</span>);</span><br><span class="line">        compatInfo.writeToParcel(data, <span class="number">0</span>);</span><br><span class="line">        data.writeInt(processState);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 通过 Binder 通信！</span></span><br><span class="line">            mRemote.transact(SCHEDULE_CREATE_SERVICE_TRANSACTION, data, <span class="keyword">null</span>,</span><br><span class="line">                    IBinder.FLAG_ONEWAY);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (TransactionTooLargeException e) &#123;</span><br><span class="line">            Log.e(<span class="string">"CREATE_SERVICE"</span>, <span class="string">"Binder failure starting service; service="</span> + info);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        data.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>进入应用进程，下面再看！！</p>
<h3 id="2-6-2-ActiveServices-requestServiceBindingsLocked"><a href="#2-6-2-ActiveServices-requestServiceBindingsLocked" class="headerlink" title="2.6.2 ActiveServices.requestServiceBindingsLocked"></a>2.6.2 ActiveServices.requestServiceBindingsLocked</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">requestServiceBindingsLocked</span><span class="params">(ServiceRecord r, <span class="keyword">boolean</span> execInFg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 遍历 r.bindings！</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=r.bindings.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">        IntentBindRecord ibr = r.bindings.valueAt(i);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 【1】请求 bind 操作，默认 rebind 为 false！</span></span><br><span class="line">        <span class="keyword">if</span> (!requestServiceBindingLocked(r, ibr, execInFg, <span class="keyword">false</span>)) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里会遍历 r.bindings 集合，还记得这个集合吗？这个集合保存这个 bind 的 intent 和 IntentBindRecord 之间的映射关系，只有 bindService 的情况下，该集合才会有元素，startService 的情况下，该集合的 size 为 0，这就解释了 startService 为什么不会执行该方法了！！</p>
<p>继续来看！！</p>
<h4 id="2-6-2-1-ActiveServices-requestServiceBindingLocked"><a href="#2-6-2-1-ActiveServices-requestServiceBindingLocked" class="headerlink" title="2.6.2.1 ActiveServices.requestServiceBindingLocked"></a>2.6.2.1 ActiveServices.requestServiceBindingLocked</h4><p>参数传入：</p>
<ul>
<li>boolean rebind：表示是否重新 bind，这里传入的是 false！</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">requestServiceBindingLocked</span><span class="params">(ServiceRecord r, IntentBindRecord i,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> execInFg, <span class="keyword">boolean</span> rebind)</span> <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.app == <span class="keyword">null</span> || r.app.thread == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果服务没有运行，那就会退出！</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里 i.requested 和 rebind 均为 false， i.apps.size() 也是大于 0 的！</span></span><br><span class="line">    <span class="keyword">if</span> ((!i.requested || rebind) &amp;&amp; i.apps.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 为 bind 操作设置超时消息处理！！</span></span><br><span class="line">            bumpServiceExecutingLocked(r, execInFg, <span class="string">"bind"</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将服务所在的进程状态更新为 ActivityManager.PROCESS_STATE_SERVICE！</span></span><br><span class="line">            r.app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 【1】执行 bind 操作，跨进程拉起应用的 onBind 方法！</span></span><br><span class="line">            r.app.thread.scheduleBindService(r, i.intent.getIntent(), rebind,</span><br><span class="line">                    r.app.repProcState);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 对于 bindService，因为 rebind 为 false，所以这里会把 requested 置为 true！</span></span><br><span class="line">            <span class="keyword">if</span> (!rebind) &#123;</span><br><span class="line">                i.requested = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将 i.hasBound 置为 true，表示已经调用了</span></span><br><span class="line">            i.hasBound = <span class="keyword">true</span>;</span><br><span class="line">            i.doRebind = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (TransactionTooLargeException e) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Keep the executeNesting count accurate.</span></span><br><span class="line">            <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">"Crashed while binding "</span> + r, e);</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> inDestroying = mDestroyingServices.contains(r);</span><br><span class="line">            serviceDoneExecutingLocked(r, inDestroying, inDestroying);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">"Crashed while binding "</span> + r);</span><br><span class="line">            <span class="comment">// Keep the executeNesting count accurate.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> inDestroying = mDestroyingServices.contains(r);</span><br><span class="line">            serviceDoneExecutingLocked(r, inDestroying, inDestroying);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>thread 是 ApplicationThreadProxy 代理对象！！</p>
<h4 id="2-6-2-2-ApplicationThreadP-scheduleBindService"><a href="#2-6-2-2-ApplicationThreadP-scheduleBindService" class="headerlink" title="2.6.2.2 ApplicationThreadP.scheduleBindService"></a>2.6.2.2 ApplicationThreadP.scheduleBindService</h4><p>这里的 IBinder token 是 ServiceRecord 对象!!<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleBindService</span><span class="params">(IBinder token, Intent intent, <span class="keyword">boolean</span> rebind,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> processState)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    Parcel data = Parcel.obtain();</span><br><span class="line">    data.writeInterfaceToken(IApplicationThread.descriptor);</span><br><span class="line">    data.writeStrongBinder(token);</span><br><span class="line">    intent.writeToParcel(data, <span class="number">0</span>);</span><br><span class="line">    data.writeInt(rebind ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    data.writeInt(processState);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// binder 通信！</span></span><br><span class="line">    mRemote.transact(SCHEDULE_BIND_SERVICE_TRANSACTION, data, <span class="keyword">null</span>,</span><br><span class="line">            IBinder.FLAG_ONEWAY);</span><br><span class="line">    data.recycle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，拉起服务的 onCreate 方法和 onBind 方法的 binder 通信都是 IBinder.FLAG_ONEWAY 的！也就是说 Binder 服务端无需等待 BInder 客户端的操作返回结果，只要 Binder 客户端一收到 Binder服务端传送的命令和数据后，Binder 服务端会立即向下执行！</p>
<p>下面，进入被绑定者进程！</p>
<h1 id="3-被绑定者进程"><a href="#3-被绑定者进程" class="headerlink" title="3 被绑定者进程"></a>3 被绑定者进程</h1><h2 id="3-1-ApplicationThread-scheduleCreateService"><a href="#3-1-ApplicationThread-scheduleCreateService" class="headerlink" title="3.1 ApplicationThread.scheduleCreateService"></a>3.1 ApplicationThread.scheduleCreateService</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleCreateService</span><span class="params">(IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">        ServiceInfo info, CompatibilityInfo compatInfo, <span class="keyword">int</span> processState)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    updateProcessState(processState, <span class="keyword">false</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建了一个 CreateServiceData 对象！</span></span><br><span class="line">    CreateServiceData s = <span class="keyword">new</span> CreateServiceData();</span><br><span class="line"></span><br><span class="line">    s.token = token;</span><br><span class="line">    s.info = info;</span><br><span class="line">    s.compatInfo = compatInfo;</span><br><span class="line"></span><br><span class="line">    sendMessage(H.CREATE_SERVICE, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里和 startService 一样，不多说了！</p>
<h2 id="3-2-ApplicationThread-scheduleBindService"><a href="#3-2-ApplicationThread-scheduleBindService" class="headerlink" title="3.2 ApplicationThread.scheduleBindService"></a>3.2 ApplicationThread.scheduleBindService</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleBindService</span><span class="params">(IBinder token, Intent intent,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> rebind, <span class="keyword">int</span> processState)</span> </span>&#123;</span><br><span class="line">    updateProcessState(processState, <span class="keyword">false</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建了一个 BindServiceData 对象！</span></span><br><span class="line">    BindServiceData s = <span class="keyword">new</span> BindServiceData();</span><br><span class="line">    s.token = token;</span><br><span class="line">    s.intent = intent;</span><br><span class="line">    s.rebind = rebind;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG_SERVICE)</span><br><span class="line">        Slog.v(TAG, <span class="string">"scheduleBindService token="</span> + token + <span class="string">" intent="</span> + intent + <span class="string">" uid="</span></span><br><span class="line">                + Binder.getCallingUid() + <span class="string">" pid="</span> + Binder.getCallingPid());</span><br><span class="line"></span><br><span class="line">    sendMessage(H.BIND_SERVICE, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里创建了一个 BindServiceData 对象！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BindServiceData</span> </span>&#123;</span><br><span class="line">    IBinder token;</span><br><span class="line">    Intent intent;</span><br><span class="line">    <span class="keyword">boolean</span> rebind;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"BindServiceData&#123;token="</span> + token + <span class="string">" intent="</span> + intent + <span class="string">"&#125;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>很简单，不多说了！</p>
<p>接着，发送 H.BIND_SERVICE 方法，进入主线程的 Handler！</p>
<h2 id="3-3-ActivityThread-H"><a href="#3-3-ActivityThread-H" class="headerlink" title="3.3 ActivityThread.H"></a>3.3 ActivityThread.H</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">H</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_MESSAGES) Slog.v(TAG, <span class="string">"&gt;&gt;&gt; handling: "</span> + codeToString(msg.what));</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 这里是处理 create service 消息；</span></span><br><span class="line">            <span class="keyword">case</span> CREATE_SERVICE:</span><br><span class="line">                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, (<span class="string">"serviceCreate: "</span> + String.valueOf(msg.obj)));</span><br><span class="line">                </span><br><span class="line">                handleCreateService((CreateServiceData)msg.obj);</span><br><span class="line">                </span><br><span class="line">                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                </span><br><span class="line">            <span class="comment">// 这里是处理 bind service 消息；</span></span><br><span class="line">            <span class="keyword">case</span> BIND_SERVICE:</span><br><span class="line">                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"serviceBind"</span>);</span><br><span class="line">                </span><br><span class="line">                handleBindService((BindServiceData)msg.obj);</span><br><span class="line">                </span><br><span class="line">                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">  </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object obj = msg.obj;</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> SomeArgs) &#123;</span><br><span class="line">            ((SomeArgs) obj).recycle();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DEBUG_MESSAGES) Slog.v(TAG, <span class="string">"&lt;&lt;&lt; done: "</span> + codeToString(msg.what));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不多说了！！</p>
<h3 id="3-3-1-ActivityThread-handleCreateService"><a href="#3-3-1-ActivityThread-handleCreateService" class="headerlink" title="3.3.1 ActivityThread.handleCreateService"></a>3.3.1 ActivityThread.handleCreateService</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleCreateService</span><span class="params">(CreateServiceData data)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果此时准备要 GC，那就跳过本次 GC！</span></span><br><span class="line">    unscheduleGcIdler();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获得应用程序的加载信息，先会从缓存中获取，找不到才创建；</span></span><br><span class="line">    LoadedApk packageInfo = getPackageInfoNoCheck(</span><br><span class="line">            data.info.applicationInfo, data.compatInfo);</span><br><span class="line"></span><br><span class="line">    Service service = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 通过反射创建要启动的服务的实例；</span></span><br><span class="line">        java.lang.ClassLoader cl = packageInfo.getClassLoader();</span><br><span class="line">        service = (Service) cl.loadClass(data.info.name).newInstance();</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mInstrumentation.onException(service, e)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Unable to instantiate service "</span> + data.info.name</span><br><span class="line">                + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (localLOGV) Slog.v(TAG, <span class="string">"Creating service "</span> + data.info.name);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建 Context 对象；</span></span><br><span class="line">        ContextImpl context = ContextImpl.createAppContext(<span class="keyword">this</span>, packageInfo);</span><br><span class="line">        context.setOuterContext(service);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回该进程的 Application 对象！</span></span><br><span class="line">        Application app = packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将服务实例和 context，Application 进行绑定；</span></span><br><span class="line">        service.attach(context, <span class="keyword">this</span>, data.info.name, data.token, app,</span><br><span class="line">                ActivityManagerNative.getDefault());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用了服务的 onCreate 方法；</span></span><br><span class="line">        service.onCreate();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将创建的服务实例保存到 ActivityThread 的托管集合中！</span></span><br><span class="line">        mServices.put(data.token, service);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 通知 AMS，操作完成；</span></span><br><span class="line">            ActivityManagerNative.getDefault().serviceDoneExecuting(</span><br><span class="line">                    data.token, SERVICE_DONE_EXECUTING_ANON, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!mInstrumentation.onException(service, e)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Unable to create service "</span> + data.info.name</span><br><span class="line">                + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>成功地拉起了 Service 的 onCreate 方法！最后有调用了 ActivityManagerNative.getDefault().serviceDoneExecuting，这个和 startService 的流程一样，这里就不多数了！</p>
<h3 id="3-3-2-ActivityThread-handleBindService"><a href="#3-3-2-ActivityThread-handleBindService" class="headerlink" title="3.3.2 ActivityThread.handleBindService"></a>3.3.2 ActivityThread.handleBindService</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleBindService</span><span class="params">(BindServiceData data)</span> </span>&#123;</span><br><span class="line">    Service s = mServices.get(data.token);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG_SERVICE)</span><br><span class="line">        Slog.v(TAG, <span class="string">"handleBindService s="</span> + s + <span class="string">" rebind="</span> + data.rebind);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            data.intent.setExtrasClassLoader(s.getClassLoader());</span><br><span class="line">            data.intent.prepareToEnterProcess();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!data.rebind) &#123;  <span class="comment">// 如果 rebind 为 false！！</span></span><br><span class="line">                </span><br><span class="line">                    <span class="comment">// 调用服务的 onBind 方法，返回值是 Service 的中定义的 “桩”！</span></span><br><span class="line">                    IBinder binder = s.onBind(data.intent);</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 这里回到了系统进程！</span></span><br><span class="line">                    ActivityManagerNative.getDefault().publishService(</span><br><span class="line">                            data.token, data.intent, binder);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果 rebind 为 true！！</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 拉起服务的 onRebind 方法！</span></span><br><span class="line">                    s.onRebind(data.intent);</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 这里回到了系统进程！</span></span><br><span class="line">                    ActivityManagerNative.getDefault().serviceDoneExecuting(</span><br><span class="line">                            data.token, SERVICE_DONE_EXECUTING_ANON, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                ensureJitEnabled();</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mInstrumentation.onException(s, e)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                        <span class="string">"Unable to bind to service "</span> + s</span><br><span class="line">                        + <span class="string">" with "</span> + data.intent + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，我们先默认是第一次绑定，rebind 为 false，我们在重写 Service 的 onBind 方法后，会返回一个 Stub 类型的对象，这个是 Service 这边定义的 “桩”，我们继续看！！！！</p>
<h2 id="3-4-ActivityManagerProxy"><a href="#3-4-ActivityManagerProxy" class="headerlink" title="3.4 ActivityManagerProxy"></a>3.4 ActivityManagerProxy</h2><p>这里不多说了！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serviceDoneExecuting</span><span class="params">(IBinder token, <span class="keyword">int</span> type, <span class="keyword">int</span> startId,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> res)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    Parcel data = Parcel.obtain();</span><br><span class="line">    Parcel reply = Parcel.obtain();</span><br><span class="line">    data.writeInterfaceToken(IActivityManager.descriptor);</span><br><span class="line">    data.writeStrongBinder(token);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里的 type 是 SERVICE_DONE_EXECUTING_ANON </span></span><br><span class="line">    data.writeInt(type);</span><br><span class="line">    data.writeInt(startId);</span><br><span class="line">    data.writeInt(res);</span><br><span class="line"></span><br><span class="line">    mRemote.transact(SERVICE_DONE_EXECUTING_TRANSACTION, data, reply, IBinder.FLAG_ONEWAY);</span><br><span class="line"></span><br><span class="line">    reply.readException();</span><br><span class="line">    data.recycle();</span><br><span class="line">    reply.recycle();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publishService</span><span class="params">(IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">        Intent intent, IBinder service)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Parcel data = Parcel.obtain();</span><br><span class="line">    Parcel reply = Parcel.obtain();</span><br><span class="line">    data.writeInterfaceToken(IActivityManager.descriptor);</span><br><span class="line">    data.writeStrongBinder(token);</span><br><span class="line">    intent.writeToParcel(data, <span class="number">0</span>);</span><br><span class="line">    data.writeStrongBinder(service);</span><br><span class="line"></span><br><span class="line">    mRemote.transact(PUBLISH_SERVICE_TRANSACTION, data, reply, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    reply.readException();</span><br><span class="line">    data.recycle();</span><br><span class="line">    reply.recycle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-系统进程"><a href="#4-系统进程" class="headerlink" title="4 系统进程"></a>4 系统进程</h1><p>进入 AMS，首先会进入 ActivityManagerN 的 onTransact 方法!</p>
<h2 id="4-1-ActivityManagerN-onTransact"><a href="#4-1-ActivityManagerN-onTransact" class="headerlink" title="4.1 ActivityManagerN.onTransact"></a>4.1 ActivityManagerN.onTransact</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> SERVICE_DONE_EXECUTING_TRANSACTION: &#123;</span><br><span class="line">    data.enforceInterface(IActivityManager.descriptor);</span><br><span class="line">    IBinder token = data.readStrongBinder();</span><br><span class="line">    <span class="keyword">int</span> type = data.readInt();</span><br><span class="line">    <span class="keyword">int</span> startId = data.readInt();</span><br><span class="line">    <span class="keyword">int</span> res = data.readInt();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 进入 AMS!</span></span><br><span class="line">    serviceDoneExecuting(token, type, startId, res);</span><br><span class="line">    reply.writeNoException();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> PUBLISH_SERVICE_TRANSACTION: &#123;</span><br><span class="line">    data.enforceInterface(IActivityManager.descriptor);</span><br><span class="line">    IBinder token = data.readStrongBinder();</span><br><span class="line">    Intent intent = Intent.CREATOR.createFromParcel(data);</span><br><span class="line">    IBinder service = data.readStrongBinder();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 进入 AMS !</span></span><br><span class="line">    publishService(token, intent, service);</span><br><span class="line">    reply.writeNoException();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-1-1-ActivityManagerS-serviceDoneExecuting"><a href="#4-1-1-ActivityManagerS-serviceDoneExecuting" class="headerlink" title="4.1.1 ActivityManagerS.serviceDoneExecuting"></a>4.1.1 ActivityManagerS.serviceDoneExecuting</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serviceDoneExecuting</span><span class="params">(IBinder token, <span class="keyword">int</span> type, <span class="keyword">int</span> startId, <span class="keyword">int</span> res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!(token <span class="keyword">instanceof</span> ServiceRecord)) &#123;</span><br><span class="line">                Slog.e(TAG, <span class="string">"serviceDoneExecuting: Invalid service token="</span> + token);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid service token"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            mServices.serviceDoneExecutingLocked((ServiceRecord)token, type, startId, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">``` </span><br><span class="line">最后进入 AS.serviceDoneExecutingLocked 方法！</span><br><span class="line"></span><br><span class="line">#### 4.1.1.1 ActiveServices.serviceDoneExecutingLocked</span><br><span class="line"></span><br><span class="line">参数传递：</span><br><span class="line"></span><br><span class="line">- <span class="keyword">int</span> type：这里的 type 是 `SERVICE_DONE_EXECUTING_ANON`  </span><br><span class="line">```java</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">serviceDoneExecutingLocked</span><span class="params">(ServiceRecord r, <span class="keyword">int</span> type, <span class="keyword">int</span> startId, <span class="keyword">int</span> res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> inDestroying = mDestroyingServices.contains(r);</span><br><span class="line">        <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (type == ActivityThread.SERVICE_DONE_EXECUTING_START) &#123;</span><br><span class="line">            </span><br><span class="line">                ... ... ... <span class="comment">// 不进入，不看</span></span><br><span class="line">                </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == ActivityThread.SERVICE_DONE_EXECUTING_STOP) &#123;</span><br><span class="line">            </span><br><span class="line">                ... ... ... <span class="comment">// 不进入，不看</span></span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 进入 serviceDoneExecutingLocked 方法，看</span></span><br><span class="line">            serviceDoneExecutingLocked(r, inDestroying, inDestroying);</span><br><span class="line"></span><br><span class="line">            Binder.restoreCallingIdentity(origId);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Done executing unknown service from pid "</span></span><br><span class="line">                    + Binder.getCallingPid());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-1-2-ActivityManagerS-publishService"><a href="#4-1-2-ActivityManagerS-publishService" class="headerlink" title="4.1.2 ActivityManagerS.publishService"></a>4.1.2 ActivityManagerS.publishService</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publishService</span><span class="params">(IBinder token, Intent intent, IBinder service)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Refuse possible leaked file descriptors</span></span><br><span class="line">    <span class="keyword">if</span> (intent != <span class="keyword">null</span> &amp;&amp; intent.hasFileDescriptors() == <span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"File descriptors passed in Intent"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里不多说了！！</span></span><br><span class="line">        <span class="keyword">if</span> (!(token <span class="keyword">instanceof</span> ServiceRecord)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid service token"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 调用 ActiveServices 的 publishServiceLocked 方法！</span></span><br><span class="line">        mServices.publishServiceLocked((ServiceRecord)token, intent, service);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续看：</p>
<h4 id="4-1-2-1-ActiveServices-publishService"><a href="#4-1-2-1-ActiveServices-publishService" class="headerlink" title="4.1.2.1 ActiveServices.publishService"></a>4.1.2.1 ActiveServices.publishService</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">publishServiceLocked</span><span class="params">(ServiceRecord r, Intent intent, IBinder service)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">"PUBLISHING "</span> + r</span><br><span class="line">                + <span class="string">" "</span> + intent + <span class="string">": "</span> + service);</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 尝试找到 intent 对应的 IntentBindRecord 对象!</span></span><br><span class="line">            Intent.FilterComparison filter</span><br><span class="line">                    = <span class="keyword">new</span> Intent.FilterComparison(intent);</span><br><span class="line">            IntentBindRecord b = r.bindings.get(filter);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (b != <span class="keyword">null</span> &amp;&amp; !b.received) &#123;  <span class="comment">// 这里的 received 还是 false!</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 将服务的 “桩” 保存到！</span></span><br><span class="line">                b.binder = service;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将 IntentBindRecord.requested 设为 true！</span></span><br><span class="line">                b.requested = <span class="keyword">true</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 将 IntentBindRecord.received 设为 true！</span></span><br><span class="line">                b.received = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> conni=r.connections.size()-<span class="number">1</span>; conni&gt;=<span class="number">0</span>; conni--) &#123;</span><br><span class="line">                    ArrayList&lt;ConnectionRecord&gt; clist = r.connections.valueAt(conni);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;clist.size(); i++) &#123;</span><br><span class="line">                        ConnectionRecord c = clist.get(i);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (!filter.equals(c.binding.intent.intent)) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(</span><br><span class="line">                                    TAG_SERVICE, <span class="string">"Not publishing to: "</span> + c);</span><br><span class="line">                            <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(</span><br><span class="line">                                    TAG_SERVICE, <span class="string">"Bound intent: "</span> + c.binding.intent.intent);</span><br><span class="line">                            <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(</span><br><span class="line">                                    TAG_SERVICE, <span class="string">"Published intent: "</span> + intent);</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">"Publishing to: "</span> + c);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                        </span><br><span class="line">                            <span class="comment">// 通过 Bind 回调绑定者进程的 ServcieConnection 的 onServiceDisconnected 方法！</span></span><br><span class="line">                            <span class="comment">// 注意这个方法是非阻塞的，是异步的，因为有 oneway 的标志！！</span></span><br><span class="line">                            c.conn.connected(r.name, service);</span><br><span class="line"></span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            Slog.w(TAG, <span class="string">"Failure sending service "</span> + r.name +</span><br><span class="line">                                  <span class="string">" to connection "</span> + c.conn.asBinder() +</span><br><span class="line">                                  <span class="string">" (in "</span> + c.binding.client.processName + <span class="string">")"</span>, e);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 接着，调用 serviceDoneExecutingLocked 方法，表示执行完成！</span></span><br><span class="line">            serviceDoneExecutingLocked(r, mDestroyingServices.contains(r), <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里会继续通过 Bind 回调绑定者进程的 ServcieConnection 的 onServiceDisconnected 方法！这个方法是非阻塞的，是异步的，因为有 oneway 的标志！！</p>
<p>c.conn 是 IServiceConnection.proxy ，即服务连接代理对象！！！这里，就要回到绑定者进程，我们后面再看！！</p>
<h3 id="4-1-3-ActivityManagerS-serviceDoneExecutingLocked"><a href="#4-1-3-ActivityManagerS-serviceDoneExecutingLocked" class="headerlink" title="4.1.3 ActivityManagerS.serviceDoneExecutingLocked"></a>4.1.3 ActivityManagerS.serviceDoneExecutingLocked</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">serviceDoneExecutingLocked</span><span class="params">(ServiceRecord r, <span class="keyword">boolean</span> inDestroying,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> finishing)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">"&lt;&lt;&lt; DONE EXECUTING "</span> + r</span><br><span class="line">            + <span class="string">": nesting="</span> + r.executeNesting</span><br><span class="line">            + <span class="string">", inDestroying="</span> + inDestroying + <span class="string">", app="</span> + r.app);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (DEBUG_SERVICE_EXECUTING) Slog.v(TAG_SERVICE_EXECUTING,</span><br><span class="line">            <span class="string">"&lt;&lt;&lt; DONE EXECUTING "</span> + r.shortName);</span><br><span class="line"></span><br><span class="line">    r.executeNesting--;</span><br><span class="line">    <span class="keyword">if</span> (r.executeNesting &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r.app != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE,</span><br><span class="line">                    <span class="string">"Nesting at 0 of "</span> + r.shortName);</span><br><span class="line">                    </span><br><span class="line">            r.app.execServicesFg = <span class="keyword">false</span>;</span><br><span class="line">            r.app.executingServices.remove(r);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (r.app.executingServices.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_SERVICE || DEBUG_SERVICE_EXECUTING) Slog.v(TAG_SERVICE_EXECUTING,</span><br><span class="line">                        <span class="string">"No more executingServices of "</span> + r.shortName);</span><br><span class="line">                        </span><br><span class="line">                <span class="comment">// 移除 onCreate / onBind 方法的超时处理任务！</span></span><br><span class="line">                mAm.mHandler.removeMessages(ActivityManagerService.SERVICE_TIMEOUT_MSG, r.app);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.executeFg) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Need to re-evaluate whether the app still needs to be in the foreground.</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=r.app.executingServices.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (r.app.executingServices.valueAt(i).executeFg) &#123;</span><br><span class="line">                        r.app.execServicesFg = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (inDestroying) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE,</span><br><span class="line">                        <span class="string">"doneExecuting remove destroying "</span> + r);</span><br><span class="line">                mDestroyingServices.remove(r);</span><br><span class="line">                r.bindings.clear();</span><br><span class="line">            &#125;</span><br><span class="line">            mAm.updateOomAdjLocked(r.app);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        r.executeFg = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (r.tracker != <span class="keyword">null</span>) &#123;</span><br><span class="line">            r.tracker.setExecuting(<span class="keyword">false</span>, mAm.mProcessStats.getMemFactorLocked(),</span><br><span class="line">                    SystemClock.uptimeMillis());</span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                r.tracker.clearCurrentOwner(r, <span class="keyword">false</span>);</span><br><span class="line">                r.tracker = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r.app != <span class="keyword">null</span> &amp;&amp; !r.app.persistent) &#123;</span><br><span class="line">                r.app.services.remove(r);</span><br><span class="line">                <span class="keyword">if</span> (r.whitelistManager) &#123;</span><br><span class="line">                    updateWhitelistManagerLocked(r.app);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            r.app = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里很简单了，就不详细说了！！</p>
<h1 id="5-绑定者进程"><a href="#5-绑定者进程" class="headerlink" title="5 绑定者进程"></a>5 绑定者进程</h1><p>下面来看看绑定者进程的 connected 方法的回调问题！！</p>
<p>IServiceConnection.aild 文件中只定义了一个接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.content.ComponentName;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line">oneway <span class="class"><span class="keyword">interface</span> <span class="title">IServiceConnection</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connected</span><span class="params">(in ComponentName name, IBinder service)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这个方法是 oneway 类型的，就是说，binder 通信是非阻塞的！</p>
<h2 id="5-1-InnerConnection-connected"><a href="#5-1-InnerConnection-connected" class="headerlink" title="5.1 InnerConnection.connected"></a>5.1 InnerConnection.connected</h2><p>进入 LoadedApk 的 InnerConnection 类！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerConnection</span> <span class="keyword">extends</span> <span class="title">IServiceConnection</span>.<span class="title">Stub</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> WeakReference&lt;LoadedApk.ServiceDispatcher&gt; mDispatcher;</span><br><span class="line"></span><br><span class="line">    InnerConnection(LoadedApk.ServiceDispatcher sd) &#123;</span><br><span class="line">        mDispatcher = <span class="keyword">new</span> WeakReference&lt;LoadedApk.ServiceDispatcher&gt;(sd);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 接着，调用 ServiceDispatcher 的 connected 方法！</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connected</span><span class="params">(ComponentName name, IBinder service)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        LoadedApk.ServiceDispatcher sd = mDispatcher.get();</span><br><span class="line">        <span class="keyword">if</span> (sd != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sd.connected(name, service);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="5-2-ServiceDispatcher-connected"><a href="#5-2-ServiceDispatcher-connected" class="headerlink" title="5.2 ServiceDispatcher.connected"></a>5.2 ServiceDispatcher.connected</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 执行一个 RunConnection 的 Runnable！</span></span><br><span class="line">    <span class="keyword">if</span> (mActivityThread != <span class="keyword">null</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        mActivityThread.post(<span class="keyword">new</span> RunConnection(name, service, <span class="number">0</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        doConnected(name, service);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-3-ServiceDispatcher-RunConnection"><a href="#5-3-ServiceDispatcher-RunConnection" class="headerlink" title="5.3 ServiceDispatcher.RunConnection"></a>5.3 ServiceDispatcher.RunConnection</h2><p>参数传递：</p>
<ul>
<li>int command：0；<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RunConnection</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    RunConnection(ComponentName name, IBinder service, <span class="keyword">int</span> command) &#123;</span><br><span class="line">        mName = name;</span><br><span class="line">        mService = service;</span><br><span class="line">        mCommand = command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mCommand == <span class="number">0</span>) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 执行连接！</span></span><br><span class="line">            doConnected(mName, mService);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mCommand == <span class="number">1</span>) &#123;</span><br><span class="line">            doDeath(mName, mService);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ComponentName mName;</span><br><span class="line">    <span class="keyword">final</span> IBinder mService;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> mCommand;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>继续看：</p>
<h2 id="5-4-ServiceDispatcher-doConnected"><a href="#5-4-ServiceDispatcher-doConnected" class="headerlink" title="5.4 ServiceDispatcher.doConnected"></a>5.4 ServiceDispatcher.doConnected</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">    ServiceDispatcher.ConnectionInfo old;</span><br><span class="line">    ServiceDispatcher.ConnectionInfo info;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 当 mForgotten 为 true，表示之前执行了 unBindService 操作！</span></span><br><span class="line">        <span class="keyword">if</span> (mForgotten) &#123;</span><br><span class="line">            <span class="comment">// We unbound before receiving the connection; ignore</span></span><br><span class="line">            <span class="comment">// any connection received.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 先尝试获得旧的可用连接，如果已有，就退出！</span></span><br><span class="line">        <span class="comment">// 所以说，对于多次 bindService，onServiceConnected 只会执行一次！</span></span><br><span class="line">        old = mActiveConnections.get(name);</span><br><span class="line">        <span class="keyword">if</span> (old != <span class="keyword">null</span> &amp;&amp; old.binder == service) &#123;</span><br><span class="line">            <span class="comment">// Huh, already have this one.  Oh well!</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// service 是被绑定的 Service 的桩对应的代理！</span></span><br><span class="line">        <span class="keyword">if</span> (service != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建一个连接信息对象！</span></span><br><span class="line">            info = <span class="keyword">new</span> ConnectionInfo();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将远程 Service 代理保存到 binder 类中！</span></span><br><span class="line">            info.binder = service;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 设置死亡监听器</span></span><br><span class="line">            info.deathMonitor = <span class="keyword">new</span> DeathMonitor(name, service);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              </span><br><span class="line">                service.linkToDeath(info.deathMonitor, <span class="number">0</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 将本次的连接信息保存到 mActiveConnections 中！</span></span><br><span class="line">                mActiveConnections.put(name, info);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// This service was dead before we got it...  just</span></span><br><span class="line">                <span class="comment">// don't do anything with it.</span></span><br><span class="line">                mActiveConnections.remove(name);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// The named service is being disconnected... clean up.</span></span><br><span class="line">            mActiveConnections.remove(name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (old != <span class="keyword">null</span>) &#123;</span><br><span class="line">            old.binder.unlinkToDeath(old.deathMonitor, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If there was an old service, it is now disconnected.</span></span><br><span class="line">    <span class="keyword">if</span> (old != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mConnection.onServiceDisconnected(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If there is a new service, it is now connected.</span></span><br><span class="line">    <span class="keyword">if</span> (service != <span class="keyword">null</span>) &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 调用了 Connection 的 onServiceConnected 方法！</span></span><br><span class="line">        mConnection.onServiceConnected(name, service);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，我们看到，调用了 mConnection.onServiceConnected，这个方法大家很熟悉了，不多说了！</p>
<h1 id="6-总结"><a href="#6-总结" class="headerlink" title="6 总结"></a>6 总结</h1><h2 id="6-1-数据结构总结"><a href="#6-1-数据结构总结" class="headerlink" title="6.1 数据结构总结"></a>6.1 数据结构总结</h2><blockquote>
<p>绑定者进程的数据结构关系图</p>
</blockquote>
<p><img src="http://static.zybuluo.com/Coolqi/p0gzyjijwj4mo5gc29oqj3ar/%E7%BB%91%E5%AE%9A%E8%80%85%E8%BF%9B%E7%A8%8B%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%B3%E7%B3%BB.png" alt="绑定者进程中的数据结构关系.png-164.8kB"></p>
<p>一个应用进程，只会有一个 InnerConnection 对象！</p>
<blockquote>
<p>系统进程的数据结构关系图</p>
</blockquote>
<p><img src="http://static.zybuluo.com/Coolqi/slum6gwlc12agci9vhvk0ula/%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%B3%E7%B3%BB.png" alt="系统进程中的数据结构关系.png-467.2kB"></p>
<h2 id="6-2-binder-通信总结"><a href="#6-2-binder-通信总结" class="headerlink" title="6.2 binder 通信总结"></a>6.2 binder 通信总结</h2><h2 id="6-3-生命周期总结"><a href="#6-3-生命周期总结" class="headerlink" title="6.3 生命周期总结"></a>6.3 生命周期总结</h2><ul>
<li><p>对于<strong>只设置了 BIND_AUTO_CREATE 标志位</strong>的情况，只调用 bindService，Service 的周期如下：</p>
<ul>
<li><p>服务没有被创建：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Service.onCreate() -&gt; Service.onBind() -&gt; ServiceConnection.onServiceConnected()</span><br></pre></td></tr></table></figure>
</li>
<li><p>服务已经被创建：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Service.onBind() -&gt; ServiceConnection.onServiceConnected()</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>对于<strong>没有设置 BIND_AUTO_CREATE 标志，但设置了其他标志的情况</strong>，只调用 bindService，Service 的周期如下：</p>
<ul>
<li><p>服务没有被创建：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无法实现 bind 操作, 但是会将本次 bind 操作的信息保存到系统进程中！</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>服务之前已经被创建（之前通过 startService 启动服务，或者其他组件通过 BIND_AUTO_CREATE 方式绑定拉起）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Service.onBind() -&gt; ServiceConnection.onServiceConnected()</span><br></pre></td></tr></table></figure>
</li>
<li><p>服务之后才被创建（之后通过 startService 启动服务，或者其他组件通过 BIND_AUTO_CREATE 方式绑定拉起）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    Service.onCreate() -&gt; Service.onBind() (-&gt; Service.onStartCommand) -&gt; ServiceConnection.onServiceConnected()</span><br><span class="line">    ``` </span><br><span class="line"></span><br><span class="line">对于第三中情况，是不是很奇怪？原因很简单，如果服务之前没有被创建，调用 bindService（只设置了其他标志），是不会拉起 Service.onBind 方法的，但是会把本次 bind 的信息保存相应的集合中，当服务被 startService 或者通过 BIND_AUTO_CREATE 方式绑定拉起后，会对之前的 bind 信息处理，返回之前 bind 对应的代理对象！！详情请参考 startService 篇！</span><br><span class="line"></span><br><span class="line">- 对于多次调用 bindService</span><br><span class="line"></span><br><span class="line">  - 设置了 BIND_AUTO_CREATE 标志！</span><br><span class="line">    ```java</span><br><span class="line">    Service.onCreate()(once) -&gt; Service.onBind()(once) -&gt; ServiceConnection.onServiceConnected()（once）</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>如果服务已经被创建的话，那 onCreate 方法是不会调用的，直接调用 onBind 方法！</p>
<ul>
<li>未设置 BIND_AUTO_CREATE 标志！ <ul>
<li>服务没有被启动！<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 无法实现 bind 操作, 但是会将本次 bind 操作的信息保存到系统进程中，等到服务被 startService 或者其他自动创建类型的 bindService 拉起后才会执行如下周期：</span></span><br><span class="line">    Service.onBind(once) -&gt; ServiceConnection.onServiceConnected()(once)</span><br><span class="line">    ```    </span><br><span class="line">     - 服务已经被启动！</span><br><span class="line">    ```java</span><br><span class="line">     Service.onBind()(once) -&gt; ServiceConnection.onServiceConnected()(once)</span><br><span class="line">    ```  </span><br><span class="line">    </span><br><span class="line">以上就是 bindService 相关的生命周期，有不对的地方，欢迎指正，谢谢！</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 6.4 相关 Log 参考</span><br><span class="line">```shell</span><br><span class="line"><span class="number">07</span>-<span class="number">04</span> <span class="number">17</span>:<span class="number">24</span>:<span class="number">21.523</span>  <span class="number">1761</span>  <span class="number">4194</span> V ActiveServices: bindService: Intent &#123; cmp=com.cooqi.servicedemo/.service.AService &#125; type=<span class="keyword">null</span> conn=android.os.BinderProxy<span class="meta">@abcfcca</span> flags=<span class="number">0x1</span></span><br><span class="line"><span class="number">07</span>-<span class="number">04</span> <span class="number">17</span>:<span class="number">24</span>:<span class="number">21.524</span>  <span class="number">1761</span>  <span class="number">4194</span> V ActiveServices: retrieveServiceLocked: Intent &#123; cmp=com.cooqi.servicedemo/.service.AService &#125; type=<span class="keyword">null</span> callingUid=<span class="number">10106</span></span><br><span class="line"><span class="number">07</span>-<span class="number">04</span> <span class="number">17</span>:<span class="number">24</span>:<span class="number">21.525</span>  <span class="number">1761</span>  <span class="number">4194</span> V ActivityManagerService: processName: com.cooqi.servicedemo uid <span class="number">10106</span> keepIfLarge <span class="keyword">false</span></span><br><span class="line"><span class="number">07</span>-<span class="number">04</span> <span class="number">17</span>:<span class="number">24</span>:<span class="number">21.526</span>  <span class="number">1761</span>  <span class="number">4194</span> V ActiveServices: Bringing up ServiceRecord&#123;<span class="number">7454958</span> u0 com.cooqi.servicedemo/.service.AService&#125; android.content.Intent$FilterComparison@<span class="number">7</span>df9497b</span><br><span class="line"><span class="number">07</span>-<span class="number">04</span> <span class="number">17</span>:<span class="number">24</span>:<span class="number">21.526</span>  <span class="number">1761</span>  <span class="number">4194</span> V ActivityManagerService: processName: com.cooqi.servicedemo uid <span class="number">10106</span> keepIfLarge <span class="keyword">false</span></span><br><span class="line"><span class="number">07</span>-<span class="number">04</span> <span class="number">17</span>:<span class="number">24</span>:<span class="number">21.527</span>  <span class="number">1761</span>  <span class="number">4194</span> V ActiveServices_MU: bringUpServiceLocked: appInfo.uid=<span class="number">10106</span> app=ProcessRecord&#123;<span class="number">39802</span>a4 <span class="number">7994</span>:com.cooqi.servicedemo/u0a106&#125;</span><br><span class="line"><span class="number">07</span>-<span class="number">04</span> <span class="number">17</span>:<span class="number">24</span>:<span class="number">21.527</span>  <span class="number">1761</span>  <span class="number">4194</span> V ActiveServices_MU: realStartServiceLocked, ServiceRecord.uid = <span class="number">10106</span>, ProcessRecord.uid = <span class="number">10106</span></span><br><span class="line"><span class="number">07</span>-<span class="number">04</span> <span class="number">17</span>:<span class="number">24</span>:<span class="number">21.527</span>  <span class="number">1761</span>  <span class="number">4194</span> V ActiveServices: &gt;&gt;&gt; EXECUTING create of ServiceRecord&#123;<span class="number">7454958</span> u0 com.cooqi.servicedemo/.service.AService&#125; in app ProcessRecord&#123;<span class="number">39802</span>a4 <span class="number">7994</span>:com.cooqi.servicedemo/u0a106&#125;</span><br><span class="line"><span class="number">07</span>-<span class="number">04</span> <span class="number">17</span>:<span class="number">24</span>:<span class="number">21.527</span>  <span class="number">1761</span>  <span class="number">4194</span> V ActiveServices: bumpServiceExecutingLocked r.executeNesting <span class="number">0</span></span><br><span class="line"><span class="number">07</span>-<span class="number">04</span> <span class="number">17</span>:<span class="number">24</span>:<span class="number">21.527</span>  <span class="number">1761</span>  <span class="number">4194</span> V ActiveServices: bumpServiceExecutingLocked r.app.executingServices.size() <span class="number">1</span></span><br><span class="line"><span class="number">07</span>-<span class="number">04</span> <span class="number">17</span>:<span class="number">24</span>:<span class="number">21.544</span>  <span class="number">1761</span>  <span class="number">4194</span> D ActivityManagerService: oom: memFactor=<span class="number">0</span> last=<span class="number">0</span> allowLow=<span class="keyword">false</span> numProcs=<span class="number">66</span> last=<span class="number">66</span></span><br><span class="line"><span class="number">07</span>-<span class="number">04</span> <span class="number">17</span>:<span class="number">24</span>:<span class="number">21.545</span>  <span class="number">1761</span>  <span class="number">4194</span> D ActivityManagerService: Did OOM ADJ in <span class="number">18</span>ms</span><br><span class="line"><span class="number">07</span>-<span class="number">04</span> <span class="number">17</span>:<span class="number">24</span>:<span class="number">21.546</span>  <span class="number">1761</span>  <span class="number">4194</span> V ActiveServices: &gt;&gt;&gt; EXECUTING bind of ServiceRecord&#123;<span class="number">7454958</span> u0 com.cooqi.servicedemo/.service.AService&#125; in app ProcessRecord&#123;<span class="number">39802</span>a4 <span class="number">7994</span>:com.cooqi.servicedemo/u0a106&#125;</span><br><span class="line"><span class="number">07</span>-<span class="number">04</span> <span class="number">17</span>:<span class="number">24</span>:<span class="number">21.547</span>  <span class="number">1761</span>  <span class="number">4194</span> V ActiveServices: bumpServiceExecutingLocked r.executeNesting <span class="number">1</span></span><br><span class="line"><span class="number">07</span>-<span class="number">04</span> <span class="number">17</span>:<span class="number">24</span>:<span class="number">21.547</span>  <span class="number">7994</span>  <span class="number">8006</span> V ActivityThread: SCHEDULE <span class="number">114</span> CREATE_SERVICE: <span class="number">0</span> / CreateServiceData&#123;token=android.os.BinderProxy@<span class="number">23f</span>fb1d className=com.cooqi.servicedemo.service.AService packageName=com.cooqi.servicedemo intent=<span class="keyword">null</span>&#125;</span><br><span class="line"><span class="number">07</span>-<span class="number">04</span> <span class="number">17</span>:<span class="number">24</span>:<span class="number">21.547</span>  <span class="number">1761</span>  <span class="number">4194</span> V ActiveServices: Bind ServiceRecord&#123;<span class="number">7454958</span> u0 com.cooqi.servicedemo/.service.AService&#125; with AppBindRecord&#123;<span class="number">6e93</span>ab1 com.cooqi.servicedemo/.service.AService:com.cooqi.servicedemo&#125;: received=<span class="keyword">false</span> apps=<span class="number">1</span> doRebind=<span class="keyword">false</span></span><br><span class="line"><span class="number">07</span>-<span class="number">04</span> <span class="number">17</span>:<span class="number">24</span>:<span class="number">21.548</span>  <span class="number">7994</span>  <span class="number">8006</span> V ActivityThread: scheduleBindService token=android.os.BinderProxy@<span class="number">23f</span>fb1d intent=Intent &#123; cmp=com.cooqi.servicedemo/.service.AService &#125; uid=<span class="number">1000</span> pid=<span class="number">0</span></span><br><span class="line"><span class="number">07</span>-<span class="number">04</span> <span class="number">17</span>:<span class="number">24</span>:<span class="number">21.548</span>  <span class="number">7994</span>  <span class="number">8006</span> V ActivityThread: SCHEDULE <span class="number">121</span> BIND_SERVICE: <span class="number">0</span> / BindServiceData&#123;token=android.os.BinderProxy@<span class="number">23f</span>fb1d intent=Intent &#123; cmp=com.cooqi.servicedemo/.service.AService &#125;&#125;</span><br><span class="line"><span class="number">07</span>-<span class="number">04</span> <span class="number">17</span>:<span class="number">24</span>:<span class="number">21.552</span>  <span class="number">7994</span>  <span class="number">7994</span> V ActivityThread: &gt;&gt;&gt; handling: CREATE_SERVICE</span><br><span class="line"><span class="number">07</span>-<span class="number">04</span> <span class="number">17</span>:<span class="number">24</span>:<span class="number">21.552</span>  <span class="number">7994</span>  <span class="number">7994</span> V ActivityThread: Creating service com.cooqi.servicedemo.service.AService</span><br><span class="line"><span class="number">07</span>-<span class="number">04</span> <span class="number">17</span>:<span class="number">24</span>:<span class="number">21.553</span>  <span class="number">7994</span>  <span class="number">7994</span> D AService: onCreate</span><br><span class="line"><span class="number">07</span>-<span class="number">04</span> <span class="number">17</span>:<span class="number">24</span>:<span class="number">21.553</span>  <span class="number">7994</span>  <span class="number">7994</span> V ActivityThread: &lt;&lt;&lt; done: CREATE_SERVICE</span><br><span class="line"><span class="number">07</span>-<span class="number">04</span> <span class="number">17</span>:<span class="number">24</span>:<span class="number">21.553</span>  <span class="number">7994</span>  <span class="number">7994</span> V ActivityThread: &gt;&gt;&gt; handling: BIND_SERVICE</span><br><span class="line"><span class="number">07</span>-<span class="number">04</span> <span class="number">17</span>:<span class="number">24</span>:<span class="number">21.554</span>  <span class="number">7994</span>  <span class="number">7994</span> V ActivityThread: handleBindService s=com.cooqi.servicedemo.service.AService@<span class="number">92</span>ef192 rebind=<span class="keyword">false</span></span><br><span class="line"><span class="number">07</span>-<span class="number">04</span> <span class="number">17</span>:<span class="number">24</span>:<span class="number">21.554</span>  <span class="number">7994</span>  <span class="number">7994</span> D AService: onBind</span><br><span class="line"><span class="number">07</span>-<span class="number">04</span> <span class="number">17</span>:<span class="number">24</span>:<span class="number">21.554</span>  <span class="number">1761</span>  <span class="number">4106</span> V ActiveServices: serviceDoneExecutingLocked ServiceRecord= ServiceRecord&#123;<span class="number">7454958</span> u0 com.cooqi.servicedemo/.service.AService&#125; type= <span class="number">0</span> startId= <span class="number">0</span> res= <span class="number">0</span></span><br><span class="line"><span class="number">07</span>-<span class="number">04</span> <span class="number">17</span>:<span class="number">24</span>:<span class="number">21.554</span>  <span class="number">1761</span>  <span class="number">4106</span> V ActiveServices: &lt;&lt;&lt; DONE EXECUTING ServiceRecord&#123;<span class="number">7454958</span> u0 com.cooqi.servicedemo/.service.AService&#125;: nesting=<span class="number">2</span>, inDestroying=<span class="keyword">false</span>, app=ProcessRecord&#123;<span class="number">39802</span>a4 <span class="number">7994</span>:com.cooqi.servicedemo/u0a106&#125;</span><br><span class="line"><span class="number">07</span>-<span class="number">04</span> <span class="number">17</span>:<span class="number">24</span>:<span class="number">21.555</span>  <span class="number">1761</span>  <span class="number">3764</span> V ActiveServices: PUBLISHING ServiceRecord&#123;<span class="number">7454958</span> u0 com.cooqi.servicedemo/.service.AService&#125; Intent &#123; cmp=com.cooqi.servicedemo/.service.AService &#125;: android.os.BinderProxy@<span class="number">7161</span>b96</span><br><span class="line"><span class="number">07</span>-<span class="number">04</span> <span class="number">17</span>:<span class="number">24</span>:<span class="number">21.556</span>  <span class="number">1761</span>  <span class="number">3764</span> V ActiveServices: Publishing to: ConnectionRecord&#123;<span class="number">5</span>b95e3b u0 CR com.cooqi.servicedemo/.service.AService:<span class="meta">@abcfcca</span>&#125;</span><br><span class="line"><span class="number">07</span>-<span class="number">04</span> <span class="number">17</span>:<span class="number">24</span>:<span class="number">21.556</span>  <span class="number">1761</span>  <span class="number">3764</span> V ActiveServices: &lt;&lt;&lt; DONE EXECUTING ServiceRecord&#123;<span class="number">7454958</span> u0 com.cooqi.servicedemo/.service.AService&#125;: nesting=<span class="number">1</span>, inDestroying=<span class="keyword">false</span>, app=ProcessRecord&#123;<span class="number">39802</span>a4 <span class="number">7994</span>:com.cooqi.servicedemo/u0a106&#125;</span><br><span class="line"><span class="number">07</span>-<span class="number">04</span> <span class="number">17</span>:<span class="number">24</span>:<span class="number">21.556</span>  <span class="number">1761</span>  <span class="number">3764</span> V ActiveServices: Nesting at <span class="number">0</span> of com.cooqi.servicedemo/.service.AService</span><br><span class="line"><span class="number">07</span>-<span class="number">04</span> <span class="number">17</span>:<span class="number">24</span>:<span class="number">21.556</span>  <span class="number">1761</span>  <span class="number">3764</span> V ActiveServices: r.app.executingServices.size(): <span class="number">0</span></span><br><span class="line"><span class="number">07</span>-<span class="number">04</span> <span class="number">17</span>:<span class="number">24</span>:<span class="number">21.556</span>  <span class="number">1761</span>  <span class="number">3764</span> V ActiveServices: No more executingServices of com.cooqi.servicedemo/.service.AService</span><br><span class="line"><span class="number">07</span>-<span class="number">04</span> <span class="number">17</span>:<span class="number">24</span>:<span class="number">21.557</span>  <span class="number">7994</span>  <span class="number">7994</span> V ActivityThread: &lt;&lt;&lt; done: BIND_SERVICE</span><br><span class="line"><span class="number">07</span>-<span class="number">04</span> <span class="number">17</span>:<span class="number">24</span>:<span class="number">21.561</span>  <span class="number">7994</span>  <span class="number">7994</span> D MainActivity: onServiceConnected</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p><a href="http://www.tuicool.com/articles/67zyea" target="_blank" rel="noopener">http://www.tuicool.com/articles/67zyea</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2016/05/15/Process篇 5 - 进程的 oomAdj 调度算法/">Process篇 5 - 进程的 oomAdj 调度算法</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2016-05-15</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/AndroidFramework源码分析/">AndroidFramework源码分析</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/AndroidFramework源码分析/Process进程/">Process进程</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Process进程/">Process进程</a></span><div class="content"><p>[toc]</p>
<p>基于 Android 7.1.1 源码，总结进程状态调整的调度策略！</p>
<h1 id="1-进程-oomAdj-的调度方法"><a href="#1-进程-oomAdj-的调度方法" class="headerlink" title="1 进程 oomAdj 的调度方法"></a>1 进程 oomAdj 的调度方法</h1><p>和进程的 oomAdj 调度相关的主要有`3 个方法：</p>
<ul>
<li><strong>updateOomAdjLocked</strong>：用于更新进程的 adj，该方法会依次调用 computeOomAdjLocked 和 applyOomAdjLocked;</li>
<li><strong>computeOomAdjLocked</strong>：计算进程的 adj，返回计算后 RawAdj 值;</li>
<li><strong>applyOomAdjLocked</strong>：应用 adj，当需要杀掉目标进程则返回 false；否则返回 true。</li>
</ul>
<p>当在一些特定的场景下，系统会调用 updateOomAdjLocked 来更新指定进程的 oomAdj，该方法会先调用 computeOomAdjLocked 计算出一个新的 oomAdj，然后在调用 applyOomAdjLocked 来设置指定进程的 oomAdj！</p>
<p>updateOomAdjLocked 有多个重载函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新指定进程的 oomAdj</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">updateOomAdjLocked</span><span class="params">(ProcessRecord app)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">updateOomAdjLocked</span><span class="params">(ProcessRecord app, <span class="keyword">int</span> cachedAdj, ProcessRecord TOP_APP, <span class="keyword">boolean</span> doingAll, <span class="keyword">long</span> now)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 更新所有进程的 oomAdj</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateOomAdjLocked</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p><strong>其中，五个参数的 updateOomAdjLocked 方法是私有方法，只提供给其他的两个方法调用！！</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">updateOomAdjLocked</span><span class="params">(ProcessRecord app, <span class="keyword">int</span> cachedAdj, ProcessRecord TOP_APP, <span class="keyword">boolean</span> doingAll, <span class="keyword">long</span> now)</span></span></span><br></pre></td></tr></table></figure>
<h1 id="2-调度时机"><a href="#2-调度时机" class="headerlink" title="2 调度时机"></a>2 调度时机</h1><p>接下里，我们看看 updateOomAdjLocked 的调度时机：</p>
<h2 id="2-1-Activity-调整"><a href="#2-1-Activity-调整" class="headerlink" title="2.1 Activity 调整"></a>2.1 Activity 调整</h2><p>和 Activity 相关的调整代码主要是位于 ActivityStackSupervisor.java 和 ActivityStack.java 中：</p>
<h3 id="2-1-1-realStartActivityLocked"><a href="#2-1-1-realStartActivityLocked" class="headerlink" title="2.1.1 realStartActivityLocked"></a>2.1.1 realStartActivityLocked</h3><p>ActivityStackSupervisor.realStartActivityLocked：启动 Activity，以下是关键代码段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//【1】将 activity 所在的进程添加到 lru process 列表中！</span></span><br><span class="line">mService.updateLruProcessLocked(app, <span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//【2】更新所有进程的 oomAdj！</span></span><br><span class="line">mService.updateOomAdjLocked();</span><br></pre></td></tr></table></figure>
<p>在启动之前会调用 updateOomAdjLocked 更新所有进程的 oomAdj！</p>
<h3 id="2-1-2-resumeTopActivityInnerLocked"><a href="#2-1-2-resumeTopActivityInnerLocked" class="headerlink" title="2.1.2 resumeTopActivityInnerLocked"></a>2.1.2 resumeTopActivityInnerLocked</h3><p>ActivityStack.resumeTopActivityInnerLocked: 恢复栈顶 Activity，以下是关键代码段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//【1】next 表示的是下一个要被 resume 的 activity</span></span><br><span class="line">next.state = ActivityState.RESUMED;</span><br><span class="line">mResumedActivity = next;</span><br><span class="line">next.task.touchActiveTime();</span><br><span class="line">mRecentTasks.addLocked(next.task);</span><br><span class="line"><span class="comment">//【2】更新 lru process 列表！</span></span><br><span class="line">mService.updateLruProcessLocked(next.app, <span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//【3】更新 lru activity 列表！</span></span><br><span class="line">updateLRUListLocked(next);</span><br><span class="line"><span class="comment">//【4】更新所有进程的 oomAdj 值</span></span><br><span class="line">mService.updateOomAdjLocked();</span><br></pre></td></tr></table></figure>
<p>更新所有进程的 oomAdj！</p>
<h3 id="2-1-3-finishCurrentActivityLocked"><a href="#2-1-3-finishCurrentActivityLocked" class="headerlink" title="2.1.3 finishCurrentActivityLocked"></a>2.1.3 finishCurrentActivityLocked</h3><p>ActivityStack.finishCurrentActivityLocked: 结束 Activity，以下是关键代码段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mode == FINISH_AFTER_VISIBLE &amp;&amp; (r.visible || r.nowVisible)</span><br><span class="line">        &amp;&amp; next != <span class="keyword">null</span> &amp;&amp; !next.nowVisible) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mStackSupervisor.mStoppingActivities.contains(r)) &#123;</span><br><span class="line">        addToStopping(r, <span class="keyword">false</span> <span class="comment">/* immediate */</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_STATES) Slog.v(TAG_STATES,</span><br><span class="line">            <span class="string">"Moving to STOPPING: "</span>+ r + <span class="string">" (finish requested)"</span>);</span><br><span class="line">    <span class="comment">// 将 activity 的状态改为 stopping！</span></span><br><span class="line">    r.state = ActivityState.STOPPING;</span><br><span class="line">    <span class="comment">//【1】如果 oomAdj 为 true，那就需要调整所有进程的 `oomAdj`</span></span><br><span class="line">    <span class="keyword">if</span> (oomAdj) &#123;</span><br><span class="line">        mService.updateOomAdjLocked();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更新所有进程的 oomAdj！</p>
<h3 id="2-1-4-destroyActivityLocked"><a href="#2-1-4-destroyActivityLocked" class="headerlink" title="2.1.4 destroyActivityLocked"></a>2.1.4 destroyActivityLocked</h3><p>ActivityStack.destroyActivityLocked: 摧毁 Activity，以下是关键代码段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (hadApp) &#123;</span><br><span class="line">    <span class="keyword">if</span> (removeFromApp) &#123;</span><br><span class="line">        r.app.activities.remove(r);</span><br><span class="line">        <span class="keyword">if</span> (mService.mHeavyWeightProcess == r.app &amp;&amp; r.app.activities.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            mService.mHeavyWeightProcess = <span class="keyword">null</span>;</span><br><span class="line">            mService.mHandler.sendEmptyMessage(</span><br><span class="line">                    ActivityManagerService.CANCEL_HEAVY_NOTIFICATION_MSG);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【1】如果被 destroy 的 activity 所在的进程已经没有任何 activity 了，那就需要调整 oomAdj！</span></span><br><span class="line">        <span class="keyword">if</span> (r.app.activities.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//【1.1】通知所有的服务，该进程没有任何 activity</span></span><br><span class="line">            mService.mServices.updateServiceConnectionActivitiesLocked(r.app);</span><br><span class="line">            <span class="comment">//【1.2】该进程没有了 activity，需要更新 lru list 和 oomAdj 的值！</span></span><br><span class="line">            mService.updateLruProcessLocked(r.app, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">//【1.2】更新所有进程的 adj</span></span><br><span class="line">            mService.updateOomAdjLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ... ... ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会更新所有进程的 oomAdj！</p>
<h2 id="2-2-Service-调整"><a href="#2-2-Service-调整" class="headerlink" title="2.2 Service 调整"></a>2.2 Service 调整</h2><p>和 Service 相关的调整代码主要是位于 ActiveServices.java 中：</p>
<h3 id="2-2-1-realStartServiceLocked"><a href="#2-2-1-realStartServiceLocked" class="headerlink" title="2.2.1 realStartServiceLocked"></a>2.2.1 realStartServiceLocked</h3><p><strong>ActiveServices.realStartServiceLocked</strong>: 启动服务，以下是关键代码段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> newService = app.services.add(r);</span><br><span class="line">bumpServiceExecutingLocked(r, execInFg, <span class="string">"create"</span>); <span class="comment">// 设置拉起 onCreate 方法超时处理！</span></span><br><span class="line">mAm.updateLruProcessLocked(app, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">mAm.updateOomAdjLocked(); <span class="comment">//【1】更新所有进程的 oomAdj</span></span><br></pre></td></tr></table></figure>
<h3 id="2-2-2-bindServiceLocked"><a href="#2-2-2-bindServiceLocked" class="headerlink" title="2.2.2 bindServiceLocked"></a>2.2.2 bindServiceLocked</h3><p><strong>ActiveServices.bindServiceLocked</strong>: 绑定服务，以下是关键代码段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s.app != <span class="keyword">null</span>) &#123; <span class="comment">// 这里的 s.app 表示服务所在的进程！</span></span><br><span class="line">    <span class="keyword">if</span> ((flags&amp;Context.BIND_TREAT_LIKE_ACTIVITY) != <span class="number">0</span>) &#123;</span><br><span class="line">        s.app.treatLikeActivity = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s.whitelistManager) &#123;</span><br><span class="line">        s.app.whitelistManager = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【1】当我们 bind 一个服务的时候，该服务的优先级会被提升！</span></span><br><span class="line">    mAm.updateLruProcessLocked(s.app, s.app.hasClientActivities</span><br><span class="line">            || s.app.treatLikeActivity, b.client);</span><br><span class="line">    <span class="comment">//【2】更新服务所在进程的 oomAdj</span></span><br><span class="line">    mAm.updateOomAdjLocked(s.app);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只更新服务所在进程的 oomAdj!</p>
<h3 id="2-2-3-unbindServiceLocked"><a href="#2-2-3-unbindServiceLocked" class="headerlink" title="2.2.3 unbindServiceLocked"></a>2.2.3 unbindServiceLocked</h3><p><strong>ActiveServices.unbindServiceLocked</strong>: 解绑服务，以下是关键代码段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (r.binding.service.app != <span class="keyword">null</span>) &#123; <span class="comment">// r.binding.service.app 在这里表示的是服务所在的进程！</span></span><br><span class="line">    <span class="keyword">if</span> (r.binding.service.app.whitelistManager) &#123;</span><br><span class="line">        updateWhitelistManagerLocked(r.binding.service.app);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【1】当我们 unbind 一个服务的时候，该服务的优先级会被降低！</span></span><br><span class="line">    <span class="keyword">if</span> ((r.flags&amp;Context.BIND_TREAT_LIKE_ACTIVITY) != <span class="number">0</span>) &#123;</span><br><span class="line">        r.binding.service.app.treatLikeActivity = <span class="keyword">true</span>;</span><br><span class="line">        mAm.updateLruProcessLocked(r.binding.service.app,</span><br><span class="line">                r.binding.service.app.hasClientActivities</span><br><span class="line">                || r.binding.service.app.treatLikeActivity, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【2】更新服务所在进程的 oomAdj！</span></span><br><span class="line">    mAm.updateOomAdjLocked(r.binding.service.app);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只更新服务所在进程的 oomAdj！！</p>
<h3 id="2-2-4-bringDownServiceLocked"><a href="#2-2-4-bringDownServiceLocked" class="headerlink" title="2.2.4 bringDownServiceLocked"></a>2.2.4 bringDownServiceLocked</h3><p><strong>ActiveServices.bringDownServiceLocked</strong>: 结束服务，以下是关键代码段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当我们要结束一个服务的时候，我们需要接触所有的绑定操作！</span></span><br><span class="line"><span class="keyword">if</span> (r.app != <span class="keyword">null</span> &amp;&amp; r.app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=r.bindings.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">        IntentBindRecord ibr = r.bindings.valueAt(i);</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">"Bringing down binding "</span> + ibr</span><br><span class="line">                + <span class="string">": hasBound="</span> + ibr.hasBound);</span><br><span class="line">        <span class="comment">// 如果有绑定操作，接触绑定！</span></span><br><span class="line">        <span class="keyword">if</span> (ibr.hasBound) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bumpServiceExecutingLocked(r, <span class="keyword">false</span>, <span class="string">"bring down unbind"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//【1】更新服务所在进程的 oomAdj！</span></span><br><span class="line">                mAm.updateOomAdjLocked(r.app);</span><br><span class="line">                ibr.hasBound = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//【2】拉起服务的 onUnBind 方法！</span></span><br><span class="line">                r.app.thread.scheduleUnbindService(r,</span><br><span class="line">                        ibr.intent.getIntent());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Exception when unbinding service "</span></span><br><span class="line">                        + r.shortName, e);</span><br><span class="line">                serviceProcessGoneLocked(r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">... ... ... ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (r.app != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (r.stats.getBatteryStats()) &#123;</span><br><span class="line">        r.stats.stopLaunchedLocked();</span><br><span class="line">    &#125;</span><br><span class="line">    r.app.services.remove(r);</span><br><span class="line">    <span class="keyword">if</span> (r.whitelistManager) &#123;</span><br><span class="line">        updateWhitelistManagerLocked(r.app);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r.app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">        updateServiceForegroundLocked(r.app, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//【1】设置拉起 onDestroy 方法的超时处理！</span></span><br><span class="line">            bumpServiceExecutingLocked(r, <span class="keyword">false</span>, <span class="string">"destroy"</span>);</span><br><span class="line">            mDestroyingServices.add(r);</span><br><span class="line">            r.destroying = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//【2】更新服务所在进程的 oomAdj 值！</span></span><br><span class="line">            mAm.updateOomAdjLocked(r.app);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//【3】拉起服务的 onDestroy 服务！</span></span><br><span class="line">            r.app.thread.scheduleStopService(r);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Exception when destroying service "</span></span><br><span class="line">                    + r.shortName, e);</span><br><span class="line">            serviceProcessGoneLocked(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(</span><br><span class="line">            TAG_SERVICE, <span class="string">"Removed service that has no process: "</span> + r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(</span><br><span class="line">        TAG_SERVICE, <span class="string">"Removed service that is not running: "</span> + r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只更新服务所在进程的 oomAdj!</p>
<h3 id="2-2-5-sendServiceArgsLocked"><a href="#2-2-5-sendServiceArgsLocked" class="headerlink" title="2.2.5 sendServiceArgsLocked"></a>2.2.5 sendServiceArgsLocked</h3><p><strong>ActiveServices.sendServiceArgsLocked</strong>: 发送启动参数，该方法会拉起服务的 onStart 方法，以下是关键代码段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bumpServiceExecutingLocked(r, execInFg, <span class="string">"start"</span>); <span class="comment">// 设置拉起 onStart 方法超时处理</span></span><br><span class="line"><span class="comment">//【1】当 oomAdjusted 为 fasle，才会执行 oomAdj 的更新！</span></span><br><span class="line"><span class="keyword">if</span> (!oomAdjusted) &#123;</span><br><span class="line">    oomAdjusted = <span class="keyword">true</span>;</span><br><span class="line">    mAm.updateOomAdjLocked(r.app); <span class="comment">// 更新服务所在进程的 oomAdj！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sendServiceArgsLocked 在很多地方都有调用：</p>
<ul>
<li><p><strong>realStartServiceLocked</strong> 方法在拉起 onCreate 方法之前，会对所有进程的 oomAdj 做一次调整；接着调用 sendServiceArgsLocked，但是由于其第三个参数 oomAdjusted 传入的是 true，所以不会再次 oomAdj 更新！</p>
</li>
<li><p><strong>cleanUpRemovedTaskLocked</strong> 方法是当我们从最近任务中移除一个任务时候，我们会移除该任务所对应的 Service，那么如果 Service 没有设置 ServiceInfo.FLAG_STOP_WITH_TASK 标志位的话，并且如果服务所在进程没有死亡，那么系统会重新拉起服务：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = services.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    ServiceRecord sr = services.get(i);</span><br><span class="line">    <span class="keyword">if</span> (sr.startRequested) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((sr.serviceInfo.flags&amp;ServiceInfo.FLAG_STOP_WITH_TASK) != <span class="number">0</span>) &#123;</span><br><span class="line">            Slog.i(TAG, <span class="string">"Stopping service "</span> + sr.shortName + <span class="string">": remove task"</span>);</span><br><span class="line">            stopServiceLocked(sr);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//【1】创建启动项！</span></span><br><span class="line">            sr.pendingStarts.add(<span class="keyword">new</span> ServiceRecord.StartItem(sr, <span class="keyword">true</span>,</span><br><span class="line">                    sr.makeNextStartId(), baseIntent, <span class="keyword">null</span>));</span><br><span class="line">            <span class="keyword">if</span> (sr.app != <span class="keyword">null</span> &amp;&amp; sr.app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//【2】拉起服务的 onStart 方法！</span></span><br><span class="line">                    sendServiceArgsLocked(sr, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (TransactionTooLargeException e) &#123;</span><br><span class="line">                    <span class="comment">// Ignore, keep going.</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，第三个参数 oomAdjusted 传入的是 false，所以会发生 oomAdj 更新！</p>
<ul>
<li><strong>bringUpServiceLocked</strong> 方法中如果服务所在进程已经被启动，并且服务的 onCreate 方法已经被拉起，那就会直接 sendServiceArgsLocked 拉起服务的 onStart 方法！</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (r.app != <span class="keyword">null</span> &amp;&amp; r.app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">    sendServiceArgsLocked(r, execInFg, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，第三个参数 oomAdjusted 也传入的是 false，所以也会发生 oomAdj 更新！</p>
<h3 id="2-2-6-serviceDoneExecutingLocked"><a href="#2-2-6-serviceDoneExecutingLocked" class="headerlink" title="2.2.6 serviceDoneExecutingLocked"></a>2.2.6 serviceDoneExecutingLocked</h3><p><strong>ActiveServices.serviceDoneExecutingLocked</strong> 以下是关键代码段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (r.executeNesting &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (r.app != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE,</span><br><span class="line">                <span class="string">"Nesting at 0 of "</span> + r.shortName);</span><br><span class="line">        r.app.execServicesFg = <span class="keyword">false</span>;</span><br><span class="line">        r.app.executingServices.remove(r);</span><br><span class="line">        <span class="keyword">if</span> (r.app.executingServices.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_SERVICE || DEBUG_SERVICE_EXECUTING) Slog.v(TAG_SERVICE_EXECUTING,</span><br><span class="line">                    <span class="string">"No more executingServices of "</span> + r.shortName);</span><br><span class="line">            mAm.mHandler.removeMessages(ActivityManagerService.SERVICE_TIMEOUT_MSG, r.app);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.executeFg) &#123;</span><br><span class="line">            <span class="comment">// Need to re-evaluate whether the app still needs to be in the foreground.</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=r.app.executingServices.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (r.app.executingServices.valueAt(i).executeFg) &#123;</span><br><span class="line">                    r.app.execServicesFg = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (inDestroying) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE,</span><br><span class="line">                    <span class="string">"doneExecuting remove destroying "</span> + r);</span><br><span class="line">            mDestroyingServices.remove(r);</span><br><span class="line">            r.bindings.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【1】更新服务所在进程的 oomAdj！</span></span><br><span class="line">        mAm.updateOomAdjLocked(r.app);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>serviceDoneExecutingLocked 方法的调用时机主要是在：</p>
<ul>
<li>执行启动 Service 等等一些操作时抛出异</li>
<li>服务所在进程死亡时；</li>
<li>bind 操作完成后；</li>
<li>unbind 操作完成后等等！</li>
</ul>
<h3 id="2-2-7-removeConnectionLocked"><a href="#2-2-7-removeConnectionLocked" class="headerlink" title="2.2.7 removeConnectionLocked"></a>2.2.7 removeConnectionLocked</h3><p><strong>ActiveServices.removeConnectionLocked</strong>：当我们要移除对一个服务的绑定的时候，会触发该方法，以下是关键代码段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s.app != <span class="keyword">null</span> &amp;&amp; s.app.thread != <span class="keyword">null</span> &amp;&amp; b.intent.apps.size() == <span class="number">0</span></span><br><span class="line">        &amp;&amp; b.intent.hasBound) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        bumpServiceExecutingLocked(s, <span class="keyword">false</span>, <span class="string">"unbind"</span>);</span><br><span class="line">        <span class="keyword">if</span> (b.client != s.app &amp;&amp; (c.flags&amp;Context.BIND_WAIVE_PRIORITY) == <span class="number">0</span></span><br><span class="line">                &amp;&amp; s.app.setProcState &lt;= ActivityManager.PROCESS_STATE_RECEIVER) &#123;</span><br><span class="line">            mAm.updateLruProcessLocked(s.app, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【1】更新进程的 oomAdj 的值！</span></span><br><span class="line">        mAm.updateOomAdjLocked(s.app);</span><br><span class="line">        b.intent.hasBound = <span class="keyword">false</span>;</span><br><span class="line">        b.intent.doRebind = <span class="keyword">false</span>;</span><br><span class="line">        s.app.thread.scheduleUnbindService(s, b.intent.intent.getIntent());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"Exception when unbinding service "</span> + s.shortName, e);</span><br><span class="line">        serviceProcessGoneLocked(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>removeConnectionLocked 的调用时机如下：</p>
<ul>
<li><p><strong>killServicesLocked</strong>：当我们要杀掉某个应用进程的时候，我们会解除该进程对其他进程中服务的绑定：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Clean up any connections this application has to other services.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = app.connections.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    ConnectionRecord r = app.connections.valueAt(i);</span><br><span class="line">    removeConnectionLocked(r, app, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>cleanUpActivityServicesLocked</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (r.connections != <span class="keyword">null</span>) &#123;</span><br><span class="line">    Iterator&lt;ConnectionRecord&gt; it = r.connections.iterator();</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        ConnectionRecord c = it.next();</span><br><span class="line">        <span class="comment">// 移除该绑定关系！</span></span><br><span class="line">        mService.mServices.removeConnectionLocked(c, <span class="keyword">null</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">    r.connections = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>unbindServiceLocked: 当我们要接触绑定某个服务的时候，会调用 removeConnectionLocked，断开连接！</p>
</li>
</ul>
<h3 id="2-5-8-setServiceForegroundLocked"><a href="#2-5-8-setServiceForegroundLocked" class="headerlink" title="2.5.8 setServiceForegroundLocked"></a>2.5.8 setServiceForegroundLocked</h3><p>ActiveServices.setServiceForegroundLocked：用于将一个服务设置为前台，关键代码段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ServiceRecord r = findServiceLocked(className, token, userId);</span><br><span class="line"><span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (id != <span class="number">0</span>) &#123;</span><br><span class="line">        ... ... ...</span><br><span class="line">        <span class="keyword">if</span> (r.app != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//【1】设置服务为前台</span></span><br><span class="line">            updateServiceForegroundLocked(r.app, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ... ... ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (r.isForeground) &#123;</span><br><span class="line">            r.isForeground = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (r.app != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mAm.updateLruProcessLocked(r.app, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">                <span class="comment">//【2】设置服务为前台</span></span><br><span class="line">                updateServiceForegroundLocked(r.app, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ... ... ... ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 updateServiceForegroundLocked 方法中，会调用：AMS.updateProcessForegroundLocked 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateServiceForegroundLocked</span><span class="params">(ProcessRecord proc, <span class="keyword">boolean</span> oomAdj)</span> </span>&#123;</span><br><span class="line">    ... ... ... ...</span><br><span class="line">    <span class="comment">//【1】更新前台进程的优先级；</span></span><br><span class="line">    mAm.updateProcessForegroundLocked(proc, anyForeground, oomAdj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AMS.updateProcessForegroundLocked 中会根据第三个参数是否为 true 来设置进程的 oomAdj：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">updateProcessForegroundLocked</span><span class="params">(ProcessRecord proc, <span class="keyword">boolean</span> isForeground,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> oomAdj)</span> </span>&#123;</span><br><span class="line">        ... ... ... ...</span><br><span class="line">        <span class="keyword">if</span> (oomAdj) &#123;</span><br><span class="line">            <span class="comment">//【1】调整 oomAdj！</span></span><br><span class="line">            updateOomAdjLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更新所有进程的 oomAdj 的值！</p>
<p>这里我们来说一下 updateProcessForegroundLocked，我们设置一个服务为前台，实际上是设置其所在的进程为前台进程，updateProcessForegroundLocked 的调用有多处，但只有在 setServiceForegroundLocked 方法的调用链中，boolean oomAdj 为 true！！</p>
<h2 id="2-3-broadcast-调整"><a href="#2-3-broadcast-调整" class="headerlink" title="2.3 broadcast 调整"></a>2.3 broadcast 调整</h2><p>和 broadcast 相关的调整代码主要是在 BroadcastQueue.java 中：</p>
<h3 id="2-3-1-processNextBroadcast"><a href="#2-3-1-processNextBroadcast" class="headerlink" title="2.3.1 processNextBroadcast"></a>2.3.1 processNextBroadcast</h3><p>BroadcastQueue.processNextBroadcast: 发送下一个广播，以下是关键代码段：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mOrderedBroadcasts.size() == <span class="number">0</span>) &#123;</span><br><span class="line">    mService.scheduleAppGcsLocked();</span><br><span class="line">    <span class="comment">//【1】在处理完最后一个有序广播队列中的广播后，会更新所有进程的 oomAdj！</span></span><br><span class="line">    <span class="keyword">if</span> (looped) &#123;</span><br><span class="line">        mService.updateOomAdjLocked();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>只针对有序发送的广播！</p>
<h3 id="2-3-2-processCurBroadcastLocked"><a href="#2-3-2-processCurBroadcastLocked" class="headerlink" title="2.3.2 processCurBroadcastLocked"></a>2.3.2 processCurBroadcastLocked</h3><p>BroadcastQueue.processCurBroadcastLocked: 处理当前广播，以下是关键代码段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">r.receiver = app.thread.asBinder();</span><br><span class="line">r.curApp = app;</span><br><span class="line">app.curReceiver = r;</span><br><span class="line"><span class="comment">//【1】更新进程的状态！</span></span><br><span class="line">app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_RECEIVER);</span><br><span class="line"><span class="comment">//【2】更新 LRU 进程列表！</span></span><br><span class="line">mService.updateLruProcessLocked(app, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//【3】更新所有进程的 oomAdj 值！</span></span><br><span class="line">mService.updateOomAdjLocked();</span><br></pre></td></tr></table></figure>
<p>只针对有序发送的广播！</p>
<h3 id="2-3-3-deliverToRegisteredReceiverLocked"><a href="#2-3-3-deliverToRegisteredReceiverLocked" class="headerlink" title="2.3.3 deliverToRegisteredReceiverLocked"></a>2.3.3 deliverToRegisteredReceiverLocked</h3><p>BroadcastQueue.deliverToRegisteredReceiverLocked: 分发已注册的广播，以下是关键代码段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ordered) &#123; <span class="comment">// 只针对有序发送的广播！</span></span><br><span class="line">    r.receiver = filter.receiverList.receiver.asBinder();</span><br><span class="line">    r.curFilter = filter;</span><br><span class="line">    filter.receiverList.curBroadcast = r;</span><br><span class="line">    r.state = BroadcastRecord.CALL_IN_RECEIVE;</span><br><span class="line">    <span class="keyword">if</span> (filter.receiverList.app != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//【1】r.curApp 表示要接受该广播的目标进程！</span></span><br><span class="line">        r.curApp = filter.receiverList.app;</span><br><span class="line">        filter.receiverList.app.curReceiver = r;</span><br><span class="line">        <span class="comment">//【2】更新目标进程的 oomAdj！</span></span><br><span class="line">        mService.updateOomAdjLocked(r.curApp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只针对有序发送的广播，只针对指定的目标进程！</p>
<h2 id="2-4-ContentProvider-调整"><a href="#2-4-ContentProvider-调整" class="headerlink" title="2.4 ContentProvider 调整"></a>2.4 ContentProvider 调整</h2><p>和 ContentProvider 相关的调整代码主要是在 ActivityManagerService.java 中：</p>
<h3 id="2-4-1-removeContentProviderXXX"><a href="#2-4-1-removeContentProviderXXX" class="headerlink" title="2.4.1 removeContentProviderXXX"></a>2.4.1 removeContentProviderXXX</h3><p>ActivityManagerService.removeContentProvider: 移除 provider，关键代码段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//【1】如果该 provider 没有其他人在使用，就会返回 true！</span></span><br><span class="line"><span class="keyword">if</span> (decProviderCountLocked(conn, <span class="keyword">null</span>, <span class="keyword">null</span>, stable)) &#123;</span><br><span class="line">    <span class="comment">//【1】更新所有进程的 oomAdj 值！</span></span><br><span class="line">    updateOomAdjLocked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更新所有进程的 oomAdj 值！</p>
<p>ActivityManagerService.removeContentProviderExternalUnchecked: 移除 provider，关键代码段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//【1】当 contentProvier 有扩展进程的引用，并且引用均被移除，更新所有进程的 oomAdj 值！</span></span><br><span class="line"><span class="keyword">if</span> (localCpr.hasExternalProcessHandles()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (localCpr.removeExternalProcessHandleLocked(token)) &#123;</span><br><span class="line">        <span class="comment">//【1.1】更新所有进程的 oomAdj 值！</span></span><br><span class="line">        updateOomAdjLocked();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Slog.e(TAG, <span class="string">"Attmpt to remove content provider "</span> + localCpr</span><br><span class="line">                + <span class="string">" with no external reference for token: "</span></span><br><span class="line">                + token + <span class="string">"."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Slog.e(TAG, <span class="string">"Attmpt to remove content provider: "</span> + localCpr</span><br><span class="line">            + <span class="string">" with no external references."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更新所有进程的 oomAdj 值！</p>
<h3 id="2-4-2-publishContentProviders"><a href="#2-4-2-publishContentProviders" class="headerlink" title="2.4.2 publishContentProviders"></a>2.4.2 publishContentProviders</h3><p>ActivityManagerService.publishContentProviders: 发布 provider，关键代码段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> N = providers.size();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">    ContentProviderHolder src = providers.get(i);</span><br><span class="line">    <span class="keyword">if</span> (src == <span class="keyword">null</span> || src.info == <span class="keyword">null</span> || src.provider == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ContentProviderRecord dst = r.pubProviders.get(src.info.name);</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_MU) Slog.v(TAG_MU, <span class="string">"ContentProviderRecord uid = "</span> + dst.uid);</span><br><span class="line">    <span class="keyword">if</span> (dst != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ComponentName comp = <span class="keyword">new</span> ComponentName(dst.info.packageName, dst.info.name);</span><br><span class="line">        mProviderMap.putProviderByClass(comp, dst);</span><br><span class="line">        String names[] = dst.info.authority.split(<span class="string">";"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; names.length; j++) &#123;</span><br><span class="line">            mProviderMap.putProviderByName(names[j], dst);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ... ... ... ...<span class="comment">// 处理 mLaunchingProviders</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (dst) &#123;</span><br><span class="line">            dst.provider = src.provider;</span><br><span class="line">            dst.proc = r;</span><br><span class="line">            dst.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【1】更新指定进程的 oomAdj！</span></span><br><span class="line">        updateOomAdjLocked(r);</span><br><span class="line">        maybeUpdateProviderUsageStatsLocked(r, src.info.packageName,</span><br><span class="line">                src.info.authority);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更新指定进程的 oomAdj！</p>
<h3 id="2-4-3-getContentProviderImpl"><a href="#2-4-3-getContentProviderImpl" class="headerlink" title="2.4.3 getContentProviderImpl"></a>2.4.3 getContentProviderImpl</h3><p>ActivityManagerService.getContentProviderImpl: 获取 provider，下面是关键代码段！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">... ... ... ...</span><br><span class="line"><span class="comment">//【1】更新 provider 所在进程的 adj！</span></span><br><span class="line"><span class="keyword">boolean</span> success = updateOomAdjLocked(cpr.proc);</span><br><span class="line">... ... ... ...</span><br></pre></td></tr></table></figure>
<p>provider 所在进程的 adj！</p>
<p>关于 ContentProvider，我会单独开一个系列来分析</p>
<h2 id="2-5-Process-调整"><a href="#2-5-Process-调整" class="headerlink" title="2.5 Process 调整"></a>2.5 Process 调整</h2><p>和 Process 相关的调整代码主要是在 ActivityManagerService.java 中:</p>
<h3 id="2-5-1-setSystemProcess"><a href="#2-5-1-setSystemProcess" class="headerlink" title="2.5.1 setSystemProcess"></a>2.5.1 setSystemProcess</h3><p>ActivityManagerService.setSystemProcess: 创建并设置系统进程，以下是关键代码段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="comment">// 创建系统进程对应的 ProcessRecord，并设置其为 persistent 类型的进程！</span></span><br><span class="line">    ProcessRecord app = newProcessRecordLocked(info, info.processName, <span class="keyword">false</span>, <span class="number">0</span>);</span><br><span class="line">    app.persistent = <span class="keyword">true</span>;</span><br><span class="line">    app.pid = MY_PID;</span><br><span class="line">    <span class="comment">// 设置系统进程的 maxAdj 为 SYSTEM_ADJ！</span></span><br><span class="line">    app.maxAdj = ProcessList.SYSTEM_ADJ;</span><br><span class="line">    app.makeActive(mSystemThread.getApplicationThread(), mProcessStats);</span><br><span class="line">    <span class="keyword">synchronized</span> (mPidsSelfLocked) &#123;</span><br><span class="line">        mPidsSelfLocked.put(app.pid, app);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 加入到 lru process 列表中！</span></span><br><span class="line">    updateLruProcessLocked(app, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 更新所有进程的 adj 值！</span></span><br><span class="line">    updateOomAdjLocked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更新所有进程的 <code>adj</code> 值！</p>
<h3 id="2-5-2-addAppLocked"><a href="#2-5-2-addAppLocked" class="headerlink" title="2.5.2 addAppLocked"></a>2.5.2 addAppLocked</h3><p>ActivityManagerService.addAppLocked: 创建 persistent 进程，以下是关键代码段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//【1】当该进程第一次或者重新创建时，会更新所有进程的 oomAdj！</span></span><br><span class="line"><span class="keyword">if</span> (app == <span class="keyword">null</span>) &#123;</span><br><span class="line">    app = newProcessRecordLocked(info, <span class="keyword">null</span>, isolated, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//【1.1】更新 lru 进程列表；</span></span><br><span class="line">    updateLruProcessLocked(app, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//【1.2】更新进程 oomAdj；</span></span><br><span class="line">    updateOomAdjLocked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更新所有进程的 oomAdj！</p>
<h3 id="2-5-3-attachApplicationLocked"><a href="#2-5-3-attachApplicationLocked" class="headerlink" title="2.5.3 attachApplicationLocked"></a>2.5.3 attachApplicationLocked</h3><p>ActivityManagerService.attachApplicationLocked: 进程创建后 attach 到 system_server 的过程，以下是关键代码段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">... ... ... ...</span><br><span class="line"><span class="keyword">if</span> (badApp) &#123;</span><br><span class="line">    app.kill(<span class="string">"error during init"</span>, <span class="keyword">true</span>);</span><br><span class="line">    handleAppDiedLocked(app, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//【1】didSomething 表示我们在启动进程后是否执行了启动组件的操作</span></span><br><span class="line"><span class="comment">// 如果有 didSomething 就为 true，那就不需要在这里更新了，因为组件启动过程会有更新的操作！</span></span><br><span class="line"><span class="keyword">if</span> (!didSomething) &#123;</span><br><span class="line">    updateOomAdjLocked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更新所有进程的 adj 值！</p>
<h3 id="2-5-4-trimApplications"><a href="#2-5-4-trimApplications" class="headerlink" title="2.5.4 trimApplications"></a>2.5.4 trimApplications</h3><p>ActivityManagerService.trimApplications: 回收应用程序内存，以下是关键代码段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理所有要被移除的进程，回收资源！</span></span><br><span class="line"><span class="keyword">for</span> (i = mRemovedProcesses.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">    <span class="keyword">final</span> ProcessRecord app = mRemovedProcesses.get(i);</span><br><span class="line">    <span class="keyword">if</span> (app.activities.size() == <span class="number">0</span></span><br><span class="line">            &amp;&amp; app.curReceiver == <span class="keyword">null</span> &amp;&amp; app.services.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (app.pid &gt; <span class="number">0</span> &amp;&amp; app.pid != MY_PID) &#123;</span><br><span class="line">            app.kill(<span class="string">"empty"</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                app.thread.scheduleExit();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cleanUpApplicationRecordLocked(app, <span class="keyword">false</span>, <span class="keyword">true</span>, -<span class="number">1</span>, <span class="keyword">false</span> <span class="comment">/*replacingPid*/</span>);</span><br><span class="line">        mRemovedProcesses.remove(i);</span><br><span class="line">        <span class="comment">//【1】如果该进程是 persistent，那就要 addAppLocked！</span></span><br><span class="line">        <span class="keyword">if</span> (app.persistent) &#123;</span><br><span class="line">            addAppLocked(app.info, <span class="keyword">false</span>, <span class="keyword">null</span> <span class="comment">/* ABI override */</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//【2】更新所有进程的 oomAdj！</span></span><br><span class="line">updateOomAdjLocked();</span><br></pre></td></tr></table></figure>
<p>更新所有进程的 oomAdj！</p>
<h3 id="2-5-5-appDiedLocked"><a href="#2-5-5-appDiedLocked" class="headerlink" title="2.5.5 appDiedLocked"></a>2.5.5 appDiedLocked</h3><p>ActivityManagerService.appDiedLocked：进程死亡，以下是关键代码段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示进程被重启了！</span></span><br><span class="line"><span class="keyword">if</span> (app.pid == pid &amp;&amp; app.thread != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">         app.thread.asBinder() == thread.asBinder()) &#123;</span><br><span class="line">     <span class="keyword">boolean</span> doLowMem = app.instrumentationClass == <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">boolean</span> doOomAdj = doLowMem;</span><br><span class="line">     <span class="keyword">if</span> (!app.killedByAm) &#123;</span><br><span class="line">         Slog.i(TAG, <span class="string">"Process "</span> + app.processName + <span class="string">" (pid "</span> + pid</span><br><span class="line">                 + <span class="string">") has died"</span>);</span><br><span class="line">         mAllowLowerMemLevel = <span class="keyword">true</span>;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// Note that we always want to do oom adj to update our state with the</span></span><br><span class="line">         <span class="comment">// new number of procs.</span></span><br><span class="line">         mAllowLowerMemLevel = <span class="keyword">false</span>;</span><br><span class="line">         doLowMem = <span class="keyword">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     EventLog.writeEvent(EventLogTags.AM_PROC_DIED, app.userId, app.pid, app.processName);</span><br><span class="line">     <span class="keyword">if</span> (DEBUG_CLEANUP) Slog.v(TAG_CLEANUP,</span><br><span class="line">         <span class="string">"Dying app: "</span> + app + <span class="string">", pid: "</span> + pid + <span class="string">", thread: "</span> + thread.asBinder());</span><br><span class="line">     handleAppDiedLocked(app, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (doOomAdj) &#123;</span><br><span class="line">         <span class="comment">//【1】更新所有进程的 oomAdj！</span></span><br><span class="line">         updateOomAdjLocked();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (doLowMem) &#123;</span><br><span class="line">         doLowMemReportIfNeededLocked(app);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (app.pid != pid) &#123;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>更新所有进程的 oomAdj！</p>
<h3 id="2-5-6-killAllBackgroundProcesses"><a href="#2-5-6-killAllBackgroundProcesses" class="headerlink" title="2.5.6 killAllBackgroundProcesses"></a>2.5.6 killAllBackgroundProcesses</h3><p>ActivityManagerService.killAllBackgroundProcesses: 杀死所有后台进程，以下是关键代码段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> ArrayList&lt;ProcessRecord&gt; procs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> NP = mProcessNames.getMap().size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> ip = <span class="number">0</span>; ip &lt; NP; ip++) &#123;</span><br><span class="line">        <span class="keyword">final</span> SparseArray&lt;ProcessRecord&gt; apps = mProcessNames.getMap().valueAt(ip);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> NA = apps.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> ia = <span class="number">0</span>; ia &lt; NA; ia++) &#123;</span><br><span class="line">            <span class="keyword">final</span> ProcessRecord app = apps.valueAt(ia);</span><br><span class="line">            <span class="comment">//【1】跳过 persistent 进程！</span></span><br><span class="line">            <span class="keyword">if</span> (app.persistent) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//【2】杀死 removed 为 ture 的进程</span></span><br><span class="line">            <span class="keyword">if</span> (app.removed) &#123;</span><br><span class="line">                procs.add(app);</span><br><span class="line">            <span class="comment">//【3】杀死 adj &gt;= CACHED_APP_MIN_ADJ 的进程！</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (app.setAdj &gt;= ProcessList.CACHED_APP_MIN_ADJ) &#123;</span><br><span class="line">                app.removed = <span class="keyword">true</span>;</span><br><span class="line">                procs.add(app);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【4】杀死上述两种进程！</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> N = procs.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        removeProcessLocked(procs.get(i), <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="string">"kill all background"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mAllowLowerMemLevel = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【5】更新了所有进程</span></span><br><span class="line">    updateOomAdjLocked();</span><br><span class="line">    doLowMemReportIfNeededLocked(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续分析！</p>
<h3 id="2-5-7-killPackageProcessesLocked"><a href="#2-5-7-killPackageProcessesLocked" class="headerlink" title="2.5.7 killPackageProcessesLocked"></a>2.5.7 killPackageProcessesLocked</h3><p><code>ActivityManagerService.killPackageProcessesLocked</code>: 杀掉指定包名相关的进程，以下是关键代码段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">... ... ...<span class="comment">// 收集需要被杀掉的进程，这里就列出了！</span></span><br><span class="line"><span class="keyword">int</span> N = procs.size();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">    removeProcessLocked(procs.get(i), callerWillRestart, allowRestart, reason);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调整所有进程的 oomAdj！</span></span><br><span class="line">updateOomAdjLocked();</span><br></pre></td></tr></table></figure>
<p>调整所有进程的 oomAdj！</p>
<h3 id="2-5-8-setProcessForeground"><a href="#2-5-8-setProcessForeground" class="headerlink" title="2.5.8 setProcessForeground"></a>2.5.8 setProcessForeground</h3><p><code>ActivityManagerService.setProcessForeground</code>：设置进程为前台进程，下面是关键代码片段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里的 isForeground 是 setProcessForeground 的参数，表示是否为前台进程！</span></span><br><span class="line"><span class="keyword">synchronized</span> (mPidsSelfLocked) &#123;</span><br><span class="line">    <span class="comment">// 获得 pid 对应的进程！</span></span><br><span class="line">    ProcessRecord pr = mPidsSelfLocked.get(pid);</span><br><span class="line">    <span class="keyword">if</span> (pr == <span class="keyword">null</span> &amp;&amp; isForeground) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"setProcessForeground called on unknown pid: "</span> + pid);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获得该进程对应的前台 token，如果不为 null，说明该进程已经是前台进程</span></span><br><span class="line">    <span class="comment">// 那就要先移除旧的 token！</span></span><br><span class="line">    ForegroundToken oldToken = mForegroundProcesses.get(pid);</span><br><span class="line">    <span class="keyword">if</span> (oldToken != <span class="keyword">null</span>) &#123;</span><br><span class="line">        oldToken.token.unlinkToDeath(oldToken, <span class="number">0</span>); <span class="comment">// 解除绑定死亡仆告对象！</span></span><br><span class="line">        mForegroundProcesses.remove(pid);</span><br><span class="line">        <span class="keyword">if</span> (pr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pr.forcingToForeground = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        changed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果 isForeground 为 true，且 token 不为 null，这里的</span></span><br><span class="line">    <span class="keyword">if</span> (isForeground &amp;&amp; token != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ForegroundToken newToken = <span class="keyword">new</span> ForegroundToken() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">binderDied</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                foregroundTokenDied(<span class="keyword">this</span>); <span class="comment">// 当 binder 对象死亡后，该方法会被调用！</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        newToken.pid = pid; <span class="comment">// 设置 newToken 的 pid 和 token！</span></span><br><span class="line">        newToken.token = token;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            token.linkToDeath(newToken, <span class="number">0</span>); <span class="comment">// 给 token 绑定死亡仆告对象！</span></span><br><span class="line">            mForegroundProcesses.put(pid, newToken); <span class="comment">// 将该进程加入到 mForegroundProcesses 列表中！</span></span><br><span class="line">            pr.forcingToForeground = token;</span><br><span class="line">            changed = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (changed) &#123; <span class="comment">// 当我们设置了一个进程为前台进程，我们需要更新所有进程的 oomAdj！</span></span><br><span class="line">    updateOomAdjLocked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调整所有进程的 <code>oomAdj</code>！</p>
<p>首先我说下 <code>ForegroundToken</code>，表示一个前台句柄，其内部有一个 <code>token</code> 对象，该对象是一个 <code>Binder</code> 对象！当我们设置了一个进程为前台进程后，每个进程都会有一个 <code>token</code> 对象！</p>
<p>其使用场景是，弹出 <code>Toast</code>，当一个进程中会弹出 <code>Toast</code> 后，该进程会被设置为前台进程，就会触发 <code>setProcessForeground</code> 方法！<code>token</code> 对象定义是在 <code>NotificationManagerService</code> 中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> IBinder mForegroundToken = <span class="keyword">new</span> Binder();</span><br></pre></td></tr></table></figure>
<p>再说一下：<code>ForegroundToken.binderDied</code> 方法，当 <code>token</code> 死亡后，其会被调用，从而触发 <code>foregroundTokenDied</code>!</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foregroundTokenDied</span><span class="params">(ForegroundToken token)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (ActivityManagerService.<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mPidsSelfLocked) &#123;</span><br><span class="line">            ForegroundToken cur</span><br><span class="line">                = mForegroundProcesses.get(token.pid);</span><br><span class="line">            <span class="keyword">if</span> (cur != token) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mForegroundProcesses.remove(token.pid);</span><br><span class="line">            ProcessRecord pr = mPidsSelfLocked.get(token.pid);</span><br><span class="line">            <span class="keyword">if</span> (pr == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pr.forcingToForeground = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 更新前台进程信息！</span></span><br><span class="line">            updateProcessForegroundLocked(pr, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新进程的 oomAdj</span></span><br><span class="line">        updateOomAdjLocked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调整所有进程的 <code>oomAdj</code>！</p>
<h3 id="2-5-9-setHasTopUi"><a href="#2-5-9-setHasTopUi" class="headerlink" title="2.5.9 setHasTopUi"></a>2.5.9 setHasTopUi</h3><p><code>ActivityManagerService.setHasTopUi</code>：设置进程是否具有 <code>top ui</code>！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHasTopUi</span><span class="params">(<span class="keyword">boolean</span> hasTopUi)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    <span class="comment">// 检查 permission.INTERNAL_SYSTEM_WINDOW 权限！</span></span><br><span class="line">    <span class="keyword">if</span> (checkCallingPermission(permission.INTERNAL_SYSTEM_WINDOW) != PERMISSION_GRANTED) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> pid = Binder.getCallingPid();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> changed = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 获得 pid 对应的进程！</span></span><br><span class="line">            ProcessRecord pr;</span><br><span class="line">            <span class="keyword">synchronized</span> (mPidsSelfLocked) &#123;</span><br><span class="line">                pr = mPidsSelfLocked.get(pid);</span><br><span class="line">                <span class="keyword">if</span> (pr == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Slog.w(TAG, <span class="string">"setHasTopUi called on unknown pid: "</span> + pid);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 判断进程的 hasTopUi 是否发生变化！</span></span><br><span class="line">                <span class="keyword">if</span> (pr.hasTopUi != hasTopUi) &#123;</span><br><span class="line">                    Slog.i(TAG, <span class="string">"Setting hasTopUi="</span> + hasTopUi + <span class="string">" for pid="</span> + pid);</span><br><span class="line">                    pr.hasTopUi = hasTopUi;</span><br><span class="line">                    changed = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 发生了变化，那就更新该进程的 oomAdj！</span></span><br><span class="line">            <span class="keyword">if</span> (changed) &#123;</span><br><span class="line">                updateOomAdjLocked(pr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只更新特定进程的 <code>oomAdj</code>！</p>
<p>该方法主要是在状态栏使用，具体的代码在 <code>StatusBarWindowManager.apply</code> 方法中，以下是关键代码！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(State state)</span> </span>&#123;</span><br><span class="line">    ... ... ...</span><br><span class="line">    <span class="keyword">if</span> (mHasTopUi != mHasTopUiChanged) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mActivityManager.setHasTopUi(mHasTopUiChanged);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">"Failed to call setHasTopUi"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        mHasTopUi = mHasTopUiChanged;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-5-10-updateSleepIfNeededLocked"><a href="#2-5-10-updateSleepIfNeededLocked" class="headerlink" title="2.5.10 updateSleepIfNeededLocked"></a>2.5.10 updateSleepIfNeededLocked</h3><p><code>ActivityManagerService.updateSleepIfNeededLocked</code>：更新睡眠状态！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateSleepIfNeededLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mSleeping &amp;&amp; !shouldSleepLocked()) &#123; <span class="comment">// 退出休眠时！</span></span><br><span class="line">        mSleeping = <span class="keyword">false</span>;</span><br><span class="line">        startTimeTrackingFocusedActivityLocked();</span><br><span class="line">        mTopProcessState = ActivityManager.PROCESS_STATE_TOP;</span><br><span class="line">        mStackSupervisor.comeOutOfSleepIfNeededLocked();</span><br><span class="line">        <span class="comment">// 更新服务的 oomAdj！</span></span><br><span class="line">        updateOomAdjLocked();</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!mSleeping &amp;&amp; shouldSleepLocked()) &#123; <span class="comment">// 进入休眠时！</span></span><br><span class="line">        mSleeping = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (mCurAppTimeTracker != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mCurAppTimeTracker.stop();</span><br><span class="line">        &#125;</span><br><span class="line">        mTopProcessState = ActivityManager.PROCESS_STATE_TOP_SLEEPING;</span><br><span class="line">        mStackSupervisor.goingToSleepLocked();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新服务的 oomAdj！</span></span><br><span class="line">        updateOomAdjLocked();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Initialize the wake times of all processes.</span></span><br><span class="line">        checkExcessivePowerUsageLocked(<span class="keyword">false</span>);</span><br><span class="line">        mHandler.removeMessages(CHECK_EXCESSIVE_WAKE_LOCKS_MSG);</span><br><span class="line">        Message nmsg = mHandler.obtainMessage(CHECK_EXCESSIVE_WAKE_LOCKS_MSG);</span><br><span class="line">        mHandler.sendMessageDelayed(nmsg, POWER_CHECK_DELAY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更新所有服务的 <code>oomAdj</code>！</p>
<h2 id="2-6-总结"><a href="#2-6-总结" class="headerlink" title="2.6 总结"></a>2.6 总结</h2><p>下面我用思维导图总结下，<code>updateOomAdjLocked</code> 的调用时机，当然了，随着版本的更替，代码逻辑和调用机制势必会发生变化，但是，<strong>已有的架构和逻辑依然具有很强的参考性</strong>，也能帮助我们在新的版本上快速建立代价整体结构的认识！！</p>
<h1 id="3-oomAdj-算法分析"><a href="#3-oomAdj-算法分析" class="headerlink" title="3 oomAdj 算法分析"></a>3 oomAdj 算法分析</h1><p>接下来，我们就要分析下 <code>oomAdj</code> 调度的核心算法了，我们从 <code>updateOomAdjLocked</code> 方法入手，我们先从最简单的一参函数看起：</p>
<h2 id="3-1-1-ActivityManagerS-updateOomAdjLocked-更新指定进程-oomAdj"><a href="#3-1-1-ActivityManagerS-updateOomAdjLocked-更新指定进程-oomAdj" class="headerlink" title="3.1 [1]ActivityManagerS.updateOomAdjLocked - 更新指定进程 oomAdj"></a>3.1 [1]ActivityManagerS.updateOomAdjLocked - 更新指定进程 oomAdj</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">updateOomAdjLocked</span><span class="params">(ProcessRecord app)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获得 top activity 以及其所在的进程 top process！</span></span><br><span class="line">    <span class="keyword">final</span> ActivityRecord TOP_ACT = resumedAppLocked();</span><br><span class="line">    <span class="keyword">final</span> ProcessRecord TOP_APP = TOP_ACT != <span class="keyword">null</span> ? TOP_ACT.app : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该进程是否是缓存进程！</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> wasCached = app.cached;</span><br><span class="line"></span><br><span class="line">    mAdjSeq++; <span class="comment">// adj 序列计数加 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】计算 cahce 状态的 adj</span></span><br><span class="line">    <span class="comment">// 如果我们知道，我们的目标进程是处于缓存状态，那么我们返回 app.curRawAdj，否则</span></span><br><span class="line">    <span class="comment">// 我们不能确定其 adj 的值，设置其为 UNKNOWN_ADJ</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> cachedAdj = app.curRawAdj &gt;= ProcessList.CACHED_APP_MIN_ADJ</span><br><span class="line">            ? app.curRawAdj : ProcessList.UNKNOWN_ADJ;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【2】更新指定进程的 oomAdj 的值，调用 5 个参数的 updateOomAdjLocked 方法，具体见[3.2]；       </span></span><br><span class="line">    <span class="keyword">boolean</span> success = updateOomAdjLocked(app, cachedAdj, TOP_APP, <span class="keyword">false</span>,</span><br><span class="line">            SystemClock.uptimeMillis());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【3】如果进程的从非缓存状态变为了缓存状态，或者相反，我们也要更新 lru 列表中其他进程的 adj！</span></span><br><span class="line">    <span class="keyword">if</span> (wasCached != app.cached || app.curRawAdj == ProcessList.UNKNOWN_ADJ) &#123;</span><br><span class="line">        updateOomAdjLocked();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更新指定进程的 <code>oomAdj</code>，被更新的进程的 <code>app.adjSeq</code> 值会等于 <code>mAdjSeq</code>，这个我们后续再看！</p>
<p>对于 <code>cachedAdj</code> 的取值范围：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNKNOWN_ADJ = <span class="number">1001</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CACHED_APP_MIN_ADJ = <span class="number">900</span>;</span><br></pre></td></tr></table></figure>
<p>该方法主要功能：</p>
<ul>
<li>执行五参 <code>updateOomAdjLocked</code>，更新指定进程的 <code>adj</code>；</li>
<li>当 <code>app</code> 经过更新 <code>adj</code> 操作后，其 <code>cached</code> 状态改变，或者 <code>curRawAdj=UNKNOWN_ADJ</code>，则执行空参 <code>updateOomAdjLocked</code>，更新所有进程的<code>adj</code>；</li>
</ul>
<p>继续来看：</p>
<h3 id="3-1-1-ActivityManagerS-resumedAppLocked"><a href="#3-1-1-ActivityManagerS-resumedAppLocked" class="headerlink" title="3.1.1 ActivityManagerS.resumedAppLocked"></a>3.1.1 ActivityManagerS.resumedAppLocked</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> ActivityRecord <span class="title">resumedAppLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获得当前的 top activity！</span></span><br><span class="line">    ActivityRecord act = mStackSupervisor.resumedAppLocked();</span><br><span class="line">    String pkg;</span><br><span class="line">    <span class="keyword">int</span> uid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//　获得 top activity 的 uid 和 package！</span></span><br><span class="line">    <span class="keyword">if</span> (act != <span class="keyword">null</span>) &#123;</span><br><span class="line">        pkg = act.packageName;</span><br><span class="line">        uid = act.info.applicationInfo.uid;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pkg = <span class="keyword">null</span>;</span><br><span class="line">        uid = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Has the UID or resumed package name changed?</span></span><br><span class="line">    <span class="comment">// 更新一下　mCurResumedUid 和 mCurResumedPackage</span></span><br><span class="line">    <span class="keyword">if</span> (uid != mCurResumedUid || (pkg != mCurResumedPackage</span><br><span class="line">            &amp;&amp; (pkg == <span class="keyword">null</span> || !pkg.equals(mCurResumedPackage)))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCurResumedPackage != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mBatteryStatsService.noteEvent(BatteryStats.HistoryItem.EVENT_TOP_FINISH,</span><br><span class="line">                    mCurResumedPackage, mCurResumedUid);</span><br><span class="line">        &#125;</span><br><span class="line">        mCurResumedPackage = pkg;</span><br><span class="line">        mCurResumedUid = uid;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 当前的 current resume pacakge 发生了变化，通知 BatteryStats</span></span><br><span class="line">        <span class="keyword">if</span> (mCurResumedPackage != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mBatteryStatsService.noteEvent(BatteryStats.HistoryItem.EVENT_TOP_START,</span><br><span class="line">                    mCurResumedPackage, mCurResumedUid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> act;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-1-1-1-ActivityStackSupervisor-resumedAppLocked"><a href="#3-1-1-1-ActivityStackSupervisor-resumedAppLocked" class="headerlink" title="3.1.1.1 ActivityStackSupervisor.resumedAppLocked"></a>3.1.1.1 ActivityStackSupervisor.resumedAppLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ActivityRecord <span class="title">resumedAppLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】获得焦点 stack!</span></span><br><span class="line">    ActivityStack stack = mFocusedStack;</span><br><span class="line">    <span class="keyword">if</span> (stack == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【2】获得 resume activity！</span></span><br><span class="line">    ActivityRecord resumedActivity = stack.mResumedActivity;</span><br><span class="line">    <span class="keyword">if</span> (resumedActivity == <span class="keyword">null</span> || resumedActivity.app == <span class="keyword">null</span>) &#123;</span><br><span class="line">        resumedActivity = stack.mPausingActivity;</span><br><span class="line">        <span class="keyword">if</span> (resumedActivity == <span class="keyword">null</span> || resumedActivity.app == <span class="keyword">null</span>) &#123;</span><br><span class="line">            resumedActivity = stack.topRunningActivityLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resumedActivity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们可以看到 <code>resumedActivity</code> 的获取逻辑！</p>
<ul>
<li>首先会焦点 <code>stack</code> 获取 <code>mResumedActivity</code>;</li>
<li>如果 <code>resumedActivity</code> 不存在，那就获取 <code>mPausingActivity</code>;</li>
<li>如果 <code>mPausingActivity</code> 不存在，那就获取 <code>top activity</code>！</li>
</ul>
<h2 id="3-3-0-ActivityManagerS-updateOomAdjLocked-更新-LRU-列表中的所有进程"><a href="#3-3-0-ActivityManagerS-updateOomAdjLocked-更新-LRU-列表中的所有进程" class="headerlink" title="3.3 [0]ActivityManagerS.updateOomAdjLocked - 更新 LRU 列表中的所有进程"></a>3.3 [0]ActivityManagerS.updateOomAdjLocked - 更新 LRU 列表中的所有进程</h2><p>刚才我们看了 <code>updateOomAdjLocked</code> 的一参和多参数方法，用来更新指定的进程的 <code>adj</code>，到那时如果该进程的状态在 <code>cache</code> 和非 <code>cache</code> 之前切换了，那就会更新所有进程的 <code>adj</code> 状态！</p>
<p>这个是最核心的一个方法，方法体很长，我们耐心点来看！！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">updateOomAdjLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】获取 top Activity 以及其所在的 top process!</span></span><br><span class="line">    <span class="keyword">final</span> ActivityRecord TOP_ACT = resumedAppLocked();</span><br><span class="line">    <span class="keyword">final</span> ProcessRecord TOP_APP = TOP_ACT != <span class="keyword">null</span> ? TOP_ACT.app : <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> nowElapsed = SystemClock.elapsedRealtime();</span><br><span class="line">    <span class="comment">// MAX_EMPTY_TIME 表示空进程的存活时长，为 30min！</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> oldTime = now - ProcessList.MAX_EMPTY_TIME;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【2】获得 LRU 进程列表的大小！</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> N = mLruProcesses.size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">        RuntimeException e = <span class="keyword">new</span> RuntimeException();</span><br><span class="line">        e.fillInStackTrace();</span><br><span class="line">        Slog.i(TAG, <span class="string">"updateOomAdj: top="</span> + TOP_ACT, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【3】重置当前所有 active uid 内部记录的进程状态：ActivityManager.PROCESS_STATE_CACHED_EMPTY：16</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=mActiveUids.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">final</span> UidRecord uidRec = mActiveUids.valueAt(i);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">false</span> &amp;&amp; DEBUG_UID_OBSERVERS) Slog.i(TAG_UID_OBSERVERS,</span><br><span class="line">                <span class="string">"Starting update of "</span> + uidRec);</span><br><span class="line">        uidRec.reset();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【4】给所有的 task 排序，更新 task 的 mLayerRank 变量！</span></span><br><span class="line">    mStackSupervisor.rankTaskLayersIfNeeded();</span><br><span class="line"></span><br><span class="line">    mAdjSeq++; <span class="comment">// 更新本次计算序列号 +1</span></span><br><span class="line"></span><br><span class="line">    mNewNumServiceProcs = <span class="number">0</span>; <span class="comment">// 表示最新的服务进程数（更新 adj 后）；</span></span><br><span class="line">    mNewNumAServiceProcs = <span class="number">0</span>; <span class="comment">// 表示最新的 A service 进程数（更新 adj 后）；</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//【5】根据系统空进程和缓存进程的总限制量，计算空进程和缓存进程限制数！！</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> emptyProcessLimit;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> cachedProcessLimit;</span><br><span class="line">    <span class="keyword">if</span> (mProcessLimit &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        emptyProcessLimit = cachedProcessLimit = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mProcessLimit == <span class="number">1</span>) &#123;</span><br><span class="line">        emptyProcessLimit = <span class="number">1</span>;</span><br><span class="line">        cachedProcessLimit = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 调用 ProcessList.computeEmptyProcessLimit 计算空进程限制数，计算方法为：totalProcessLimit(参数) / 2</span></span><br><span class="line">        emptyProcessLimit = ProcessList.computeEmptyProcessLimit(mProcessLimit);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可以得到：</span></span><br><span class="line">        <span class="comment">// 缓存进程限制数 = 空进程限制数 = 总进程限制数 / 2；</span></span><br><span class="line">        cachedProcessLimit = mProcessLimit - emptyProcessLimit;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CACHED_APP_MAX_ADJ 为 906，而 CACHED_APP_MIN_ADJ 为 900，所以计算出的 numSlots 为 3</span></span><br><span class="line">    <span class="comment">// 就是说，我们将 cache adj 划分为 3 个范围，每个范围可以容纳定量的 empty 和 cache 进程！</span></span><br><span class="line">    <span class="keyword">int</span> numSlots = (ProcessList.CACHED_APP_MAX_ADJ</span><br><span class="line">            - ProcessList.CACHED_APP_MIN_ADJ + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算当前空进程的数量：等于所有进程数 N - 非 cache 进程数 - 被隐藏的 cache 进程数！ </span></span><br><span class="line">    <span class="keyword">int</span> numEmptyProcs = N - mNumNonCachedProcs - mNumCachedHiddenProcs;</span><br><span class="line">    <span class="keyword">if</span> (numEmptyProcs &gt; cachedProcessLimit) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 空进程的数量不能超过缓存进程限制数，最大只能和其相等，这是一定的！</span></span><br><span class="line">        numEmptyProcs = cachedProcessLimit;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算空进程分配因子（每个 slot 可以容纳的空进程数量），最高为 1；</span></span><br><span class="line">    <span class="keyword">int</span> emptyFactor = numEmptyProcs / numSlots;</span><br><span class="line">    <span class="keyword">if</span> (emptyFactor &lt; <span class="number">1</span>) emptyFactor = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算缓存进程分配因子（计算出每个 slot 中，可容纳后台进程的数量），最高为 1；</span></span><br><span class="line">    <span class="keyword">int</span> cachedFactor = (mNumCachedHiddenProcs &gt; <span class="number">0</span> ? mNumCachedHiddenProcs : <span class="number">1</span>) / numSlots;</span><br><span class="line">    <span class="keyword">if</span> (cachedFactor &lt; <span class="number">1</span>) cachedFactor = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> stepCached = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> stepEmpty = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numCached = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> numEmpty = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> numTrimming = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    mNumNonCachedProcs = <span class="number">0</span>; <span class="comment">// 用于记录非 cache/empty 进程数，初始化为 0；</span></span><br><span class="line">    mNumCachedHiddenProcs = <span class="number">0</span>; <span class="comment">// 用于记录 cache 进程数，初四化为 0；</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于为 cache 进程和 empty 进程分配 adj！</span></span><br><span class="line">    <span class="keyword">int</span> curCachedAdj = ProcessList.CACHED_APP_MIN_ADJ; <span class="comment">// 900；</span></span><br><span class="line">    <span class="keyword">int</span> nextCachedAdj = curCachedAdj + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> curEmptyAdj = ProcessList.CACHED_APP_MIN_ADJ; <span class="comment">// 900；</span></span><br><span class="line">    <span class="keyword">int</span> nextEmptyAdj = curEmptyAdj + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【8】逆序遍历 mLruProcesses 进程列表，更新每一个进程的 adj！</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=N-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">        ProcessRecord app = mLruProcesses.get(i);</span><br><span class="line">        <span class="keyword">if</span> (!app.killedByAm &amp;&amp; app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            app.procStateChanged = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【8.1】这里调用了 5 个参数的 computeOomAdjLocked 方法，更新指定的进程的 adj</span></span><br><span class="line">            <span class="comment">// 注意这里的 doingAll 参数传入的是 true，具体分析见 3.3.1 节!</span></span><br><span class="line">            computeOomAdjLocked(app, ProcessList.UNKNOWN_ADJ, TOP_APP, <span class="keyword">true</span>, now);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果计算后，仍然没有分配给进程一个合适的 adj，即：app.curAdj &gt;= ProcessList.UNKNOWN_ADJ</span></span><br><span class="line">            <span class="comment">// 那就在这里分配！</span></span><br><span class="line">            <span class="comment">// （computeOomAdjLocked 可能无法计算 cache 进程和 empty 进程的 adj，所以在下面处理！）</span></span><br><span class="line">            <span class="keyword">if</span> (app.curAdj &gt;= ProcessList.UNKNOWN_ADJ) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 根据进程的状态进行处理：</span></span><br><span class="line">                <span class="keyword">switch</span> (app.curProcState) &#123;</span><br><span class="line">                    <span class="keyword">case</span> ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:</span><br><span class="line">                    <span class="keyword">case</span> ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 如果进程是持有 activity 的 cache 进程，或者</span></span><br><span class="line">                        <span class="comment">// 给其分配一个 cache adj！</span></span><br><span class="line">                        <span class="comment">// 从 900 到 906，逐个分配，最大不超过 906！</span></span><br><span class="line">                        app.curRawAdj = curCachedAdj;</span><br><span class="line">                        app.curAdj = app.modifyRawOomAdj(curCachedAdj); <span class="comment">// 此时是单纯的加 1；</span></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (DEBUG_LRU &amp;&amp; <span class="keyword">false</span>) Slog.d(TAG_LRU, <span class="string">"Assigning activity LRU #"</span> + i</span><br><span class="line">                                + <span class="string">" adj: "</span> + app.curAdj + <span class="string">" (curCachedAdj="</span> + curCachedAdj</span><br><span class="line">                                + <span class="string">")"</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (curCachedAdj != nextCachedAdj) &#123;</span><br><span class="line">                            stepCached++;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (stepCached &gt;= cachedFactor) &#123; <span class="comment">// 判断是否到达分配因子！</span></span><br><span class="line">                                stepCached = <span class="number">0</span>; <span class="comment">// stepCached 置为 0，进行下一个 slot 的分配！</span></span><br><span class="line">                                curCachedAdj = nextCachedAdj;</span><br><span class="line">                                nextCachedAdj += <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">if</span> (nextCachedAdj &gt; ProcessList.CACHED_APP_MAX_ADJ) &#123; <span class="comment">// 控制 adj 的不超过最大值！</span></span><br><span class="line">                                    nextCachedAdj = ProcessList.CACHED_APP_MAX_ADJ;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="comment">// 否则，将其视为 empty 进程对待，给其分配一个 empty adj！</span></span><br><span class="line">                        <span class="comment">// 从 900 到 906，逐个分配，最大不超过 906！</span></span><br><span class="line">                        app.curRawAdj = curEmptyAdj;</span><br><span class="line">                        app.curAdj = app.modifyRawOomAdj(curEmptyAdj);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (DEBUG_LRU &amp;&amp; <span class="keyword">false</span>) Slog.d(TAG_LRU, <span class="string">"Assigning empty LRU #"</span> + i</span><br><span class="line">                                + <span class="string">" adj: "</span> + app.curAdj + <span class="string">" (curEmptyAdj="</span> + curEmptyAdj</span><br><span class="line">                                + <span class="string">")"</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (curEmptyAdj != nextEmptyAdj) &#123;</span><br><span class="line">                            stepEmpty++;</span><br><span class="line">                            <span class="keyword">if</span> (stepEmpty &gt;= emptyFactor) &#123;</span><br><span class="line">                                stepEmpty = <span class="number">0</span>;</span><br><span class="line">                                curEmptyAdj = nextEmptyAdj;</span><br><span class="line">                                nextEmptyAdj += <span class="number">2</span>;</span><br><span class="line">                                <span class="keyword">if</span> (nextEmptyAdj &gt; ProcessList.CACHED_APP_MAX_ADJ) &#123;</span><br><span class="line">                                    nextEmptyAdj = ProcessList.CACHED_APP_MAX_ADJ;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//【8.2】分配好后，调用 applyOomAdjLocked 更新进程的 adj，具体分析见 3.3.2 节!</span></span><br><span class="line">            applyOomAdjLocked(app, <span class="keyword">true</span>, now, nowElapsed);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【8.3】根据进程的类型，统计不同类型的进程数量!</span></span><br><span class="line">            <span class="keyword">switch</span> (app.curProcState) &#123;</span><br><span class="line">                <span class="keyword">case</span> ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:</span><br><span class="line">                <span class="keyword">case</span> ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 如果进程是持有 activity 的 cache 进程或者是客户端进程，</span></span><br><span class="line">                    <span class="comment">// 属于 cache 进程，mNumCachedHiddenProcs 加 1!</span></span><br><span class="line">                    mNumCachedHiddenProcs++;</span><br><span class="line">                    numCached++;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 注意，如果当前 cache 进程数量超过了限制量，那就杀掉超过限制的所有进程！</span></span><br><span class="line">                    <span class="comment">// 但是依然统计数量！</span></span><br><span class="line">                    <span class="keyword">if</span> (numCached &gt; cachedProcessLimit) &#123;</span><br><span class="line">                        app.kill(<span class="string">"cached #"</span> + numCached, <span class="keyword">true</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> ActivityManager.PROCESS_STATE_CACHED_EMPTY:</span><br><span class="line">            </span><br><span class="line">                    <span class="comment">// 如果进程是 empty cache 进程，下面的处理！</span></span><br><span class="line">                    <span class="keyword">if</span> (numEmpty &gt; ProcessList.TRIM_EMPTY_APPS</span><br><span class="line">                            &amp;&amp; app.lastActivityTime &lt; oldTime) &#123;</span><br><span class="line">                        <span class="comment">// 如果空进程的数量超过了空进程上限数，且该空进程的空闲时间超过了 30 min</span></span><br><span class="line">                        <span class="comment">// 那就杀掉该进程！</span></span><br><span class="line">                        app.kill(<span class="string">"empty for "</span></span><br><span class="line">                                + ((oldTime + ProcessList.MAX_EMPTY_TIME - app.lastActivityTime)</span><br><span class="line">                                / <span class="number">1000</span>) + <span class="string">"s"</span>, <span class="keyword">true</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 否则，numEmpty 加 1，如果此时空进程数超过了空进程限制数，杀掉该进程！</span></span><br><span class="line">                        <span class="comment">// 但是依然统计数量！</span></span><br><span class="line">                        numEmpty++;</span><br><span class="line">                        <span class="keyword">if</span> (numEmpty &gt; emptyProcessLimit) &#123;</span><br><span class="line">                            app.kill(<span class="string">"empty #"</span> + numEmpty, <span class="keyword">true</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="comment">// 其他类型，默认属于非 cache/empty 进程，mNumNonCachedProcs 加 1；</span></span><br><span class="line">                    mNumNonCachedProcs++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【8.4】进一步处理进程的状态！</span></span><br><span class="line">            <span class="keyword">if</span> (app.isolated &amp;&amp; app.services.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果这是一个隔离进程，且内部不再运行任何服务，kill 该进程！</span></span><br><span class="line">                app.kill(<span class="string">"isolated not needed"</span>, <span class="keyword">true</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            </span><br><span class="line">                <span class="comment">// 否则，保留该进程，更新其对应的 uid 中记录的进程状态！</span></span><br><span class="line">                <span class="keyword">final</span> UidRecord uidRec = app.uidRecord;</span><br><span class="line">                <span class="keyword">if</span> (uidRec != <span class="keyword">null</span> &amp;&amp; uidRec.curProcState &gt; app.curProcState) &#123;</span><br><span class="line">                    uidRec.curProcState = app.curProcState;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【8.5】进一步处理进程的状态！</span></span><br><span class="line">            <span class="keyword">if</span> (app.curProcState &gt;= ActivityManager.PROCESS_STATE_HOME</span><br><span class="line">                    &amp;&amp; !app.killedByAm) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 记录需要回收内存的，进程状态优先级不高于 PROCESS_STATE_HOME 的后台进程数量！</span></span><br><span class="line">                <span class="comment">// PROCESS_STATE_HOME 表示持有 Home 的后台进程的状态！</span></span><br><span class="line">                numTrimming++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【9】mNewNumServiceProcs 用于保存更新 adj 后，最新的服务进程数，更新 mNumServiceProcs！</span></span><br><span class="line">    mNumServiceProcs = mNewNumServiceProcs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【10】计算统计到的 cache 和 empty 进程总数！</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> numCachedAndEmpty = numCached + numEmpty;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【11】根据统计的 cache 和 empty 进程总数，计算内存回收等级，用于内存回收！</span></span><br><span class="line">    <span class="keyword">int</span> memFactor;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// TRIM_CACHED_APPS 表示触发内存回收的 cache 进程上限： 5；</span></span><br><span class="line">    <span class="comment">// TRIM_EMPTY_APPS 表示触发内存回收的 empty 进程上限：16；</span></span><br><span class="line">    <span class="keyword">if</span> (numCached &lt;= ProcessList.TRIM_CACHED_APPS</span><br><span class="line">            &amp;&amp; numEmpty &lt;= ProcessList.TRIM_EMPTY_APPS) &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (numCachedAndEmpty &lt;= ProcessList.TRIM_CRITICAL_THRESHOLD) &#123; <span class="comment">// 个数为 3；</span></span><br><span class="line">            <span class="comment">// 总数小于 3 时，内存回收等级为 critical，取值为 3！</span></span><br><span class="line">            memFactor = ProcessStats.ADJ_MEM_FACTOR_CRITICAL;</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numCachedAndEmpty &lt;= ProcessList.TRIM_LOW_THRESHOLD) &#123; <span class="comment">// 个数为 5；</span></span><br><span class="line">            <span class="comment">// 总数小于 3 时，内存回收等级为 low，取值为 2；</span></span><br><span class="line">            memFactor = ProcessStats.ADJ_MEM_FACTOR_LOW; </span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则，内存回收等级为 moderate，取值为 1；</span></span><br><span class="line">            memFactor = ProcessStats.ADJ_MEM_FACTOR_MODERATE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 取值为 0，cachce 和 empty 进程足够时，内存回收等级为 normal</span></span><br><span class="line">        memFactor = ProcessStats.ADJ_MEM_FACTOR_NORMAL; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG_OOM_ADJ) Slog.d(TAG_OOM_ADJ, <span class="string">"oom: memFactor="</span> + memFactor</span><br><span class="line">            + <span class="string">" last="</span> + mLastMemoryLevel + <span class="string">" allowLow="</span> + mAllowLowerMemLevel</span><br><span class="line">            + <span class="string">" numProcs="</span> + mLruProcesses.size() + <span class="string">" last="</span> + mLastNumProcesses);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果新的内存回收等级比上一次的大，判读是否使用新的内存回收等级！</span></span><br><span class="line">    <span class="comment">// 一般情况下，内存回收等级变高时（即允许尽可能多地回收），是不允许降级的</span></span><br><span class="line">    <span class="comment">// 但 mAllowLowerMemLevel  为false，或进程数量变多时，可以降级！</span></span><br><span class="line">    <span class="keyword">if</span> (memFactor &gt; mLastMemoryLevel) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mAllowLowerMemLevel || mLruProcesses.size() &gt;= mLastNumProcesses) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用上一次的低内存级别！</span></span><br><span class="line">            memFactor = mLastMemoryLevel;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_OOM_ADJ) Slog.d(TAG_OOM_ADJ, <span class="string">"Keeping last mem factor!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (memFactor != mLastMemoryLevel) &#123;</span><br><span class="line">        EventLogTags.writeAmMemFactor(memFactor, mLastMemoryLevel);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新内存级别和进程数量！</span></span><br><span class="line">    mLastMemoryLevel = memFactor;</span><br><span class="line">    mLastNumProcesses = mLruProcesses.size();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将最新的内存回收等级保存到 ProcessStats 中，如果和上一次的不同，allChanged 为 true！</span></span><br><span class="line">    <span class="keyword">boolean</span> allChanged = mProcessStats.setMemFactorLocked(memFactor, !isSleepingLocked(), now);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> trackerMemFactor = mProcessStats.getMemFactorLocked();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果最新的内存回收等级不等于 normal，那么所有进程都要进行内存回收工作！</span></span><br><span class="line">    <span class="keyword">if</span> (memFactor != ProcessStats.ADJ_MEM_FACTOR_NORMAL) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mLowRamStartTime == <span class="number">0</span>) &#123; <span class="comment">// 记录内存回收时间</span></span><br><span class="line">            mLowRamStartTime = now;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> fgTrimLevel;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算前台进程的内存回收等级；</span></span><br><span class="line">        <span class="keyword">switch</span> (memFactor) &#123;</span><br><span class="line">            <span class="keyword">case</span> ProcessStats.ADJ_MEM_FACTOR_CRITICAL:</span><br><span class="line">                fgTrimLevel = ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL; <span class="comment">// critical 级别；</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ProcessStats.ADJ_MEM_FACTOR_LOW:</span><br><span class="line">                fgTrimLevel = ComponentCallbacks2.TRIM_MEMORY_RUNNING_LOW; <span class="comment">// low 级别；</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                fgTrimLevel = ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE; <span class="comment">// moderate 级别；</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算回收因子，numTrimming 表示所有需要回收内存的后台进程！</span></span><br><span class="line">        <span class="comment">// 其实就是分阶段的回收！</span></span><br><span class="line">        <span class="keyword">int</span> factor = numTrimming / <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> minFactor = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 home 进程不会 null，previous 进程不为 null，最小因子均加 1；</span></span><br><span class="line">        <span class="keyword">if</span> (mHomeProcess != <span class="keyword">null</span>) minFactor++;</span><br><span class="line">        <span class="keyword">if</span> (mPreviousProcess != <span class="keyword">null</span>) minFactor++;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 回收因子不能低于最小因子！</span></span><br><span class="line">        <span class="keyword">if</span> (factor &lt; minFactor) factor = minFactor;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始默认的回收级别为 complete！</span></span><br><span class="line">        <span class="keyword">int</span> curLevel = ComponentCallbacks2.TRIM_MEMORY_COMPLETE;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 再次逆序遍历 mLruProcesses 列表，根据进程的状态进行不同的回收处理！</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=N-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">// 开始处理进程！</span></span><br><span class="line">            ProcessRecord app = mLruProcesses.get(i);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果内存回收等级变化了，或者进程的状态发生变化，更新进程的监控信息！</span></span><br><span class="line">            <span class="keyword">if</span> (allChanged || app.procStateChanged) &#123;</span><br><span class="line">                setProcessTrackerStateLocked(app, trackerMemFactor, now);</span><br><span class="line">                app.procStateChanged = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (app.curProcState &gt;= ActivityManager.PROCESS_STATE_HOME</span><br><span class="line">                    &amp;&amp; !app.killedByAm) &#123;</span><br><span class="line">            <span class="comment">// 如果进程的状态优先级不高于 PROCESS_STATE_HOME：12，并且没有被 AMS 后台杀死，进入该分支！</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (app.trimMemoryLevel &lt; curLevel &amp;&amp; app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果进程的内存回收级别低于 curLevel，并且进程还在运行，执行内存回收！</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,</span><br><span class="line">                                <span class="string">"Trimming memory of "</span> + app.processName + <span class="string">" to "</span> + curLevel);</span><br><span class="line">                        <span class="comment">// 回收内存！</span></span><br><span class="line">                        app.thread.scheduleTrimMemory(curLevel);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">false</span>) &#123; <span class="comment">// 这里默认是不进入的！</span></span><br><span class="line">                        <span class="keyword">if</span> (curLevel &gt;= ComponentCallbacks2.TRIM_MEMORY_COMPLETE</span><br><span class="line">                                &amp;&amp; app != mHomeProcess &amp;&amp; app != mPreviousProcess) &#123;</span><br><span class="line">                            mStackSupervisor.scheduleDestroyAllActivities(app, <span class="string">"trim"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 更新进程的内存回收级别！</span></span><br><span class="line">                app.trimMemoryLevel = curLevel;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 记录处理的进度，当到达回收因子的时候，step 归 0，准备进入下一个回收因子阶段！</span></span><br><span class="line">                step++;</span><br><span class="line">                <span class="keyword">if</span> (step &gt;= factor) &#123;</span><br><span class="line">                    step = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">switch</span> (curLevel) &#123;</span><br><span class="line">                        <span class="keyword">case</span> ComponentCallbacks2.TRIM_MEMORY_COMPLETE: </span><br><span class="line">                            <span class="comment">// 如果是 COMPLETE:80，设置 curLevel 为 MODERATE:60</span></span><br><span class="line">                            curLevel = ComponentCallbacks2.TRIM_MEMORY_MODERATE;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                            </span><br><span class="line">                        <span class="keyword">case</span> ComponentCallbacks2.TRIM_MEMORY_MODERATE:</span><br><span class="line">                            <span class="comment">// 如果是 COMPLETE:60，设置 curLevel 为 BACKGROUND:40</span></span><br><span class="line">                            curLevel = ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                            </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (app.curProcState == ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) &#123;</span><br><span class="line">            <span class="comment">// 如果进程的状态属于 height weight 类型（9）的进程，进入该分支！</span></span><br><span class="line">            </span><br><span class="line">                <span class="keyword">if</span> (app.trimMemoryLevel &lt; ComponentCallbacks2.TRIM_MEMORY_BACKGROUND</span><br><span class="line">                        &amp;&amp; app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果进程的内存回收级别低于 BACKGROUND:40，并且进程还在运行，执行内存回收！</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,</span><br><span class="line">                                <span class="string">"Trimming memory of heavy-weight "</span> + app.processName</span><br><span class="line">                                + <span class="string">" to "</span> + ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);</span><br><span class="line">                        <span class="comment">// 回收内存！</span></span><br><span class="line">                        app.thread.scheduleTrimMemory(</span><br><span class="line">                                ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 更新进程的内存回收登记为 BACKGROUND:40</span></span><br><span class="line">                app.trimMemoryLevel = ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;</span><br><span class="line">                </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 其他情况，进入这里：</span></span><br><span class="line">            </span><br><span class="line">                <span class="keyword">if</span> ((app.curProcState &gt;= ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND</span><br><span class="line">                        || app.systemNoUi) &amp;&amp; app.pendingUiClean) &#123;</span><br><span class="line">                <span class="comment">// 如果该进程的进程状态优先级低于 important background: 7，或者其是 system 进程但是不显示 ui</span></span><br><span class="line">                <span class="comment">// 且 pendingUiClean 为 true，这种进程的回收登记很特殊，为 TRIM_MEMORY_UI_HIDDEN: 20</span></span><br><span class="line">                </span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> level = ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN;</span><br><span class="line">                    <span class="keyword">if</span> (app.trimMemoryLevel &lt; level &amp;&amp; app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 如果进程的内存回收级别低于 level，并且进程还在运行，执行内存回收！</span></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,</span><br><span class="line">                                    <span class="string">"Trimming memory of bg-ui "</span> + app.processName</span><br><span class="line">                                    + <span class="string">" to "</span> + level);</span><br><span class="line">                            <span class="comment">// 回收内存！</span></span><br><span class="line">                            app.thread.scheduleTrimMemory(level);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 设置 pendingUiClean 为 false，表示 ui 资源已经被回收了</span></span><br><span class="line">                    app.pendingUiClean = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 如果 TRIM_MEMORY_UI_HIDDEN 等级不够无法回收，则以前台进程的回收级别再次回收！！</span></span><br><span class="line">                <span class="keyword">if</span> (app.trimMemoryLevel &lt; fgTrimLevel &amp;&amp; app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,</span><br><span class="line">                                <span class="string">"Trimming memory of fg "</span> + app.processName</span><br><span class="line">                                + <span class="string">" to "</span> + fgTrimLevel);</span><br><span class="line">                        <span class="comment">// 回收内存！</span></span><br><span class="line">                        app.thread.scheduleTrimMemory(fgTrimLevel);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 更新进程的内存回收登记！</span></span><br><span class="line">                app.trimMemoryLevel = fgTrimLevel;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果最新的内存回收等级等于 normal，那么进入该分支！</span></span><br><span class="line">        <span class="keyword">if</span> (mLowRamStartTime != <span class="number">0</span>) &#123;</span><br><span class="line">            mLowRamTimeSinceLastIdle += now - mLowRamStartTime;</span><br><span class="line">            mLowRamStartTime = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 逆序遍历 mLruProcesses！</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=N-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            ProcessRecord app = mLruProcesses.get(i);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 同样的，更新进程信息！</span></span><br><span class="line">            <span class="keyword">if</span> (allChanged || app.procStateChanged) &#123;</span><br><span class="line">                setProcessTrackerStateLocked(app, trackerMemFactor, now);</span><br><span class="line">                app.procStateChanged = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果该进程的进程状态优先级低于 important background: 6，或者其是 system 进程但是不显示 ui</span></span><br><span class="line">            <span class="comment">// 且 pendingUiClean 为 true，才会回收内存！！</span></span><br><span class="line">            <span class="keyword">if</span> ((app.curProcState &gt;= ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND</span><br><span class="line">                    || app.systemNoUi) &amp;&amp; app.pendingUiClean) &#123;</span><br><span class="line">                    </span><br><span class="line">                <span class="comment">// 回收等级是 TRIM_MEMORY_UI_HIDDEN: 20</span></span><br><span class="line">                <span class="keyword">if</span> (app.trimMemoryLevel &lt; ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN</span><br><span class="line">                        &amp;&amp; app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,</span><br><span class="line">                                <span class="string">"Trimming memory of ui hidden "</span> + app.processName</span><br><span class="line">                                + <span class="string">" to "</span> + ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);</span><br><span class="line">                                </span><br><span class="line">                        <span class="comment">// 回收内存！</span></span><br><span class="line">                        app.thread.scheduleTrimMemory(</span><br><span class="line">                                ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 设置 pendingUiClean 为 false；</span></span><br><span class="line">                app.pendingUiClean = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 这里很特殊，设置 trimMemoryLevel 为 0；</span></span><br><span class="line">            app.trimMemoryLevel = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果允许销毁后台 Activity</span></span><br><span class="line">    <span class="comment">// 可以通过：开发者选项 ——》不保留活动，开启！</span></span><br><span class="line">    <span class="keyword">if</span> (mAlwaysFinishActivities) &#123;</span><br><span class="line">        mStackSupervisor.scheduleDestroyAllActivities(<span class="keyword">null</span>, <span class="string">"always-finish"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// allChanged 为 true，表示发生了内存回收，这里是请求 PSS 内存！</span></span><br><span class="line">    <span class="keyword">if</span> (allChanged) &#123;</span><br><span class="line">        requestPssAllProcsLocked(now, <span class="keyword">false</span>, mProcessStats.isMemFactorLowered());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新活跃的 uid 的状态！</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=mActiveUids.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">final</span> UidRecord uidRec = mActiveUids.valueAt(i);</span><br><span class="line">        <span class="keyword">int</span> uidChange = UidRecord.CHANGE_PROCSTATE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 setProcState 和 curProcState 不相等，说明所属进程状态发生了变化！</span></span><br><span class="line">        <span class="keyword">if</span> (uidRec.setProcState != uidRec.curProcState) &#123;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">if</span> (DEBUG_UID_OBSERVERS) Slog.i(TAG_UID_OBSERVERS,</span><br><span class="line">                    <span class="string">"Changes in "</span> + uidRec + <span class="string">": proc state from "</span> + uidRec.setProcState</span><br><span class="line">                    + <span class="string">" to "</span> + uidRec.curProcState);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (ActivityManager.isProcStateBackground(uidRec.curProcState)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ActivityManager.isProcStateBackground(uidRec.setProcState)) &#123;</span><br><span class="line">                    <span class="comment">// 如果 uid 所属进程当前的状态是后台进程，但是之前的状态不是后台进程！</span></span><br><span class="line">                    <span class="comment">// 更新 uid 的 lastBackgroundTime 变量！</span></span><br><span class="line"></span><br><span class="line">                    uidRec.lastBackgroundTime = nowElapsed;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (!mHandler.hasMessages(IDLE_UIDS_MSG)) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 发送 uid 处于 idle 状态的消息！</span></span><br><span class="line">                        mHandler.sendEmptyMessageDelayed(IDLE_UIDS_MSG, BACKGROUND_SETTLE_TIME);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果 uid 所属进程当前的状态是前台进程，那么该 uid 处于 active 状态！</span></span><br><span class="line">                <span class="keyword">if</span> (uidRec.idle) &#123;</span><br><span class="line">                    uidChange = UidRecord.CHANGE_ACTIVE;</span><br><span class="line">                    uidRec.idle = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                uidRec.lastBackgroundTime = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 更新 setProcState 为 curProcState！</span></span><br><span class="line">            uidRec.setProcState = uidRec.curProcState;</span><br><span class="line">            enqueueUidChangeLocked(uidRec, -<span class="number">1</span>, uidChange);</span><br><span class="line">            noteUidProcessState(uidRec.uid, uidRec.curProcState);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新进程的状态！</span></span><br><span class="line">    <span class="keyword">if</span> (mProcessStats.shouldWriteNowLocked(now)) &#123;</span><br><span class="line">        mHandler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (ActivityManagerService.<span class="keyword">this</span>) &#123;</span><br><span class="line">                    mProcessStats.writeStateAsyncLocked();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG_OOM_ADJ) &#123; <span class="comment">// debug 相关，不处理！</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> duration = SystemClock.uptimeMillis() - now;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">            Slog.d(TAG_OOM_ADJ, <span class="string">"Did OOM ADJ in "</span> + duration + <span class="string">"ms"</span>,</span><br><span class="line">                    <span class="keyword">new</span> RuntimeException(<span class="string">"here"</span>).fillInStackTrace());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Slog.d(TAG_OOM_ADJ, <span class="string">"Did OOM ADJ in "</span> + duration + <span class="string">"ms"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-1-变量总结"><a href="#3-2-1-变量总结" class="headerlink" title="3.2.1 变量总结"></a>3.2.1 变量总结</h3><p>下面我们来总结，空参 <code>updateOomAdjLocked</code> 中遇到的一些变量：</p>
<h3 id="3-2-2-过程总结"><a href="#3-2-2-过程总结" class="headerlink" title="3.2.2 过程总结"></a>3.2.2 过程总结</h3><h2 id="3-3-5-ActivityManagerS-updateOomAdjLocked"><a href="#3-3-5-ActivityManagerS-updateOomAdjLocked" class="headerlink" title="3.3 [5]ActivityManagerS.updateOomAdjLocked"></a>3.3 [5]ActivityManagerS.updateOomAdjLocked</h2><p>最后，我们来看 <code>5</code> 参的 <code>updateOomAdjLocked</code> 方法更新指定进程的 <code>oomAdj</code>，参数传递：</p>
<ul>
<li><strong>ProcessRecord app</strong>：要更新 <code>oomAdj</code> 的进程；</li>
<li><strong>int cachedAdj</strong>：进程处于 <code>cache</code> 状态的 <code>adj</code> 值；</li>
<li><strong>ProcessRecord TOP_APP</strong>：<code>top activity</code> 所在进程；</li>
<li><strong>boolean doingAll</strong>：是否对所有进程都更新 <code>adj</code> 的值！</li>
<li><strong>long now</strong>：更新的时间点！</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">updateOomAdjLocked</span><span class="params">(ProcessRecord app, <span class="keyword">int</span> cachedAdj,</span></span></span><br><span class="line"><span class="function"><span class="params">        ProcessRecord TOP_APP, <span class="keyword">boolean</span> doingAll, <span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (app.thread == <span class="keyword">null</span>) &#123; <span class="comment">// 进程没有启动！</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【1】计算 oomAdj 的值，doingAll 表示是否是对所有的进程都更新</span></span><br><span class="line">    <span class="comment">// 如果是的话，那就会统计进程数量！</span></span><br><span class="line">    computeOomAdjLocked(app, cachedAdj, TOP_APP, doingAll, now);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】应用 oomAdj 的值；</span></span><br><span class="line">    <span class="keyword">return</span> applyOomAdjLocked(app, doingAll, now, SystemClock.elapsedRealtime());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到，更新指定进程的 <code>oomAdj</code> 的会先调用 <code>computeOomAdjLocked</code> 计算 <code>oomAdj</code>，在调用 <code>applyOomAdjLocked</code> 应用计算的  <code>oomAdj</code>！！</p>
<h3 id="3-3-1-ActivityManagerS-computeOomAdjLocked"><a href="#3-3-1-ActivityManagerS-computeOomAdjLocked" class="headerlink" title="3.3.1 ActivityManagerS.computeOomAdjLocked"></a>3.3.1 ActivityManagerS.computeOomAdjLocked</h3><p>该方法用于计算除了 <code>cachedProcess</code> 和 <code>emptyProcess</code> 进程以外的进程的 <code>oom_adj</code> 值！</p>
<p>该方法的判断分支很多，我们按照模块划分下：</p>
<h4 id="3-3-1-1-已经更新-进程未启动的情况"><a href="#3-3-1-1-已经更新-进程未启动的情况" class="headerlink" title="3.3.1.1 已经更新/进程未启动的情况"></a>3.3.1.1 已经更新/进程未启动的情况</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">computeOomAdjLocked</span><span class="params">(ProcessRecord app, <span class="keyword">int</span> cachedAdj, ProcessRecord TOP_APP,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> doingAll, <span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】如果该进程的 app.adjSeq 和 mAdjSeq 相等，说明已经计算过了，直接返回计算的结果！</span></span><br><span class="line">    <span class="keyword">if</span> (mAdjSeq == app.adjSeq) &#123;</span><br><span class="line">        <span class="keyword">return</span> app.curRawAdj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】如果进程的 thread 为 null，说明进程没有启动，</span></span><br><span class="line">    <span class="comment">// 设置进程的调度组为 SCHED_GROUP_BACKGROUND，进程状态为 SCHED_GROUP_BACKGROUND</span></span><br><span class="line">    <span class="comment">// curAdj 和 curRawAdj 均为 CACHED_APP_MAX_ADJ；                                              </span></span><br><span class="line">    <span class="keyword">if</span> (app.thread == <span class="keyword">null</span>) &#123;</span><br><span class="line">        app.adjSeq = mAdjSeq; </span><br><span class="line">        app.curSchedGroup = ProcessList.SCHED_GROUP_BACKGROUND;</span><br><span class="line">        app.curProcState = ActivityManager.PROCESS_STATE_CACHED_EMPTY;</span><br><span class="line">        <span class="keyword">return</span> (app.curAdj=app.curRawAdj=ProcessList.CACHED_APP_MAX_ADJ);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ... ... ... ... <span class="comment">// 见下面[3.1.2.1.2]！</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>对于已经更新过的进程，通过 <code>mAdjSeq == app.adjSeq</code> 进行判断，当系统每次调用 <code>updateOomAdjLocked</code> 方法更新系统中进程的 <code>adj</code> 的时候，<code>mAdjSeq</code> 的值就会加一，同时，本次更新过的进程的 <code>adjSeq</code> 也会等于 <code>mAdjSeq</code>！</p>
</li>
<li><p>对于<strong>进程还没有启动的情况</strong>，我们默认设置初始的值给对应的属性！</p>
<ul>
<li><code>app.curSchedGroup = ProcessList.SCHED_GROUP_BACKGROUND</code> : </li>
<li><code>app.curProcState = ActivityManager.PROCESS_STATE_CACHED_EMPTY</code> : <code>16</code></li>
<li><code>app.curAdj = app.curRawAdj = ProcessList.CACHED_APP_MAX_ADJ</code> : <code>906</code></li>
</ul>
</li>
</ul>
<h4 id="3-3-1-2-系统进程"><a href="#3-3-1-2-系统进程" class="headerlink" title="3.3.1.2 系统进程"></a>3.3.1.2 系统进程</h4><p>下面我们来看看系统进程的处理！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">... ... ... ... <span class="comment">// 见上面[3.1.2.1.1]！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一些 debug 的变量，后续会使用！</span></span><br><span class="line">app.adjTypeCode = ActivityManager.RunningAppProcessInfo.REASON_UNKNOWN;</span><br><span class="line">app.adjSource = <span class="keyword">null</span>;</span><br><span class="line">app.adjTarget = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">app.empty = <span class="keyword">false</span>; <span class="comment">// 进程是否会为空；</span></span><br><span class="line">app.cached = <span class="keyword">false</span>; <span class="comment">// 进程是否被缓存；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> activitiesSize = app.activities.size(); <span class="comment">// 该进程中的 activity 数！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//【3】如果进程的 maxAdj &lt;= FOREGROUND_APP_ADJ(0)，说明该进程是系统进程，那么一定是在前台！</span></span><br><span class="line"><span class="keyword">if</span> (app.maxAdj &lt;= ProcessList.FOREGROUND_APP_ADJ) &#123;</span><br><span class="line">    app.adjType = <span class="string">"fixed"</span>;</span><br><span class="line">    app.adjSeq = mAdjSeq;</span><br><span class="line">    app.curRawAdj = app.maxAdj;</span><br><span class="line">    app.foregroundActivities = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置进程的调度组为 SCHED_GROUP_DEFAULT；</span></span><br><span class="line">    app.curSchedGroup = ProcessList.SCHED_GROUP_DEFAULT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置进程的状态为 PROCESS_STATE_PERSISTENT；</span></span><br><span class="line">    app.curProcState = ActivityManager.PROCESS_STATE_PERSISTENT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断系统进程当前是否正在显示 ui，如果正在显示，那么我们需要等到用户离开 ui 后再回收内存！</span></span><br><span class="line">    app.systemNoUi = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (app == TOP_APP) &#123; <span class="comment">// 如果该系统进程是 top activity 所在进程，systemNoUi 为 false；</span></span><br><span class="line">        app.systemNoUi = <span class="keyword">false</span>;</span><br><span class="line">        app.curSchedGroup = ProcessList.SCHED_GROUP_TOP_APP;</span><br><span class="line">        app.adjType = <span class="string">"pers-top-activity"</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (app.hasTopUi) &#123; <span class="comment">// 如果该系统进程 hasTopUi 为 true，说明其持有 top-level ui，systemNoUi 为 false；</span></span><br><span class="line">        app.systemNoUi = <span class="keyword">false</span>;</span><br><span class="line">        app.curSchedGroup = ProcessList.SCHED_GROUP_TOP_APP;</span><br><span class="line">        app.adjType = <span class="string">"pers-top-ui"</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (activitiesSize &gt; <span class="number">0</span>) &#123; <span class="comment">// 如果系统进程中的 activity 数目大于 0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; activitiesSize; j++) &#123;</span><br><span class="line">            <span class="keyword">final</span> ActivityRecord r = app.activities.get(j);</span><br><span class="line">            <span class="keyword">if</span> (r.visible) &#123; <span class="comment">// 如果有可见的 activity，那么 systemNoUi 为 false；</span></span><br><span class="line">                app.systemNoUi = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果系统进程持有 ui 界面，那其进程状态为 PROCESS_STATE_PERSISTENT_UI；</span></span><br><span class="line">    <span class="keyword">if</span> (!app.systemNoUi) &#123;</span><br><span class="line">        app.curProcState = ActivityManager.PROCESS_STATE_PERSISTENT_UI;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 那么其 curAdj 为 maxAdj 的值，这里直接 return！</span></span><br><span class="line">    <span class="keyword">return</span> (app.curAdj = app.maxAdj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">... ... ... ... <span class="comment">// 见下面[3.1.2.1.3]！</span></span><br></pre></td></tr></table></figure>
<p>对于系统进程，其一定是要在前台的，这里首先判断了最大的 <code>maxAdj</code> 的取值！<code>FOREGROUND_APP_ADJ</code> 的取值为 <code>0</code>，表示前台进程的 <code>adj</code>！</p>
<p><strong><code>maxAdj</code> 在进程对象刚创建的时候，会被初始化为 <code>UNKNOWN_ADJ</code></strong>！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">maxAdj = ProcessList.UNKNOWN_ADJ;</span><br><span class="line">curRawAdj = setRawAdj = ProcessList.INVALID_ADJ;</span><br><span class="line">curAdj = setAdj = verifiedAdj = ProcessList.INVALID_ADJ;</span><br></pre></td></tr></table></figure>
<p><strong>1、在设置系统进程 <code>setSystemProcess</code> 的时候，会被设置为如下值：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为系统进程创建 ProcessRecord 对象！</span></span><br><span class="line">ProcessRecord app = newProcessRecordLocked(info, info.processName, <span class="keyword">false</span>, <span class="number">0</span>);</span><br><span class="line">app.persistent = <span class="keyword">true</span>; <span class="comment">// 表示为常驻进程！</span></span><br><span class="line">app.pid = MY_PID;</span><br><span class="line">app.maxAdj = ProcessList.SYSTEM_ADJ; <span class="comment">// 设置 maxAdj！</span></span><br><span class="line">app.makeActive(mSystemThread.getApplicationThread(), mProcessStats);</span><br></pre></td></tr></table></figure></p>
<p><strong>2、在启动 <code>persistent app</code> 的时候，会调用 <code>addAppLocked</code> 方法，设置为如下值：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((info.flags &amp; PERSISTENT_MASK) == PERSISTENT_MASK) &#123;</span><br><span class="line">    app.persistent = <span class="keyword">true</span>;</span><br><span class="line">    app.maxAdj = ProcessList.PERSISTENT_PROC_ADJ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>这两个值对应的 <code>adj</code> 优先级都高于 <code>FOREGROUND_APP_ADJ</code>，都属于 <code>persistent adj</code>，都会进入该分支</strong>！</p>
<p>这一段的逻辑如下：</p>
<p>如果进程的 <code>maxAdj</code> 比 <code>FOREGROUND_APP_ADJ</code> 小，说明其是常驻进程或者系统进程，那么就做如下判断：</p>
<ul>
<li><strong><code>app == TOP_APP</code></strong></li>
</ul>
<p>当前的 <code>top activity</code> 所在进程就是该进程，那么有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.systemNoUi = <span class="keyword">false</span>;</span><br><span class="line">app.curSchedGroup = ProcessList.SCHED_GROUP_TOP_APP;</span><br><span class="line">app.curProcState = ActivityManager.PROCESS_STATE_PERSISTENT_UI;</span><br><span class="line">app.foregroundActivities = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>app.hasTopUi</code></strong></li>
</ul>
<p>当前进程不是 <code>top process</code>，但是显示 <code>top-level</code> 级别的 <code>ui</code>，那么有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.systemNoUi = <span class="keyword">false</span>;</span><br><span class="line">app.curSchedGroup = ProcessList.SCHED_GROUP_TOP_APP;</span><br><span class="line">app.curProcState = ActivityManager.PROCESS_STATE_PERSISTENT_UI;</span><br><span class="line">app.foregroundActivities = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>activitiesSize &gt; 0</code></strong></li>
</ul>
<p>如果即不是<code>top process</code>，也没有显示<code>top-level ui</code>，那就要判断下内部的是否持有可见的<code>activity</code>，如果有那么<code>systemNoUi</code>为</p>
<p><code>false</code>，<code>curProcState = ActivityManager.PROCESS_STATE_PERSISTENT_UI</code>;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.systemNoUi = <span class="keyword">false</span>; / <span class="keyword">true</span></span><br><span class="line">app.curSchedGroup = ProcessList.SCHED_GROUP_TOP_APP;</span><br><span class="line">app.curProcState = ActivityManager.PROCESS_STATE_PERSISTENT_UI; / ActivityManager.PROCESS_STATE_PERSISTENT;</span><br><span class="line">app.foregroundActivities = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>
<p>对于 <code>persistent</code> 进程的情况，最后返回的是 <code>app.curAdj = app.curRawAdj = app.maxAdj</code>!</p>
<h4 id="3-3-1-3-前台进程"><a href="#3-3-1-3-前台进程" class="headerlink" title="3.3.1.3 前台进程"></a>3.3.1.3 前台进程</h4><p>对于其他的进程来说，<code>maxAdj</code> 只会在初始化的时候被设置为 <code>ProcessList.UNKNOWN_ADJ</code>; 显然，他们是需要进入下面的分支的，<strong>判断其是否属于前台进程</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">... ... ... ... <span class="comment">// 见上面[3.1.2.1.2]！</span></span><br><span class="line"></span><br><span class="line">app.systemNoUi = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> PROCESS_STATE_CUR_TOP = mTopProcessState; <span class="comment">// 用于保存当前 top process 的状态！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//【4】接下来就开始决定非系统前台进程的重要性了，从高级别开始一直到低级别，逐级分配 oomAdj！</span></span><br><span class="line"><span class="comment">// adj 用来保存计算出的 oomAdj，schedGroup 用来保存计算出的调度组，procState 用来保存计算出的进程状态！</span></span><br><span class="line"><span class="keyword">int</span> adj;</span><br><span class="line"><span class="keyword">int</span> schedGroup;</span><br><span class="line"><span class="keyword">int</span> procState;</span><br><span class="line"><span class="keyword">boolean</span> foregroundActivities = <span class="keyword">false</span>;</span><br><span class="line">BroadcastQueue queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (app == TOP_APP) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该进程就是 top activity 所在的进程，此时进程处于前台！</span></span><br><span class="line">    adj = ProcessList.FOREGROUND_APP_ADJ; <span class="comment">// 0；</span></span><br><span class="line">    </span><br><span class="line">    schedGroup = ProcessList.SCHED_GROUP_TOP_APP;</span><br><span class="line">    app.adjType = <span class="string">"top-activity"</span>;</span><br><span class="line">    foregroundActivities = <span class="keyword">true</span>;</span><br><span class="line">    </span><br><span class="line">    procState = PROCESS_STATE_CUR_TOP;</span><br><span class="line">    </span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (app.instrumentationClass != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果进程中有正在运行的 instrumentation，用于测试，此时进程处于前台！</span></span><br><span class="line">    adj = ProcessList.FOREGROUND_APP_ADJ; <span class="comment">// 0</span></span><br><span class="line">    </span><br><span class="line">    schedGroup = ProcessList.SCHED_GROUP_DEFAULT;</span><br><span class="line">    app.adjType = <span class="string">"instrumentation"</span>;</span><br><span class="line">    </span><br><span class="line">    procState = ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE; <span class="comment">// 4</span></span><br><span class="line">    </span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ((queue = isReceivingBroadcast(app)) != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果进程中有正在运行的 BroadcastReceiver 接收处理广播，此时进程处于前台！</span></span><br><span class="line">    <span class="comment">// 然后根据广播所处的队列类型设置调度组！</span></span><br><span class="line">    adj = ProcessList.FOREGROUND_APP_ADJ; <span class="comment">// 0</span></span><br><span class="line">    </span><br><span class="line">    schedGroup = (queue == mFgBroadcastQueue)</span><br><span class="line">            ? ProcessList.SCHED_GROUP_DEFAULT : ProcessList.SCHED_GROUP_BACKGROUND;</span><br><span class="line">    app.adjType = <span class="string">"broadcast"</span>;</span><br><span class="line">    </span><br><span class="line">    procState = ActivityManager.PROCESS_STATE_RECEIVER; <span class="comment">// 11</span></span><br><span class="line">    </span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (app.executingServices.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果进程中有服务正在执行，此时进程处于前台，然后根据执行操作的前台后台，设置不同调度组；</span></span><br><span class="line">    adj = ProcessList.FOREGROUND_APP_ADJ; <span class="comment">// 0</span></span><br><span class="line">    </span><br><span class="line">    schedGroup = app.execServicesFg ?</span><br><span class="line">            ProcessList.SCHED_GROUP_DEFAULT : ProcessList.SCHED_GROUP_BACKGROUND;</span><br><span class="line">    app.adjType = <span class="string">"exec-service"</span>;</span><br><span class="line">    </span><br><span class="line">    procState = ActivityManager.PROCESS_STATE_SERVICE; <span class="comment">// 10</span></span><br><span class="line">    <span class="comment">//Slog.i(TAG, "EXEC " + (app.execServicesFg ? "FG" : "BG") + ": " + app);</span></span><br><span class="line">    </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他类型的进程进入该分支，进程状态为 PROCESS_STATE_CACHED_EMPTY，调度组为 SCHED_GROUP_BACKGROUND！</span></span><br><span class="line">    <span class="comment">// 这种情况下我们无法知道实际的 adj，我们暂时使用 cache adj，后续我们会继续调整！</span></span><br><span class="line">    schedGroup = ProcessList.SCHED_GROUP_BACKGROUND;</span><br><span class="line">    </span><br><span class="line">    adj = cachedAdj;</span><br><span class="line">    procState = ActivityManager.PROCESS_STATE_CACHED_EMPTY; <span class="comment">// 16</span></span><br><span class="line">    </span><br><span class="line">    app.cached = <span class="keyword">true</span>;</span><br><span class="line">    app.empty = <span class="keyword">true</span>;</span><br><span class="line">    app.adjType = <span class="string">"cch-empty"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">... ... ... ... <span class="comment">// 见下面[3.1.2.1.4]！</span></span><br></pre></td></tr></table></figure>
<p>首先来说一下：<code>mTopProcessState</code>，其表示 <code>top process</code> 的状态，其默认取值为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mTopProcessState = ActivityManager.PROCESS_STATE_TOP;</span><br></pre></td></tr></table></figure></p>
<p>当我们的系统进入睡眠状态的时候，会更新其状态，具体的方法在 <code>updateSleepIfNeededLocked</code> 方法：</p>
<ul>
<li>当系统不睡眠时候，设置 <code>mTopProcessState = ActivityManager.PROCESS_STATE_TOP</code>；</li>
<li>当系统睡眠时候，设置 <code>mTopProcessState = ActivityManager.PROCESS_STATE_TOP_SLEEPING</code>；</li>
</ul>
<p>我们来看看，<strong>那些进程能归类于前台进程</strong>：</p>
<ul>
<li><strong>1、当前进程是 <code>top process</code></strong>，进行如下处理：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">adj = ProcessList.FOREGROUND_APP_ADJ; <span class="comment">// 取值 0</span></span><br><span class="line">schedGroup = ProcessList.SCHED_GROUP_TOP_APP;</span><br><span class="line">foregroundActivities = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">procState = PROCESS_STATE_CUR_TOP; <span class="comment">// 进程状态 2 或者 5！</span></span><br></pre></td></tr></table></figure>
<p>这里的 <code>PROCESS_STATE_CUR_TOP</code> 就是 <code>mTopProcessState</code>，且 <code>foregroundActivities</code> 只有在该条件下才为 <code>true</code>；</p>
<ul>
<li><strong>4、当前进程不是 <code>top process</code>，但是其内部运行着 <code>instrumentation</code> 用于测试的话：</strong> </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">adj = ProcessList.FOREGROUND_APP_ADJ; <span class="comment">// 取值 0</span></span><br><span class="line">schedGroup = ProcessList.SCHED_GROUP_DEFAULT;</span><br><span class="line">foregroundActivities = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">procState = ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE; <span class="comment">// 进程状态 4；</span></span><br></pre></td></tr></table></figure>
<p>继续来看：</p>
<p><br></p>
<ul>
<li><strong>3、当前进程不是 <code>top process</code>，内部没有运行着 <code>instrumentation</code>，但是其内部有正在接受处理广播的 <code>BroadcastReceiver</code> 的话：</strong> </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">adj = ProcessList.FOREGROUND_APP_ADJ; <span class="comment">// 取值 0</span></span><br><span class="line">schedGroup = (queue == mFgBroadcastQueue) ? ProcessList.SCHED_GROUP_DEFAULT : ProcessList.SCHED_GROUP_BACKGROUND;</span><br><span class="line">foregroundActivities = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">procState = ActivityManager.PROCESS_STATE_RECEIVER; <span class="comment">// 进程状态 11；</span></span><br></pre></td></tr></table></figure>
<p>如果广播所在的队列是后台队列，所属的调度组为：<code>SCHED_GROUP_BACKGROUND</code>，如果是前台，调度组为 <code>SCHED_GROUP_DEFAULT</code>；</p>
<p><br></p>
<ul>
<li><strong>4、当前进程不是 <code>top process</code>，内部没有运行着 <code>instrumentation</code>，也没有接受处理广播的 <code>BroadcastReceiver</code>，但是有正在执行的 <code>Service</code> 的话：</strong> </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">adj = ProcessList.FOREGROUND_APP_ADJ; <span class="comment">// 取值 0</span></span><br><span class="line">schedGroup = app.execServicesFg ? ProcessList.SCHED_GROUP_DEFAULT : ProcessList.SCHED_GROUP_BACKGROUND;</span><br><span class="line">foregroundActivities = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">procState = ActivityManager.PROCESS_STATE_SERVICE; <span class="comment">// 进程状态 10；</span></span><br></pre></td></tr></table></figure>
<p>如果后台执行，所属的调度组为：<code>SCHED_GROUP_BACKGROUND</code>，如果是前台，调度组为 <code>SCHED_GROUP_DEFAULT</code>；</p>
<p><br></p>
<ul>
<li>5、其他不属于以上的情况，说明其不是前台进程，有如下处理：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">schedGroup = ProcessList.SCHED_GROUP_BACKGROUND;</span><br><span class="line">adj = cachedAdj; <span class="comment">// 我们使用 cachedAdj ，或者为 unknowAdj；</span></span><br><span class="line"></span><br><span class="line">procState = ActivityManager.PROCESS_STATE_CACHED_EMPTY; <span class="comment">// 进程状态为 16；</span></span><br><span class="line">foregroundActivities = <span class="keyword">false</span>;</span><br><span class="line">app.cached = <span class="keyword">true</span>;</span><br><span class="line">app.empty = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>
<p>对于这种情况，我们将其当作 <code>cache</code> 进程处理，后续会进行调整！</p>
<p>对于前台进程，其 <code>oom_adj</code> 均被赋值为 <code>FOREGROUND_APP_ADJ</code>，即从 <code>LowMemoryKiller</code> 的角度来看，它们的重要性是一致的。<br>但这些进程的 <code>procState</code> 不同，于是从 <code>ActivityManagerService</code> 主动回收内存的角度来看，它们的重要性不同。</p>
<p>这里我们关注一个变量 <code>foregroundActivities</code>，这里只有在 <code>app == TOP_APP</code> 的情况下为 <code>true</code>，表示持有前台 <code>activity</code>!</p>
<p>我们继续来看！</p>
<h4 id="3-3-1-4-处理非前台-activity-所在进程"><a href="#3-3-1-4-处理非前台-activity-所在进程" class="headerlink" title="3.3.1.4 处理非前台 activity 所在进程"></a>3.3.1.4 处理非前台 activity 所在进程</h4><p>处理完了前台进程，接下来，处理非前台 <code>activity</code> 的情况，这里可以看作上面部分的延续，以下几种情况，会进入下面的逻辑，进一步的调整其 <code>adj</code>!</p>
<ul>
<li><strong>如果该进程是前台进程，但不是 <code>top process</code>，并且内部持有 <code>activity</code></strong>，其 <code>adj</code> 为 <code>FOREGROUND_APP_ADJ</code>！</li>
<li><strong>如果该进程不是前台进程，并且内部持有 <code>activity</code></strong>，其 <code>adj</code> 为 <code>cachedAdj</code>！</li>
</ul>
<p>这里的 <code>top process</code> 是 <code>top activity</code> 所在的进程！！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">... ... ... ... <span class="comment">// 见上面[3.1.2.1.3]！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//【5】处理完了前台进程，接下来，处理非前台 activity 的情况！</span></span><br><span class="line"><span class="keyword">if</span> (!foregroundActivities &amp;&amp; activitiesSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// minLayer 默认等于 PERCEPTIBLE_APP_ADJ（200） - VISIBLE_APP_ADJ（100）- 1，等于 99！</span></span><br><span class="line">    <span class="keyword">int</span> minLayer = ProcessList.VISIBLE_APP_LAYER_MAX;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; activitiesSize; j++) &#123; <span class="comment">// 遍历！</span></span><br><span class="line">        <span class="keyword">final</span> ActivityRecord r = app.activities.get(j);</span><br><span class="line">        <span class="keyword">if</span> (r.app != app) &#123;</span><br><span class="line"></span><br><span class="line">            Log.e(TAG, <span class="string">"Found activity "</span> + r + <span class="string">" in proc activity list using "</span> + r.app</span><br><span class="line">                    + <span class="string">" instead of expected "</span> + app);</span><br><span class="line">                    </span><br><span class="line">            <span class="keyword">if</span> (r.app == <span class="keyword">null</span> || (r.app.uid == app.uid)) &#123;</span><br><span class="line">                <span class="comment">// 处理数据异常的问题！</span></span><br><span class="line">                r.app = app;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (r.visible) &#123;</span><br><span class="line">            <span class="comment">//【5.1】如果 activity 是可见的，</span></span><br><span class="line">            <span class="comment">// 那提高 adj 最高为 VISIBLE_APP_ADJ，提高 procState 最高为 PROCESS_STATE_CUR_TOP！</span></span><br><span class="line">            <span class="keyword">if</span> (adj &gt; ProcessList.VISIBLE_APP_ADJ) &#123; <span class="comment">// 100</span></span><br><span class="line">                adj = ProcessList.VISIBLE_APP_ADJ;</span><br><span class="line">                app.adjType = <span class="string">"visible"</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (procState &gt; PROCESS_STATE_CUR_TOP) &#123; <span class="comment">// top state: 2/5</span></span><br><span class="line">                procState = PROCESS_STATE_CUR_TOP;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            schedGroup = ProcessList.SCHED_GROUP_DEFAULT; <span class="comment">// 调整调度组为 default！</span></span><br><span class="line"></span><br><span class="line">            app.cached = <span class="keyword">false</span>;</span><br><span class="line">            app.empty = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            foregroundActivities = <span class="keyword">true</span>; <span class="comment">// 设置 foregroundActivities 为 true；</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果其所在 task 如果不为 null，需要根据 task.mLayerRank</span></span><br><span class="line">            <span class="comment">// 调整 minLayer 的值！</span></span><br><span class="line">            <span class="keyword">if</span> (r.task != <span class="keyword">null</span> &amp;&amp; minLayer &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> layer = r.task.mLayerRank;</span><br><span class="line">                <span class="keyword">if</span> (layer &gt;= <span class="number">0</span> &amp;&amp; minLayer &gt; layer) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// minLayer 为其所在 task.mLayerRank 值！</span></span><br><span class="line">                    minLayer = layer;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.state == ActivityState.PAUSING || r.state == ActivityState.PAUSED) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【5.2】如果 activity 正在暂停，或者已经暂停，</span></span><br><span class="line">            <span class="comment">// 调整 adj 至少为 PERCEPTIBLE_APP_ADJ，调整 procState 至少为 top 进程的状态；</span></span><br><span class="line">            <span class="keyword">if</span> (adj &gt; ProcessList.PERCEPTIBLE_APP_ADJ) &#123; <span class="comment">// 200</span></span><br><span class="line">                adj = ProcessList.PERCEPTIBLE_APP_ADJ;</span><br><span class="line">                app.adjType = <span class="string">"pausing"</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (procState &gt; PROCESS_STATE_CUR_TOP) &#123; <span class="comment">// top state: 2/5</span></span><br><span class="line">                procState = PROCESS_STATE_CUR_TOP;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            schedGroup = ProcessList.SCHED_GROUP_DEFAULT;</span><br><span class="line"></span><br><span class="line">            app.cached = <span class="keyword">false</span>;</span><br><span class="line">            app.empty = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            foregroundActivities = <span class="keyword">true</span>; <span class="comment">// 设置 foregroundActivities 为 true；</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.state == ActivityState.STOPPING) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【5.3】如果 activity 正在停止， 调整 adj 至少为 PERCEPTIBLE_APP_ADJ</span></span><br><span class="line">            <span class="keyword">if</span> (adj &gt; ProcessList.PERCEPTIBLE_APP_ADJ) &#123; <span class="comment">// 200</span></span><br><span class="line">                adj = ProcessList.PERCEPTIBLE_APP_ADJ;</span><br><span class="line">                app.adjType = <span class="string">"stopping"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果此时 activity 没有开始 finish，那就调整 procState 最低为 PROCESS_STATE_LAST_ACTIVITY！</span></span><br><span class="line">            <span class="keyword">if</span> (!r.finishing) &#123;</span><br><span class="line">                <span class="keyword">if</span> (procState &gt; ActivityManager.PROCESS_STATE_LAST_ACTIVITY) &#123; <span class="comment">// 13</span></span><br><span class="line">                    procState = ActivityManager.PROCESS_STATE_LAST_ACTIVITY; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            app.cached = <span class="keyword">false</span>;</span><br><span class="line">            app.empty = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            foregroundActivities = <span class="keyword">true</span>; <span class="comment">// 设置 foregroundActivities 为 true；</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【5.4】不属于以上情况的话，只是含有 cached activity 的进程！</span></span><br><span class="line">            <span class="comment">// 这里只会设置进程状态 procState 最低为 PROCESS_STATE_CACHED_ACTIVITY！</span></span><br><span class="line">            <span class="keyword">if</span> (procState &gt; ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) &#123; <span class="comment">// 14</span></span><br><span class="line">                procState = ActivityManager.PROCESS_STATE_CACHED_ACTIVITY; </span><br><span class="line">                app.adjType = <span class="string">"cch-act"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同时，不同可见进程的 oom_adj 有一定的差异，我们根据其所在的 task 的 mLayerRank 来动态调整其 adj！</span></span><br><span class="line">    <span class="comment">// 如果此时 adj 为 VISIBLE_APP_ADJ（100），那就给 adj 加上 minLayer！</span></span><br><span class="line">    <span class="comment">// minLayer </span></span><br><span class="line">    <span class="keyword">if</span> (adj == ProcessList.VISIBLE_APP_ADJ) &#123;</span><br><span class="line">        adj += minLayer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">... ... ... ... <span class="comment">// 见下面[3.1.2.1.5]！</span></span><br></pre></td></tr></table></figure>
<p><strong>如果进程中没有 <code>top activity</code>，但是内部运行着 <code>activity</code></strong>，还需要进入如下的判断：</p>
<ul>
<li><strong>1、如果 r.visible，表示内部有 activity 是可见的：</strong><ul>
<li>如果 <code>adj &gt; ProcessList.VISIBLE_APP_ADJ</code>：<strong>100</strong>，那就调整到 <code>ProcessList.VISIBLE_APP_ADJ</code>；</li>
<li>如果 <code>procState &gt; PROCESS_STATE_CUR_TOP</code>，那就调整到 <code>top process state</code>；</li>
<li>设置 <code>foregroundActivities</code> 为 <code>true</code>；</li>
</ul>
</li>
</ul>
<p><strong>然后结束处理</strong>；</p>
<p><br></p>
<ul>
<li><p><strong>2、如果 r.state == ActivityState.PAUSING || r.state == ActivityState.PAUSED，表示内部有 activity 是正在暂停，或者已经暂停：</strong></p>
<ul>
<li>如果 <code>adj &gt; ProcessList.VISIBLE_APP_ADJ</code>：<strong>100</strong>，那就调整到 <code>ProcessList.VISIBLE_APP_ADJ</code>；</li>
<li>如果 <code>procState &gt; PROCESS_STATE_CUR_TOP</code>，那就调整到 <code>top process state</code>；</li>
<li>设置 <code>foregroundActivities</code> 为 <code>true</code>；</li>
</ul>
</li>
</ul>
<p><strong>然后继续处理其他 <code>activity</code></strong></p>
<p><br></p>
<ul>
<li><p><strong>3、如果 r.state == ActivityState.STOPPING，表示内部有 activity 是正在停止：</strong></p>
<ul>
<li>如果 <code>adj &gt; ProcessList.PERCEPTIBLE_APP_ADJ</code>：<strong>200</strong>，那就调整到 <code>ProcessList.PERCEPTIBLE_APP_ADJ</code>；</li>
<li>如果此时 <code>activity</code> 没有开始 <code>finish</code>，并且 <code>procState &gt; ActivityManager.PROCESS_STATE_LAST_ACTIVITY</code>：<strong>13</strong>，那就调整 <code>procState</code> 为 <code>PROCESS_STATE_LAST_ACTIVITY</code>；</li>
<li>设置 <code>foregroundActivities</code> 为 <code>true</code>，<strong>然后继续处理其他 <code>activity</code></strong>；</li>
</ul>
</li>
</ul>
<p><br></p>
<ul>
<li><strong>4、其他情况：</strong><ul>
<li>如果 <code>procState &gt; ActivityManager.PROCESS_STATE_CACHED_ACTIVITY</code>: <strong>14</strong>，那就设置 <code>procState</code> 为 <code>PROCESS_STATE_CACHED_ACTIVITY</code>，然后继续处理其他 <code>activity</code>!</li>
</ul>
</li>
</ul>
<p><br></p>
<ul>
<li><strong>5、最后，如果 <code>adj</code> 等于 <code>VISIBLE_APP_ADJ：100</code></strong>，在其之上加入 <code>minLayer</code> 调整，这样的话，最后的 <code>adj</code> 介于 <code>100</code> 和 <code>200</code> 之间！</li>
</ul>
<p><br></p>
<p><strong>我们得到：</strong></p>
<ul>
<li>对于 <strong>如果该进程是前台进程，但不是 <code>top process</code> 这种情况，其 <code>adj</code> 为 <code>FOREGROUND_APP_ADJ：0</code>，不会做 <code>adj</code> 调整</strong>，<strong>但是其 <code>procState</code> 会发生变化</strong>，其变化依据是依赖于进程内部的 <code>activity</code> 的状态，根据【3.3.1.3】节我们知道，其  <code>procState</code> 的取值如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">procState = PROCESS_STATE_CUR_TOP; <span class="comment">// 进程状态 2 或者 5！</span></span><br><span class="line">procState = ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE; <span class="comment">// 进程状态 4；</span></span><br><span class="line">procState = ActivityManager.PROCESS_STATE_RECEIVER; <span class="comment">// 进程状态 11；</span></span><br><span class="line">procState = ActivityManager.PROCESS_STATE_SERVICE; <span class="comment">// 进程状态 10；</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>可以看到，如果其内部持有非 <code>top activity</code>，这里的调整，顶多会将其调整到 <code>PROCESS_STATE_CUR_TOP</code> 级别！</p>
<ul>
<li><strong>而对于非前台进程，在【3.3.1.3】节，会被置为如下的状态</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adj = cachedAdj; <span class="comment">// 我们使用 cachedAdj ，或者为 unknowAdj；</span></span><br><span class="line">procState = ActivityManager.PROCESS_STATE_CACHED_EMPTY; <span class="comment">// 进程状态为 16；</span></span><br><span class="line">foregroundActivities = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>可以看到，如果其内持有非 <code>top activity</code>，会根据其 <code>activity</code> 的状态，其 <code>adj</code> 被调整为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内部有非 top activity，且其 visible；</span></span><br><span class="line">ProcessList.VISIBLE_APP_ADJ <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部有非 top activity，其没 visible，但是 pausing 或者 paused，或者 stoping；</span></span><br><span class="line">ProcessList.PERCEPTIBLE_APP_ADJ <span class="comment">// 200</span></span><br></pre></td></tr></table></figure></p>
<p>其 <code>procState</code> 被调整为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内部有非 top activity，其 visible / pausing / pauesed，且其 procState &gt; PROCESS_STATE_CUR_TOP（满足）</span></span><br><span class="line">ActivityManager.PROCESS_STATE_CUR_TOP <span class="comment">// 2 或者 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部有非 top activity，其 stopping，但没 finishing，且其 procState &gt; ActivityManager.PROCESS_STATE_LAST_ACTIVITY（满足）</span></span><br><span class="line">ActivityManager.PROCESS_STATE_LAST_ACTIVITY <span class="comment">// 13</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部有非 top activity，其没 visible / pausing / pauesed / stopping，且其 procState &gt; PROCESS_STATE_CACHED_ACTIVITY（满足）</span></span><br><span class="line">ActivityManager.PROCESS_STATE_CACHED_ACTIVITY <span class="comment">// 14</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>我们接着来看！！</p>
<h4 id="3-3-1-5-调整可感知进程"><a href="#3-3-1-5-调整可感知进程" class="headerlink" title="3.3.1.5 调整可感知进程"></a>3.3.1.5 调整可感知进程</h4><p>接下来处理可感知的进程，可以看到，能够进入该分支的需要满足下面某一个条件：</p>
<ul>
<li><code>adj</code> 的值大于 <code>PERCEPTIBLE_APP_ADJ（200）</code>：</li>
<li><code>procState</code> 的值大于 <code>PROCESS_STATE_FOREGROUND_SERVICE（4）</code>：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">... ... ... ... // 见上面[3.1.2.1.4]！</span><br><span class="line"></span><br><span class="line">//【5】接下来，处理 adj 大于 PERCEPTIBLE_APP_ADJ（200） </span><br><span class="line">// 或者 procState 大于 PROCESS_STATE_FOREGROUND_SERVICE（4）的情况！</span><br><span class="line">if (adj &gt; ProcessList.PERCEPTIBLE_APP_ADJ</span><br><span class="line">        || procState &gt; ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE) &#123;</span><br><span class="line"></span><br><span class="line">    if (app.foregroundServices) &#123;</span><br><span class="line"></span><br><span class="line">        //【5.1】如果该进程中有前台服务，那么用户是可以感知到这种进程的，所以是可见的！</span><br><span class="line">        // 设置 adj 最低为 PERCEPTIBLE_APP_ADJ（200）</span><br><span class="line">        // 设置 procState 最低为 PROCESS_STATE_FOREGROUND_SERVICE（4）</span><br><span class="line">        adj = ProcessList.PERCEPTIBLE_APP_ADJ;</span><br><span class="line">        procState = ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;</span><br><span class="line">        app.cached = false;</span><br><span class="line">        app.adjType = &quot;fg-service&quot;;</span><br><span class="line">        schedGroup = ProcessList.SCHED_GROUP_DEFAULT;</span><br><span class="line"></span><br><span class="line">    &#125; else if (app.forcingToForeground != null) &#123;</span><br><span class="line"></span><br><span class="line">        //【5.2】如果进程 forcingToForeground 不为 null，说明进程被强制设置到前台，同样可见！</span><br><span class="line">        // 设置 adj 最低为 PERCEPTIBLE_APP_ADJ（200）</span><br><span class="line">        // 设置 procState 最低为 PROCESS_STATE_IMPORTANT_FOREGROUND（6）</span><br><span class="line">        adj = ProcessList.PERCEPTIBLE_APP_ADJ;</span><br><span class="line">        procState = ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;</span><br><span class="line">        app.cached = false;</span><br><span class="line">        app.adjType = &quot;force-fg&quot;;</span><br><span class="line">        app.adjSource = app.forcingToForeground;</span><br><span class="line">        schedGroup = ProcessList.SCHED_GROUP_DEFAULT;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">... ... ... ... // 见下面[3.1.2.1.6]！</span><br></pre></td></tr></table></figure>
<p>对于系统进程和前台进程 <code>adj</code> 的优先级均是高于 <code>ProcessList.FOREGROUND_APP_ADJ</code>，所以第一个条件是不满足的！</p>
<p>我们来看看<strong>那些进程属于可感知的进程</strong>：</p>
<ul>
<li><strong><code>app.foregroundServices</code> 为 <code>true</code>，表示服务被 <code>start</code> 后，调用了 <code>startForeground</code> 方法</strong><br>此时我们来看看进程的属性：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adj = ProcessList.PERCEPTIBLE_APP_ADJ; <span class="comment">// 200;</span></span><br><span class="line">procState = ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE; <span class="comment">// 4</span></span><br><span class="line">schedGroup = ProcessList.SCHED_GROUP_DEFAULT;</span><br></pre></td></tr></table></figure>
<p>在 <code>Service</code> 的被启动后，可以调用 <code>startForeground</code>，让服务进程变为可感知的</p>
<ul>
<li><strong><code>app.foregroundServices</code> 为 <code>false</code>，但是 <code>app.forcingToForeground != null</code>，表示调用了 <code>setProcessForeground</code> 方法</strong><br>此时我们来看看进程的属性：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adj = ProcessList.PERCEPTIBLE_APP_ADJ; <span class="comment">// 200</span></span><br><span class="line">procState = ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND; <span class="comment">// 6</span></span><br><span class="line">schedGroup = ProcessList.SCHED_GROUP_DEFAULT;</span><br></pre></td></tr></table></figure>
<p>当我们在进程中调用了 <code>setProcessForeground</code> 方法后，该进程的 <code>app.forcingToForeground</code> 不为 <code>null</code>，这样进程就会变为可感知的！！</p>
<p><br></p>
<p><strong>注意</strong></p>
<p><strong>这里要重点看第二个条件：<code>procState &gt; ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE : 4</code></strong></p>
<p>只要满足该条件的进程，也可以进入该分支，即使对于前台进程，其 <code>adj == FOREGROUND_APP_ADJ</code>，也可能会进入该分支，比如：</p>
<ul>
<li><p>不是 <code>top process</code>，其内部没有非<code>top activity</code>，但是其内部有正在接受处理广播的 <code>BroadcastReceiver</code>，其 <code>procState ==  PROCESS_STATE_RECEIVER：11</code>!</p>
</li>
<li><p>不是 <code>top process</code>，其内部没有非<code>top activity</code>，但是其内部有正在执行的 <code>Service</code>，其 <code>procState == PROCESS_STATE_SERVICE：10</code>!</p>
</li>
</ul>
<p>如果其被显示设置成了前台的话，<code>adj</code> 和 <code>procState</code> 也会发生调整！</p>
<p>接着来看：</p>
<h4 id="3-3-1-6-heavy-weight-进程"><a href="#3-3-1-6-heavy-weight-进程" class="headerlink" title="3.3.1.6 heavy weight 进程"></a>3.3.1.6 heavy weight 进程</h4><p>下面是处理 <code>heavy weight</code> 类型的进程！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">... ... ... ... // 见上面[3.1.2.1.5]</span><br><span class="line"></span><br><span class="line">//【6】接下来，处理 heavy weight 进程！</span><br><span class="line">if (app == mHeavyWeightProcess) &#123;</span><br><span class="line"></span><br><span class="line">    //【6.1】设置进程 adj 最低为 HEAVY_WEIGHT_APP_ADJ</span><br><span class="line">    if (adj &gt; ProcessList.HEAVY_WEIGHT_APP_ADJ) &#123; // 400</span><br><span class="line">        adj = ProcessList.HEAVY_WEIGHT_APP_ADJ;</span><br><span class="line">        schedGroup = ProcessList.SCHED_GROUP_BACKGROUND;</span><br><span class="line">        app.cached = false;</span><br><span class="line">        app.adjType = &quot;heavy&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //【6.2】设置进程状态 procState 最低为 PROCESS_STATE_HEAVY_WEIGHT</span><br><span class="line">    if (procState &gt; ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) &#123; // 9</span><br><span class="line">        procState = ActivityManager.PROCESS_STATE_HEAVY_WEIGHT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">... ... ... ... // 见下面[3.1.2.1.7]</span><br></pre></td></tr></table></figure>
<p><code>ams</code> 通过 <code>mHeavyWeightProcess</code> 来保存系统中的 <code>heavy weight</code> 进程！</p>
<ul>
<li><p>如果 <code>app == mHeavyWeightProcess</code>，说明该进程是 <code>heavy weight</code> 类型的进程，我们来看看其属性设置：</p>
<ul>
<li><strong>adj = ProcessList.HEAVY_WEIGHT_APP_ADJ;</strong></li>
<li><strong>procState = ActivityManager.PROCESS_STATE_HEAVY_WEIGHT;</strong></li>
<li>schedGroup = ProcessList.SCHED_GROUP_BACKGROUND;</li>
</ul>
</li>
</ul>
<p><strong>注意</strong>，对于 <code>adj</code> 的调整，只有 <code>cacheAdj</code> 或者 <code>unKnowAdj</code> 的情况下，如果满足条件，才会被调整为 <code>HEAVY_WEIGHT_APP_ADJ</code>；</p>
<p>而对于 <code>stateProc</code>，只要 <code>procState &gt; ActivityManager.PROCESS_STATE_HEAVY_WEIGHT：9</code>，并且该进程是 <code>heavy weight</code> 进程，那就会发生调整，这个可以参见【3.3.1.6】节！</p>
<p>接着来看：</p>
<h4 id="3-3-1-7-home-进程"><a href="#3-3-1-7-home-进程" class="headerlink" title="3.3.1.7 home 进程"></a>3.3.1.7 home 进程</h4><p>下面是处理 <code>home</code> 进程！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> ... ... ... ... <span class="comment">// 见上面[3.1.2.1.6]</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//【7】接下来，处理 home 进程！</span></span><br><span class="line"> <span class="keyword">if</span> (app == mHomeProcess) &#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//【7.1】设置进程 adj 最低为 HOME_APP_ADJ</span></span><br><span class="line">     <span class="keyword">if</span> (adj &gt; ProcessList.HOME_APP_ADJ) &#123; <span class="comment">// 600</span></span><br><span class="line">         adj = ProcessList.HOME_APP_ADJ;</span><br><span class="line">         schedGroup = ProcessList.SCHED_GROUP_BACKGROUND;</span><br><span class="line">         app.cached = <span class="keyword">false</span>;</span><br><span class="line">         app.adjType = <span class="string">"home"</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//【7.2】设置进程状态 procState 最低为 PROCESS_STATE_HOME！</span></span><br><span class="line">     <span class="keyword">if</span> (procState &gt; ActivityManager.PROCESS_STATE_HOME) &#123; <span class="comment">// 12</span></span><br><span class="line">         procState = ActivityManager.PROCESS_STATE_HOME;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">... ... ... ... <span class="comment">// 见下面[3.1.2.1.8]</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>如果 <code>app == mHomeProcess</code>，说明该进程是 <code>home</code> 所在的进程，我们来看看其属性设置：</p>
<ul>
<li><strong>adj = ProcessList.HOME_APP_ADJ; // 600</strong></li>
<li><strong>procState = ActivityManager.PROCESS_STATE_HOME; // 12</strong></li>
<li>schedGroup = ProcessList.SCHED_GROUP_BACKGROUND;</li>
</ul>
</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li><p>对于 <code>home process</code> 的情况，只有 <code>cacheAdj</code> 或者 <code>unKnowAdj</code> 的情况下，才会被调整 <code>adj</code> 和 <code>procState</code>！</p>
</li>
<li><p>而对于 <code>foreground process</code>，<code>visible process</code>，<code>perceptible process</code>和 <code>heavy weight process</code> 来说，他们的 <code>adj</code> 和 <code>procState</code>都远远高于 <code>home process</code>，所以是不会调整的！</p>
</li>
</ul>
<p>接着来看：</p>
<h4 id="3-3-1-8-持有-activity-的-previous-进程"><a href="#3-3-1-8-持有-activity-的-previous-进程" class="headerlink" title="3.3.1.8 持有 activity 的 previous 进程"></a>3.3.1.8 持有 activity 的 previous 进程</h4><p>下面是处理持有 <code>activity</code> 的 <code>previous</code> 进程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> ... ... ... ... <span class="comment">// 见上面[3.1.2.1.7]</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//【8】接下来，处理用户之前所在的，持有 activity 的 previous 进程！</span></span><br><span class="line"> <span class="comment">// 因为这是前一个显示 ui 给用户的进程，我们尽量不杀死它，这样能够给用户一个好的用户体验！</span></span><br><span class="line"> <span class="keyword">if</span> (app == mPreviousProcess &amp;&amp; app.activities.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//【8.1】设置进程 adj 最低为 PREVIOUS_APP_ADJ！</span></span><br><span class="line">     <span class="keyword">if</span> (adj &gt; ProcessList.PREVIOUS_APP_ADJ) &#123; <span class="comment">// 700</span></span><br><span class="line">         adj = ProcessList.PREVIOUS_APP_ADJ;</span><br><span class="line">         schedGroup = ProcessList.SCHED_GROUP_BACKGROUND;</span><br><span class="line">         app.cached = <span class="keyword">false</span>;</span><br><span class="line">         app.adjType = <span class="string">"previous"</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//【8.2】设置进程状态 procState 最低为 PROCESS_STATE_LAST_ACTIVITY！</span></span><br><span class="line">     <span class="keyword">if</span> (procState &gt; ActivityManager.PROCESS_STATE_LAST_ACTIVITY) &#123; <span class="comment">// 13</span></span><br><span class="line">         procState = ActivityManager.PROCESS_STATE_LAST_ACTIVITY;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">false</span>) Slog.i(TAG, <span class="string">"OOM "</span> + app + <span class="string">": initial adj="</span> + adj</span><br><span class="line">         + <span class="string">" reason="</span> + app.adjType);</span><br><span class="line">         </span><br><span class="line">... ... ... ... <span class="comment">// 见下面[3.1.2.1.9]</span></span><br></pre></td></tr></table></figure>
<p><strong>持有 <code>activity</code> 的 <code>previous</code> 进程</strong>，就是上一个显示 <code>activity</code> 的进程！</p>
<ul>
<li><p><strong><code>app == mPreviousProcess &amp;&amp; app.activities.size() &gt; 0</code>，表示该进程是用户所在的上一个进程，并且该进程内部运行着 <code>activity</code>：</strong><br>下面我们来看看这类进程的属性设置：</p>
<ul>
<li><strong>adj = ProcessList.PREVIOUS_APP_ADJ</strong>;</li>
<li><strong>procState = ActivityManager.PROCESS_STATE_LAST_ACTIVITY</strong>;</li>
<li>schedGroup = ProcessList.SCHED_GROUP_BACKGROUND;</li>
</ul>
</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li><p>对于 <code>previous process</code> 的情况，只有 <code>cacheAdj</code> 或者 <code>unKnowAdj</code> 的情况下，才会被调整 <code>adj</code> 和 <code>procState</code>！</p>
</li>
<li><p>而对于 <code>foreground process</code>，<code>visible process</code>，<code>perceptible process</code>和 <code>heavy weight process</code>， <code>home process</code> 来说，他们的 <code>adj</code> 和 <code>procState</code>都远远高于 <code>previous process</code>，所以是不会调整的！</p>
</li>
</ul>
<p>接着来看：</p>
<h4 id="3-3-1-9-处于-back-up-的进程"><a href="#3-3-1-9-处于-back-up-的进程" class="headerlink" title="3.3.1.9 处于 back-up 的进程"></a>3.3.1.9 处于 back-up 的进程</h4><p>下面是处理处于 <code>back-up</code> 的进程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> ... ... ... ... <span class="comment">// 见上面[3.1.2.1.8]</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 设置进程的 adjSeq 为此时的 mAdjSeq，通过比较 adjSeq 和 mAdjSeq 就可以知道进程是否已经进行了 oomAdj 更新！</span></span><br><span class="line"> app.adjSeq = mAdjSeq;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 如果进程中的 services 或者 providers 被其他进程依赖，那么该进程的 oomAdj 也会发生变化，所以后续还要调整！</span></span><br><span class="line"> app.curRawAdj = adj; </span><br><span class="line"> app.hasStartedServices = <span class="keyword">false</span>; <span class="comment">// hasStartedServices 表示该进程中是否有被启动的 service</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//【9】接下来，处理正在执行备份操作的进程，对比这类进程，我们要避免杀死他们；</span></span><br><span class="line"> <span class="keyword">if</span> (mBackupTarget != <span class="keyword">null</span> &amp;&amp; app == mBackupTarget.app) &#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//【9.1】设置进程 adj 最低为 BACKUP_APP_ADJ：300</span></span><br><span class="line">     <span class="keyword">if</span> (adj &gt; ProcessList.BACKUP_APP_ADJ) &#123; <span class="comment">// 300</span></span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (DEBUG_BACKUP) Slog.v(TAG_BACKUP, <span class="string">"oom BACKUP_APP_ADJ for "</span> + app);</span><br><span class="line">         adj = ProcessList.BACKUP_APP_ADJ;</span><br><span class="line">         </span><br><span class="line">         <span class="comment">// 同时，设置进程 procState 最低为 PROCESS_STATE_IMPORTANT_BACKGROUND</span></span><br><span class="line">         <span class="keyword">if</span> (procState &gt; ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) &#123; <span class="comment">// 7</span></span><br><span class="line">             procState = ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         app.adjType = <span class="string">"backup"</span>;</span><br><span class="line">         app.cached = <span class="keyword">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//【9.2】设置进程状态 procState 最低为 PROCESS_STATE_BACKUP：8！</span></span><br><span class="line">     <span class="keyword">if</span> (procState &gt; ActivityManager.PROCESS_STATE_BACKUP) &#123;</span><br><span class="line">         procState = ActivityManager.PROCESS_STATE_BACKUP;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">... ... ... ... <span class="comment">// 见下面[3.1.2.1.10]</span></span><br></pre></td></tr></table></figure>
<p>对于正在备份的进程有：</p>
<ul>
<li><code>mBackupTarget != null &amp;&amp; app == mBackupTarget.app</code> 条件满足，那就做如下调整：</li>
</ul>
<p>如果 <code>adj &gt; ProcessList.BACKUP_APP_ADJ</code> 的话：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adj = ProcessList.BACKUP_APP_ADJ; <span class="comment">// 优先级最低为 BACKUP_APP_ADJ</span></span><br><span class="line">procState = ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND; <span class="comment">// 优先级最低为 PROCESS_STATE_IMPORTANT_BACKGROUND</span></span><br></pre></td></tr></table></figure></p>
<p>否则，只调整 <code>procState</code> 优先级最低为 <code>PROCESS_STATE_BACKUP</code> </p>
<p><strong>注意：</strong></p>
<ul>
<li><strong>正在备份的进程和前面遇到的进程并不冲突</strong>，比如，一个前台进程也有可能正在做备份操作，所以这里将其对应的调整放在了其他进程之后！</li>
</ul>
<p>我们继续来看：</p>
<h4 id="3-3-1-10-处理持有-services-的进程"><a href="#3-3-1-10-处理持有-services-的进程" class="headerlink" title="3.3.1.10 处理持有 services 的进程"></a>3.3.1.10 处理持有 services 的进程</h4><p>下面是处理处于持有 <code>services</code> 的进程，当进程中持有 <code>services</code> 并且别其他进程绑定后，该进程的 <code>adj</code> 和 <code>state</code> 会发生变化！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br></pre></td><td class="code"><pre><span class="line">       ... ... ... ... <span class="comment">// 见上面[3.1.2.1.9]  </span></span><br><span class="line">       </span><br><span class="line">        <span class="keyword">boolean</span> mayBeTop = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【9】处理该进程中的 serivce，判断是否有其他进程依赖这些 service，如果有，那么该进程的 adj 会发生变化！</span></span><br><span class="line">        <span class="comment">// 循环触发的条件是：adj &gt; ProcessList.FOREGROUND_APP_ADJ / schedGroup == ProcessList.SCHED_GROUP_BACKGROUND</span></span><br><span class="line">        <span class="comment">//  / procState &gt; ActivityManager.PROCESS_STATE_TOP</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> is = app.services.size()-<span class="number">1</span>;</span><br><span class="line">                is &gt;= <span class="number">0</span> &amp;&amp; (adj &gt; ProcessList.FOREGROUND_APP_ADJ</span><br><span class="line">                        || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND</span><br><span class="line">                        || procState &gt; ActivityManager.PROCESS_STATE_TOP);</span><br><span class="line">                is--) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------------------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//【9.1】处理每一个 ServiceRecord 对象！</span></span><br><span class="line">            ServiceRecord s = app.services.valueAt(is);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//【9.2】s.startRequested 为 true 表示服务是通过 startService 方式启动了！</span></span><br><span class="line">            <span class="keyword">if</span> (s.startRequested) &#123;</span><br><span class="line">                <span class="comment">// 设置 hasStartedServices 为 true！</span></span><br><span class="line">                app.hasStartedServices = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 同时设置 procState 至少为 PROCESS_STATE_SERVICE！</span></span><br><span class="line">                <span class="keyword">if</span> (procState &gt; ActivityManager.PROCESS_STATE_SERVICE) &#123; <span class="comment">// 10！</span></span><br><span class="line">                    procState = ActivityManager.PROCESS_STATE_SERVICE;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (app.hasShownUi &amp;&amp; app != mHomeProcess) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 如果进程自启动后，显示过 ui ，并且不是 home 进程，这里并没有做调整，设置了一个标记，用于 debug！</span></span><br><span class="line">                    <span class="keyword">if</span> (adj &gt; ProcessList.SERVICE_ADJ) &#123;</span><br><span class="line">                        app.adjType = <span class="string">"cch-started-ui-services"</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 如果该服务的在 30 mins 内活跃过，那么我们会保持其进程在后台之前！</span></span><br><span class="line">                    <span class="comment">// 调整 adj 最低为 SERVICE_ADJ，可以看到 adj 大于 500 的进程均会受此判断的影响！</span></span><br><span class="line">                    <span class="keyword">if</span> (now &lt; (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (adj &gt; ProcessList.SERVICE_ADJ) &#123; <span class="comment">// 500</span></span><br><span class="line">                            adj = ProcessList.SERVICE_ADJ;</span><br><span class="line">                            app.adjType = <span class="string">"started-services"</span>;</span><br><span class="line">                            app.cached = <span class="keyword">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                   </span><br><span class="line">                    <span class="comment">// 如果该服务没有活跃的时间已经超过了 30 mins，那就不会更新其 adj！</span></span><br><span class="line">                    <span class="keyword">if</span> (adj &gt; ProcessList.SERVICE_ADJ) &#123;</span><br><span class="line">                        app.adjType = <span class="string">"cch-started-services"</span>; <span class="comment">// 增加 debug 的描述信息！</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//----------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//【9.3】如果该服务被 bind 了，处理该服务的所有绑定信息！</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> conni = s.connections.size()-<span class="number">1</span>;</span><br><span class="line">                    conni &gt;= <span class="number">0</span> &amp;&amp; (adj &gt; ProcessList.FOREGROUND_APP_ADJ</span><br><span class="line">                            || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND</span><br><span class="line">                            || procState &gt; ActivityManager.PROCESS_STATE_TOP);</span><br><span class="line">                    conni--) &#123;</span><br><span class="line"></span><br><span class="line">                ArrayList&lt;ConnectionRecord&gt; clist = s.connections.valueAt(conni);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">                        i &lt; clist.size() &amp;&amp; (adj &gt; ProcessList.FOREGROUND_APP_ADJ</span><br><span class="line">                                || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND</span><br><span class="line">                                || procState &gt; ActivityManager.PROCESS_STATE_TOP);</span><br><span class="line">                        i++) &#123;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 获得连接的 client 客户端！</span></span><br><span class="line">                    ConnectionRecord cr = clist.get(i);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//【9.3.1】如果 client 的宿主进程就是当前进程，跳过！</span></span><br><span class="line">                    <span class="keyword">if</span> (cr.binding.client == app) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//【9.3.1】接下来，根据 bind 时候设置的 flags 的不同，进行不同的处理！</span></span><br><span class="line">                    </span><br><span class="line"><span class="comment">///--------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//【9.3.1.1】如果 bind 的时候没有设置 BIND_WAIVE_PRIORITY，进入下面的分支！</span></span><br><span class="line">                    <span class="comment">// BIND_WAIVE_PRIORITY 表示 client 会不会影响服务进程的优先级，为 1 表示不会影响，就不会进入 if 分支</span></span><br><span class="line">                    <span class="comment">// 为 0 表示会影响！</span></span><br><span class="line">                    <span class="keyword">if</span> ((cr.flags &amp; Context.BIND_WAIVE_PRIORITY) == <span class="number">0</span>) &#123;</span><br><span class="line">                        </span><br><span class="line">                        ProcessRecord client = cr.binding.client;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 计算绑定者进程 client 的 adj，这里依然是调用 computeOomAdjLocked 方法，不多说！</span></span><br><span class="line">                        <span class="comment">// 计算绑定者进程 client 的状态！ </span></span><br><span class="line">                        <span class="keyword">int</span> clientAdj = computeOomAdjLocked(client, cachedAdj,</span><br><span class="line">                                TOP_APP, doingAll, now);</span><br><span class="line">                        <span class="keyword">int</span> clientProcState = client.curProcState;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 当绑定者进程 client 的状态 clientProcState &gt;= PROCESS_STATE_CACHED_ACTIVITY：14</span></span><br><span class="line">                        <span class="comment">// 设置其为 PROCESS_STATE_CACHED_EMPTY：16</span></span><br><span class="line">                        <span class="keyword">if</span> (clientProcState &gt;= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) &#123;</span><br><span class="line">                            clientProcState = ActivityManager.PROCESS_STATE_CACHED_EMPTY;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        String adjType = <span class="keyword">null</span>;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 如果 bind 的时候还设置了 BIND_ALLOW_OOM_MANAGEMENT 标志位，表明</span></span><br><span class="line">                        <span class="comment">// 如果遇到 OOM 需要杀死进程，被绑定的服务进程会被 OOM 杀掉，那就不调整该进程的 adj！！</span></span><br><span class="line">                        <span class="keyword">if</span> ((cr.flags &amp; Context.BIND_ALLOW_OOM_MANAGEMENT) != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (app.hasShownUi &amp;&amp; app != mHomeProcess) &#123;</span><br><span class="line">                                <span class="comment">// 如果当前进程已经显示 ui 且不是 home 进程，</span></span><br><span class="line">                                <span class="comment">// 此时设置 clientAdj 和 clientProcState 均为当前进程的 adj 和 procState！</span></span><br><span class="line">                                <span class="comment">// 不再考虑 client 的影响！</span></span><br><span class="line">                                <span class="keyword">if</span> (adj &gt; clientAdj) &#123;</span><br><span class="line">                                    <span class="comment">// 用一个标签标记，用于debug</span></span><br><span class="line">                                    adjType = <span class="string">"cch-bound-ui-services"</span>;</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                app.cached = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                                <span class="comment">// 设置 client 的 adj 和 procState；</span></span><br><span class="line">                                clientAdj = adj;</span><br><span class="line">                                clientProcState = procState;</span><br><span class="line"></span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="comment">// 如果当前进程没有显示 ui，并且在距离上次该服务活跃的时间超过 30mins</span></span><br><span class="line">                                <span class="comment">// 此时只设置 clientAdj 为当前进程的 adj！</span></span><br><span class="line">                                <span class="comment">// 不再考虑 client 的影响！</span></span><br><span class="line">                                <span class="keyword">if</span> (now &gt;= (s.lastActivity</span><br><span class="line">                                        + ActiveServices.MAX_SERVICE_INACTIVITY)) &#123;</span><br><span class="line"></span><br><span class="line">                                    <span class="keyword">if</span> (adj &gt; clientAdj) &#123;</span><br><span class="line">                                        adjType = <span class="string">"cch-bound-services"</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line"></span><br><span class="line">                                    clientAdj = adj;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 如果 client 的 adj 和当前进程的 adj 一样，即不需要考虑客户端进程了</span></span><br><span class="line">                        <span class="comment">// 如果当前进程的 adj &gt; 绑定者进程的 clientAdj，那就需要调整当前进程的 adj，进入以下分支！</span></span><br><span class="line">                        <span class="keyword">if</span> (adj &gt; clientAdj) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (app.hasShownUi &amp;&amp; app != mHomeProcess</span><br><span class="line">                                    &amp;&amp; clientAdj &gt; ProcessList.PERCEPTIBLE_APP_ADJ) &#123;</span><br><span class="line"></span><br><span class="line">                                <span class="comment">// 如果进程显示 ui，并且不是 home process，</span></span><br><span class="line">                                <span class="comment">// 并且绑定者进程的 adj 优先级低于可感知 ProcessList.PERCEPTIBLE_APP_ADJ: 200</span></span><br><span class="line">                                <span class="comment">// 这种情况也不需要考虑客户端进程的影响！</span></span><br><span class="line">                                adjType = <span class="string">"cch-bound-ui-services"</span>;</span><br><span class="line"></span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                                <span class="comment">// 不满足上述条件，进入下面的判断，此时该进程的 adj 会收到 client 进程的 adj 的影响！</span></span><br><span class="line">                                <span class="keyword">if</span> ((cr.flags &amp; (Context.BIND_ABOVE_CLIENT</span><br><span class="line">                                        | Context.BIND_IMPORTANT)) != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                                    <span class="comment">// 如果绑定设置了 BIND_IMPORTANT 和 BIND_ABOVE_CLIENT 标记</span></span><br><span class="line">                                    <span class="comment">// BIND_ABOVE_CLIENT 表示客户端处于前台时，绑定的 service 进程也变为前台进程</span></span><br><span class="line">                                    <span class="comment">// 那么该进程的 adj 满足一下关系：</span></span><br><span class="line">                                    <span class="comment">// adj 会被调整到和 client 一样但是不超过 PERSISTENT_SERVICE_ADJ！</span></span><br><span class="line">                                    adj = clientAdj &gt;= ProcessList.PERSISTENT_SERVICE_ADJ</span><br><span class="line">                                            ? clientAdj : ProcessList.PERSISTENT_SERVICE_ADJ;</span><br><span class="line"></span><br><span class="line">                                &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((cr.flags &amp; Context.BIND_NOT_VISIBLE) != <span class="number">0</span></span><br><span class="line">                                        &amp;&amp; clientAdj &lt; ProcessList.PERCEPTIBLE_APP_ADJ</span><br><span class="line">                                        &amp;&amp; adj &gt; ProcessList.PERCEPTIBLE_APP_ADJ) &#123;</span><br><span class="line"></span><br><span class="line">                                    <span class="comment">// BIND_NOT_VISIBLE 表示服务进程不能变为 visible 进程</span></span><br><span class="line">                                    <span class="comment">// 如果绑定设置了 BIND_NOT_VISIBLE 标记，且绑定者 adj 优先级</span></span><br><span class="line">                                    <span class="comment">// 高于可感知，而当前进程的 adj 优先级低于可感知</span></span><br><span class="line">                                    <span class="comment">// 那么该进程的 adj 会被提升到可感知 PERCEPTIBLE_APP_ADJ！</span></span><br><span class="line">                                    adj = ProcessList.PERCEPTIBLE_APP_ADJ;</span><br><span class="line"></span><br><span class="line">                                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (clientAdj &gt;= ProcessList.PERCEPTIBLE_APP_ADJ) &#123;</span><br><span class="line"></span><br><span class="line">                                    <span class="comment">// 其他情况，如果 clientAdj 优先级不高于可感知</span></span><br><span class="line">                                    <span class="comment">// 那么当前进程的 adj 和 client 一样！</span></span><br><span class="line">                                    adj = clientAdj;</span><br><span class="line"> </span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                                    <span class="comment">// 其他情况，如果当前进程的 adj 大于可感知 VISIBLE_APP_ADJ</span></span><br><span class="line">                                    <span class="comment">// 那么 adj 取绑定者进程 clientAdj 和 VISIBLE_APP_ADJ 的最大值，即优先级最低的那个！</span></span><br><span class="line">                                    <span class="keyword">if</span> (adj &gt; ProcessList.VISIBLE_APP_ADJ) &#123;</span><br><span class="line">                                        adj = Math.max(clientAdj, ProcessList.VISIBLE_APP_ADJ);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                <span class="comment">// 如果绑定者进程没有处于 cache 状态，那么当前进程也不能处于 cache！</span></span><br><span class="line">                                <span class="keyword">if</span> (!client.cached) &#123;</span><br><span class="line">                                    app.cached = <span class="keyword">false</span>;</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                adjType = <span class="string">"service"</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 接下来，处理 BIND_NOT_FOREGROUND 标志位的情况！</span></span><br><span class="line">                        <span class="keyword">if</span> ((cr.flags &amp; Context.BIND_NOT_FOREGROUND) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">//【9.3.1.2】如果 bind 的时候没有设置 BIND_NOT_FOREGROUND 标志位，</span></span><br><span class="line">                            <span class="comment">// 那么被绑定的服务进程优先级可以被提升到 FOREGROUND 级别！</span></span><br><span class="line">                            </span><br><span class="line">                            <span class="comment">// 如果 client 的调度组大于该进程的调度组，调整该进程的调度组</span></span><br><span class="line">                            <span class="keyword">if</span> (client.curSchedGroup &gt; schedGroup) &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((cr.flags &amp; Context.BIND_IMPORTANT) != <span class="number">0</span>) &#123;</span><br><span class="line">                                    schedGroup = client.curSchedGroup;</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    schedGroup = ProcessList.SCHED_GROUP_DEFAULT;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 根据 client 进程的状态，设置 clientProcState 的值，后面会根据 clientProcState 为参考</span></span><br><span class="line">                            <span class="comment">// 调整该进程的 procState！</span></span><br><span class="line">                            <span class="comment">// 如果 clientProcState 优先级不低于 PROCESS_STATE_TOP，说明其处于 top 状态，进入 IF 分支</span></span><br><span class="line">                            <span class="keyword">if</span> (clientProcState &lt;= ActivityManager.PROCESS_STATE_TOP) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (clientProcState == ActivityManager.PROCESS_STATE_TOP) &#123;</span><br><span class="line">                                </span><br><span class="line">                                    <span class="comment">// 如果 clientProcState 等于 PROCESS_STATE_TOP，说明 client 进程就是 top 进程！</span></span><br><span class="line">                                    <span class="comment">// 设置 mayBeTop 为 true，后续会统一做调整，这里不做调整！</span></span><br><span class="line">                                    <span class="comment">// 设置 clientProcState 为 PROCESS_STATE_CACHED_EMPTY，不做参考！</span></span><br><span class="line">                                    mayBeTop = <span class="keyword">true</span>;</span><br><span class="line">                                    clientProcState = ActivityManager.PROCESS_STATE_CACHED_EMPTY;</span><br><span class="line"></span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    </span><br><span class="line">                                    <span class="comment">// 如果 clientProcState 小于 PROCESS_STATE_TOP，说明 client 进程的优先级比 top process</span></span><br><span class="line">                                    <span class="comment">// 还要高，比如 persistent 进程，这种情况不会将当前进程调整为 top，而是需要</span></span><br><span class="line">                                    <span class="comment">// 调整 clientProcState 的值，作为参考！</span></span><br><span class="line">                                    <span class="keyword">if</span> ((cr.flags &amp; Context.BIND_FOREGROUND_SERVICE) != <span class="number">0</span>) &#123;</span><br><span class="line">                                        clientProcState =</span><br><span class="line">                                                ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;</span><br><span class="line"></span><br><span class="line">                                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mWakefulness</span><br><span class="line">                                                    == PowerManagerInternal.WAKEFULNESS_AWAKE &amp;&amp;</span><br><span class="line">                                            (cr.flags &amp; Context.BIND_FOREGROUND_SERVICE_WHILE_AWAKE)</span><br><span class="line">                                                    != <span class="number">0</span>) &#123;</span><br><span class="line">                                        clientProcState =</span><br><span class="line">                                                ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;</span><br><span class="line"></span><br><span class="line">                                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                        clientProcState =</span><br><span class="line">                                                ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;</span><br><span class="line"></span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            </span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">//【9.3.1.2】如果 bind 的时候设置了 BIND_NOT_FOREGROUND 标志位，</span></span><br><span class="line">                            <span class="comment">// 那么被绑定的服务进程优先级不能被提升到 FOREGROUND 级别！</span></span><br><span class="line">                            <span class="comment">// 设置 clientProcState 最高为 PROCESS_STATE_IMPORTANT_BACKGROUND！</span></span><br><span class="line">                            <span class="keyword">if</span> (clientProcState &lt;</span><br><span class="line">                                    ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) &#123;</span><br><span class="line"></span><br><span class="line">                                clientProcState =</span><br><span class="line">                                        ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 如果当前进程的 state 优先级低于 client 进程的 state，设置二者相等！</span></span><br><span class="line">                        <span class="keyword">if</span> (procState &gt; clientProcState) &#123;</span><br><span class="line">                            procState = clientProcState;</span><br><span class="line">                        &#125;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 如果当前进程的状态高于 PROCESS_STATE_IMPORTANT_BACKGROUND</span></span><br><span class="line">                        <span class="comment">// 并且绑定时候设置了 BIND_SHOWING_UI 标志位，那就设置 pendingUiClean 为 true</span></span><br><span class="line">                        <span class="keyword">if</span> (procState &lt; ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND</span><br><span class="line">                                &amp;&amp; (cr.flags &amp; Context.BIND_SHOWING_UI) != <span class="number">0</span>) &#123;</span><br><span class="line">                            app.pendingUiClean = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// debug 调试相关，暂不处理！</span></span><br><span class="line">                        <span class="keyword">if</span> (adjType != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            app.adjType = adjType;</span><br><span class="line">                            app.adjTypeCode = ActivityManager.RunningAppProcessInfo</span><br><span class="line">                                    .REASON_SERVICE_IN_USE;</span><br><span class="line">                            app.adjSource = cr.binding.client;</span><br><span class="line">                            app.adjSourceProcState = clientProcState;</span><br><span class="line">                            app.adjTarget = s.name;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//【9.2.1.2】如果 bind 的时候设置了 BIND_TREAT_LIKE_ACTIVITY，设置其 treatLikeActivity 为 true！</span></span><br><span class="line">                    <span class="keyword">if</span> ((cr.flags &amp; Context.BIND_TREAT_LIKE_ACTIVITY) != <span class="number">0</span>) &#123;</span><br><span class="line">                        app.treatLikeActivity = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///-----------------------------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">final</span> ActivityRecord a = cr.activity; <span class="comment">// 获得绑定该 service 的 activity！</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//【9.2.1.3】如果 bind 的时候设置了 BIND_ADJUST_WITH_ACTIVITY，</span></span><br><span class="line">                    <span class="comment">// 表示系统根据绑定 service 的 activity 的重要程度来调整这个 service 的优先级！</span></span><br><span class="line">                    <span class="keyword">if</span> ((cr.flags&amp;Context.BIND_ADJUST_WITH_ACTIVITY) != <span class="number">0</span>) &#123;</span><br><span class="line">    </span><br><span class="line">                        <span class="comment">// 如果存在绑定者 activity，并且进程此时的 adj 大于 FOREGROUND_APP_ADJ</span></span><br><span class="line">                        <span class="comment">// 同时 activity 是可见的，或者 activity 处于 resume 或者 pause 状态，</span></span><br><span class="line">                        <span class="comment">// 那就需要调整其 adj 为 FOREGROUND_APP_ADJ！</span></span><br><span class="line">                        <span class="keyword">if</span> (a != <span class="keyword">null</span> &amp;&amp; adj &gt; ProcessList.FOREGROUND_APP_ADJ &amp;&amp;</span><br><span class="line">                            (a.visible || a.state == ActivityState.RESUMED ||</span><br><span class="line">                             a.state == ActivityState.PAUSING)) &#123;</span><br><span class="line"></span><br><span class="line">                            adj = ProcessList.FOREGROUND_APP_ADJ; <span class="comment">// 那就需要调整其 adj 为 FOREGROUND_APP_ADJ！</span></span><br><span class="line">                            </span><br><span class="line">                            <span class="comment">// 接着判断 flags 是否设置了 BIND_NOT_FOREGROUND 标志位，</span></span><br><span class="line">                            <span class="comment">// 该 flags 表示被绑定的 service 永远不会有运行于前台的优先级，如果没有设置，进入该分支！</span></span><br><span class="line">                            <span class="keyword">if</span> ((cr.flags &amp; Context.BIND_NOT_FOREGROUND) == <span class="number">0</span>) &#123;</span><br><span class="line">                            </span><br><span class="line">                                <span class="comment">// 接着判断 flags 是否设置了 BIND_IMPORTANT 标志位，</span></span><br><span class="line">                                <span class="comment">// 该标志位表示服务对客户端是非常重要的，会将服务提升至前台进程优先级！</span></span><br><span class="line">                                <span class="comment">// 调整其所属的调度组；</span></span><br><span class="line">                                <span class="keyword">if</span> ((cr.flags &amp; Context.BIND_IMPORTANT) != <span class="number">0</span>) &#123;</span><br><span class="line">                                    schedGroup = ProcessList.SCHED_GROUP_TOP_APP_BOUND;</span><br><span class="line"></span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    schedGroup = ProcessList.SCHED_GROUP_DEFAULT;</span><br><span class="line"></span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            app.cached = <span class="keyword">false</span>;</span><br><span class="line">                            app.adjType = <span class="string">"service"</span>;</span><br><span class="line">                            app.adjTypeCode = ActivityManager.RunningAppProcessInfo</span><br><span class="line">                                    .REASON_SERVICE_IN_USE;</span><br><span class="line">                            app.adjSource = a;</span><br><span class="line">                            app.adjSourceProcState = procState;</span><br><span class="line">                            app.adjTarget = s.name;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       ... ... ... ... <span class="comment">// 见下面[3.1.2.1.11]</span></span><br></pre></td></tr></table></figure>
<p><strong>1、进入条件：</strong></p>
<ul>
<li>`is &gt;= 0 &amp;&amp; (adj &gt; ProcessList.FOREGROUND_APP_ADJ || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND<pre><code>|| procState &gt; ActivityManager.PROCESS_STATE_TOP`
</code></pre><strong>第一个条件</strong>：该进程中运行着服务！<br><strong>第二个条件</strong>：<pre><code>该进程的 `adj &gt; ProcessList.FOREGROUND_APP_ADJ`，只要优先级低于前台进程，都可以满足；
或者 `schedGroup == ProcessList.SCHED_GROUP_BACKGROUND`，只要调度组为后台类型，就可以满足；
或者 `procState &gt; ActivityManager.PROCESS_STATE_TOP`，只要进程状态优先级低于 `top state`；
</code></pre></li>
</ul>
<p><strong>2、处理 <code>Service</code> 的逻辑如下</strong>：</p>
<ul>
<li>处理进程中通过 <code>startService</code> 启动的服务：</li>
<li>处理进程中被其他进程 <code>bind</code> 的服务，针对 <code>bind</code> 时候传入的 <code>flags</code> 进行不同的处理：<ul>
<li>如果设置了 <code>Context.BIND_WAIVE_PRIORITY</code>：</li>
<li>如果设置了 <code>Context.BIND_TREAT_LIKE_ACTIVITY</code>：</li>
<li>如果设置了 <code>Context.BIND_ADJUST_WITH_ACTIVITY</code>：</li>
</ul>
</li>
</ul>
<h4 id="3-3-1-11-处理持有-providers-的进程"><a href="#3-3-1-11-处理持有-providers-的进程" class="headerlink" title="3.3.1.11 处理持有 providers 的进程"></a>3.3.1.11 处理持有 providers 的进程</h4><p>最后，来看看对持有 <code>ContentProvider</code> 进程的处理， 由于 <code>ContentProvider</code> 也是有 <code>client</code> 的，所以客户端的绑定也会影响其进程！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">... ... ... ... <span class="comment">// 见上面[3.1.2.1.10]  </span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//【10】处理该进程中的 providers，判断是否有其他进程依赖这些 providers，如果有，那么该进程的 adj 会发生变化！</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> provi = app.pubProviders.size()-<span class="number">1</span>;</span><br><span class="line">         provi &gt;= <span class="number">0</span> &amp;&amp; (adj &gt; ProcessList.FOREGROUND_APP_ADJ</span><br><span class="line">                 || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND</span><br><span class="line">                 || procState &gt; ActivityManager.PROCESS_STATE_TOP);</span><br><span class="line">         provi--) &#123;</span><br><span class="line">         </span><br><span class="line">     <span class="comment">//【10.1】app.pubProviders 内部用于保存该进程中所有的 provider！</span></span><br><span class="line">     ContentProviderRecord cpr = app.pubProviders.valueAt(provi);</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = cpr.connections.size()-<span class="number">1</span>;</span><br><span class="line">             i &gt;= <span class="number">0</span> &amp;&amp; (adj &gt; ProcessList.FOREGROUND_APP_ADJ</span><br><span class="line">                     || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND</span><br><span class="line">                     || procState &gt; ActivityManager.PROCESS_STATE_TOP);</span><br><span class="line">             i--) &#123;</span><br><span class="line"></span><br><span class="line">         ContentProviderConnection conn = cpr.connections.get(i);</span><br><span class="line">         ProcessRecord client = conn.client;</span><br><span class="line"></span><br><span class="line">         <span class="comment">//【10.1.1】跳过那些同一个进程中的绑定！</span></span><br><span class="line">         <span class="keyword">if</span> (client == app) &#123;</span><br><span class="line">             <span class="keyword">continue</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">//【10.1.2】计算 client 进程的 adj 和 procState！</span></span><br><span class="line">         <span class="keyword">int</span> clientAdj = computeOomAdjLocked(client, cachedAdj, TOP_APP, doingAll, now);</span><br><span class="line">         <span class="keyword">int</span> clientProcState = client.curProcState;</span><br><span class="line">    </span><br><span class="line">         <span class="comment">//【10.1.3】如果 client 的 procState 优先级比 PROCESS_STATE_CACHED_ACTIVITY 还低，调整其最低为：</span></span><br><span class="line">         <span class="comment">// PROCESS_STATE_CACHED_EMPTY，即如果 client 进程属于缓存状态，我们一律将其视为空进程；</span></span><br><span class="line">         <span class="keyword">if</span> (clientProcState &gt;= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) &#123;</span><br><span class="line">             clientProcState = ActivityManager.PROCESS_STATE_CACHED_EMPTY;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">//【10.1.4】处理该进程的 adj 的优先级比 client 进程的 adj 低，那就需要调整该进程的 adj 了！</span></span><br><span class="line">         <span class="keyword">if</span> (adj &gt; clientAdj) &#123;</span><br><span class="line">             <span class="comment">// 这里和 Service 的处理是一样的！</span></span><br><span class="line">             <span class="comment">// 如果该进程已经显示过了 ui，并且不是 home proces，且其 client 进程的 adj 优先级低于可感知</span></span><br><span class="line">             <span class="comment">// 那就不考虑 client 进程对当前进程的影响，不调整其 adj！</span></span><br><span class="line">             <span class="keyword">if</span> (app.hasShownUi &amp;&amp; app != mHomeProcess</span><br><span class="line">                     &amp;&amp; clientAdj &gt; ProcessList.PERCEPTIBLE_APP_ADJ) &#123;</span><br><span class="line">                 app.adjType = <span class="string">"cch-ui-provider"</span>;</span><br><span class="line"></span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="comment">// 否则，将当前进程的 adj 调整为 client 进程的 adj，但是不超过 FOREGROUND_APP_ADJ！</span></span><br><span class="line">                 adj = clientAdj &gt; ProcessList.FOREGROUND_APP_ADJ</span><br><span class="line">                         ? clientAdj : ProcessList.FOREGROUND_APP_ADJ;</span><br><span class="line">                 app.adjType = <span class="string">"provider"</span>;</span><br><span class="line"></span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             app.cached &amp;= client.cached;</span><br><span class="line"></span><br><span class="line">             <span class="comment">// debug 相关，不处理！</span></span><br><span class="line">             app.adjTypeCode = ActivityManager.RunningAppProcessInfo</span><br><span class="line">                     .REASON_PROVIDER_IN_USE;</span><br><span class="line">             app.adjSource = client;</span><br><span class="line">             app.adjSourceProcState = clientProcState;</span><br><span class="line">             app.adjTarget = cpr.name;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">//【10.1.5】调整该进程的 procState！！</span></span><br><span class="line">         <span class="comment">// 如果 client 进程的 procState 优先级不高于 top process 的状态，我们要对 clientProcState 做一下调整！</span></span><br><span class="line">         <span class="keyword">if</span> (clientProcState &lt;= ActivityManager.PROCESS_STATE_TOP) &#123;</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 要先调整下 client 进程的 procState！</span></span><br><span class="line">             <span class="keyword">if</span> (clientProcState == ActivityManager.PROCESS_STATE_TOP) &#123;</span><br><span class="line">                 <span class="comment">// 如果 client 进程是 top 级别的，设置 mayBeTop 为 true，此时我们不会立刻做调整，后续会做调整！</span></span><br><span class="line">                 <span class="comment">// 设置 clientProcState 为 PROCESS_STATE_CACHED_EMPTY，不做参考！ </span></span><br><span class="line">                 mayBeTop = <span class="keyword">true</span>;</span><br><span class="line">                 clientProcState = ActivityManager.PROCESS_STATE_CACHED_EMPTY;</span><br><span class="line">                 </span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="comment">// 如果 clientProcState 小于 PROCESS_STATE_TOP，说明 client 进程的优先级比 top process</span></span><br><span class="line">                 <span class="comment">// 还要高，比如 persistent 进程，这种情况不会将当前进程调整为 top，而是需要</span></span><br><span class="line">                 <span class="comment">// 调整 clientProcState 的值，作为参考，这里是设置其为 PROCESS_STATE_BOUND_FOREGROUND_SERVICE</span></span><br><span class="line">                 clientProcState =</span><br><span class="line">                         ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 如果此时该进程的 procState 优先级低于 client 进程的 procState，提高其等于 client 进程的 procState</span></span><br><span class="line">         <span class="keyword">if</span> (procState &gt; clientProcState) &#123;</span><br><span class="line">             procState = clientProcState;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">//【10.1.6】调整该进程的调度组 schedGroup！       </span></span><br><span class="line">         <span class="keyword">if</span> (client.curSchedGroup &gt; schedGroup) &#123;</span><br><span class="line">             schedGroup = ProcessList.SCHED_GROUP_DEFAULT;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//【10.2】如何当前的 provider 依赖于一些 external (non-framework) process，</span></span><br><span class="line">     <span class="comment">// 那么我们要保证当前进程的 adj 至少为 FOREGROUND_APP_ADJ</span></span><br><span class="line">     <span class="keyword">if</span> (cpr.hasExternalProcessHandles()) &#123;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (adj &gt; ProcessList.FOREGROUND_APP_ADJ) &#123;</span><br><span class="line">             adj = ProcessList.FOREGROUND_APP_ADJ;</span><br><span class="line">             schedGroup = ProcessList.SCHED_GROUP_DEFAULT;</span><br><span class="line">             app.cached = <span class="keyword">false</span>;</span><br><span class="line">             app.adjType = <span class="string">"provider"</span>;</span><br><span class="line">             app.adjTarget = cpr.name;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (procState &gt; ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND) &#123;</span><br><span class="line">             procState = ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//【11】如果该进程中之前有 provider 活跃过，并且距离上一次 provider 活时间超过了 20 秒</span></span><br><span class="line"> <span class="comment">// 对该进程的 adj，schedGroup 和 procState 做进一步调整；</span></span><br><span class="line"> <span class="keyword">if</span> (app.lastProviderTime &gt; <span class="number">0</span> &amp;&amp; (app.lastProviderTime + CONTENT_PROVIDER_RETAIN_TIME) &gt; now) &#123;</span><br><span class="line">     <span class="keyword">if</span> (adj &gt; ProcessList.PREVIOUS_APP_ADJ) &#123;</span><br><span class="line">         adj = ProcessList.PREVIOUS_APP_ADJ;</span><br><span class="line">         schedGroup = ProcessList.SCHED_GROUP_BACKGROUND;</span><br><span class="line">         app.cached = <span class="keyword">false</span>;</span><br><span class="line">         app.adjType = <span class="string">"provider"</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (procState &gt; ActivityManager.PROCESS_STATE_LAST_ACTIVITY) &#123;</span><br><span class="line">         procState = ActivityManager.PROCESS_STATE_LAST_ACTIVITY;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> ... ... ...<span class="comment">// 见下面[3.1.2.1.12]</span></span><br></pre></td></tr></table></figure>
<p>这个方法的流程很长，我们总结一下整个的计算过程：</p>
<ul>
<li>整个的计算过程是从优先级高的 <code>adj</code> 开始，逐级向下遍历，逐渐的调整进程的 <code>oomAdj</code> 和 <code>procState</code> 的状态，知道找到一个合适的 <code>oomAdj</code> 和 <code>procState</code> 值！</li>
</ul>
<h4 id="3-3-1-12-最后调整阶段"><a href="#3-3-1-12-最后调整阶段" class="headerlink" title="3.3.1.12 最后调整阶段"></a>3.3.1.12 最后调整阶段</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">    ... ... ...<span class="comment">// 见上面[3.1.2.1.11]  </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//【12】处理 top process 绑定了当前进程的 Service 或者 Provider 的情况！</span></span><br><span class="line">    <span class="keyword">if</span> (mayBeTop &amp;&amp; procState &gt; ActivityManager.PROCESS_STATE_TOP) &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// top 进程绑定了该进程 Service 或者 provider，我们应该将该进程也设置为 top 状态</span></span><br><span class="line">        <span class="comment">// 但是如果此时该进程因为一些原因正在后台运行，我们会将其设置到特定的状态！</span></span><br><span class="line">        <span class="keyword">switch</span> (procState) &#123;</span><br><span class="line">            <span class="keyword">case</span> ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND: <span class="comment">// 很重要，可以感知到；</span></span><br><span class="line">            <span class="keyword">case</span> ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND: <span class="comment">// 很重要，感知不到；</span></span><br><span class="line">            <span class="keyword">case</span> ActivityManager.PROCESS_STATE_SERVICE: <span class="comment">// 后台服务；</span></span><br><span class="line">                <span class="comment">// 上面这三这种状态都是会长时间保持的状态，将其设置为 PROCESS_STATE_BOUND_FOREGROUND_SERVICE！</span></span><br><span class="line">                <span class="comment">// 在所有的后台进程之上</span></span><br><span class="line">                procState = ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">// 其他情况，该进程的状态为 top</span></span><br><span class="line">                procState = ActivityManager.PROCESS_STATE_TOP;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【13】如果该进程的 procState 优先级低于 PROCESS_STATE_CACHED_EMPTY，表示当前进程是一个 cache 进程！</span></span><br><span class="line">    <span class="keyword">if</span> (procState &gt;= ActivityManager.PROCESS_STATE_CACHED_EMPTY) &#123;</span><br><span class="line">        <span class="keyword">if</span> (app.hasClientActivities) &#123; </span><br><span class="line"></span><br><span class="line">            <span class="comment">// hasClientActivities 为 true，表示该进程内部有 activity 作为客户端绑定其他的服务！ </span></span><br><span class="line">            <span class="comment">// 调整 procState 为 PROCESS_STATE_CACHED_ACTIVITY_CLIENT</span></span><br><span class="line">            procState = ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT;</span><br><span class="line">            app.adjType = <span class="string">"cch-client-act"</span>;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (app.treatLikeActivity) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// treatLikeActivity 为 true，表示该进程需要被当作有 activity 的进程对待！</span></span><br><span class="line">            <span class="comment">// 设置 procState 为 PROCESS_STATE_CACHED_ACTIVITY</span></span><br><span class="line">            procState = ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;</span><br><span class="line">            app.adjType = <span class="string">"cch-as-act"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【14】如果该进程的 adj 等于 SERVICE_ADJ，这边会对进程根据 Service A list 和 Service B list 做一个划分！</span></span><br><span class="line">    <span class="keyword">if</span> (adj == ProcessList.SERVICE_ADJ) &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// doingAll 为 true 表示本次 update 更新的是所有进程的 adj，只有在空参数 update 调用的时候会为 true！</span></span><br><span class="line">        <span class="keyword">if</span> (doingAll) &#123; </span><br><span class="line">        </span><br><span class="line">            <span class="comment">// 先判断该进程是否是 Service B list 进程</span></span><br><span class="line">            app.serviceb = mNewNumAServiceProcs &gt; (mNumServiceProcs / <span class="number">3</span>);</span><br><span class="line">            </span><br><span class="line">            mNewNumServiceProcs++; <span class="comment">// 计算最新的服务进程数， + 1；</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//Slog.i(TAG, "ADJ " + app + " serviceb=" + app.serviceb);</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!app.serviceb) &#123;</span><br><span class="line">            </span><br><span class="line">                <span class="comment">// This service isn't far enough down on the LRU list to</span></span><br><span class="line">                <span class="comment">// normally be a B service, but if we are low on RAM and it</span></span><br><span class="line">                <span class="comment">// is large we want to force it down since we would prefer to</span></span><br><span class="line">                <span class="comment">// keep launcher over it.</span></span><br><span class="line">                <span class="comment">// 如果不是 Service B list，但内存回收等级过高，也被视为 Service B list</span></span><br><span class="line">                <span class="keyword">if</span> (mLastMemoryLevel &gt; ProcessStats.ADJ_MEM_FACTOR_NORMAL</span><br><span class="line">                        &amp;&amp; app.lastPss &gt;= mProcessList.getCachedRestoreThresholdKb()) &#123;</span><br><span class="line">                    app.serviceHighRam = <span class="keyword">true</span>;</span><br><span class="line">                    app.serviceb = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="comment">//Slog.i(TAG, "ADJ " + app + " high ram!");</span></span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Service A list 类型的进程数 + 1；</span></span><br><span class="line">                    mNewNumAServiceProcs++;</span><br><span class="line">                    <span class="comment">//Slog.i(TAG, "ADJ " + app + " not high ram!");</span></span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                app.serviceHighRam = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (app.serviceb) &#123; </span><br><span class="line">            <span class="comment">// 如果 serviceb 为 true，则该进程是 Service B list 中的！</span></span><br><span class="line">            <span class="comment">// 设置其 adj 为 SERVICE_B_ADJ！</span></span><br><span class="line">            adj = ProcessList.SERVICE_B_ADJ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置进程的 curRawAdj 为最终的计算结果！</span></span><br><span class="line">    app.curRawAdj = adj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Slog.i(TAG, "OOM ADJ " + app + ": pid=" + app.pid +</span></span><br><span class="line">    <span class="comment">//      " adj=" + adj + " curAdj=" + app.curAdj + " maxAdj=" + app.maxAdj);</span></span><br><span class="line">    <span class="keyword">if</span> (adj &gt; app.maxAdj) &#123;</span><br><span class="line">        adj = app.maxAdj;</span><br><span class="line">        <span class="keyword">if</span> (app.maxAdj &lt;= ProcessList.PERCEPTIBLE_APP_ADJ) &#123;</span><br><span class="line">            schedGroup = ProcessList.SCHED_GROUP_DEFAULT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do final modification to adj.  Everything we do between here and applying</span></span><br><span class="line">    <span class="comment">// the final setAdj must be done in this function, because we will also use</span></span><br><span class="line">    <span class="comment">// it when computing the final cached adj later.  Note that we don't need to</span></span><br><span class="line">    <span class="comment">// worry about this for max adj above, since max adj will always be used to</span></span><br><span class="line">    <span class="comment">// keep it out of the cached vaues.</span></span><br><span class="line">    <span class="comment">// 对上面计算出的 adj 做第二次修正计算，其返回值是进程的最终 adj！！</span></span><br><span class="line">    app.curAdj = app.modifyRawOomAdj(adj);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置其他的一些变量属性！</span></span><br><span class="line">    app.curSchedGroup = schedGroup;</span><br><span class="line">    app.curProcState = procState;</span><br><span class="line">    app.foregroundActivities = foregroundActivities;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.curRawAdj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里调用了 <code>modifyRawOomAdj</code> 方法，根据 <code>BIND_ABOVE_CLIENT</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">modifyRawOomAdj</span><span class="params">(<span class="keyword">int</span> adj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// hasAboveClient 为 true，表示该进程通过 BIND_ABOVE_CLIENT 方式绑定了 Service！</span></span><br><span class="line">    <span class="comment">// BIND_ABOVE_CLIENT 表示该进程的优先级已经超过了 Activity，也就是说当资源不够的时候 Activity 要比 Service 先死；</span></span><br><span class="line">    <span class="comment">// 所以需要降低该进程的 adj 优先级！</span></span><br><span class="line">    <span class="keyword">if</span> (hasAboveClient) &#123;</span><br><span class="line">        <span class="keyword">if</span> (adj &lt; ProcessList.FOREGROUND_APP_ADJ) &#123;</span><br><span class="line">            <span class="comment">// System process will not get dropped, ever</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (adj &lt; ProcessList.VISIBLE_APP_ADJ) &#123;</span><br><span class="line">            adj = ProcessList.VISIBLE_APP_ADJ;</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (adj &lt; ProcessList.PERCEPTIBLE_APP_ADJ) &#123;</span><br><span class="line">            adj = ProcessList.PERCEPTIBLE_APP_ADJ;</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (adj &lt; ProcessList.CACHED_APP_MIN_ADJ) &#123;</span><br><span class="line">            adj = ProcessList.CACHED_APP_MIN_ADJ;</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (adj &lt; ProcessList.CACHED_APP_MAX_ADJ) &#123;</span><br><span class="line">            adj++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 一般情况是直接返回第一次计算后的值的！</span></span><br><span class="line">    <span class="keyword">return</span> adj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>LRU list</code> 中，从后往前数，前 <code>1/3</code> 的 <code>service</code> 进程就是 <code>AService</code> 进程，其余的就是 <code>BService</code> 进程；</p>
<h3 id="3-3-2-ActivityManagerS-applyOomAdjLocked"><a href="#3-3-2-ActivityManagerS-applyOomAdjLocked" class="headerlink" title="3.3.2  ActivityManagerS.applyOomAdjLocked"></a>3.3.2  ActivityManagerS.applyOomAdjLocked</h3><p>最后，<code>applyOomAdjLocked</code> 方法用来应用计算出的 <code>adj</code>！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">applyOomAdjLocked</span><span class="params">(ProcessRecord app, <span class="keyword">boolean</span> doingAll, <span class="keyword">long</span> now,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span> nowElapsed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> success = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】更新 setRawAdj 的值！</span></span><br><span class="line">    <span class="keyword">if</span> (app.curRawAdj != app.setRawAdj) &#123;</span><br><span class="line">        app.setRawAdj = app.curRawAdj; <span class="comment">// 更新 setRawAdj！</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> changes = <span class="number">0</span>; <span class="comment">// 用于记录进程的状态是否发生了变化！</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】更新 setAdj 的值！</span></span><br><span class="line">    <span class="keyword">if</span> (app.curAdj != app.setAdj) &#123;</span><br><span class="line">        ProcessList.setOomAdj(app.pid, app.info.uid, app.curAdj); <span class="comment">// 设置进程的最新 adj！</span></span><br><span class="line">        <span class="keyword">if</span> (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,</span><br><span class="line">                <span class="string">"Set "</span> + app.pid + <span class="string">" "</span> + app.processName + <span class="string">" adj "</span> + app.curAdj + <span class="string">": "</span></span><br><span class="line">                + app.adjType);</span><br><span class="line">        app.setAdj = app.curAdj;  <span class="comment">// 更新 setAdj！</span></span><br><span class="line">        app.verifiedAdj = ProcessList.INVALID_ADJ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【3】更新 setSchedGroup 调度组信息！</span></span><br><span class="line">    <span class="keyword">if</span> (app.setSchedGroup != app.curSchedGroup) &#123;</span><br><span class="line">        <span class="keyword">int</span> oldSchedGroup = app.setSchedGroup;</span><br><span class="line">        app.setSchedGroup = app.curSchedGroup; <span class="comment">// 更新 setSchedGroup！</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,</span><br><span class="line">                <span class="string">"Setting sched group of "</span> + app.processName</span><br><span class="line">                + <span class="string">" to "</span> + app.curSchedGroup);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (app.waitingToKill != <span class="keyword">null</span> &amp;&amp; app.curReceiver == <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; app.setSchedGroup == ProcessList.SCHED_GROUP_BACKGROUND) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【3.1】杀掉那些之前延迟 kill，现在不持有 receiver 且属于后台的进程！</span></span><br><span class="line">            app.kill(app.waitingToKill, <span class="keyword">true</span>);</span><br><span class="line">            success = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【3.2】根据调度组 curSchedGroup，设置进程组信息！</span></span><br><span class="line">            <span class="keyword">int</span> processGroup;</span><br><span class="line">            <span class="keyword">switch</span> (app.curSchedGroup) &#123;</span><br><span class="line">                <span class="keyword">case</span> ProcessList.SCHED_GROUP_BACKGROUND:</span><br><span class="line">                    <span class="comment">// 后台调度组: 6</span></span><br><span class="line">                    processGroup = Process.THREAD_GROUP_BG_NONINTERACTIVE;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> ProcessList.SCHED_GROUP_TOP_APP:</span><br><span class="line">                <span class="keyword">case</span> ProcessList.SCHED_GROUP_TOP_APP_BOUND:</span><br><span class="line">                    <span class="comment">// 前台调度组：5</span></span><br><span class="line">                    processGroup = Process.THREAD_GROUP_TOP_APP;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="comment">// 默认调度组：-1</span></span><br><span class="line">                    processGroup = Process.THREAD_GROUP_DEFAULT;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> oldId = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//【3.3】设置进程的调度组！</span></span><br><span class="line">                Process.setProcessGroup(app.pid, processGroup);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//【3.4】根据调度组，设置</span></span><br><span class="line">                <span class="keyword">if</span> (app.curSchedGroup == ProcessList.SCHED_GROUP_TOP_APP) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// do nothing if we already switched to RT</span></span><br><span class="line">                    <span class="comment">//【3.3.1】如果之前进程的调度组不是 top app 级别，而现在的调度组是 top app 级别，进入这里！</span></span><br><span class="line">                    <span class="keyword">if</span> (oldSchedGroup != ProcessList.SCHED_GROUP_TOP_APP) &#123;</span><br><span class="line">                    </span><br><span class="line">                        <span class="comment">// Switch VR thread for app to SCHED_FIFO</span></span><br><span class="line">                        <span class="keyword">if</span> (mInVrMode &amp;&amp; app.vrThreadTid != <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                <span class="comment">// 如果进程启动了 VR    </span></span><br><span class="line">                                Process.setThreadScheduler(app.vrThreadTid,</span><br><span class="line">                                    Process.SCHED_FIFO | Process.SCHED_RESET_ON_FORK, <span class="number">1</span>);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">                                <span class="comment">// thread died, ignore</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (mUseFifoUiScheduling) &#123;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// Switch UI pipeline for app to SCHED_FIFO</span></span><br><span class="line">                            app.savedPriority = Process.getThreadPriority(app.pid);</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                Process.setThreadScheduler(app.pid,</span><br><span class="line">                                    Process.SCHED_FIFO | Process.SCHED_RESET_ON_FORK, <span class="number">1</span>);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">                                <span class="comment">// thread died, ignore</span></span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (app.renderThreadTid != <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    Process.setThreadScheduler(app.renderThreadTid,</span><br><span class="line">                                        Process.SCHED_FIFO | Process.SCHED_RESET_ON_FORK, <span class="number">1</span>);</span><br><span class="line">                                &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">                                    <span class="comment">// thread died, ignore</span></span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">if</span> (DEBUG_OOM_ADJ) &#123;</span><br><span class="line">                                    Slog.d(<span class="string">"UI_FIFO"</span>, <span class="string">"Set RenderThread (TID "</span> +</span><br><span class="line">                                        app.renderThreadTid + <span class="string">") to FIFO"</span>);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (DEBUG_OOM_ADJ) &#123;</span><br><span class="line">                                    Slog.d(<span class="string">"UI_FIFO"</span>, <span class="string">"Not setting RenderThread TID"</span>);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// Boost priority for top app UI and render threads</span></span><br><span class="line">                            Process.setThreadPriority(app.pid, -<span class="number">10</span>);</span><br><span class="line">                            <span class="keyword">if</span> (app.renderThreadTid != <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    Process.setThreadPriority(app.renderThreadTid, -<span class="number">10</span>);</span><br><span class="line">                                &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">                                    <span class="comment">// thread died, ignore</span></span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldSchedGroup == ProcessList.SCHED_GROUP_TOP_APP &amp;&amp;</span><br><span class="line">                           app.curSchedGroup != ProcessList.SCHED_GROUP_TOP_APP) &#123;</span><br><span class="line">                <span class="comment">//【3.3.2】如果之前进程的调度组是 top app 级别，而现在的调度组不是 top app 级别，则进入这里！</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Reset VR thread to SCHED_OTHER</span></span><br><span class="line">                    <span class="comment">// Safe to do even if we're not in VR mode</span></span><br><span class="line">                    <span class="comment">// 进程的 vrThreadTid 不等于 0，说明我们在 VR 模式！</span></span><br><span class="line">                    <span class="keyword">if</span> (app.vrThreadTid != <span class="number">0</span>) &#123;</span><br><span class="line">                        Process.setThreadScheduler(app.vrThreadTid, Process.SCHED_OTHER, <span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (mUseFifoUiScheduling) &#123;</span><br><span class="line">                        <span class="comment">// Reset UI pipeline to SCHED_OTHER</span></span><br><span class="line">                        Process.setThreadScheduler(app.pid, Process.SCHED_OTHER, <span class="number">0</span>);</span><br><span class="line">                        Process.setThreadPriority(app.pid, app.savedPriority);</span><br><span class="line">                        <span class="keyword">if</span> (app.renderThreadTid != <span class="number">0</span>) &#123;</span><br><span class="line">                            Process.setThreadScheduler(app.renderThreadTid,</span><br><span class="line">                                Process.SCHED_OTHER, <span class="number">0</span>);</span><br><span class="line">                            Process.setThreadPriority(app.renderThreadTid, -<span class="number">4</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// Reset priority for top app UI and render threads</span></span><br><span class="line">                        Process.setThreadPriority(app.pid, <span class="number">0</span>);</span><br><span class="line">                        <span class="keyword">if</span> (app.renderThreadTid != <span class="number">0</span>) &#123;</span><br><span class="line">                            Process.setThreadPriority(app.renderThreadTid, <span class="number">0</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Failed setting process group of "</span> + app.pid</span><br><span class="line">                        + <span class="string">" to "</span> + app.curSchedGroup);</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                Binder.restoreCallingIdentity(oldId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【4】接下来是记录进程的信息和状态的变化！</span></span><br><span class="line">    <span class="comment">// 进程内部的 acitivity 的状态发生了变化！ProcessChangeItem.CHANGE_ACTIVITIES</span></span><br><span class="line">    <span class="keyword">if</span> (app.repForegroundActivities != app.foregroundActivities) &#123;</span><br><span class="line">        app.repForegroundActivities = app.foregroundActivities; <span class="comment">// 更新 repForegroundActivities！</span></span><br><span class="line">        changes |= ProcessChangeItem.CHANGE_ACTIVITIES;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【5】进程状态发生了变化，通知上层应用进程！！</span></span><br><span class="line">    <span class="keyword">if</span> (app.repProcState != app.curProcState) &#123;</span><br><span class="line">        app.repProcState = app.curProcState; <span class="comment">// 更新 repProcState！</span></span><br><span class="line">        changes |= ProcessChangeItem.CHANGE_PROCESS_STATE;</span><br><span class="line">        <span class="keyword">if</span> (app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">                    <span class="comment">//RuntimeException h = new RuntimeException("here");</span></span><br><span class="line">                    Slog.i(TAG, <span class="string">"Sending new process state "</span> + app.repProcState</span><br><span class="line">                            + <span class="string">" to "</span> + app <span class="comment">/*, h*/</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//【5.1】通知上层进程！</span></span><br><span class="line">                app.thread.setProcessState(app.repProcState);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【5】如果进程在先后状态下的内存状态不同，那就要更新下下次申请 PSS 的时间！</span></span><br><span class="line">    <span class="keyword">if</span> (app.setProcState == ActivityManager.PROCESS_STATE_NONEXISTENT</span><br><span class="line">            || ProcessList.procStatesDifferForMem(app.curProcState, app.setProcState)) &#123;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">false</span> &amp;&amp; mTestPssMode &amp;&amp; app.setProcState &gt;= <span class="number">0</span> &amp;&amp; app.lastStateTime &lt;= (now - <span class="number">200</span>)) &#123; <span class="comment">// 用于 debug！</span></span><br><span class="line">            <span class="keyword">long</span> start = SystemClock.uptimeMillis();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 记录 PPS 物理内存！</span></span><br><span class="line">            <span class="keyword">long</span> pss = Debug.getPss(app.pid, mTmpLong, <span class="keyword">null</span>);</span><br><span class="line">            recordPssSampleLocked(app, app.curProcState, pss, mTmpLong[<span class="number">0</span>], mTmpLong[<span class="number">1</span>], now);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从 mPendingPssProcesses 列表中删除当前进程！</span></span><br><span class="line">            mPendingPssProcesses.remove(app);</span><br><span class="line">            Slog.i(TAG, <span class="string">"Recorded pss for "</span> + app + <span class="string">" state "</span> + app.setProcState</span><br><span class="line">                    + <span class="string">" to "</span> + app.curProcState + <span class="string">": "</span></span><br><span class="line">                    + (SystemClock.uptimeMillis()-start) + <span class="string">"ms"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        app.lastStateTime = now;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【5.1】更新下次申请 pss 内存的时间！</span></span><br><span class="line">        app.nextPssTime = ProcessList.computeNextPssTime(app.curProcState, <span class="keyword">true</span>,</span><br><span class="line">                mTestPssMode, isSleepingLocked(), now);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DEBUG_PSS) Slog.d(TAG_PSS, <span class="string">"Process state change from "</span></span><br><span class="line">                + ProcessList.makeProcStateString(app.setProcState) + <span class="string">" to "</span></span><br><span class="line">                + ProcessList.makeProcStateString(app.curProcState) + <span class="string">" next pss in "</span></span><br><span class="line">                + (app.nextPssTime-now) + <span class="string">": "</span> + app);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//【5.2】如果当前时间已经超过了 nextPssTime 下一次申请 PSS 的时间</span></span><br><span class="line">        <span class="comment">// 那就要请求 PSS 物理内存！</span></span><br><span class="line">        <span class="keyword">if</span> (now &gt; app.nextPssTime || (now &gt; (app.lastPssTime + ProcessList.PSS_MAX_INTERVAL)</span><br><span class="line">                &amp;&amp; now &gt; (app.lastStateTime + ProcessList.minTimeFromStateChange(</span><br><span class="line">                mTestPssMode)))) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 请求物理内存！</span></span><br><span class="line">            requestPssLocked(app, app.setProcState);</span><br><span class="line">            app.nextPssTime = ProcessList.computeNextPssTime(app.curProcState, <span class="keyword">false</span>,</span><br><span class="line">                    mTestPssMode, isSleepingLocked(), now);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">false</span> &amp;&amp; DEBUG_PSS) Slog.d(TAG_PSS,</span><br><span class="line">                <span class="string">"Not requesting PSS of "</span> + app + <span class="string">": next="</span> + (app.nextPssTime-now));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【6】更新 setProcState 属性！</span></span><br><span class="line">    <span class="keyword">if</span> (app.setProcState != app.curProcState) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,</span><br><span class="line">                <span class="string">"Proc state change of "</span> + app.processName</span><br><span class="line">                        + <span class="string">" to "</span> + app.curProcState);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算进程状态变化前后的重要性！</span></span><br><span class="line">        <span class="keyword">boolean</span> setImportant = app.setProcState &lt; ActivityManager.PROCESS_STATE_SERVICE;</span><br><span class="line">        <span class="keyword">boolean</span> curImportant = app.curProcState &lt; ActivityManager.PROCESS_STATE_SERVICE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (setImportant &amp;&amp; !curImportant) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果进程变的不重要了，需要记录下其 wake time，用于后续的 kill 操作！</span></span><br><span class="line">            BatteryStatsImpl stats = mBatteryStatsService.getActiveStatistics();</span><br><span class="line">            <span class="keyword">synchronized</span> (stats) &#123;</span><br><span class="line">                app.lastWakeTime = stats.getProcessWakeTime(app.info.uid,</span><br><span class="line">                        app.pid, nowElapsed);</span><br><span class="line">            &#125;</span><br><span class="line">            app.lastCpuTime = app.curCpuTime;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新进程的使用情况！</span></span><br><span class="line">        maybeUpdateUsageStatsLocked(app, nowElapsed);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新 setProcState！</span></span><br><span class="line">        app.setProcState = app.curProcState;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (app.setProcState &gt;= ActivityManager.PROCESS_STATE_HOME) &#123;</span><br><span class="line">            app.notCachedSinceIdle = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!doingAll) &#123;</span><br><span class="line">            setProcessTrackerStateLocked(app, mProcessStats.getMemFactorLocked(), now);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            app.procStateChanged = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (app.reportedInteraction &amp;&amp; (nowElapsed - app.interactionEventTime)</span><br><span class="line">            &gt; USAGE_STATS_INTERACTION_INTERVAL) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// For apps that sit around for a long time in the interactive state, we need</span></span><br><span class="line">        <span class="comment">// to report this at least once a day so they don't go idle.</span></span><br><span class="line">        maybeUpdateUsageStatsLocked(app, nowElapsed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【7】如果 changes 不等于 0，说明进程的状态信息发生了变化！</span></span><br><span class="line">    <span class="comment">// 我们需要将这次的改变封装为 mPendingProcessChanges，通知那些监控进程变化的服务！</span></span><br><span class="line">    <span class="keyword">if</span> (changes  != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DEBUG_PROCESS_OBSERVERS) Slog.i(TAG_PROCESS_OBSERVERS,</span><br><span class="line">                <span class="string">"Changes in "</span> + app + <span class="string">": "</span> + changes);</span><br><span class="line">                </span><br><span class="line">        <span class="comment">// 判断该进程是否已经有一个 ProcessChangeItem！</span></span><br><span class="line">        <span class="keyword">int</span> i = mPendingProcessChanges.size()-<span class="number">1</span>;</span><br><span class="line">        ProcessChangeItem item = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            item = mPendingProcessChanges.get(i);</span><br><span class="line">            <span class="keyword">if</span> (item.pid == app.pid) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_PROCESS_OBSERVERS) Slog.i(TAG_PROCESS_OBSERVERS,</span><br><span class="line">                        <span class="string">"Re-using existing item: "</span> + item);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// i &lt; 0 说明该进程没有已存在的等待处理的 ProcessChangeItem 项，那就创建一个新的！</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> NA = mAvailProcessChanges.size();</span><br><span class="line">            <span class="comment">// 尝试从 mAvailProcessChanges 中回收复用一个 ProcessChangeItem 项！</span></span><br><span class="line">            <span class="comment">// 不能回收，就创建一个新的！</span></span><br><span class="line">            <span class="keyword">if</span> (NA &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                item = mAvailProcessChanges.remove(NA-<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_PROCESS_OBSERVERS) Slog.i(TAG_PROCESS_OBSERVERS,</span><br><span class="line">                        <span class="string">"Retrieving available item: "</span> + item);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                item = <span class="keyword">new</span> ProcessChangeItem();</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_PROCESS_OBSERVERS) Slog.i(TAG_PROCESS_OBSERVERS,</span><br><span class="line">                        <span class="string">"Allocating new item: "</span> + item);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 初始化变量！</span></span><br><span class="line">            item.changes = <span class="number">0</span>;</span><br><span class="line">            item.pid = app.pid;</span><br><span class="line">            item.uid = app.info.uid;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mPendingProcessChanges.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_PROCESS_OBSERVERS) Slog.i(TAG_PROCESS_OBSERVERS,</span><br><span class="line">                        <span class="string">"*** Enqueueing dispatch processes changed!"</span>);</span><br><span class="line">                mUiHandler.obtainMessage(DISPATCH_PROCESSES_CHANGED_UI_MSG).sendToTarget();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加到 mPendingProcessChanges 列表中！</span></span><br><span class="line">            mPendingProcessChanges.add(item);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置 ProcessChangeItem 的属性！</span></span><br><span class="line">        item.changes |= changes;</span><br><span class="line">        item.processState = app.repProcState;</span><br><span class="line">        item.foregroundActivities = app.repForegroundActivities;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (DEBUG_PROCESS_OBSERVERS) Slog.i(TAG_PROCESS_OBSERVERS,</span><br><span class="line">                <span class="string">"Item "</span> + Integer.toHexString(System.identityHashCode(item))</span><br><span class="line">                + <span class="string">" "</span> + app.toShortString() + <span class="string">": changes="</span> + item.changes</span><br><span class="line">                + <span class="string">" procState="</span> + item.processState</span><br><span class="line">                + <span class="string">" foreground="</span> + item.foregroundActivities</span><br><span class="line">                + <span class="string">" type="</span> + app.adjType + <span class="string">" source="</span> + app.adjSource</span><br><span class="line">                + <span class="string">" target="</span> + app.adjTarget);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h1><p>首先，我们知道对于进程的优先级，<code>Android</code> 有 <code>2</code> 套分级机制：</p>
<ul>
<li><code>ActivityManagerService</code> 中对进程优先级的分级，以 <code>PROCESS_STATE_</code> 开头，定义在 <code>ActivityManager.java</code> 中;</li>
<li><code>LowMemoryKiller</code> 通过 <code>oomAdj</code> 对进程优先级的分级;</li>
</ul>
<pre><code>//开始逆序处理LRU中的每一个进程
// 对应重要性大于home的进程而言，重要性越高，内存回收等级越低
// 对于重要性小于home的进程，排在LRU表越靠后，即越重要回收等级越高
// 这么安排的理由有两个：1、此时越不重要的进程，其中运行的组件越少，能够回收的内存不多，不需要高回收等级
// 2、越不重要的进程越有可能被LMK kill掉，没必要以高等级回收内存
</code></pre><p>Android 并不是 kill 掉所有 Empty 进程后，才 kill 后台进程。<br>它是将 CACHED_APP_MIN_ADJ 和 CACHED_APP_MAX_ADJ 之间的范围，分成 3 个 slot。 </p>
<p>然后在每个 slot 中，分别分配一定量的后台进程和 Empty 进程。<br>在单独的 slot 中，会先 kill 掉 empty 进程，后 kill 掉后台进程。<br>只有当一个 slot 中的进程 kill 完毕后，才会 kill 掉下一个 slot 中的进程。<br>我们将从后面的代码中，得到对应的分析依据，这里先有个印象即可。</p>
<p>  <a href="http://blog.csdn.net/Gaugamela/article/details/54176460" target="_blank" rel="noopener">http://blog.csdn.net/Gaugamela/article/details/54176460</a></p>
<p>  <a href="http://www.cnblogs.com/tiger-wang-ms/p/6445213.html" target="_blank" rel="noopener">http://www.cnblogs.com/tiger-wang-ms/p/6445213.html</a></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2016/05/10/BroadcastReceiver篇 5 - sendBroadcast 流程分析/">BroadcastReceiver篇 5 - sendBroadcast 流程分析</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2016-05-10</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/AndroidFramework源码分析/">AndroidFramework源码分析</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/AndroidFramework源码分析/BroadcastReceiver广播接收者/">BroadcastReceiver广播接收者</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/BroadcastReceiver广播接收者/">BroadcastReceiver广播接收者</a></span><div class="content"><p>[toc]</p>
<p>本文基于 Android 7.1.1，分析发送广播的流程，转载请说明出处！</p>
<p>写本文的目的：</p>
<ul>
<li>了解广播发送的流程；</li>
<li>了解 AMS 对广播接收者组件的管理；</li>
<li>记录自己的研究和分析；</li>
</ul>
<h1 id="0-综述"><a href="#0-综述" class="headerlink" title="0 综述"></a>0 综述</h1><p>在 Android 系统中，有如下种类的广播，他们的发送方式各不一样，我们先来简单的了解一下：</p>
<p><strong>1. 普通广播</strong></p>
<p>发送普通广播的方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sendBroadcast(...)</span><br><span class="line">sendBroadcastMultiplePermissions(...)</span><br><span class="line">sendBroadcastAsUser(...)</span><br></pre></td></tr></table></figure></p>
<p>普通广播的发送参数 serialized 为 <code>false</code>，<code>sticky</code> 也为 <code>false</code>，表示普通广播既不是粘性的，也不是无序的；</p>
<p>对于普通广播，<code>AMS</code> 会针对其接收者的类型做不同的处理：</p>
<ul>
<li>对于动态注册的广播接收者，<code>AMS</code> 会遍历对应的目标接收者集合，依次发送广播；</li>
<li>对于静态注册的广播接收者，<code>AMS</code> 在发送普通广播时，会按照有序的方式来进行分发；</li>
</ul>
<p>由此可见，对于普通广播来说，动态注册的广播接收者会先接收到广播！</p>
<p><br></p>
<p><strong>2. 有序广播</strong></p>
<p>发送有序广播的方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sendOrderedBroadcast(...)</span><br><span class="line">sendOrderedBroadcastAsUser(...)</span><br></pre></td></tr></table></figure></p>
<p>有序广播的发送参数 <code>serialized</code> 为 <code>true</code>，<code>sticky</code> 为 <code>false</code>；</p>
<p>对于有序广播，AMS 会收集能够匹配的静态注册和动态注册的广播接收者，按照优先级们，依次有序的发送广播！</p>
<p>AMS 收到上一个 <code>BroadcastReceiver</code> 处理完毕的消息返回后，才会将广播发送给下一个 <code>BroadcastReceiver</code>；其中，任意一个 <code>BroadcastReceiver</code>，都可以中止后续的广播分发流程；同时，上一个 <code>BroadcastReceiver</code> 可以将额外的信息添加到广播中。</p>
<p>对于发送给静态注册的广播接收者的普通广播，<code>AMS</code> 是将其按照发送有序广播的方式来进行发送的，因为静态注册的接收者由于其注册方式的特殊性，其所在进程可能没有被启动，所以如果采用并发的方式发送，那么系统需要在同一时间启动大量的进程，这显然不是合理的设计！</p>
<p><br></p>
<p><strong>3. 粘性广播</strong></p>
<p>发送粘性广播的方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sendStickyBroadcast(...)</span><br><span class="line">sendStickyBroadcastAsUser(...)</span><br></pre></td></tr></table></figure></p>
<p>粘性广播的发送参数 <code>serialized</code> 为 <code>false</code>，<code>sticky</code> 为 <code>true</code>；</p>
<p>粘性广播的特性是系统会保存这个广播，当系统中又新注册了一个广播接收者时，该接收者会立刻接收到这个广播，粘性广播默认属于普通广播！</p>
<p><br></p>
<p><strong>4. 粘性有序广播</strong></p>
<p>发送粘性有序广播的方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sendStickyOrderedBroadcast(...)</span><br></pre></td></tr></table></figure></p>
<p>粘性广播的发送参数 <code>serialized</code> 为 <code>true</code>，<code>sticky</code> 为 <code>true</code>；</p>
<p>粘性有序广播本质上属于有序广播，只不过其具有 “粘性”！</p>
<p><br></p>
<p>本篇文章，会主要分析下广播的发送和处理过程：</p>
<h1 id="1-发送者进程"><a href="#1-发送者进程" class="headerlink" title="1 发送者进程"></a>1 发送者进程</h1><h2 id="1-1-ContextWapper-sendBroadcast"><a href="#1-1-ContextWapper-sendBroadcast" class="headerlink" title="1.1 ContextWapper.sendBroadcast"></a>1.1 ContextWapper.sendBroadcast</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendBroadcast</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1.2】继续调用</span></span><br><span class="line">    mBase.sendBroadcast(intent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">... ... ... ...</span><br></pre></td></tr></table></figure>
<p>这里的 <code>mBase</code> 对象是 <code>ContextImpl</code> 实例，其他的方法的调用方式也是一样的！</p>
<h2 id="1-2-ContextImpl-sendBroadcast"><a href="#1-2-ContextImpl-sendBroadcast" class="headerlink" title="1.2 ContextImpl.sendBroadcast"></a>1.2 ContextImpl.sendBroadcast</h2><p>进入 <code>ContextImpl</code>，我们看看不同的 <code>send</code> 方法都做了什么操作：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendBroadcast</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">    warnIfCallingFromSystemProcess();</span><br><span class="line">    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        intent.prepareToLeaveProcess(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//【1.3】开始发送广播！</span></span><br><span class="line">        ActivityManagerNative.getDefault().broadcastIntent(</span><br><span class="line">                mMainThread.getApplicationThread(), intent, resolvedType, <span class="keyword">null</span>,</span><br><span class="line">                Activity.RESULT_OK, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, AppOpsManager.OP_NONE, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">false</span>,</span><br><span class="line">                getUserId());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，这里最终调用了 <code>AMS</code> 的 <code>broadcastIntent</code> 方法！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** &#123;<span class="doctag">@hide</span>&#125; */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getUserId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mUser.getIdentifier();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getUserId 方法用来获得进程所在的设备用户 <code>id</code>，一般我们在应用程序进程中，只能获得当前的设备用户 <code>id</code>，这个 <code>id</code> 是进程启动时获得的！</p>
<h2 id="1-3-ActivityManagerProxy-broadcastIntent"><a href="#1-3-ActivityManagerProxy-broadcastIntent" class="headerlink" title="1.3 ActivityManagerProxy.broadcastIntent"></a>1.3 ActivityManagerProxy.broadcastIntent</h2><p>我们来看一下，发送普通广播的参数传递：</p>
<ul>
<li><code>IApplicationThread caller</code>：发送者进程的 <code>ApplicationThread</code> 对象，用于跨进程通信！</li>
<li><code>Intent intent</code>：广播 <code>Intent</code></li>
<li><code>String resolvedType</code>：</li>
<li><code>IIntentReceiver resultTo</code>：广播发送后的结果反馈对象，这里传入 <code>null</code>！</li>
<li><code>int resultCode</code>：广播发送后的结果反馈码，这里传入 <code>Activity.RESULT_OK</code>！</li>
<li><code>String resultData</code>： 广播发送后的结果反馈数据，这里传入 <code>null</code>！</li>
<li><code>Bundle map</code>：传入 null；</li>
<li><code>String[] requiredPermissions</code>：广播接受者需要的权限，传入 <code>null</code> 或者指定的权限数组！</li>
<li><code>int appOp</code>：发送广播相关的应用操作，传入 <code>AppOpsManager.OP_NONE</code> 或者指定的操作！</li>
<li><code>Bundle options</code>：广播携带的参数信息，传入 <code>null</code> 或者指定的 <code>Bundle</code> 对象！</li>
<li><code>boolean serialized</code>：广播是否是序列化的，普通的广播传入 <code>false</code>；</li>
<li><code>boolean sticky</code>： 广播是否是粘性的，传入 <code>false</code>；</li>
<li><code>int userId</code>：当前的设备用户 <code>id</code>；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">broadcastIntent</span><span class="params">(IApplicationThread caller,</span></span></span><br><span class="line"><span class="function"><span class="params">        Intent intent, String resolvedType, IIntentReceiver resultTo,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> resultCode, String resultData, Bundle map,</span></span></span><br><span class="line"><span class="function"><span class="params">        String[] requiredPermissions, <span class="keyword">int</span> appOp, Bundle options, <span class="keyword">boolean</span> serialized,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> userId)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    Parcel data = Parcel.obtain();</span><br><span class="line">    Parcel reply = Parcel.obtain();</span><br><span class="line">    data.writeInterfaceToken(IActivityManager.descriptor);</span><br><span class="line">    data.writeStrongBinder(caller != <span class="keyword">null</span> ? caller.asBinder() : <span class="keyword">null</span>);</span><br><span class="line">    intent.writeToParcel(data, <span class="number">0</span>);</span><br><span class="line">    data.writeString(resolvedType);</span><br><span class="line">    data.writeStrongBinder(resultTo != <span class="keyword">null</span> ? resultTo.asBinder() : <span class="keyword">null</span>);</span><br><span class="line">    data.writeInt(resultCode);</span><br><span class="line">    data.writeString(resultData);</span><br><span class="line">    data.writeBundle(map);</span><br><span class="line">    data.writeStringArray(requiredPermissions);</span><br><span class="line">    data.writeInt(appOp);</span><br><span class="line">    data.writeBundle(options);</span><br><span class="line">    data.writeInt(serialized ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    data.writeInt(sticky ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    data.writeInt(userId);</span><br><span class="line">    <span class="comment">//【1】BROADCAST_INTENT_TRANSACTION binder 消息！</span></span><br><span class="line">    mRemote.transact(BROADCAST_INTENT_TRANSACTION, data, reply, <span class="number">0</span>);</span><br><span class="line">    reply.readException();</span><br><span class="line">    <span class="keyword">int</span> res = reply.readInt();</span><br><span class="line">    reply.recycle();</span><br><span class="line">    data.recycle();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面，就是进入系统进程！</p>
<h1 id="2-系统进程"><a href="#2-系统进程" class="headerlink" title="2 系统进程"></a>2 系统进程</h1><p>首先，进入 <code>ActivityManagerNative</code> 中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">    <span class="keyword">case</span> BROADCAST_INTENT_TRANSACTION:</span><br><span class="line">    &#123;</span><br><span class="line">        data.enforceInterface(IActivityManager.descriptor);</span><br><span class="line">        IBinder b = data.readStrongBinder();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【1】获得代理对象 ApplicationThreadProxy！</span></span><br><span class="line">        IApplicationThread app =</span><br><span class="line">            b != <span class="keyword">null</span> ? ApplicationThreadNative.asInterface(b) : <span class="keyword">null</span>;</span><br><span class="line">        Intent intent = Intent.CREATOR.createFromParcel(data);</span><br><span class="line">        String resolvedType = data.readString();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【2】显然这里的 resultTo = null;</span></span><br><span class="line">        b = data.readStrongBinder();</span><br><span class="line">        IIntentReceiver resultTo =</span><br><span class="line">            b != <span class="keyword">null</span> ? IIntentReceiver.Stub.asInterface(b) : <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【3】得到 Activity.RESULT_OK</span></span><br><span class="line">        <span class="keyword">int</span> resultCode = data.readInt();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【4】均为 null！</span></span><br><span class="line">        String resultData = data.readString();</span><br><span class="line">        Bundle resultExtras = data.readBundle();</span><br><span class="line">        String[] perms = data.readStringArray();</span><br><span class="line">        <span class="keyword">int</span> appOp = data.readInt();</span><br><span class="line">        Bundle options = data.readBundle();</span><br><span class="line">        <span class="keyword">boolean</span> serialized = data.readInt() != <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> sticky = data.readInt() != <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> userId = data.readInt();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【2.1】调用 AMS 的 broadcastIntent 方法继续发送广播！</span></span><br><span class="line">        <span class="keyword">int</span> res = broadcastIntent(app, intent, resolvedType, resultTo,</span><br><span class="line">                resultCode, resultData, resultExtras, perms, appOp,</span><br><span class="line">                options, serialized, sticky, userId);</span><br><span class="line"></span><br><span class="line">        reply.writeNoException();</span><br><span class="line">        reply.writeInt(res);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们进入 <code>AMS</code> 的方法中去看看：</p>
<h2 id="2-1-AMService-broadcastIntent"><a href="#2-1-AMService-broadcastIntent" class="headerlink" title="2.1 AMService.broadcastIntent"></a>2.1 AMService.broadcastIntent</h2><p>这里的参数和之前保持一致，不用多说！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">broadcastIntent</span><span class="params">(IApplicationThread caller,</span></span></span><br><span class="line"><span class="function"><span class="params">        Intent intent, String resolvedType, IIntentReceiver resultTo,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> resultCode, String resultData, Bundle resultExtras,</span></span></span><br><span class="line"><span class="function"><span class="params">        String[] requiredPermissions, <span class="keyword">int</span> appOp, Bundle bOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> serialized, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先判断进程是否隔离！ </span></span><br><span class="line">    enforceNotIsolatedCaller(<span class="string">"broadcastIntent"</span>);</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        intent = verifyBroadcastLocked(intent);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【1】获得发送者所在进程！</span></span><br><span class="line">        <span class="keyword">final</span> ProcessRecord callerApp = getRecordForAppLocked(caller);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> callingPid = Binder.getCallingPid();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> callingUid = Binder.getCallingUid();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【×2.2】调用 broadcastIntentLocked 方法继续处理广播的分发！</span></span><br><span class="line">        <span class="keyword">int</span> res = broadcastIntentLocked(callerApp,</span><br><span class="line">                callerApp != <span class="keyword">null</span> ? callerApp.info.packageName : <span class="keyword">null</span>,</span><br><span class="line">                intent, resolvedType, resultTo, resultCode, resultData, resultExtras,</span><br><span class="line">                requiredPermissions, appOp, bOptions, serialized, sticky,</span><br><span class="line">                callingPid, callingUid, userId);</span><br><span class="line"></span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-AMService-broadcastIntentLocked"><a href="#2-2-AMService-broadcastIntentLocked" class="headerlink" title="2.2 AMService.broadcastIntentLocked"></a>2.2 AMService.broadcastIntentLocked</h2><p>这里我们再来看看参数传递：</p>
<ul>
<li><strong><code>ProcessRecord callerApp</code></strong>：发送者所在的进程对象</li>
<li><strong><code>String callerPackage</code></strong>：发送者所在的应用包名</li>
<li><strong><code>Intent intent</code></strong>：广播 <code>Intent</code></li>
<li><strong><code>String resolvedType</code></strong>：</li>
<li><strong><code>IIntentReceiver resultTo</code></strong>： 广播发送后的结果反馈对象；</li>
<li><strong><code>int resultCode</code></strong>：广播发送后的结果反馈码，这里传入 <code>Activity.RESULT_OK</code>；</li>
<li><strong><code>String resultData</code></strong>：广播发送后的结果反馈数据，这里传入 <code>null</code>；</li>
<li><strong><code>Bundle resultExtras</code></strong>： 传入 <code>null</code>；</li>
<li><strong><code>String[] requiredPermissions</code></strong>： 广播接受者需要的权限，传入 <code>null</code> 或者指定的权限数组；</li>
<li><strong><code>int appOp</code></strong>：发送广播相关的应用操作，传入 <code>AppOpsManager.OP_NONE</code> 或者指定的操作；</li>
<li><strong><code>Bundle bOptions</code></strong>：广播携带的参数信息，传入 <code>null</code> 或者指定的 <code>Bundle</code> 对象；</li>
<li><strong><code>boolean ordered</code></strong>：广播是否是有序广播还是普通广播；</li>
<li><strong><code>boolean sticky</code></strong>：广播是否是粘性的；</li>
<li><strong><code>int callingPid</code></strong>：发送者所在进程的 <code>pid</code>；</li>
<li><strong><code>int callingUid</code></strong>：发送者所在进程的 <code>uid</code>；</li>
<li><strong><code>int userId</code></strong>：目标设备用户 <code>id</code>；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">broadcastIntentLocked</span><span class="params">(ProcessRecord callerApp,</span></span></span><br><span class="line"><span class="function"><span class="params">        String callerPackage, Intent intent, String resolvedType,</span></span></span><br><span class="line"><span class="function"><span class="params">        IIntentReceiver resultTo, <span class="keyword">int</span> resultCode, String resultData,</span></span></span><br><span class="line"><span class="function"><span class="params">        Bundle resultExtras, String[] requiredPermissions, <span class="keyword">int</span> appOp, Bundle bOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> ordered, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> callingPid, <span class="keyword">int</span> callingUid, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    intent = <span class="keyword">new</span> Intent(intent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】给 intent 添加 Intent.FLAG_EXCLUDE_STOPPED_PACKAGES 标志位！</span></span><br><span class="line">    <span class="comment">// 禁止广播发送给被强制停止的应用！</span></span><br><span class="line">    intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】如果系统还没有完成启动，并且广播没有设置 FLAG_RECEIVER_BOOT_UPGRADE 标志位！</span></span><br><span class="line">    <span class="comment">// 那就给广播 Intent 添加 Intent.FLAG_RECEIVER_REGISTERED_ONLY 标志位</span></span><br><span class="line">    <span class="comment">// 这样，该广播就不会发送给静态注册的广播接收者了，也就不会拉起其所在的进程！</span></span><br><span class="line">    <span class="keyword">if</span> (!mProcessesReady &amp;&amp; (intent.getFlags()&amp;Intent.FLAG_RECEIVER_BOOT_UPGRADE) == <span class="number">0</span>) &#123;</span><br><span class="line">        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST,</span><br><span class="line">            (sticky ? <span class="string">"Broadcast sticky: "</span>: <span class="string">"Broadcast: "</span>) + intent</span><br><span class="line">            + <span class="string">" ordered="</span> + ordered + <span class="string">" userid="</span> + userId);</span><br><span class="line">    <span class="keyword">if</span> ((resultTo != <span class="keyword">null</span>) &amp;&amp; !ordered) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"Broadcast "</span> + intent + <span class="string">" not ordered but result callback requested!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    userId = mUserController.handleIncomingUser(callingPid, callingUid, userId, <span class="keyword">true</span>,</span><br><span class="line">            ALLOW_NON_FULL, <span class="string">"broadcast"</span>, callerPackage);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【3】判断接受该广播的设备用户是否运行，如果没有运行，就停止发送广播！</span></span><br><span class="line">    <span class="keyword">if</span> (userId != UserHandle.USER_ALL &amp;&amp; !mUserController.isUserRunningLocked(userId, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((callingUid != Process.SYSTEM_UID</span><br><span class="line">                || (intent.getFlags() &amp; Intent.FLAG_RECEIVER_BOOT_UPGRADE) == <span class="number">0</span>)</span><br><span class="line">                &amp;&amp; !Intent.ACTION_SHUTDOWN.equals(intent.getAction())) &#123;</span><br><span class="line"></span><br><span class="line">            Slog.w(TAG, <span class="string">"Skipping broadcast of "</span> + intent</span><br><span class="line">                    + <span class="string">": user "</span> + userId + <span class="string">" is stopped"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> ActivityManager.BROADCAST_FAILED_USER_STOPPED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【4】如果广播带有附加参数，用于修改 doze 临时白名单，那么就要校验是否有</span></span><br><span class="line">    <span class="comment">// CHANGE_DEVICE_IDLE_TEMP_WHITELIST 权限！</span></span><br><span class="line">    BroadcastOptions brOptions = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (bOptions != <span class="keyword">null</span>) &#123;</span><br><span class="line">        brOptions = <span class="keyword">new</span> BroadcastOptions(bOptions);</span><br><span class="line">        <span class="keyword">if</span> (brOptions.getTemporaryAppWhitelistDuration() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (checkComponentPermission(</span><br><span class="line">                    android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST,</span><br><span class="line">                    Binder.getCallingPid(), Binder.getCallingUid(), -<span class="number">1</span>, <span class="keyword">true</span>)</span><br><span class="line">                    != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">                String msg = <span class="string">"Permission Denial: "</span> + intent.getAction()</span><br><span class="line">                        + <span class="string">" broadcast from "</span> + callerPackage + <span class="string">" (pid="</span> + callingPid</span><br><span class="line">                        + <span class="string">", uid="</span> + callingUid + <span class="string">")"</span></span><br><span class="line">                        + <span class="string">" requires "</span></span><br><span class="line">                        + android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST;</span><br><span class="line">                Slog.w(TAG, msg);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【5】判断该广播是否是被保护的广播，被保护的广播只能由系统发送！</span></span><br><span class="line">    <span class="keyword">final</span> String action = intent.getAction();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isProtectedBroadcast;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//【×2.2.2】判断是否是保护广播！</span></span><br><span class="line">        isProtectedBroadcast = AppGlobals.getPackageManager().isProtectedBroadcast(action);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line"></span><br><span class="line">        Slog.w(TAG, <span class="string">"Remote exception"</span>, e);</span><br><span class="line">        <span class="keyword">return</span> ActivityManager.BROADCAST_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【6】判断发送者进程是否是系统进程；</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isCallerSystem;</span><br><span class="line">    <span class="keyword">switch</span> (UserHandle.getAppId(callingUid)) &#123;</span><br><span class="line">        <span class="keyword">case</span> Process.ROOT_UID:</span><br><span class="line">        <span class="keyword">case</span> Process.SYSTEM_UID:</span><br><span class="line">        <span class="keyword">case</span> Process.PHONE_UID:</span><br><span class="line">        <span class="keyword">case</span> Process.BLUETOOTH_UID:</span><br><span class="line">        <span class="keyword">case</span> Process.NFC_UID:</span><br><span class="line">            isCallerSystem = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            isCallerSystem = (callerApp != <span class="keyword">null</span>) &amp;&amp; callerApp.persistent;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【7】安全校验，禁止非系统的 app 发送受保护的广播！</span></span><br><span class="line">    <span class="keyword">if</span> (!isCallerSystem) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isProtectedBroadcast) &#123;</span><br><span class="line">            <span class="comment">//【7.1】如果应用是非系统应用，但是广播是受保护的，那就抛出异常！</span></span><br><span class="line">            String msg = <span class="string">"Permission Denial: not allowed to send broadcast "</span></span><br><span class="line">                    + action + <span class="string">" from pid="</span></span><br><span class="line">                    + callingPid + <span class="string">", uid="</span> + callingUid;</span><br><span class="line">            Slog.w(TAG, msg);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(msg);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(action)</span><br><span class="line">                || AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)) &#123;</span><br><span class="line">            <span class="comment">//【7.2】如果不是受保护的广播，那么会对一些特殊广播做限制，只能发送给应用自身！</span></span><br><span class="line">            <span class="keyword">if</span> (callerPackage == <span class="keyword">null</span>) &#123;</span><br><span class="line">                String msg = <span class="string">"Permission Denial: not allowed to send broadcast "</span></span><br><span class="line">                        + action + <span class="string">" from unknown caller."</span>;</span><br><span class="line">                Slog.w(TAG, msg);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(msg);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (intent.getComponent() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果指定了组件名，那么会校验下组件所属的包名是否和发送者一样！</span></span><br><span class="line">                <span class="keyword">if</span> (!intent.getComponent().getPackageName().equals(</span><br><span class="line">                        callerPackage)) &#123;</span><br><span class="line">                    String msg = <span class="string">"Permission Denial: not allowed to send broadcast "</span></span><br><span class="line">                            + action + <span class="string">" to "</span></span><br><span class="line">                            + intent.getComponent().getPackageName() + <span class="string">" from "</span></span><br><span class="line">                            + callerPackage;</span><br><span class="line">                    Slog.w(TAG, msg);</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 设置包名，限制目标包为自身！</span></span><br><span class="line">                intent.setPackage(callerPackage);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【8】针对一些特殊 action 的广播进行处理，比如 uid 被移除，package 相关的广播，外置应用是否可用！</span></span><br><span class="line">    <span class="keyword">if</span> (action != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">            <span class="keyword">case</span> Intent.ACTION_UID_REMOVED:</span><br><span class="line">            <span class="keyword">case</span> Intent.ACTION_PACKAGE_REMOVED:</span><br><span class="line">            <span class="keyword">case</span> Intent.ACTION_PACKAGE_CHANGED:</span><br><span class="line">            <span class="keyword">case</span> Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:</span><br><span class="line">            <span class="keyword">case</span> Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:</span><br><span class="line">            <span class="keyword">case</span> Intent.ACTION_PACKAGES_SUSPENDED:</span><br><span class="line">            <span class="keyword">case</span> Intent.ACTION_PACKAGES_UNSUSPENDED:</span><br><span class="line">                <span class="comment">//【8.1】首先判断发送者是否有 android.Manifest.permission.BROADCAST_PACKAGE_REMOVED 权限！</span></span><br><span class="line">                <span class="comment">// 没有的话，抛出异常！</span></span><br><span class="line">                <span class="keyword">if</span> (checkComponentPermission(</span><br><span class="line">                        android.Manifest.permission.BROADCAST_PACKAGE_REMOVED,</span><br><span class="line">                        callingPid, callingUid, -<span class="number">1</span>, <span class="keyword">true</span>)</span><br><span class="line">                        != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">                    String msg = <span class="string">"Permission Denial: "</span> + intent.getAction()</span><br><span class="line">                            + <span class="string">" broadcast from "</span> + callerPackage + <span class="string">" (pid="</span> + callingPid</span><br><span class="line">                            + <span class="string">", uid="</span> + callingUid + <span class="string">")"</span></span><br><span class="line">                            + <span class="string">" requires "</span></span><br><span class="line">                            + android.Manifest.permission.BROADCAST_PACKAGE_REMOVED;</span><br><span class="line">                    Slog.w(TAG, msg);</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(msg);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">                    <span class="keyword">case</span> Intent.ACTION_UID_REMOVED:</span><br><span class="line">                        <span class="comment">//【8.2】如果是 Intent.ACTION_UID_REMOVED，就从 mBatteryStatsService </span></span><br><span class="line">                        <span class="comment">// 和 mAppOpsService 中移除这个 uid 的信息！</span></span><br><span class="line">                        <span class="keyword">final</span> Bundle intentExtras = intent.getExtras();</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">int</span> uid = intentExtras != <span class="keyword">null</span></span><br><span class="line">                                ? intentExtras.getInt(Intent.EXTRA_UID) : -<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">if</span> (uid &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            mBatteryStatsService.removeUid(uid);</span><br><span class="line">                            mAppOpsService.uidRemoved(uid);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:</span><br><span class="line">                        <span class="comment">//【8.3】如果是扩展应用不可用的广播，那就清楚该应用的相关数据！</span></span><br><span class="line">                        String list[] =</span><br><span class="line">                                intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (list != <span class="keyword">null</span> &amp;&amp; list.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">                                forceStopPackageLocked(list[i], -<span class="number">1</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">true</span>,</span><br><span class="line">                                        <span class="keyword">false</span>, <span class="keyword">false</span>, userId, <span class="string">"storage unmount"</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                            mRecentTasks.cleanupLocked(UserHandle.USER_ALL);</span><br><span class="line">                            sendPackageBroadcastLocked(</span><br><span class="line">                                    IApplicationThread.EXTERNAL_STORAGE_UNAVAILABLE, list,</span><br><span class="line">                                    userId);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:</span><br><span class="line">                        <span class="comment">//【8.4】如果是扩展应用可用的广播，那就只清楚最近任务中的数据！</span></span><br><span class="line">                        mRecentTasks.cleanupLocked(UserHandle.USER_ALL);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> Intent.ACTION_PACKAGE_REMOVED:</span><br><span class="line">                    <span class="keyword">case</span> Intent.ACTION_PACKAGE_CHANGED:</span><br><span class="line">                        <span class="comment">//【8.5】如果是 package 移除或改变的广播，进入这里！！</span></span><br><span class="line">                        <span class="comment">// CHANGED 广播一般是在某个组件 enabled or disabled 的时候！</span></span><br><span class="line">                        Uri data = intent.getData();</span><br><span class="line">                        String ssp;</span><br><span class="line">                        <span class="keyword">if</span> (data != <span class="keyword">null</span> &amp;&amp; (ssp=data.getSchemeSpecificPart()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="comment">//【8.5.1】判断是否是覆盖安装，卸载！</span></span><br><span class="line">                            <span class="keyword">boolean</span> removed = Intent.ACTION_PACKAGE_REMOVED.equals(action);</span><br><span class="line">                            <span class="keyword">final</span> <span class="keyword">boolean</span> replacing =</span><br><span class="line">                                    intent.getBooleanExtra(Intent.EXTRA_REPLACING, <span class="keyword">false</span>);</span><br><span class="line">                            <span class="keyword">final</span> <span class="keyword">boolean</span> killProcess =</span><br><span class="line">                                    !intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 这里的 fullUninstall 表示是否完全卸载，卸载掉覆盖安装的 apk，replacing 为 true！</span></span><br><span class="line">                            <span class="keyword">final</span> <span class="keyword">boolean</span> fullUninstall = removed &amp;&amp; !replacing;</span><br><span class="line">                            <span class="comment">//【8.5.2】应用包被移除了，进入该分支！</span></span><br><span class="line">                            <span class="keyword">if</span> (removed) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (killProcess) &#123;</span><br><span class="line">                                    <span class="comment">//【8.5.2.1】杀掉进程！</span></span><br><span class="line">                                    forceStopPackageLocked(ssp, UserHandle.getAppId(</span><br><span class="line">                                            intent.getIntExtra(Intent.EXTRA_UID, -<span class="number">1</span>)),</span><br><span class="line">                                            <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, fullUninstall, userId,</span><br><span class="line">                                            removed ? <span class="string">"pkg removed"</span> : <span class="string">"pkg changed"</span>);</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">final</span> <span class="keyword">int</span> cmd = killProcess</span><br><span class="line">                                        ? IApplicationThread.PACKAGE_REMOVED</span><br><span class="line">                                        : IApplicationThread.PACKAGE_REMOVED_DONT_KILL;</span><br><span class="line"></span><br><span class="line">                                sendPackageBroadcastLocked(cmd,</span><br><span class="line">                                        <span class="keyword">new</span> String[] &#123;ssp&#125;, userId);</span><br><span class="line">                                <span class="comment">//【8.5.2.2】如果是卸载应用的话，移除该应用的所有信息：包括 uid 信息，uri 权限信息</span></span><br><span class="line">                                <span class="comment">// 最近任务，以及电池使用信息！</span></span><br><span class="line">                                <span class="keyword">if</span> (fullUninstall) &#123;</span><br><span class="line">                                    mAppOpsService.packageRemoved(</span><br><span class="line">                                            intent.getIntExtra(Intent.EXTRA_UID, -<span class="number">1</span>), ssp);</span><br><span class="line">                                    removeUriPermissionsForPackageLocked(ssp, userId, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">                                    removeTasksByPackageNameLocked(ssp, userId);</span><br><span class="line"></span><br><span class="line">                                    <span class="keyword">if</span> (mUnsupportedDisplaySizeDialog != <span class="keyword">null</span> &amp;&amp; ssp.equals(</span><br><span class="line">                                            mUnsupportedDisplaySizeDialog.getPackageName())) &#123;</span><br><span class="line">                                        mUnsupportedDisplaySizeDialog.dismiss();</span><br><span class="line">                                        mUnsupportedDisplaySizeDialog = <span class="keyword">null</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    mCompatModePackages.handlePackageUninstalledLocked(ssp);</span><br><span class="line">                                    mBatteryStatsService.notePackageUninstalled(ssp);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="comment">//【8.5.3】应用包没有被移除，进入该分支，如果需要是杀掉进程，那就执行 kill 操作！</span></span><br><span class="line">                                <span class="keyword">if</span> (killProcess) &#123;</span><br><span class="line">                                    killPackageProcessesLocked(ssp, UserHandle.getAppId(</span><br><span class="line">                                            intent.getIntExtra(Intent.EXTRA_UID, -<span class="number">1</span>)),</span><br><span class="line">                                            userId, ProcessList.INVALID_ADJ,</span><br><span class="line">                                            <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="string">"change "</span> + ssp);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="comment">//【8.5.4】清除掉 disable 的包组件！</span></span><br><span class="line">                                cleanupDisabledPackageComponentsLocked(ssp, userId, killProcess,</span><br><span class="line">                                        intent.getStringArrayExtra(</span><br><span class="line">                                                Intent.EXTRA_CHANGED_COMPONENT_NAME_LIST));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> Intent.ACTION_PACKAGES_SUSPENDED:</span><br><span class="line">                    <span class="keyword">case</span> Intent.ACTION_PACKAGES_UNSUSPENDED:</span><br><span class="line">                        <span class="comment">//【8.6】如果是 SUSPENDED 或 UNSUSPENDED 的广播，进入这里！！</span></span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">boolean</span> suspended = Intent.ACTION_PACKAGES_SUSPENDED.equals(</span><br><span class="line">                                intent.getAction());</span><br><span class="line">                        <span class="keyword">final</span> String[] packageNames = intent.getStringArrayExtra(</span><br><span class="line">                                Intent.EXTRA_CHANGED_PACKAGE_LIST);</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">int</span> userHandle = intent.getIntExtra(</span><br><span class="line">                                Intent.EXTRA_USER_HANDLE, UserHandle.USER_NULL);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">synchronized</span>(ActivityManagerService.<span class="keyword">this</span>) &#123;</span><br><span class="line">                            mRecentTasks.onPackagesSuspendedChanged(</span><br><span class="line">                                    packageNames, suspended, userHandle);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> Intent.ACTION_PACKAGE_REPLACED:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//【8.7】如果是 REPLACED （覆盖安装的时候）的广播，进入这里！！</span></span><br><span class="line">                <span class="keyword">final</span> Uri data = intent.getData();</span><br><span class="line">                <span class="keyword">final</span> String ssp;</span><br><span class="line">                <span class="keyword">if</span> (data != <span class="keyword">null</span> &amp;&amp; (ssp = data.getSchemeSpecificPart()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">final</span> ApplicationInfo aInfo =</span><br><span class="line">                            getPackageManagerInternalLocked().getApplicationInfo(</span><br><span class="line">                                    ssp,</span><br><span class="line">                                    userId);</span><br><span class="line">                    <span class="keyword">if</span> (aInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        Slog.w(TAG, <span class="string">"Dropping ACTION_PACKAGE_REPLACED for non-existent pkg:"</span></span><br><span class="line">                                + <span class="string">" ssp="</span> + ssp + <span class="string">" data="</span> + data);</span><br><span class="line">                        <span class="keyword">return</span> ActivityManager.BROADCAST_SUCCESS;</span><br><span class="line">                    &#125;</span><br><span class="line">                    mStackSupervisor.updateActivityApplicationInfoLocked(aInfo);</span><br><span class="line">                    sendPackageBroadcastLocked(IApplicationThread.PACKAGE_REPLACED,</span><br><span class="line">                            <span class="keyword">new</span> String[] &#123;ssp&#125;, userId);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> Intent.ACTION_PACKAGE_ADDED:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//【8.8】如果是 ADDED （全新安装的时候）的广播，进入这里！！</span></span><br><span class="line">                Uri data = intent.getData();</span><br><span class="line">                String ssp;</span><br><span class="line">                <span class="keyword">if</span> (data != <span class="keyword">null</span> &amp;&amp; (ssp = data.getSchemeSpecificPart()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">boolean</span> replacing =</span><br><span class="line">                            intent.getBooleanExtra(Intent.EXTRA_REPLACING, <span class="keyword">false</span>);</span><br><span class="line">                    mCompatModePackages.handlePackageAddedLocked(ssp, replacing);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        ApplicationInfo ai = AppGlobals.getPackageManager().</span><br><span class="line">                                getApplicationInfo(ssp, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                        mBatteryStatsService.notePackageInstalled(ssp,</span><br><span class="line">                                ai != <span class="keyword">null</span> ? ai.versionCode : <span class="number">0</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> Intent.ACTION_PACKAGE_DATA_CLEARED:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//【8.9】如果是 PACKAGE_DATA_CLEARED （清楚数据）的广播，进入这里！！</span></span><br><span class="line">                Uri data = intent.getData();</span><br><span class="line">                String ssp;</span><br><span class="line">                <span class="keyword">if</span> (data != <span class="keyword">null</span> &amp;&amp; (ssp = data.getSchemeSpecificPart()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// Hide the "unsupported display" dialog if necessary.</span></span><br><span class="line">                    <span class="keyword">if</span> (mUnsupportedDisplaySizeDialog != <span class="keyword">null</span> &amp;&amp; ssp.equals(</span><br><span class="line">                            mUnsupportedDisplaySizeDialog.getPackageName())) &#123;</span><br><span class="line">                        mUnsupportedDisplaySizeDialog.dismiss();</span><br><span class="line">                        mUnsupportedDisplaySizeDialog = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    mCompatModePackages.handlePackageDataClearedLocked(ssp);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> Intent.ACTION_TIMEZONE_CHANGED:</span><br><span class="line">                <span class="comment">// If this is the time zone changed action, queue up a message that will reset</span></span><br><span class="line">                <span class="comment">// the timezone of all currently running processes. This message will get</span></span><br><span class="line">                <span class="comment">// queued up before the broadcast happens.</span></span><br><span class="line">                mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> Intent.ACTION_TIME_CHANGED:</span><br><span class="line">                <span class="comment">// If the user set the time, let all running processes know.</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> is24Hour =</span><br><span class="line">                        intent.getBooleanExtra(Intent.EXTRA_TIME_PREF_24_HOUR_FORMAT, <span class="keyword">false</span>) ? <span class="number">1</span></span><br><span class="line">                                : <span class="number">0</span>;</span><br><span class="line">                mHandler.sendMessage(mHandler.obtainMessage(UPDATE_TIME, is24Hour, <span class="number">0</span>));</span><br><span class="line">                BatteryStatsImpl stats = mBatteryStatsService.getActiveStatistics();</span><br><span class="line">                <span class="keyword">synchronized</span> (stats) &#123;</span><br><span class="line">                    stats.noteCurrentTimeChangedLocked();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> Intent.ACTION_CLEAR_DNS_CACHE:</span><br><span class="line">                mHandler.sendEmptyMessage(CLEAR_DNS_CACHE_MSG);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> Proxy.PROXY_CHANGE_ACTION:</span><br><span class="line">                ProxyInfo proxy = intent.getParcelableExtra(Proxy.EXTRA_PROXY_INFO);</span><br><span class="line">                mHandler.sendMessage(mHandler.obtainMessage(UPDATE_HTTP_PROXY_MSG, proxy));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> android.hardware.Camera.ACTION_NEW_PICTURE:</span><br><span class="line">            <span class="keyword">case</span> android.hardware.Camera.ACTION_NEW_VIDEO:</span><br><span class="line">                <span class="comment">// These broadcasts are no longer allowed by the system, since they can</span></span><br><span class="line">                <span class="comment">// cause significant thrashing at a crictical point (using the camera).</span></span><br><span class="line">                <span class="comment">// Apps should use JobScehduler to monitor for media provider changes.</span></span><br><span class="line">                Slog.w(TAG, action + <span class="string">" no longer allowed; dropping from "</span></span><br><span class="line">                        + UserHandle.formatUid(callingUid));</span><br><span class="line">                <span class="keyword">if</span> (resultTo != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">final</span> BroadcastQueue queue = broadcastQueueForIntent(intent);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        queue.performReceiveLocked(callerApp, resultTo, intent,</span><br><span class="line">                                Activity.RESULT_CANCELED, <span class="keyword">null</span>, <span class="keyword">null</span>,</span><br><span class="line">                                <span class="keyword">false</span>, <span class="keyword">false</span>, userId);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                        Slog.w(TAG, <span class="string">"Failure ["</span></span><br><span class="line">                                + queue.mQueueName + <span class="string">"] sending broadcast result of "</span></span><br><span class="line">                                + intent, e);</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Lie; we don't want to crash the app.</span></span><br><span class="line">                <span class="keyword">return</span> ActivityManager.BROADCAST_SUCCESS;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【9】如果 sticky 为 true，表示该广播为粘性广播，那就要收集到指定的集合中！</span></span><br><span class="line">    <span class="keyword">if</span> (sticky) &#123;</span><br><span class="line">        <span class="comment">//【9.1】权限校验，发送粘性广播必须配置 android.Manifest.permission.BROADCAST_STICKY 权限！</span></span><br><span class="line">        <span class="comment">// 否则会抛出异常！</span></span><br><span class="line">        <span class="keyword">if</span> (checkPermission(android.Manifest.permission.BROADCAST_STICKY,</span><br><span class="line">                callingPid, callingUid) != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">            String msg = <span class="string">"Permission Denial: broadcastIntent() requesting a sticky broadcast from pid="</span></span><br><span class="line">                    + callingPid + <span class="string">", uid="</span> + callingUid</span><br><span class="line">                    + <span class="string">" requires "</span> + android.Manifest.permission.BROADCAST_STICKY;</span><br><span class="line"></span><br><span class="line">            Slog.w(TAG, msg);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【9.2】对于粘性广播，不能强制广播接收者应具有的权限！</span></span><br><span class="line">        <span class="keyword">if</span> (requiredPermissions != <span class="keyword">null</span> &amp;&amp; requiredPermissions.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Can't broadcast sticky intent "</span> + intent</span><br><span class="line">                    + <span class="string">" and enforce permissions "</span> + Arrays.toString(requiredPermissions));</span><br><span class="line">            <span class="keyword">return</span> ActivityManager.BROADCAST_STICKY_CANT_HAVE_PERMISSION;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【9.3】如果粘性广播设置具体的组件，抛出异常！</span></span><br><span class="line">        <span class="keyword">if</span> (intent.getComponent() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(</span><br><span class="line">                    <span class="string">"Sticky broadcasts can't target a specific component"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【9.4】如果我们的目标设备用户 id 不是 UserHandle.USER_ALL</span></span><br><span class="line">        <span class="comment">// 那就要判断是否已经有一个相同的全局粘性广播，如果有，产生冲突，抛出异常！</span></span><br><span class="line">        <span class="keyword">if</span> (userId != UserHandle.USER_ALL) &#123;</span><br><span class="line">            ArrayMap&lt;String, ArrayList&lt;Intent&gt;&gt; stickies = mStickyBroadcasts.get(</span><br><span class="line">                    UserHandle.USER_ALL);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (stickies != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ArrayList&lt;Intent&gt; list = stickies.get(intent.getAction());</span><br><span class="line">                <span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> N = list.size();</span><br><span class="line">                    <span class="keyword">int</span> i;</span><br><span class="line">                    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (intent.filterEquals(list.get(i))) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                                    <span class="string">"Sticky broadcast "</span> + intent + <span class="string">" for user "</span></span><br><span class="line">                                    + userId + <span class="string">" conflicts with existing global broadcast"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【9.5】将该粘性广播 Intent 添加到设备用户 userId 对应的广播列表中！</span></span><br><span class="line">        <span class="comment">// 如果之前已经添加过，就取代之前的相同粘性广播！</span></span><br><span class="line">        ArrayMap&lt;String, ArrayList&lt;Intent&gt;&gt; stickies = mStickyBroadcasts.get(userId);</span><br><span class="line">        <span class="keyword">if</span> (stickies == <span class="keyword">null</span>) &#123;</span><br><span class="line">            stickies = <span class="keyword">new</span> ArrayMap&lt;&gt;();</span><br><span class="line">            mStickyBroadcasts.put(userId, stickies);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Intent&gt; list = stickies.get(intent.getAction());</span><br><span class="line">        <span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;</span><br><span class="line">            list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            stickies.put(intent.getAction(), list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> stickiesCount = list.size();</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; stickiesCount; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (intent.filterEquals(list.get(i))) &#123;</span><br><span class="line">                <span class="comment">//【9.5.1】如果有重复，就取代旧的粘性广播！</span></span><br><span class="line">                list.set(i, <span class="keyword">new</span> Intent(intent));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【9.5.2】没有重复，就将这个广播添加到该粘性广播列表中！</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= stickiesCount) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> Intent(intent));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【10】根据传入的设备用户 id，获得广播的目标设备用户数组！</span></span><br><span class="line">    <span class="keyword">int</span>[] users;</span><br><span class="line">    <span class="keyword">if</span> (userId == UserHandle.USER_ALL) &#123;</span><br><span class="line">        <span class="comment">// 如果 userId 为 UserHandle.USER_ALL，说明这个广播要发送给所有的设备用户，</span></span><br><span class="line">        <span class="comment">// 就调用 getStartedUserArrayLocked 方法获得当前被启动的所有的设备用户数组！</span></span><br><span class="line">        users = mUserController.getStartedUserArrayLocked();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 userId 不为 UserHandle.USER_ALL，说明这个广播是发送给指定的设备用户的！</span></span><br><span class="line">        users = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;userId&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【11】收集能够接收和处理该广播的广播接收者！</span></span><br><span class="line">    <span class="comment">// receivers 保存静态注册的广播接受者，registeredReceivers 保存动态注册的广播接收者！</span></span><br><span class="line">    List receivers = <span class="keyword">null</span>;</span><br><span class="line">    List&lt;BroadcastFilter&gt; registeredReceivers = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断 Intent 是否设置了 Intent.FLAG_RECEIVER_REGISTERED_ONLY 标志位，如果设置了该标志位</span></span><br><span class="line">    <span class="comment">// 那么，静态注册的广播接收者无法接受这个广播！</span></span><br><span class="line">    <span class="keyword">if</span> ((intent.getFlags()&amp;Intent.FLAG_RECEIVER_REGISTERED_ONLY) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//【×2.2.1】收集系统中匹配该广播的静态注册的广播接收者！</span></span><br><span class="line">        receivers = collectReceiverComponents(intent, resolvedType, callingUid, users);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【12】如果广播 Intent 没有设置组件信息，那就从 mReceiverResolver 中进行匹配动态注册的接收者！</span></span><br><span class="line">    <span class="comment">// mReceiverResolver 用来保存动态注册的广播接收者信息，这个我们在前面讲过！</span></span><br><span class="line">    <span class="keyword">if</span> (intent.getComponent() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (userId == UserHandle.USER_ALL &amp;&amp; callingUid == Process.SHELL_UID) &#123;</span><br><span class="line">            <span class="comment">// 遍历每一个设备用户！</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; users.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mUserController.hasUserRestriction(</span><br><span class="line">                        UserManager.DISALLOW_DEBUGGING_FEATURES, users[i])) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                List&lt;BroadcastFilter&gt; registeredReceiversForUser =</span><br><span class="line">                        mReceiverResolver.queryIntent(intent,</span><br><span class="line">                                resolvedType, <span class="keyword">false</span>, users[i]);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (registeredReceivers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    registeredReceivers = registeredReceiversForUser;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (registeredReceiversForUser != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    registeredReceivers.addAll(registeredReceiversForUser);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            registeredReceivers = mReceiverResolver.queryIntent(intent,</span><br><span class="line">                    resolvedType, <span class="keyword">false</span>, userId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【13】判断 intent 是否设置了 FLAG_RECEIVER_REPLACE_PENDING 标志位，如果设置了。</span></span><br><span class="line">    <span class="comment">// 那么新的 intent 会取代前面正在处于等待状态的 intent；</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> replacePending =</span><br><span class="line">            (intent.getFlags() &amp; Intent.FLAG_RECEIVER_REPLACE_PENDING) != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, <span class="string">"Enqueing broadcast: "</span> + intent.getAction()</span><br><span class="line">            + <span class="string">" replacePending="</span> + replacePending);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> NR = registeredReceivers != <span class="keyword">null</span> ? registeredReceivers.size() : <span class="number">0</span>; <span class="comment">// 动态接受者的广播！</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【14】如果该广播是普通广播，并且存在匹配的动态注册的接收器，将广播添加到队列的并行集合中！</span></span><br><span class="line">    <span class="keyword">if</span> (!ordered &amp;&amp; NR &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isCallerSystem) &#123;</span><br><span class="line">            checkBroadcastFromSystem(intent, callerApp, callerPackage, callingUid,</span><br><span class="line">                    isProtectedBroadcast, registeredReceivers);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【×2.3.1】根据 Intent 是否设置了 Intent.FLAG_RECEIVER_FOREGROUND 标志位，选择指定的前台队列或者后台队列！</span></span><br><span class="line">        <span class="keyword">final</span> BroadcastQueue queue = broadcastQueueForIntent(intent);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【×2.3.2】创建广播对应的 BroadcastRecord 对象，发送给动态注册的广播接收者 registeredReceivers！</span></span><br><span class="line">        BroadcastRecord r = <span class="keyword">new</span> BroadcastRecord(queue, intent, callerApp,</span><br><span class="line">                callerPackage, callingPid, callingUid, resolvedType, requiredPermissions,</span><br><span class="line">                appOp, brOptions, registeredReceivers, resultTo, resultCode, resultData,</span><br><span class="line">                resultExtras, ordered, sticky, <span class="keyword">false</span>, userId);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, <span class="string">"Enqueueing parallel broadcast "</span> + r);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【×2.3.3】如果在队列的 mParallelBroadcasts 集合中能够找到相同的无序广播，就取代之前的旧的无序广播！</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> replaced = replacePending &amp;&amp; queue.replaceParallelBroadcastLocked(r);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!replaced) &#123;</span><br><span class="line">            <span class="comment">//【×2.3.4】将该广播添加到队列的并行集合 mParallelBroadcasts 中！</span></span><br><span class="line">            queue.enqueueParallelBroadcastLocked(r);</span><br><span class="line">            <span class="comment">//【×2.3.5】启动队列的广播分发任务！</span></span><br><span class="line">            queue.scheduleBroadcastsLocked();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【14.1】将动态注册的广播接收者集合 registeredReceivers 清空！</span></span><br><span class="line">        registeredReceivers = <span class="keyword">null</span>;</span><br><span class="line">        NR = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【15】将查询到的广播接收者合并到一个列表中！</span></span><br><span class="line">    <span class="keyword">int</span> ir = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果收集到静态注册的广播接收者，才会进入该分支！</span></span><br><span class="line">    <span class="comment">// 对于普通广播来说，动态注册的广播接收者在前面已经处理完了，这只剩下了静态注册的广播接收者了！</span></span><br><span class="line">    <span class="comment">// 对于有序广播来说，静态和动态的广播接收者都还没有处理！</span></span><br><span class="line">    <span class="keyword">if</span> (receivers != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//【15.1】这里对一些特殊的 action 做了一些处理，目的是防止刚安装的应用包通过静态接收这些广播实现自启动！</span></span><br><span class="line">        <span class="comment">// 首先收集这些这些广播中携带的 packageName！</span></span><br><span class="line">        String skipPackages[] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction())</span><br><span class="line">                || Intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction())</span><br><span class="line">                || Intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) &#123;</span><br><span class="line">            Uri data = intent.getData();</span><br><span class="line">            <span class="keyword">if</span> (data != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//【15.1.1】上面的广播会携带 Scheme 属性，表示包名，这里会收集到 skipPackages 中！</span></span><br><span class="line">                String pkgName = data.getSchemeSpecificPart();</span><br><span class="line">                <span class="keyword">if</span> (pkgName != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    skipPackages = <span class="keyword">new</span> String[] &#123; pkgName &#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) &#123;</span><br><span class="line">            skipPackages = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【15.2】从静态注册的广播接收者中删除属于这些 package 的广播接收者，防止应用自启动！</span></span><br><span class="line">        <span class="keyword">if</span> (skipPackages != <span class="keyword">null</span> &amp;&amp; (skipPackages.length &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String skipPackage : skipPackages) &#123;</span><br><span class="line">                <span class="keyword">if</span> (skipPackage != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> NT = receivers.size();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> it=<span class="number">0</span>; it&lt;NT; it++) &#123;</span><br><span class="line">                        ResolveInfo curt = (ResolveInfo)receivers.get(it);</span><br><span class="line">                        <span class="keyword">if</span> (curt.activityInfo.packageName.equals(skipPackage)) &#123;</span><br><span class="line">                            receivers.remove(it);</span><br><span class="line">                            it--;</span><br><span class="line">                            NT--;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> NT = receivers != <span class="keyword">null</span> ? receivers.size() : <span class="number">0</span>; <span class="comment">// 静态接收者的数量！</span></span><br><span class="line">        <span class="keyword">int</span> it = <span class="number">0</span>;</span><br><span class="line">        ResolveInfo curt = <span class="keyword">null</span>;</span><br><span class="line">        BroadcastFilter curr = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【15.3】注意，这里的 while 循环的目的是将所有的广播接收者合并到同一个集合中！</span></span><br><span class="line">        <span class="comment">// 如果是有序广播，这里会进入 while 循环，将 registeredReceivers 中的动态广播接收者，</span></span><br><span class="line">        <span class="comment">// 根据优先级合并到静态注册的广播接收者集合 receivers 中！</span></span><br><span class="line">        <span class="comment">// 对于普通广播，动态注册的广播接收者在前面已经处理完了，所以只剩下静态注册的接收者，所以不会进入循环！</span></span><br><span class="line">        <span class="keyword">while</span> (it &lt; NT &amp;&amp; nr &lt; NR) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curt == <span class="keyword">null</span>) &#123;</span><br><span class="line">                curt = (ResolveInfo)receivers.get(it);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (curr == <span class="keyword">null</span>) &#123;</span><br><span class="line">                curr = registeredReceivers.get(ir);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (curr.getPriority() &gt;= curt.priority) &#123; <span class="comment">// 按照优先级！</span></span><br><span class="line">                receivers.add(it, curr);</span><br><span class="line">                ir++;</span><br><span class="line">                curr = <span class="keyword">null</span>;</span><br><span class="line">                it++;</span><br><span class="line">                NT++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                it++;</span><br><span class="line">                curt = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (ir &lt; NR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (receivers == <span class="keyword">null</span>) &#123;</span><br><span class="line">            receivers = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【15.3】将剩余的动态接收者收集进来。当然如果没有静态接收者</span></span><br><span class="line">        <span class="comment">// 这里就只收集动态接收者；</span></span><br><span class="line">        receivers.add(registeredReceivers.get(ir));</span><br><span class="line">        ir++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【16】如果是系统调用，那么这里会做广播检查；</span></span><br><span class="line">    <span class="keyword">if</span> (isCallerSystem) &#123;</span><br><span class="line">        checkBroadcastFromSystem(intent, callerApp, callerPackage, callingUid,</span><br><span class="line">                isProtectedBroadcast, receivers);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【17】最后，将广播分发给已经合并到同一个集合中的广播接收者！</span></span><br><span class="line">    <span class="comment">// 如果没有收集到任何的广播接收者，且这个广播是一个隐式广播，那就把这个广播的状态记录下来！</span></span><br><span class="line">    <span class="keyword">if</span> ((receivers != <span class="keyword">null</span> &amp;&amp; receivers.size() &gt; <span class="number">0</span>)</span><br><span class="line">            || resultTo != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里的逻辑和上面的类似，不多说了！</span></span><br><span class="line">        <span class="comment">// 注意这里的 ordered，对于目标为静态接收者的普通广播，为 false，对于有序广播，则为 true；</span></span><br><span class="line">        <span class="comment">//【×2.3.1】选择合适的队列！</span></span><br><span class="line">        BroadcastQueue queue = broadcastQueueForIntent(intent);</span><br><span class="line">        <span class="comment">//【×2.3.2】创建广播对象！</span></span><br><span class="line">        BroadcastRecord r = <span class="keyword">new</span> BroadcastRecord(queue, intent, callerApp,</span><br><span class="line">                callerPackage, callingPid, callingUid, resolvedType,</span><br><span class="line">                requiredPermissions, appOp, brOptions, receivers, resultTo, resultCode,</span><br><span class="line">                resultData, resultExtras, ordered, sticky, <span class="keyword">false</span>, userId);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, <span class="string">"Enqueueing ordered broadcast "</span> + r</span><br><span class="line">                + <span class="string">": prev had "</span> + queue.mOrderedBroadcasts.size());</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.i(TAG_BROADCAST,</span><br><span class="line">                <span class="string">"Enqueueing broadcast "</span> + r.intent.getAction());</span><br><span class="line">        <span class="comment">//【×2.3.3】判读是否要取代已经存在的广播；</span></span><br><span class="line">        <span class="keyword">boolean</span> replaced = replacePending &amp;&amp; queue.replaceOrderedBroadcastLocked(r);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!replaced) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【×2.3.4】将广播添加到有序列表中！</span></span><br><span class="line">            queue.enqueueOrderedBroadcastLocked(r);</span><br><span class="line">            <span class="comment">//【×2.3.5】触发广播分发！</span></span><br><span class="line">            queue.scheduleBroadcastsLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (intent.getComponent() == <span class="keyword">null</span> &amp;&amp; intent.getPackage() == <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; (intent.getFlags()&amp;Intent.FLAG_RECEIVER_REGISTERED_ONLY) == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将广播的状态记录下来！</span></span><br><span class="line">            addBroadcastStatLocked(intent.getAction(), callerPackage, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ActivityManager.BROADCAST_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来总结一下，这个方法方法流程：</p>
<ul>
<li><p><strong>1.</strong> 给 intent 添加 <code>Intent.FLAG_EXCLUDE_STOPPED_PACKAGES</code> 标志位，禁止广播发送给被强制停止的应用！</p>
<ul>
<li><strong>1.1</strong> 如果系统没有启动完成，就给广播添加 <code>Intent.FLAG_RECEIVER_REGISTERED_ONLY</code> 标志位，禁止启动静态广播接收者！<br><br></li>
</ul>
</li>
<li><p><strong>2.</strong> 针对一些特殊 <code>action</code> 的广播进行处理，比如 <code>uid</code> 被移除，<code>package</code> 相关的广播等等！<br><br></p>
</li>
<li><p><strong>3.</strong> 如果是粘性广播，就需要将广播收集到 <code>mStickyBroadcasts</code> 集合中！</p>
<ul>
<li><strong>3.1</strong> 权限校验：发送粘性广播必须配置 <code>android.Manifest.permission.BROADCAST_STICKY</code> 权限！</li>
<li><strong>3.2</strong> 对于粘性广播，不能强制广播接收者应具有的权限！</li>
<li><strong>3.3</strong> 如果有相同的全局粘性广播，会产生冲突！<br><br></li>
</ul>
</li>
<li><p><strong>4.</strong> 收集能够匹配当前广播的广播接收者：</p>
<ul>
<li><strong>4.1</strong> 尝试收集能够匹配当前广播的静态注册的广播接收者（如果 <code>intent</code> 设置了 <code>Intent.FLAG_RECEIVER_REGISTERED_ONLY</code>，不收集）</li>
<li><strong>4.2</strong> 收集能够匹配当前广播动态注册的广播接收者<ul>
<li><strong>4.2.1</strong> 如果广播没有设置组件信息，那就从 <code>mReceiverResolver</code> 对象中收集动态广播接收者！<br><br>    </li>
</ul>
</li>
</ul>
</li>
<li><p><strong>5.</strong> 如果广播是普通广播，且存在匹配的动态注册的广播接收者 <code>registeredReceivers</code>！</p>
<ul>
<li><strong>5.1</strong> 创建对应的 <code>BroadcastRecord(registeredReceivers)</code> 对象，这里的 <code>BroadcastRecord.receivers</code> 都是动态注册的广播接收者！</li>
<li><strong>5.2</strong> 并添加到指定的队列（前台后台由 <code>Intent.FLAG_RECEIVER_FOREGROUND</code> 决定）的无序并行集合 <code>mParallelBroadcasts</code> 中！</li>
<li><strong>5.3</strong> 触发广播发送任务，清空 <code>registeredReceivers</code>！<br><br></li>
</ul>
</li>
<li><p><strong>6.</strong> 将收集到的静态广播接收者 <code>receivers</code> 和动态广播接收者 <code>registeredReceivers</code> 合并到同一个列表 <code>receivers</code> 中，只有在收集到静态注册的广播接收者才会合并！</p>
<ul>
<li><strong>6.1</strong> 这首先会针对一些特殊 <code>action</code> 做了处理，防止应用自启动！</li>
<li><strong>6.2</strong> 对于普通广播，到这里就只剩下静态广播接收者了，无需合并；<pre><code>对于有序广播，到这里静态广播接收者和动态广播接收者都没有处理，那就按照优先级，将二者合并到静态广播接收者 receivers 中！
</code></pre><br>   </li>
</ul>
</li>
<li><p><strong>7.</strong> 处理 <code>6</code> 中获得的合并广播接收者集合！</p>
<ul>
<li><strong>7.1</strong> 创建对应的 <code>BroadcastRecord(receivers)</code> 对象，注意这里的 <code>BroadcastRecord.receivers</code> 可能只有静态广播接收者，可能静态动态都有！</li>
<li><strong>7.2</strong> 并添加到指定的队列（前台后台由 <code>Intent.FLAG_RECEIVER_FOREGROUND</code> 决定）的无序并行集合 <code>mParallelBroadcasts</code> / 有序集合 <code>mOrderedBroadcasts</code> 中！</li>
<li><strong>7.3</strong> 触发广播发送任务；<br><br>   </li>
</ul>
</li>
</ul>
<p>接下来，我们来看看这个方法中的一些细节：</p>
<h3 id="2-2-1-AMService-collectReceiverComponents"><a href="#2-2-1-AMService-collectReceiverComponents" class="headerlink" title="2.2.1 AMService.collectReceiverComponents"></a>2.2.1 AMService.collectReceiverComponents</h3><p><code>collectReceiverComponents</code> 方法用来收集指定设备用户下的静态注册的广播接收者：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;ResolveInfo&gt; <span class="title">collectReceiverComponents</span><span class="params">(Intent intent, String resolvedType,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> callingUid, <span class="keyword">int</span>[] users)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pmFlags = STOCK_PM_FLAGS | MATCH_DEBUG_TRIAGED_MISSING;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用来保存查询结果！</span></span><br><span class="line">    List&lt;ResolveInfo&gt; receivers = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用来保存在所有设备用户下都只有一个实例的广播接收者！</span></span><br><span class="line">        HashSet&lt;ComponentName&gt; singleUserReceivers = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> scannedFirstReceivers = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> user : users) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Skip users that have Shell restrictions, with exception of always permitted</span></span><br><span class="line">            <span class="comment">// Shell broadcasts</span></span><br><span class="line">            <span class="keyword">if</span> (callingUid == Process.SHELL_UID</span><br><span class="line">                    &amp;&amp; mUserController.hasUserRestriction(</span><br><span class="line">                            UserManager.DISALLOW_DEBUGGING_FEATURES, user)</span><br><span class="line">                    &amp;&amp; !isPermittedShellBroadcast(intent)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 查询指定设备用户下的静态广播接收者！</span></span><br><span class="line">            List&lt;ResolveInfo&gt; newReceivers = AppGlobals.getPackageManager()</span><br><span class="line">                    .queryIntentReceivers(intent, resolvedType, pmFlags, user).getList();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果不是系统用户，那就要检测该设备用户下的所有静态广播接收者，</span></span><br><span class="line">            <span class="comment">// 过滤掉设置了 systemUserOnly 属性的接收者！</span></span><br><span class="line">            <span class="keyword">if</span> (user != UserHandle.USER_SYSTEM &amp;&amp; newReceivers != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;newReceivers.size(); i++) &#123;</span><br><span class="line">                    ResolveInfo ri = newReceivers.get(i);</span><br><span class="line">                    <span class="keyword">if</span> ((ri.activityInfo.flags&amp;ActivityInfo.FLAG_SYSTEM_USER_ONLY) != <span class="number">0</span>) &#123;</span><br><span class="line">                        newReceivers.remove(i);</span><br><span class="line">                        i--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (newReceivers != <span class="keyword">null</span> &amp;&amp; newReceivers.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                newReceivers = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 保存查询结果，查询第一个设备用户下的广播接收者进入该分支！</span></span><br><span class="line">            <span class="keyword">if</span> (receivers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                receivers = newReceivers;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newReceivers != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 后续设备用户下的查询会进入该分支！</span></span><br><span class="line">                <span class="keyword">if</span> (!scannedFirstReceivers) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 收集那些在所有的设备用户下都只有一个实例的广播接收者！</span></span><br><span class="line">                    scannedFirstReceivers = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;receivers.size(); i++) &#123;</span><br><span class="line">                        ResolveInfo ri = receivers.get(i);</span><br><span class="line">                        <span class="keyword">if</span> ((ri.activityInfo.flags&amp;ActivityInfo.FLAG_SINGLE_USER) != <span class="number">0</span>) &#123;</span><br><span class="line">                            ComponentName cn = <span class="keyword">new</span> ComponentName(</span><br><span class="line">                                    ri.activityInfo.packageName, ri.activityInfo.name);</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (singleUserReceivers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                singleUserReceivers = <span class="keyword">new</span> HashSet&lt;ComponentName&gt;();</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            singleUserReceivers.add(cn);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;newReceivers.size(); i++) &#123;</span><br><span class="line">                    ResolveInfo ri = newReceivers.get(i);</span><br><span class="line">                    <span class="keyword">if</span> ((ri.activityInfo.flags&amp;ActivityInfo.FLAG_SINGLE_USER) != <span class="number">0</span>) &#123;</span><br><span class="line">                        ComponentName cn = <span class="keyword">new</span> ComponentName(</span><br><span class="line">                                ri.activityInfo.packageName, ri.activityInfo.name);</span><br><span class="line">                        <span class="keyword">if</span> (singleUserReceivers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            singleUserReceivers = <span class="keyword">new</span> HashSet&lt;ComponentName&gt;();</span><br><span class="line">                        &#125;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 这里保证了在所有的设备用户下都只有一个实例的广播接收者只会被添加一次！</span></span><br><span class="line">                        <span class="keyword">if</span> (!singleUserReceivers.contains(cn)) &#123;</span><br><span class="line">                            singleUserReceivers.add(cn);</span><br><span class="line">                            receivers.add(ri);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        receivers.add(ri);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">        <span class="comment">// pm is in same process, this will never happen.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> receivers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里要注意：</p>
<p>如果我们在 <code>AndroidManifest.xml</code> 中给静态广播接收者设置了 <code>android:singleUser=&quot;true&quot;</code> 属性的话，那么他对应的 <code>ActivityInfo.flags</code> 会被设置 <code>ActivityInfo.FLAG_SINGLE_USER</code> 位，这样该接收者在所有的设备用户下都只会有一个实例！</p>
<p>具体的关于静态广播接收者的查询过程，请去看另一篇文章!</p>
<h3 id="2-2-2-PackageManagerS-isProtectedBroadcast"><a href="#2-2-2-PackageManagerS-isProtectedBroadcast" class="headerlink" title="2.2.2 PackageManagerS.isProtectedBroadcast"></a>2.2.2 PackageManagerS.isProtectedBroadcast</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isProtectedBroadcast</span><span class="params">(String actionName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mPackages) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mProtectedBroadcasts.contains(actionName)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (actionName != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> remove these terrible hacks</span></span><br><span class="line">            <span class="keyword">if</span> (actionName.startsWith(<span class="string">"android.net.netmon.lingerExpired"</span>)</span><br><span class="line">                    || actionName.startsWith(<span class="string">"com.android.server.sip.SipWakeupTimer"</span>)</span><br><span class="line">                    || actionName.startsWith(<span class="string">"com.android.internal.telephony.data-reconnect"</span>)</span><br><span class="line">                    || actionName.startsWith(<span class="string">"android.net.netmon.launchCaptivePortalApp"</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看看如何判断一个广播是否是受保护的广播：</p>
<ul>
<li>该广播在 <code>mProtectedBroadcasts</code> 列表中；</li>
<li>该广播是指定的一些广播；</li>
</ul>
<p>二者满足任何一个条件就行了！</p>
<p>其中 mProtectedBroadcasts 是在 PMS 里面对 protected-broadcast 类型的标签进行解析得到的，这里我们不细看！</p>
<h2 id="2-3-广播的分发处理"><a href="#2-3-广播的分发处理" class="headerlink" title="2.3 广播的分发处理"></a>2.3 广播的分发处理</h2><p>接下来，我们去看看广播队列是如何处理其内部的广播分发的，我们先回到 ActivityManagerS 中去！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">... ... ...</span><br><span class="line">            BroadcastQueue queue = broadcastQueueForIntent(intent);</span><br><span class="line"></span><br><span class="line">            BroadcastRecord r = <span class="keyword">new</span> BroadcastRecord(queue, intent, callerApp,</span><br><span class="line">                    callerPackage, callingPid, callingUid, resolvedType,</span><br><span class="line">                    requiredPermissions, appOp, brOptions, receivers, resultTo, resultCode,</span><br><span class="line">                    resultData, resultExtras, ordered, sticky, <span class="keyword">false</span>, userId);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, <span class="string">"Enqueueing ordered broadcast "</span> + r</span><br><span class="line">                    + <span class="string">": prev had "</span> + queue.mOrderedBroadcasts.size());</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.i(TAG_BROADCAST,</span><br><span class="line">                    <span class="string">"Enqueueing broadcast "</span> + r.intent.getAction());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> replaced = replacePending &amp;&amp; queue.replaceOrderedBroadcastLocked(r);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!replaced) &#123;</span><br><span class="line">                queue.enqueueOrderedBroadcastLocked(r);</span><br><span class="line">                queue.scheduleBroadcastsLocked();</span><br><span class="line">            &#125;</span><br><span class="line">... ... ...</span><br></pre></td></tr></table></figure></p>
<p>这里是分发广播的核心代码段，我们一个一个来分析！</p>
<h3 id="2-3-1-ActivityManagerS-broadcastQueueForIntent"><a href="#2-3-1-ActivityManagerS-broadcastQueueForIntent" class="headerlink" title="2.3.1 ActivityManagerS.broadcastQueueForIntent"></a>2.3.1 ActivityManagerS.broadcastQueueForIntent</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BroadcastQueue <span class="title">broadcastQueueForIntent</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isFg = (intent.getFlags() &amp; Intent.FLAG_RECEIVER_FOREGROUND) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_BROADCAST_BACKGROUND) Slog.i(TAG_BROADCAST,</span><br><span class="line">            <span class="string">"Broadcast intent "</span> + intent + <span class="string">" on "</span></span><br><span class="line">            + (isFg ? <span class="string">"foreground"</span> : <span class="string">"background"</span>) + <span class="string">" queue"</span>);</span><br><span class="line">    <span class="keyword">return</span> (isFg) ? mFgBroadcastQueue : mBgBroadcastQueue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用于判断将这个 <code>Intent</code> 插入哪个队列，插入的依据是 <code>Intent</code> 是否设置了 <code>Intent.FLAG_RECEIVER_FOREGROUND</code> 标志位！</p>
<p>这里我们可以看到 <code>ActivityManagerS</code> 通过 2 个队列来管理内部的广播：</p>
<ul>
<li><code>mFgBroadcastQueue</code>：前台广播队列；</li>
<li><code>mBgBroadcastQueue</code>：后台广播队列；</li>
</ul>
<h3 id="2-3-2-new-BroadcastRecord"><a href="#2-3-2-new-BroadcastRecord" class="headerlink" title="2.3.2 new BroadcastRecord"></a>2.3.2 new BroadcastRecord</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">BroadcastRecord(BroadcastQueue _queue,</span><br><span class="line">        Intent _intent, ProcessRecord _callerApp, String _callerPackage,</span><br><span class="line">        <span class="keyword">int</span> _callingPid, <span class="keyword">int</span> _callingUid, String _resolvedType, String[] _requiredPermissions,</span><br><span class="line">        <span class="keyword">int</span> _appOp, BroadcastOptions _options, List _receivers, IIntentReceiver _resultTo,</span><br><span class="line">        <span class="keyword">int</span> _resultCode, String _resultData, Bundle _resultExtras, <span class="keyword">boolean</span> _serialized,</span><br><span class="line">        <span class="keyword">boolean</span> _sticky, <span class="keyword">boolean</span> _initialSticky,</span><br><span class="line">        <span class="keyword">int</span> _userId) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_intent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Can't construct with a null intent"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    queue = _queue; <span class="comment">// 该广播位于的广播队列</span></span><br><span class="line">    intent = _intent; <span class="comment">// 广播的 Intent</span></span><br><span class="line">    targetComp = _intent.getComponent(); <span class="comment">// 广播的目标组件</span></span><br><span class="line">    callerApp = _callerApp; <span class="comment">// 发送者的进程对象</span></span><br><span class="line">    callerPackage = _callerPackage; <span class="comment">// 发送者的包名</span></span><br><span class="line">    callingPid = _callingPid; <span class="comment">// 发送者的 pid</span></span><br><span class="line">    callingUid = _callingUid; <span class="comment">// 发送者的 uid</span></span><br><span class="line">    resolvedType = _resolvedType;</span><br><span class="line">    requiredPermissions = _requiredPermissions; <span class="comment">// 广播接收者需要具备的权限！</span></span><br><span class="line">    appOp = _appOp;</span><br><span class="line">    options = _options;</span><br><span class="line">    receivers = _receivers; <span class="comment">// 广播接收者集合，包含静态广播接收者和动态广播接收者</span></span><br><span class="line">    delivery = <span class="keyword">new</span> <span class="keyword">int</span>[_receivers != <span class="keyword">null</span> ? _receivers.size() : <span class="number">0</span>]; <span class="comment">// 广播的分发情况！</span></span><br><span class="line"></span><br><span class="line">    resultTo = _resultTo;</span><br><span class="line">    resultCode = _resultCode;</span><br><span class="line">    resultData = _resultData;</span><br><span class="line">    resultExtras = _resultExtras;</span><br><span class="line"></span><br><span class="line">    ordered = _serialized; <span class="comment">// 该广播是有序广播吗？</span></span><br><span class="line">    sticky = _sticky; <span class="comment">// 该广播是粘性广播吗？</span></span><br><span class="line">    initialSticky = _initialSticky; </span><br><span class="line">    userId = _userId; <span class="comment">// 广播的目标设备用户</span></span><br><span class="line">    nextReceiver = <span class="number">0</span>; <span class="comment">// 下一个要接受该广播的接收者序号！</span></span><br><span class="line">    state = IDLE; <span class="comment">// 广播的状态！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些属性其实很简单！</p>
<h3 id="2-3-3-BroadcastQueue-replaceXXXXX"><a href="#2-3-3-BroadcastQueue-replaceXXXXX" class="headerlink" title="2.3.3 BroadcastQueue.replaceXXXXX"></a>2.3.3 BroadcastQueue.replaceXXXXX</h3><p>替换掉 BroadcastQueue 中 mParallelBroadcasts 已有的正在等待分发的 intent：</p>
<ul>
<li>replace ParallelBroadcast</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">replaceParallelBroadcastLocked</span><span class="params">(BroadcastRecord r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mParallelBroadcasts.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">final</span> Intent curIntent = mParallelBroadcasts.get(i).intent;</span><br><span class="line">        <span class="comment">//【1】匹配 filter，如果有匹配的 intent，替换掉！</span></span><br><span class="line">        <span class="keyword">if</span> (r.intent.filterEquals(curIntent)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,</span><br><span class="line">                    <span class="string">"***** DROPPING PARALLEL ["</span></span><br><span class="line">            + mQueueName + <span class="string">"]: "</span> + r.intent);</span><br><span class="line">            mParallelBroadcasts.set(i, r);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，如下操作：</p>
<ul>
<li><strong>replace Ordered Broadcast</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">replaceOrderedBroadcastLocked</span><span class="params">(BroadcastRecord r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mOrderedBroadcasts.size() - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">//【1】匹配 filter，如果有匹配的 intent，替换掉！</span></span><br><span class="line">        <span class="keyword">if</span> (r.intent.filterEquals(mOrderedBroadcasts.get(i).intent)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,</span><br><span class="line">                    <span class="string">"***** DROPPING ORDERED ["</span></span><br><span class="line">                    + mQueueName + <span class="string">"]: "</span> + r.intent);</span><br><span class="line">            mOrderedBroadcasts.set(i, r);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不多说了！</p>
<h3 id="2-3-4-BroadcastQueue-enqueueOrderedBroadcastLocked"><a href="#2-3-4-BroadcastQueue-enqueueOrderedBroadcastLocked" class="headerlink" title="2.3.4 BroadcastQueue.enqueueOrderedBroadcastLocked"></a>2.3.4 BroadcastQueue.enqueueOrderedBroadcastLocked</h3><p>这里是将广播添加到广播队列的并行集合或者是有序集合中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueueParallelBroadcastLocked</span><span class="params">(BroadcastRecord r)</span> </span>&#123;</span><br><span class="line">    mParallelBroadcasts.add(r);</span><br><span class="line">    r.enqueueClockTime = System.currentTimeMillis();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueueOrderedBroadcastLocked</span><span class="params">(BroadcastRecord r)</span> </span>&#123;</span><br><span class="line">    mOrderedBroadcasts.add(r);</span><br><span class="line">    r.enqueueClockTime = System.currentTimeMillis();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过前面的分析，我们可以看出：</p>
<ul>
<li>对于普通广播来说<ul>
<li>先会被添加到 <code>mParallelBroadcasts</code> 中，<code>BroadcastRecord.receivers</code> 为动态注册的广播接收者集合，采用并发的发送方式；</li>
<li>再被添加到 <code>mOrderedBroadcasts</code> 中，<code>BroadcastRecord.receivers</code> 为静态注册的广播接收者集合，采用有序的发送方式；</li>
</ul>
</li>
</ul>
<p><br></p>
<ul>
<li>对于有序广播来说：<ul>
<li>会被直接添加到 <code>mOrderedBroadcasts</code> 中， <code>BroadcastRecord.receivers</code> 为静态注册和动态注册的广播接收者集合，按照优先级排序，采用有序的发送方式；</li>
</ul>
</li>
</ul>
<p><br></p>
<h3 id="2-3-5-BroadcastQueue-scheduleBroadcastsLocked"><a href="#2-3-5-BroadcastQueue-scheduleBroadcastsLocked" class="headerlink" title="2.3.5 BroadcastQueue.scheduleBroadcastsLocked"></a>2.3.5 BroadcastQueue.scheduleBroadcastsLocked</h3><p>接下来，就是触发广播的分发调度！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleBroadcastsLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, <span class="string">"Schedule broadcasts ["</span></span><br><span class="line">            + mQueueName + <span class="string">"]: current="</span></span><br><span class="line">            + mBroadcastsScheduled);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mBroadcastsScheduled) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【×2.4】发送 `BROADCAST_INTENT_MSG` 消息！</span></span><br><span class="line">    mHandler.sendMessage(mHandler.obtainMessage(BROADCAST_INTENT_MSG, <span class="keyword">this</span>));</span><br><span class="line">    mBroadcastsScheduled = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面就进入了 BroadcastHandler 中！</p>
<h2 id="2-4-BroadcastHandler-handleMessage"><a href="#2-4-BroadcastHandler-handleMessage" class="headerlink" title="2.4 BroadcastHandler.handleMessage"></a>2.4 BroadcastHandler.handleMessage</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BroadcastHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BroadcastHandler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(looper, <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="comment">//【1】处理 BROADCAST_INTENT_MSG 消息！</span></span><br><span class="line">            <span class="keyword">case</span> BROADCAST_INTENT_MSG: &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(</span><br><span class="line">                        TAG_BROADCAST, <span class="string">"Received BROADCAST_INTENT_MSG"</span>);</span><br><span class="line">                <span class="comment">//【×2.5】进行广播分发，参数传入 true；</span></span><br><span class="line">                processNextBroadcast(<span class="keyword">true</span>);</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> BROADCAST_TIMEOUT_MSG: &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (mService) &#123;</span><br><span class="line">                    broadcastTimeoutLocked(<span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> SCHEDULE_TEMP_WHITELIST_MSG: &#123;</span><br><span class="line">                DeviceIdleController.LocalService dic = mService.mLocalDeviceIdleController;</span><br><span class="line">                <span class="keyword">if</span> (dic != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    dic.addPowerSaveTempWhitelistAppDirect(UserHandle.getAppId(msg.arg1),</span><br><span class="line">                            msg.arg2, <span class="keyword">true</span>, (String)msg.obj);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>收到 <code>BROADCAST_INTENT_MSG</code> 消息后，调用 <code>processNextBroadcast</code> 方法，执行广播分发！</p>
<h2 id="2-5-BroadcastQueue-processNextBroadcast"><a href="#2-5-BroadcastQueue-processNextBroadcast" class="headerlink" title="2.5 BroadcastQueue.processNextBroadcast"></a>2.5 BroadcastQueue.processNextBroadcast</h2><p>processNextBroadcast 方法比较长，需要我们仔细分析，参数传递：</p>
<ul>
<li><strong>boolean fromMsg</strong>：传入 true，表示触发是来自消息调用！</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">processNextBroadcast</span><span class="params">(<span class="keyword">boolean</span> fromMsg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(mService) &#123;</span><br><span class="line">        BroadcastRecord r;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, <span class="string">"processNextBroadcast ["</span></span><br><span class="line">                + mQueueName + <span class="string">"]: "</span></span><br><span class="line">                + mParallelBroadcasts.size() + <span class="string">" broadcasts, "</span></span><br><span class="line">                + mOrderedBroadcasts.size() + <span class="string">" ordered broadcasts"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【1】更新 cpu 的状态信息！</span></span><br><span class="line">        mService.updateCpuStats();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fromMsg) &#123;</span><br><span class="line">            <span class="comment">//【2】如果 fromMsg 为 true，会将 mBroadcastsScheduled 置为 false；</span></span><br><span class="line">            <span class="comment">// 这样之前又可以继续发送消息触发分发了！</span></span><br><span class="line">            mBroadcastsScheduled = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【3】立刻分发 mParallelBroadcasts 集合中的普通广播！</span></span><br><span class="line">        <span class="comment">// 根据前面的分析，普通广播会先被加入到 mParallelBroadcasts 中并且目标接收者是动态注册的广播接受者！</span></span><br><span class="line">        <span class="keyword">while</span> (mParallelBroadcasts.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            r = mParallelBroadcasts.remove(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//【3.1】更新普通广播的分发时间！</span></span><br><span class="line">            r.dispatchTime = SystemClock.uptimeMillis();</span><br><span class="line">            r.dispatchClockTime = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> N = r.receivers.size();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, <span class="string">"Processing parallel broadcast ["</span></span><br><span class="line">                    + mQueueName + <span class="string">"] "</span> + r);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">                Object target = r.receivers.get(i);</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_BROADCAST)  Slog.v(TAG_BROADCAST,</span><br><span class="line">                        <span class="string">"Delivering non-ordered on ["</span> + mQueueName + <span class="string">"] to registered "</span></span><br><span class="line">                        + target + <span class="string">": "</span> + r);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//【×2.5.1.1】将该普通广播分发给动态注册的每个接收者！</span></span><br><span class="line">                deliverToRegisteredReceiverLocked(r, (BroadcastFilter)target, <span class="keyword">false</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//【×2.5.1.2】分发成功后，将该普通广播添加到历史集合中！</span></span><br><span class="line">            addBroadcastToHistoryLocked(r);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, <span class="string">"Done with parallel broadcast ["</span></span><br><span class="line">                    + mQueueName + <span class="string">"] "</span> + r);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【4】处理正在等待目标进程启动的广播，如果 mPendingBroadcast 不为 null，说明该广播仍然未处理！</span></span><br><span class="line">        <span class="keyword">if</span> (mPendingBroadcast != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST,</span><br><span class="line">                    <span class="string">"processNextBroadcast ["</span> + mQueueName + <span class="string">"]: waiting for "</span></span><br><span class="line">                    + mPendingBroadcast.curApp);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> isDead;</span><br><span class="line">            <span class="keyword">synchronized</span> (mService.mPidsSelfLocked) &#123;</span><br><span class="line">                <span class="comment">//【4.1】获得目标进程的 ProcessRecord 对象！</span></span><br><span class="line">                ProcessRecord proc = mService.mPidsSelfLocked.get(mPendingBroadcast.curApp.pid);</span><br><span class="line">                isDead = proc == <span class="keyword">null</span> || proc.crashing;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//【4.2】如果目标进程没有死亡，就继续的等待，return！</span></span><br><span class="line">            <span class="keyword">if</span> (!isDead) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"pending app  ["</span></span><br><span class="line">                        + mQueueName + <span class="string">"]"</span> + mPendingBroadcast.curApp</span><br><span class="line">                        + <span class="string">" died before responding to broadcast"</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//【4.3】目标进程死亡，将 mPendingBroadcast 初始化为 null！</span></span><br><span class="line">                mPendingBroadcast.state = BroadcastRecord.IDLE;</span><br><span class="line">                mPendingBroadcast.nextReceiver = mPendingBroadcastRecvIndex;</span><br><span class="line">                mPendingBroadcast = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> looped = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【5】 while 循环用于移除 mOrderedBroadcasts 列表中的无需发送的广播，并找到下一个需要发送的广播！</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">//【5.1】如果 mOrderedBroadcasts 的广播已经处理完了，就直接返回！</span></span><br><span class="line">            <span class="keyword">if</span> (mOrderedBroadcasts.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                mService.scheduleAppGcsLocked();</span><br><span class="line">                <span class="keyword">if</span> (looped) &#123;</span><br><span class="line">                    <span class="comment">//【5.1.1】更新系统 oomAdj 的值！</span></span><br><span class="line">                    mService.updateOomAdjLocked();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//【5.2】获得有序队列中的第一个要分发的广播！</span></span><br><span class="line">            r = mOrderedBroadcasts.get(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">boolean</span> forceReceive = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> numReceivers = (r.receivers != <span class="keyword">null</span>) ? r.receivers.size() : <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (mService.mProcessesReady &amp;&amp; r.dispatchTime &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//【5.3】判断是否广播超时，超时则调用 broadcastTimeoutLocked(false) 强行结束广播；</span></span><br><span class="line">                <span class="comment">// 并设置 forceReceive 为 true，设置广播状态 r.state 为 BroadcastRecord.IDLE！  </span></span><br><span class="line">                <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">                <span class="keyword">if</span> ((numReceivers &gt; <span class="number">0</span>) &amp;&amp;</span><br><span class="line">                        (now &gt; r.dispatchTime + (<span class="number">2</span>*mTimeoutPeriod*numReceivers))) &#123;</span><br><span class="line"></span><br><span class="line">                    Slog.w(TAG, <span class="string">"Hung broadcast ["</span></span><br><span class="line">                            + mQueueName + <span class="string">"] discarded after timeout failure:"</span></span><br><span class="line">                            + <span class="string">" now="</span> + now</span><br><span class="line">                            + <span class="string">" dispatchTime="</span> + r.dispatchTime</span><br><span class="line">                            + <span class="string">" startTime="</span> + r.receiverTime</span><br><span class="line">                            + <span class="string">" intent="</span> + r.intent</span><br><span class="line">                            + <span class="string">" numReceivers="</span> + numReceivers</span><br><span class="line">                            + <span class="string">" nextReceiver="</span> + r.nextReceiver</span><br><span class="line">                            + <span class="string">" state="</span> + r.state);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//【5.4】处理广播超时</span></span><br><span class="line">                    broadcastTimeoutLocked(<span class="keyword">false</span>); </span><br><span class="line">                    <span class="comment">//【5.5】广播超时了，所以我们视其为接收，forceReceive 为 true；</span></span><br><span class="line">                    forceReceive = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="comment">//【5.6】更新广播的状态为 idle；</span></span><br><span class="line">                    r.state = BroadcastRecord.IDLE;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【5.7】判断广播的状态是否是 BroadcastRecord.IDLE，对于 mOrderedBroadcasts 集合中的广播来说，</span></span><br><span class="line">            <span class="comment">// 只有广播的状态为 BroadcastRecord.IDLE 时才能继续下一次的分发，这里就直接返回了！！</span></span><br><span class="line">            <span class="keyword">if</span> (r.state != BroadcastRecord.IDLE) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.d(TAG_BROADCAST,</span><br><span class="line">                        <span class="string">"processNextBroadcast("</span></span><br><span class="line">                        + mQueueName + <span class="string">") called when not idle (state="</span></span><br><span class="line">                        + r.state + <span class="string">")"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//【5.8】如果该广播没有接收者，或者该广播的所有接收者都接收到了广播（nextReceiver 大于接收者数）</span></span><br><span class="line">            <span class="comment">// 或者该广播被终止继续传递（有序广播特性），或者该广播超时了被视为强制接收了，进入该分支；</span></span><br><span class="line">            <span class="keyword">if</span> (r.receivers == <span class="keyword">null</span> || r.nextReceiver &gt;= numReceivers</span><br><span class="line">                    || r.resultAbort || forceReceive) &#123;</span><br><span class="line">                    </span><br><span class="line">                <span class="keyword">if</span> (r.resultTo != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.i(TAG_BROADCAST,</span><br><span class="line">                                <span class="string">"Finishing broadcast ["</span> + mQueueName + <span class="string">"] "</span></span><br><span class="line">                                + r.intent.getAction() + <span class="string">" app="</span> + r.callerApp);</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">//【×2.5.1.3】如果该广播的 r.resultTo 不为 null，resultTo 也是一个广播接收者，</span></span><br><span class="line">                        <span class="comment">// 那就调用 performReceiveLocked() 将该广播发送给 resultTo！</span></span><br><span class="line">                        performReceiveLocked(r.callerApp, r.resultTo,</span><br><span class="line">                            <span class="keyword">new</span> Intent(r.intent), r.resultCode,</span><br><span class="line">                            r.resultData, r.resultExtras, <span class="keyword">false</span>, <span class="keyword">false</span>, r.userId);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//【5.8.1】将广播的 r.resultTo 置为 null；</span></span><br><span class="line">                        r.resultTo = <span class="keyword">null</span>;</span><br><span class="line">                        </span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                        r.resultTo = <span class="keyword">null</span>;</span><br><span class="line">                        Slog.w(TAG, <span class="string">"Failure ["</span></span><br><span class="line">                                + mQueueName + <span class="string">"] sending broadcast result of "</span></span><br><span class="line">                                + r.intent, e);</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, <span class="string">"Cancelling BROADCAST_TIMEOUT_MSG"</span>);</span><br><span class="line">                <span class="comment">//【5.8.2】取消广播超时的消息！</span></span><br><span class="line">                cancelBroadcastTimeoutLocked();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST,</span><br><span class="line">                        <span class="string">"Finished with ordered broadcast "</span> + r);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//【×2.5.1.2】将广播添加到历史集合中！</span></span><br><span class="line">                addBroadcastToHistoryLocked(r);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//【5.8.3】如果该广播是一个隐式广播，将该广播添加到 mCurBroadcastStats 中记录下来！</span></span><br><span class="line">                <span class="keyword">if</span> (r.intent.getComponent() == <span class="keyword">null</span> &amp;&amp; r.intent.getPackage() == <span class="keyword">null</span></span><br><span class="line">                        &amp;&amp; (r.intent.getFlags()&amp;Intent.FLAG_RECEIVER_REGISTERED_ONLY) == <span class="number">0</span>) &#123;</span><br><span class="line">                    mService.addBroadcastStatLocked(r.intent.getAction(), r.callerPackage,</span><br><span class="line">                            r.manifestCount, r.manifestSkipCount, r.finishTime-r.dispatchTime);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//【5.8.4】从 mOrderedBroadcasts 中移除该广播！</span></span><br><span class="line">                mOrderedBroadcasts.remove(<span class="number">0</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//【5.8.5】将 r 设为 null，进行下一次循环！</span></span><br><span class="line">                r = <span class="keyword">null</span>;</span><br><span class="line">                looped = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (r == <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【6】分发 mOrderedBroadcasts 集合中的广播，通过前面的分析 mOrderedBroadcasts 会存储 2 种类型的广播</span></span><br><span class="line">        <span class="comment">// 普通广播，接收者为静态注册的；有序广播，接收者为的动态和静态注册的合并；</span></span><br><span class="line">        <span class="comment">// 首先，计算广播的下一个接收者的序号。同时，增加目标接收者计数！！ </span></span><br><span class="line">        <span class="keyword">int</span> recIdx = r.nextReceiver++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【7】初始化该广播的接收时间，该时间会不断更新！！</span></span><br><span class="line">        r.receiverTime = SystemClock.uptimeMillis();</span><br><span class="line">        <span class="comment">//【8】如果是第一个接收者，就记录广播的开始分发时间；</span></span><br><span class="line">        <span class="keyword">if</span> (recIdx == <span class="number">0</span>) &#123;</span><br><span class="line">            r.dispatchTime = r.receiverTime;</span><br><span class="line">            r.dispatchClockTime = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, <span class="string">"Processing ordered broadcast ["</span></span><br><span class="line">                    + mQueueName + <span class="string">"] "</span> + r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【9】如果没有设置广播超时消息，那就设置超时消息！</span></span><br><span class="line">        <span class="keyword">if</span> (!mPendingBroadcastTimeoutMessage) &#123;</span><br><span class="line">            <span class="keyword">long</span> timeoutTime = r.receiverTime + mTimeoutPeriod;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,</span><br><span class="line">                    <span class="string">"Submitting BROADCAST_TIMEOUT_MSG ["</span></span><br><span class="line">                    + mQueueName + <span class="string">"] for "</span> + r + <span class="string">" at "</span> + timeoutTime);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//【9.1】设置广播处理的超时时间为 10s</span></span><br><span class="line">            <span class="comment">// 这里会将 mPendingBroadcastTimeoutMessage 设置为 true；</span></span><br><span class="line">            setBroadcastTimeoutLocked(timeoutTime);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【10】获得广播的额外数据；</span></span><br><span class="line">        <span class="keyword">final</span> BroadcastOptions brOptions = r.options;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【11】获得广播的下一个接收者；</span></span><br><span class="line">        <span class="keyword">final</span> Object nextReceiver = r.receivers.get(recIdx);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【12】如果下一个广播接收者是动态注册的广播接收者！（这里只可能是有序广播）</span></span><br><span class="line">        <span class="keyword">if</span> (nextReceiver <span class="keyword">instanceof</span> BroadcastFilter) &#123;</span><br><span class="line">            BroadcastFilter filter = (BroadcastFilter)nextReceiver;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (DEBUG_BROADCAST)  Slog.v(TAG_BROADCAST,</span><br><span class="line">                    <span class="string">"Delivering ordered ["</span></span><br><span class="line">                    + mQueueName + <span class="string">"] to registered "</span></span><br><span class="line">                    + filter + <span class="string">": "</span> + r);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//【×2.5.1.1】将该有序广播分发给动态注册的广播接收者，该方法中会进一步过滤！！</span></span><br><span class="line">            deliverToRegisteredReceiverLocked(r, filter, r.ordered, recIdx);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【12.1】当所有的接收者都接收到了广播时，那么 r.receiver 为 null；</span></span><br><span class="line">            <span class="comment">// 或者说该广播是普通广播，那么这里会继续下一次分发！</span></span><br><span class="line">            <span class="keyword">if</span> (r.receiver == <span class="keyword">null</span> || !r.ordered) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, <span class="string">"Quick finishing ["</span></span><br><span class="line">                        + mQueueName + <span class="string">"]: ordered="</span></span><br><span class="line">                        + r.ordered + <span class="string">" receiver="</span> + r.receiver);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//【12.2】将广播的状态设置为 idle；</span></span><br><span class="line">                r.state = BroadcastRecord.IDLE;</span><br><span class="line">                <span class="comment">//【×2.3.5】重新发送BROADCAST_INTENT_MSG，触发下一次发送广播的流程！</span></span><br><span class="line">                scheduleBroadcastsLocked();</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果广播没有分发完成，并且是有序广播，并且其携带了额外数据，为了防止其在 doze 模式下</span></span><br><span class="line">                <span class="comment">// 能够收到广播，所以如果额外数据中指定了 temp duration，那么会将其加入到 doze 临时白名单中；</span></span><br><span class="line">                <span class="keyword">if</span> (brOptions != <span class="keyword">null</span> &amp;&amp; brOptions.getTemporaryAppWhitelistDuration() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    scheduleTempWhitelistLocked(filter.owningUid,</span><br><span class="line">                            brOptions.getTemporaryAppWhitelistDuration(), r);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//【12.3】这里直接 return 掉，因为对于有序广播而言，</span></span><br><span class="line">            <span class="comment">// 已经通知了一个 BroadcastReceiver，需要等待其处理结果，因此返回！</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【13】如果下一个广播接收者是静态注册的广播接收者（对于有序/普通广播）</span></span><br><span class="line">        ResolveInfo info =</span><br><span class="line">            (ResolveInfo)nextReceiver;</span><br><span class="line">        ComponentName component = <span class="keyword">new</span> ComponentName(</span><br><span class="line">                info.activityInfo.applicationInfo.packageName,</span><br><span class="line">                info.activityInfo.name);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【14】判断是否跳过该静态接收者！</span></span><br><span class="line">        <span class="keyword">boolean</span> skip = <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【15】如果 sdk 不匹配，跳过该接收者！</span></span><br><span class="line">        <span class="keyword">if</span> (brOptions != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                (info.activityInfo.applicationInfo.targetSdkVersion</span><br><span class="line">                        &lt; brOptions.getMinManifestReceiverApiLevel() ||</span><br><span class="line">                info.activityInfo.applicationInfo.targetSdkVersion</span><br><span class="line">                        &gt; brOptions.getMaxManifestReceiverApiLevel())) &#123;</span><br><span class="line">            skip = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【16】检查广播发送者是否具有接收者要求的权限！</span></span><br><span class="line">        <span class="keyword">int</span> perm = mService.checkComponentPermission(info.activityInfo.permission,</span><br><span class="line">                r.callingPid, r.callingUid, info.activityInfo.applicationInfo.uid,</span><br><span class="line">                info.activityInfo.exported);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!skip &amp;&amp; perm != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">            <span class="comment">//【16.1】如果发送者不被授予该权限，那就跳过该接收者！</span></span><br><span class="line">            <span class="keyword">if</span> (!info.activityInfo.exported) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Permission Denial: broadcasting "</span></span><br><span class="line">                        + r.intent.toString()</span><br><span class="line">                        + <span class="string">" from "</span> + r.callerPackage + <span class="string">" (pid="</span> + r.callingPid</span><br><span class="line">                        + <span class="string">", uid="</span> + r.callingUid + <span class="string">")"</span></span><br><span class="line">                        + <span class="string">" is not exported from uid "</span> + info.activityInfo.applicationInfo.uid</span><br><span class="line">                        + <span class="string">" due to receiver "</span> + component.flattenToShortString());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Permission Denial: broadcasting "</span></span><br><span class="line">                        + r.intent.toString()</span><br><span class="line">                        + <span class="string">" from "</span> + r.callerPackage + <span class="string">" (pid="</span> + r.callingPid</span><br><span class="line">                        + <span class="string">", uid="</span> + r.callingUid + <span class="string">")"</span></span><br><span class="line">                        + <span class="string">" requires "</span> + info.activityInfo.permission</span><br><span class="line">                        + <span class="string">" due to receiver "</span> + component.flattenToShortString());</span><br><span class="line">            &#125;</span><br><span class="line">            skip = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!skip &amp;&amp; info.activityInfo.permission != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//【16.2】权限校验通过，那就要判断发送者是否能执行接收者指定的权限对应的操作！</span></span><br><span class="line">            <span class="comment">// 一般情况下，如果有权限有对应的 op，那么权限在授予的情况下，也会授予 op！</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> opCode = AppOpsManager.permissionToOpCode(info.activityInfo.permission);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (opCode != AppOpsManager.OP_NONE</span><br><span class="line">                    &amp;&amp; mService.mAppOpsService.noteOperation(opCode, r.callingUid,</span><br><span class="line">                            r.callerPackage) != AppOpsManager.MODE_ALLOWED) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Appop Denial: broadcasting "</span></span><br><span class="line">                        + r.intent.toString()</span><br><span class="line">                        + <span class="string">" from "</span> + r.callerPackage + <span class="string">" (pid="</span></span><br><span class="line">                        + r.callingPid + <span class="string">", uid="</span> + r.callingUid + <span class="string">")"</span></span><br><span class="line">                        + <span class="string">" requires appop "</span> + AppOpsManager.permissionToOp(</span><br><span class="line">                                info.activityInfo.permission)</span><br><span class="line">                        + <span class="string">" due to registered receiver "</span></span><br><span class="line">                        + component.flattenToShortString());</span><br><span class="line">                skip = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【17】如果接收者不是 system uid 的，而广播发送者指定了权限，那就要校验接收者是否具有该权限！</span></span><br><span class="line">        <span class="keyword">if</span> (!skip &amp;&amp; info.activityInfo.applicationInfo.uid != Process.SYSTEM_UID &amp;&amp;</span><br><span class="line">            r.requiredPermissions != <span class="keyword">null</span> &amp;&amp; r.requiredPermissions.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r.requiredPermissions.length; i++) &#123;</span><br><span class="line">                String requiredPermission = r.requiredPermissions[i];</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    perm = AppGlobals.getPackageManager().</span><br><span class="line">                            checkPermission(requiredPermission,</span><br><span class="line">                                    info.activityInfo.applicationInfo.packageName,</span><br><span class="line">                                    UserHandle.getUserId(info.activityInfo.applicationInfo.uid));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                    perm = PackageManager.PERMISSION_DENIED;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//【17.1】接收者不具有该权限，跳过该接收者！</span></span><br><span class="line">                <span class="keyword">if</span> (perm != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">                    Slog.w(TAG, <span class="string">"Permission Denial: receiving "</span></span><br><span class="line">                            + r.intent + <span class="string">" to "</span></span><br><span class="line">                            + component.flattenToShortString()</span><br><span class="line">                            + <span class="string">" requires "</span> + requiredPermission</span><br><span class="line">                            + <span class="string">" due to sender "</span> + r.callerPackage</span><br><span class="line">                            + <span class="string">" (uid "</span> + r.callingUid + <span class="string">")"</span>);</span><br><span class="line">                    skip = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//【17.2】判断接收者是否能执行发送者指定的权限所对应的操作！</span></span><br><span class="line">                <span class="keyword">int</span> appOp = AppOpsManager.permissionToOpCode(requiredPermission);</span><br><span class="line">                <span class="keyword">if</span> (appOp != AppOpsManager.OP_NONE &amp;&amp; appOp != r.appOp</span><br><span class="line">                        &amp;&amp; mService.mAppOpsService.noteOperation(appOp,</span><br><span class="line">                        info.activityInfo.applicationInfo.uid, info.activityInfo.packageName)</span><br><span class="line">                        != AppOpsManager.MODE_ALLOWED) &#123;</span><br><span class="line">                    Slog.w(TAG, <span class="string">"Appop Denial: receiving "</span></span><br><span class="line">                            + r.intent + <span class="string">" to "</span></span><br><span class="line">                            + component.flattenToShortString()</span><br><span class="line">                            + <span class="string">" requires appop "</span> + AppOpsManager.permissionToOp(</span><br><span class="line">                            requiredPermission)</span><br><span class="line">                            + <span class="string">" due to sender "</span> + r.callerPackage</span><br><span class="line">                            + <span class="string">" (uid "</span> + r.callingUid + <span class="string">")"</span>);</span><br><span class="line">                    skip = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【18】如果广播无需权限，只需要执行某个 op 的话，这里会判断是否有 op 权限！</span></span><br><span class="line">        <span class="keyword">if</span> (!skip &amp;&amp; r.appOp != AppOpsManager.OP_NONE</span><br><span class="line">                &amp;&amp; mService.mAppOpsService.noteOperation(r.appOp,</span><br><span class="line">                info.activityInfo.applicationInfo.uid, info.activityInfo.packageName)</span><br><span class="line">                != AppOpsManager.MODE_ALLOWED) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Appop Denial: receiving "</span></span><br><span class="line">                    + r.intent + <span class="string">" to "</span></span><br><span class="line">                    + component.flattenToShortString()</span><br><span class="line">                    + <span class="string">" requires appop "</span> + AppOpsManager.opToName(r.appOp)</span><br><span class="line">                    + <span class="string">" due to sender "</span> + r.callerPackage</span><br><span class="line">                    + <span class="string">" (uid "</span> + r.callingUid + <span class="string">")"</span>);</span><br><span class="line">            skip = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【19】判断 Intent 是否满足 AMS 的 IntentFirewall 防火墙要求，不满足，跳过！</span></span><br><span class="line">        <span class="keyword">if</span> (!skip) &#123;</span><br><span class="line">            skip = !mService.mIntentFirewall.checkBroadcast(r.intent, r.callingUid,</span><br><span class="line">                    r.callingPid, r.resolvedType, info.activityInfo.applicationInfo.uid);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【20】判断该接收者是否是单例！</span></span><br><span class="line">        <span class="keyword">boolean</span> isSingleton = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            isSingleton = mService.isSingleton(info.activityInfo.processName,</span><br><span class="line">                    info.activityInfo.applicationInfo,</span><br><span class="line">                    info.activityInfo.name, info.activityInfo.flags);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SecurityException e) &#123;</span><br><span class="line">            Slog.w(TAG, e.getMessage());</span><br><span class="line">            skip = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【20.1】如果接收者是单例模式，那就要校验接收者是否有</span></span><br><span class="line">        <span class="comment">// android.Manifest.permission.INTERACT_ACROSS_USERS 权限，如果没有，跳过该接收者！</span></span><br><span class="line">        <span class="keyword">if</span> ((info.activityInfo.flags&amp;ActivityInfo.FLAG_SINGLE_USER) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ActivityManager.checkUidPermission(</span><br><span class="line">                    android.Manifest.permission.INTERACT_ACROSS_USERS,</span><br><span class="line">                    info.activityInfo.applicationInfo.uid)</span><br><span class="line">                            != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Permission Denial: Receiver "</span> + component.flattenToShortString()</span><br><span class="line">                        + <span class="string">" requests FLAG_SINGLE_USER, but app does not hold "</span></span><br><span class="line">                        + android.Manifest.permission.INTERACT_ACROSS_USERS);</span><br><span class="line">                skip = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【21】记录处理的静态接收者数量！</span></span><br><span class="line">        <span class="keyword">if</span> (!skip) &#123;</span><br><span class="line">            r.manifestCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r.manifestSkipCount++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【22】如果接收者所在进程 crash 了，跳过该接收者！</span></span><br><span class="line">        <span class="keyword">if</span> (r.curApp != <span class="keyword">null</span> &amp;&amp; r.curApp.crashing) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Skipping deliver ordered ["</span> + mQueueName + <span class="string">"] "</span> + r</span><br><span class="line">                    + <span class="string">" to "</span> + r.curApp + <span class="string">": process crashing"</span>);</span><br><span class="line">            skip = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【23】判断该静态接收者所在的 package 是否可用，不可用就跳过！</span></span><br><span class="line">        <span class="keyword">if</span> (!skip) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> isAvailable = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                isAvailable = AppGlobals.getPackageManager().isPackageAvailable(</span><br><span class="line">                        info.activityInfo.packageName,</span><br><span class="line">                        UserHandle.getUserId(info.activityInfo.applicationInfo.uid));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Exception getting recipient info for "</span></span><br><span class="line">                        + info.activityInfo.packageName, e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!isAvailable) &#123; <span class="comment">// 不可用，跳过！</span></span><br><span class="line">                <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,</span><br><span class="line">                        <span class="string">"Skipping delivery to "</span> + info.activityInfo.packageName + <span class="string">" / "</span></span><br><span class="line">                        + info.activityInfo.applicationInfo.uid</span><br><span class="line">                        + <span class="string">" : package no longer available"</span>);</span><br><span class="line">                skip = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【24】如果在任何组件运行时都要重新校验权限，那就执权限校验，校验失败，跳过！</span></span><br><span class="line">        <span class="keyword">if</span> (Build.PERMISSIONS_REVIEW_REQUIRED &amp;&amp; !skip) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!requestStartTargetPermissionsReviewIfNeededLocked(r,</span><br><span class="line">                    info.activityInfo.packageName, UserHandle.getUserId(</span><br><span class="line">                            info.activityInfo.applicationInfo.uid))) &#123;</span><br><span class="line">                skip = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> receiverUid = info.activityInfo.applicationInfo.uid;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【25】如果发送者不是系统进程，且接收者是单例，并且本次调用是有效的</span></span><br><span class="line">        <span class="comment">// 那就始终返回默认设备用户下的接收者对象，保持单例有效性！</span></span><br><span class="line">        <span class="keyword">if</span> (r.callingUid != Process.SYSTEM_UID &amp;&amp; isSingleton</span><br><span class="line">                &amp;&amp; mService.isValidSingletonCall(r.callingUid, receiverUid)) &#123;</span><br><span class="line">            info.activityInfo = mService.getActivityInfoForUser(info.activityInfo, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【26】获得目标广播接收者的进程名；</span></span><br><span class="line">        String targetProcess = info.activityInfo.processName;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【27】获得目标广播接收者所在进程的 ProcessRecord 对象！</span></span><br><span class="line">        ProcessRecord app = mService.getProcessRecordLocked(targetProcess,</span><br><span class="line">                info.activityInfo.applicationInfo.uid, <span class="keyword">false</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!skip) &#123;</span><br><span class="line">            <span class="comment">//【28】判断该静态接收者所在进程是否允许后台启动或者在后台接受广播，不允许就跳过！</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> allowed = mService.checkAllowBackgroundLocked(</span><br><span class="line">                    info.activityInfo.applicationInfo.uid, info.activityInfo.packageName, -<span class="number">1</span>,</span><br><span class="line">                    <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (allowed != ActivityManager.APP_START_MODE_NORMAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (allowed == ActivityManager.APP_START_MODE_DISABLED) &#123;</span><br><span class="line">                    Slog.w(TAG, <span class="string">"Background execution disabled: receiving "</span></span><br><span class="line">                            + r.intent + <span class="string">" to "</span></span><br><span class="line">                            + component.flattenToShortString());</span><br><span class="line">                    skip = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (((r.intent.getFlags()&amp;Intent.FLAG_RECEIVER_EXCLUDE_BACKGROUND) != <span class="number">0</span>)</span><br><span class="line">                        || (r.intent.getComponent() == <span class="keyword">null</span></span><br><span class="line">                            &amp;&amp; r.intent.getPackage() == <span class="keyword">null</span></span><br><span class="line">                            &amp;&amp; ((r.intent.getFlags()</span><br><span class="line">                                    &amp; Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND) == <span class="number">0</span>))) &#123;</span><br><span class="line">                    <span class="comment">//【28.1】这里针对 intent 的属性做了判断：</span></span><br><span class="line">                    <span class="comment">// 如果 intent 设置了 FLAG_RECEIVER_EXCLUDE_BACKGROUND，那就不能发给后台接收者；</span></span><br><span class="line">                    <span class="comment">// 如果是没有设置 FLAG_RECEIVER_INCLUDE_BACKGROUND 的隐式广播，那么也不能发给后台接收者；</span></span><br><span class="line">                    Slog.w(TAG, <span class="string">"Background execution not allowed: receiving "</span></span><br><span class="line">                            + r.intent + <span class="string">" to "</span></span><br><span class="line">                            + component.flattenToShortString());</span><br><span class="line"></span><br><span class="line">                    skip = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【29】如果 skip 的值为 true，说明要跳过当前的静态接收者，继续下次广播分发！！</span></span><br><span class="line">        <span class="keyword">if</span> (skip) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_BROADCAST)  Slog.v(TAG_BROADCAST,</span><br><span class="line">                    <span class="string">"Skipping delivery of ordered ["</span> + mQueueName + <span class="string">"] "</span></span><br><span class="line">                    + r + <span class="string">" for whatever reason"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【29.1】设置序号为 recIdx 的接收者的分发状态为 BroadcastRecord.DELIVERY_SKIPPED 跳过！</span></span><br><span class="line">            r.delivery[recIdx] = BroadcastRecord.DELIVERY_SKIPPED;</span><br><span class="line">            r.receiver = <span class="keyword">null</span>;</span><br><span class="line">            r.curFilter = <span class="keyword">null</span>;</span><br><span class="line">            r.state = BroadcastRecord.IDLE;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【×2.3.5】继续下次广播分发，结束方法！</span></span><br><span class="line">            scheduleBroadcastsLocked();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【30】如果该静态接收者不会跳过，那就设置其属性，准备发送广播！</span></span><br><span class="line">        r.delivery[recIdx] = BroadcastRecord.DELIVERY_DELIVERED;</span><br><span class="line">        r.state = BroadcastRecord.APP_RECEIVE; <span class="comment">// 广播状态；</span></span><br><span class="line">        r.curComponent = component;</span><br><span class="line">        r.curReceiver = info.activityInfo;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DEBUG_MU &amp;&amp; r.callingUid &gt; UserHandle.PER_USER_RANGE) &#123;</span><br><span class="line">            Slog.v(TAG_MU, <span class="string">"Updated broadcast record activity info for secondary user, "</span></span><br><span class="line">                    + info.activityInfo + <span class="string">", callingUid = "</span> + r.callingUid + <span class="string">", uid = "</span></span><br><span class="line">                    + info.activityInfo.applicationInfo.uid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【31】如果额外参数指定了 doze 白名单参数，那么就设置临时白名单；</span></span><br><span class="line">        <span class="keyword">if</span> (brOptions != <span class="keyword">null</span> &amp;&amp; brOptions.getTemporaryAppWhitelistDuration() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            scheduleTempWhitelistLocked(receiverUid,</span><br><span class="line">                    brOptions.getTemporaryAppWhitelistDuration(), r);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【32】设置接收者所在的包 stoped 状态为 false！</span></span><br><span class="line">            AppGlobals.getPackageManager().setPackageStoppedState(</span><br><span class="line">                    r.curComponent.getPackageName(), <span class="keyword">false</span>, UserHandle.getUserId(r.callingUid));</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Failed trying to unstop package "</span></span><br><span class="line">                    + r.curComponent.getPackageName() + <span class="string">": "</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【33】如果静态广播接收者所在的进程已经启动，那就要直接发送广播！</span></span><br><span class="line">        <span class="keyword">if</span> (app != <span class="keyword">null</span> &amp;&amp; app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                app.addPackage(info.activityInfo.packageName,</span><br><span class="line">                        info.activityInfo.applicationInfo.versionCode, mService.mProcessStats);</span><br><span class="line">                        </span><br><span class="line">                <span class="comment">//【×2.5.2.1.1】发送广播，并等待结果返回！</span></span><br><span class="line">                processCurBroadcastLocked(r, app);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Exception when sending broadcast to "</span></span><br><span class="line">                      + r.curComponent, e);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">                Slog.wtf(TAG, <span class="string">"Failed sending broadcast to "</span></span><br><span class="line">                        + r.curComponent + <span class="string">" with "</span> + r.intent, e);</span><br><span class="line"></span><br><span class="line">                logBroadcastReceiverDiscardLocked(r);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//【×4.1.2】发送失败，结束本次发送！</span></span><br><span class="line">                finishReceiverLocked(r, r.resultCode, r.resultData,</span><br><span class="line">                        r.resultExtras, r.resultAbort, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//【×2.3.5】继续发送后续的广播！</span></span><br><span class="line">                scheduleBroadcastsLocked();</span><br><span class="line">                r.state = BroadcastRecord.IDLE; <span class="comment">// 设置状态！</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DEBUG_BROADCAST)  Slog.v(TAG_BROADCAST,</span><br><span class="line">                <span class="string">"Need to start app ["</span></span><br><span class="line">                + mQueueName + <span class="string">"] "</span> + targetProcess + <span class="string">" for broadcast "</span> + r);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【34】如果静态广播接收者所在的进程没有启动，那就要先启动其所在进程！</span></span><br><span class="line">        <span class="keyword">if</span> ((r.curApp=mService.startProcessLocked(targetProcess,</span><br><span class="line">                info.activityInfo.applicationInfo, <span class="keyword">true</span>,</span><br><span class="line">                r.intent.getFlags() | Intent.FLAG_FROM_BACKGROUND,</span><br><span class="line">                <span class="string">"broadcast"</span>, r.curComponent,</span><br><span class="line">                (r.intent.getFlags()&amp;Intent.FLAG_RECEIVER_BOOT_UPGRADE) != <span class="number">0</span>, <span class="keyword">false</span>, <span class="keyword">false</span>))</span><br><span class="line">                        == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            Slog.w(TAG, <span class="string">"Unable to launch app "</span></span><br><span class="line">                    + info.activityInfo.applicationInfo.packageName + <span class="string">"/"</span></span><br><span class="line">                    + info.activityInfo.applicationInfo.uid + <span class="string">" for broadcast "</span></span><br><span class="line">                    + r.intent + <span class="string">": process is bad"</span>);</span><br><span class="line">            </span><br><span class="line">            logBroadcastReceiverDiscardLocked(r);</span><br><span class="line">            <span class="comment">//【×4.1.2】目标进程启动失败，结束本次发送！</span></span><br><span class="line">            finishReceiverLocked(r, r.resultCode, r.resultData,</span><br><span class="line">                    r.resultExtras, r.resultAbort, <span class="keyword">false</span>);</span><br><span class="line">                    </span><br><span class="line">            <span class="comment">//【×2.3.5】继续发送后续的广播！</span></span><br><span class="line">            scheduleBroadcastsLocked();</span><br><span class="line">            r.state = BroadcastRecord.IDLE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【35】将当前的广播保存到 mPendingBroadcast 中，表示正在等待目标进程启动的广播！</span></span><br><span class="line">        mPendingBroadcast = r;</span><br><span class="line">        <span class="comment">// 广播的目标接收者的序号！</span></span><br><span class="line">        mPendingBroadcastRecvIndex = recIdx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法的逻辑很长，我们来总结一下他的业务流程：</p>
<ul>
<li>1 立刻分发 <code>mParallelBroadcasts</code> 集合中的目标为动态接收者的普通广播，方式方式为并行！<ul>
<li>1.1 调用【<code>deliverToRegisteredReceiverLocked</code>】发送广播！</li>
</ul>
</li>
</ul>
<p><br></p>
<ul>
<li>2 处理正在等待目标进程启动的广播 <code>mPendingBroadcast</code>，<code>mPendingBroadcast</code> 是有序的发送方式！<ul>
<li>2.1 如果进程没有启动成功，就等待进程启动后处理改广播，<code>return</code>；</li>
</ul>
</li>
</ul>
<p><br></p>
<ul>
<li>3 移除 <code>mOrderedBroadcasts</code> 列表中的无需发送的广播，并找到下一个需要发送的广播，<code>mOrderedBroadcasts</code> 集合中的所有广播都是有序发送！<ul>
<li>3.1 如果某个广播超时了，就强行结束广播，并设置广播的状态为 <code>BroadcastRecord.IDLE</code>;</li>
<li>3.2 如果某个广播的状态不是 <code>BroadcastRecord.IDLE</code>，说明上一个接收者没有结束广播处理，<code>return</code>；</li>
<li>3.3 如果某个广播没有接收者，或者已经分发给了所有的目标接受者，或者被终止传递，或者广播超时了，那就移除该广播！<br>  如果指定了 <code>r.resultTo</code>，那还需要将该广播发送给 <code>resultTo</code> 接受者！ </li>
</ul>
</li>
</ul>
<p><br></p>
<ul>
<li><p>4 有序分发 <code>mOrderedBroadcasts</code> 的广播，根据下一个接收者的不同，做不同的处理！</p>
<ul>
<li>4.1 如果是动态接收者，调用【<code>deliverToRegisteredReceiverLocked</code>】发送广播，然后等待处理结果，<code>return</code>！</li>
<li><p>4.2 如果是静态接收者，先要判断是否 skip 该接收者；</p>
<ul>
<li><p>4.2.1 跳过的触发条件：</p>
<pre><code>- sdk 不匹配，跳过；
- 发送者不具有接收者要求的权限，跳过；
- 接收者不具有发送者要求的权限，跳过；
- 广播不满足 `AMS` 的 `IntentFirewall` 防火墙要求，跳过；
- 接收者是单例，但是没有申明 `android.Manifest.permission.INTERACT_ACROSS_USERS`，跳过；
- 接收者所在进程 `crash` 了，跳过；
- 接收者所在 `package` 不可用，跳过；
- 接收者所在进程不允许后台启动，跳过；

&lt;/br&gt;
</code></pre></li>
<li><p>4.2.2 如果需要跳过该接受者，执行 <code>scheduleBroadcastsLocked</code>，进行下一次广播分发；</p>
<pre><code>- `r.delivery[recIdx] = BroadcastRecord.DELIVERY_SKIPPED`;
- `r.receiver = null`;
- `r.curFilter = null`;
- `r.state = BroadcastRecord.IDLE`;

&lt;/br&gt;
</code></pre></li>
<li><p>4.2.3 如果不跳过，就执行发送操作，这里需要判断静态接收者的进程是否启动；</p>
<pre><code>- 4.2.3.1 静态广播接收者所在的进程已经启动，调用【`processCurBroadcastLocked`】 发送广播，并等待结果，`return`；
- 4.2.3.2 静态广播接收者所在的进程没有启动，调用 `startProcessLocked` 启动进程：
        - 启动成功，将当前广播保存到 `mPendingBroadcast` 中，等待处理！
        - 启动失败，那就 执行 `scheduleBroadcastsLocked`，进行下一次广播分发；
</code></pre></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><br></p>
<p>梳理后，整个方法的业务逻辑很清楚了，下面我们来关注一些细节：</p>
<h3 id="2-5-1-发送给动态注册的接收者"><a href="#2-5-1-发送给动态注册的接收者" class="headerlink" title="2.5.1 发送给动态注册的接收者"></a>2.5.1 发送给动态注册的接收者</h3><h4 id="2-5-1-1-BroadcastQueue-deliverToRegisteredReceiverLocked"><a href="#2-5-1-1-BroadcastQueue-deliverToRegisteredReceiverLocked" class="headerlink" title="2.5.1.1 BroadcastQueue.deliverToRegisteredReceiverLocked"></a>2.5.1.1 BroadcastQueue.deliverToRegisteredReceiverLocked</h4><p>对于目标是动态接收者的普通广播（<code>ordered</code> 为 <code>false</code>），和目标是动态接收者的有序广播（<code>ordered</code> 为 <code>true</code>），都是通过 <code>deliverToRegisteredReceiverLocked</code> 直接发送的！</p>
<p>下面，我们来看看如何给动态注册的接收者发送广播！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deliverToRegisteredReceiverLocked</span><span class="params">(BroadcastRecord r,</span></span></span><br><span class="line"><span class="function"><span class="params">        BroadcastFilter filter, <span class="keyword">boolean</span> ordered, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】判断是否跳过这个接收者，这个和前面的流程很类似！</span></span><br><span class="line">    <span class="keyword">boolean</span> skip = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【2】首先是权限校验，校验发送者是否有接收者定义的权限，没有，跳过该接收者！</span></span><br><span class="line">    <span class="comment">// 权限如果是授予的，那还要再校验下 appOps！</span></span><br><span class="line">    <span class="keyword">if</span> (filter.requiredPermission != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> perm = mService.checkComponentPermission(filter.requiredPermission,</span><br><span class="line">                r.callingPid, r.callingUid, -<span class="number">1</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (perm != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Permission Denial: broadcasting "</span></span><br><span class="line">                    + r.intent.toString()</span><br><span class="line">                    + <span class="string">" from "</span> + r.callerPackage + <span class="string">" (pid="</span></span><br><span class="line">                    + r.callingPid + <span class="string">", uid="</span> + r.callingUid + <span class="string">")"</span></span><br><span class="line">                    + <span class="string">" requires "</span> + filter.requiredPermission</span><br><span class="line">                    + <span class="string">" due to registered receiver "</span> + filter);</span><br><span class="line">            skip = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> opCode = AppOpsManager.permissionToOpCode(filter.requiredPermission);</span><br><span class="line">            <span class="keyword">if</span> (opCode != AppOpsManager.OP_NONE</span><br><span class="line">                    &amp;&amp; mService.mAppOpsService.noteOperation(opCode, r.callingUid,</span><br><span class="line">                            r.callerPackage) != AppOpsManager.MODE_ALLOWED) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Appop Denial: broadcasting "</span></span><br><span class="line">                        + r.intent.toString()</span><br><span class="line">                        + <span class="string">" from "</span> + r.callerPackage + <span class="string">" (pid="</span></span><br><span class="line">                        + r.callingPid + <span class="string">", uid="</span> + r.callingUid + <span class="string">")"</span></span><br><span class="line">                        + <span class="string">" requires appop "</span> + AppOpsManager.permissionToOp(</span><br><span class="line">                                filter.requiredPermission)</span><br><span class="line">                        + <span class="string">" due to registered receiver "</span> + filter);</span><br><span class="line">                skip = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【3】校验接收者者是否有发送者定义的权限，没有，跳过该接收者！</span></span><br><span class="line">    <span class="comment">// 权限如果是授予的，那还要再校验下 appOps！</span></span><br><span class="line">    <span class="keyword">if</span> (!skip &amp;&amp; r.requiredPermissions != <span class="keyword">null</span> &amp;&amp; r.requiredPermissions.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r.requiredPermissions.length; i++) &#123;</span><br><span class="line">            String requiredPermission = r.requiredPermissions[i];</span><br><span class="line">            <span class="keyword">int</span> perm = mService.checkComponentPermission(requiredPermission,</span><br><span class="line">                    filter.receiverList.pid, filter.receiverList.uid, -<span class="number">1</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (perm != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Permission Denial: receiving "</span></span><br><span class="line">                        + r.intent.toString()</span><br><span class="line">                        + <span class="string">" to "</span> + filter.receiverList.app</span><br><span class="line">                        + <span class="string">" (pid="</span> + filter.receiverList.pid</span><br><span class="line">                        + <span class="string">", uid="</span> + filter.receiverList.uid + <span class="string">")"</span></span><br><span class="line">                        + <span class="string">" requires "</span> + requiredPermission</span><br><span class="line">                        + <span class="string">" due to sender "</span> + r.callerPackage</span><br><span class="line">                        + <span class="string">" (uid "</span> + r.callingUid + <span class="string">")"</span>);</span><br><span class="line"></span><br><span class="line">                skip = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> appOp = AppOpsManager.permissionToOpCode(requiredPermission);</span><br><span class="line">            <span class="keyword">if</span> (appOp != AppOpsManager.OP_NONE &amp;&amp; appOp != r.appOp</span><br><span class="line">                    &amp;&amp; mService.mAppOpsService.noteOperation(appOp,</span><br><span class="line">                    filter.receiverList.uid, filter.packageName)</span><br><span class="line">                    != AppOpsManager.MODE_ALLOWED) &#123;</span><br><span class="line"></span><br><span class="line">                Slog.w(TAG, <span class="string">"Appop Denial: receiving "</span></span><br><span class="line">                        + r.intent.toString()</span><br><span class="line">                        + <span class="string">" to "</span> + filter.receiverList.app</span><br><span class="line">                        + <span class="string">" (pid="</span> + filter.receiverList.pid</span><br><span class="line">                        + <span class="string">", uid="</span> + filter.receiverList.uid + <span class="string">")"</span></span><br><span class="line">                        + <span class="string">" requires appop "</span> + AppOpsManager.permissionToOp(</span><br><span class="line">                        requiredPermission)</span><br><span class="line">                        + <span class="string">" due to sender "</span> + r.callerPackage</span><br><span class="line">                        + <span class="string">" (uid "</span> + r.callingUid + <span class="string">")"</span>);</span><br><span class="line"></span><br><span class="line">                skip = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【4】校验接收者权限，这里跟踪下代码，由于传入的权限为 null，方法里面只针对 uid 做了判断</span></span><br><span class="line">    <span class="comment">// 看是不是 root 或者 system，是不是隔离进程 uid；</span></span><br><span class="line">    <span class="keyword">if</span> (!skip &amp;&amp; (r.requiredPermissions == <span class="keyword">null</span> || r.requiredPermissions.length == <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">int</span> perm = mService.checkComponentPermission(<span class="keyword">null</span>,</span><br><span class="line">                filter.receiverList.pid, filter.receiverList.uid, -<span class="number">1</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (perm != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Permission Denial: security check failed when receiving "</span></span><br><span class="line">                    + r.intent.toString()</span><br><span class="line">                    + <span class="string">" to "</span> + filter.receiverList.app</span><br><span class="line">                    + <span class="string">" (pid="</span> + filter.receiverList.pid</span><br><span class="line">                    + <span class="string">", uid="</span> + filter.receiverList.uid + <span class="string">")"</span></span><br><span class="line">                    + <span class="string">" due to sender "</span> + r.callerPackage</span><br><span class="line">                    + <span class="string">" (uid "</span> + r.callingUid + <span class="string">")"</span>);</span><br><span class="line">            skip = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【5】校验 ops！</span></span><br><span class="line">    <span class="keyword">if</span> (!skip &amp;&amp; r.appOp != AppOpsManager.OP_NONE</span><br><span class="line">            &amp;&amp; mService.mAppOpsService.noteOperation(r.appOp,</span><br><span class="line">            filter.receiverList.uid, filter.packageName)</span><br><span class="line">            != AppOpsManager.MODE_ALLOWED) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"Appop Denial: receiving "</span></span><br><span class="line">                + r.intent.toString()</span><br><span class="line">                + <span class="string">" to "</span> + filter.receiverList.app</span><br><span class="line">                + <span class="string">" (pid="</span> + filter.receiverList.pid</span><br><span class="line">                + <span class="string">", uid="</span> + filter.receiverList.uid + <span class="string">")"</span></span><br><span class="line">                + <span class="string">" requires appop "</span> + AppOpsManager.opToName(r.appOp)</span><br><span class="line">                + <span class="string">" due to sender "</span> + r.callerPackage</span><br><span class="line">                + <span class="string">" (uid "</span> + r.callingUid + <span class="string">")"</span>);</span><br><span class="line">        skip = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【6】判断是否允许后台发送广播，不允许就跳过！</span></span><br><span class="line">    <span class="keyword">if</span> (!skip) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> allowed = mService.checkAllowBackgroundLocked(filter.receiverList.uid,</span><br><span class="line">                filter.packageName, -<span class="number">1</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (allowed == ActivityManager.APP_START_MODE_DISABLED) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Background execution not allowed: receiving "</span></span><br><span class="line">                    + r.intent</span><br><span class="line">                    + <span class="string">" to "</span> + filter.receiverList.app</span><br><span class="line">                    + <span class="string">" (pid="</span> + filter.receiverList.pid</span><br><span class="line">                    + <span class="string">", uid="</span> + filter.receiverList.uid + <span class="string">")"</span>);</span><br><span class="line">            skip = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【7】广播不通过防火墙校验，跳过该接收者！</span></span><br><span class="line">    <span class="keyword">if</span> (!mService.mIntentFirewall.checkBroadcast(r.intent, r.callingUid,</span><br><span class="line">            r.callingPid, r.resolvedType, filter.receiverList.uid)) &#123;</span><br><span class="line">        skip = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【8】接收者所在进程 crash 了，就跳过接收者！</span></span><br><span class="line">    <span class="keyword">if</span> (!skip &amp;&amp; (filter.receiverList.app == <span class="keyword">null</span> || filter.receiverList.app.crashing)) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"Skipping deliver ["</span> + mQueueName + <span class="string">"] "</span> + r</span><br><span class="line">                + <span class="string">" to "</span> + filter.receiverList + <span class="string">": process crashing"</span>);</span><br><span class="line">        skip = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【9】如果跳过该接收者，那就设置该接收者为 DELIVERY_SKIPPED；</span></span><br><span class="line">    <span class="keyword">if</span> (skip) &#123;</span><br><span class="line">        r.delivery[index] = BroadcastRecord.DELIVERY_SKIPPED;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【10】如果需要 review 权限，那就拉起 review！</span></span><br><span class="line">    <span class="keyword">if</span> (Build.PERMISSIONS_REVIEW_REQUIRED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!requestStartTargetPermissionsReviewIfNeededLocked(r, filter.packageName,</span><br><span class="line">                filter.owningUserId)) &#123;</span><br><span class="line">            r.delivery[index] = BroadcastRecord.DELIVERY_SKIPPED;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【11】开始发送广播！</span></span><br><span class="line">    r.delivery[index] = BroadcastRecord.DELIVERY_DELIVERED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【12】如果是有序广播，下面的分支！！</span></span><br><span class="line">    <span class="keyword">if</span> (ordered) &#123;</span><br><span class="line">        <span class="comment">//【12.1】设置广播的目标接收者 IIntentReceier.Proxy 对象，用于挂进程拉起 onReceive 方法！</span></span><br><span class="line">        r.receiver = filter.receiverList.receiver.asBinder();</span><br><span class="line">        <span class="comment">//【12.2】设置一系列相互引用；</span></span><br><span class="line">        r.curFilter = filter;</span><br><span class="line">        filter.receiverList.curBroadcast = r;</span><br><span class="line">        <span class="comment">//【12.2】设置广播状态；</span></span><br><span class="line">        r.state = BroadcastRecord.CALL_IN_RECEIVE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【12.3】如果接收者所在进程已经启动！</span></span><br><span class="line">        <span class="keyword">if</span> (filter.receiverList.app != <span class="keyword">null</span>) &#123;</span><br><span class="line">            r.curApp = filter.receiverList.app;</span><br><span class="line">            filter.receiverList.app.curReceiver = r;</span><br><span class="line">            mService.updateOomAdjLocked(r.curApp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_BROADCAST_LIGHT) Slog.i(TAG_BROADCAST,</span><br><span class="line">                <span class="string">"Delivering to "</span> + filter + <span class="string">" : "</span> + r);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (filter.receiverList.app != <span class="keyword">null</span> &amp;&amp; filter.receiverList.app.inFullBackup) &#123;</span><br><span class="line">            <span class="comment">//【13】如果接收者的进程正在进行数据的备份和还原操作，那就跳过当前接收者！</span></span><br><span class="line">            <span class="comment">// 发送给下一个接收者，先 finishReceiverLocked，再 scheduleBroadcastsLocked！！</span></span><br><span class="line">            <span class="keyword">if</span> (ordered) &#123;</span><br><span class="line">                skipReceiverLocked(r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//【×2.5.1.3】发送广播，one way 异步传输，无需等待返回！</span></span><br><span class="line">            performReceiveLocked(filter.receiverList.app, filter.receiverList.receiver,</span><br><span class="line">                    <span class="keyword">new</span> Intent(r.intent), r.resultCode, r.resultData,</span><br><span class="line">                    r.resultExtras, r.ordered, r.initialSticky, r.userId);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【14】如果是有序广播，将广播状态置为 CALL_DONE_RECEIVE 已经接受！</span></span><br><span class="line">        <span class="keyword">if</span> (ordered) &#123;</span><br><span class="line">            <span class="comment">//【14.1】修改广播状态为 CALL_DONE_RECEIVE！</span></span><br><span class="line">            r.state = BroadcastRecord.CALL_DONE_RECEIVE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"Failure sending broadcast "</span> + r.intent, e);</span><br><span class="line">        <span class="keyword">if</span> (ordered) &#123;</span><br><span class="line">            r.receiver = <span class="keyword">null</span>;</span><br><span class="line">            r.curFilter = <span class="keyword">null</span>;</span><br><span class="line">            filter.receiverList.curBroadcast = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (filter.receiverList.app != <span class="keyword">null</span>) &#123;</span><br><span class="line">                filter.receiverList.app.curReceiver = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>整个方法的逻辑很简单！</p>
<h4 id="2-5-1-2-BroadcastQueue-addBroadcastToHistoryLocked"><a href="#2-5-1-2-BroadcastQueue-addBroadcastToHistoryLocked" class="headerlink" title="2.5.1.2 BroadcastQueue.addBroadcastToHistoryLocked"></a>2.5.1.2 BroadcastQueue.addBroadcastToHistoryLocked</h4><p>将分发的广播加入历史集合中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addBroadcastToHistoryLocked</span><span class="params">(BroadcastRecord r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r.callingUid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// This was from a registerReceiver() call; ignore it.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    r.finishTime = SystemClock.uptimeMillis();</span><br><span class="line"></span><br><span class="line">    mBroadcastHistory[mHistoryNext] = r;</span><br><span class="line">    mHistoryNext = ringAdvance(mHistoryNext, <span class="number">1</span>, MAX_BROADCAST_HISTORY);</span><br><span class="line"></span><br><span class="line">    mBroadcastSummaryHistory[mSummaryHistoryNext] = r.intent;</span><br><span class="line">    mSummaryHistoryEnqueueTime[mSummaryHistoryNext] = r.enqueueClockTime;</span><br><span class="line">    mSummaryHistoryDispatchTime[mSummaryHistoryNext] = r.dispatchClockTime;</span><br><span class="line">    mSummaryHistoryFinishTime[mSummaryHistoryNext] = System.currentTimeMillis();</span><br><span class="line">    mSummaryHistoryNext = ringAdvance(mSummaryHistoryNext, <span class="number">1</span>, MAX_BROADCAST_SUMMARY_HISTORY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-5-1-3-BroadcastQueue-performReceiveLocked"><a href="#2-5-1-3-BroadcastQueue-performReceiveLocked" class="headerlink" title="2.5.1.3 BroadcastQueue.performReceiveLocked"></a>2.5.1.3 BroadcastQueue.performReceiveLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">performReceiveLocked</span><span class="params">(ProcessRecord app, IIntentReceiver receiver,</span></span></span><br><span class="line"><span class="function"><span class="params">        Intent intent, <span class="keyword">int</span> resultCode, String data, Bundle extras,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> ordered, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> sendingUser)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (app != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//【×2.5.1.4】one-way 通过 Binder 通信，进入接收者所在的进程！</span></span><br><span class="line">                app.thread.scheduleRegisteredReceiver(receiver, intent, resultCode,</span><br><span class="line">                        data, extras, ordered, sticky, sendingUser, app.repProcState);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (mService) &#123;</span><br><span class="line">                    Slog.w(TAG, <span class="string">"Can't deliver broadcast to "</span> + app.processName</span><br><span class="line">                            + <span class="string">" (pid "</span> + app.pid + <span class="string">"). Crashing it."</span>);</span><br><span class="line">                    app.scheduleCrash(<span class="string">"can't deliver broadcast"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RemoteException(<span class="string">"app.thread must not be null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//【1】如果进程 app 为 null，这里会直接通过 binder 拉起相应方法！</span></span><br><span class="line">        receiver.performReceive(intent, resultCode, data, extras, ordered,</span><br><span class="line">                sticky, sendingUser);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里会调用 <code>ApplicationThreadProxy</code> 对象的 <code>scheduleRegisteredReceiver</code>！</p>
<p>这里就要进入接收者所在的进程了！</p>
<h4 id="2-5-1-4-ApplicationThreadP-scheduleRegisteredReceiver"><a href="#2-5-1-4-ApplicationThreadP-scheduleRegisteredReceiver" class="headerlink" title="2.5.1.4 ApplicationThreadP.scheduleRegisteredReceiver"></a>2.5.1.4 ApplicationThreadP.scheduleRegisteredReceiver</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleRegisteredReceiver</span><span class="params">(IIntentReceiver receiver, Intent intent,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> resultCode, String dataStr, Bundle extras, <span class="keyword">boolean</span> ordered,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> sendingUser, <span class="keyword">int</span> processState)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    Parcel data = Parcel.obtain();</span><br><span class="line">    data.writeInterfaceToken(IApplicationThread.descriptor);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里的 receiver 是动态注册的接收者在 AMS 中的 IIntentReceiver.Proxy 对象！</span></span><br><span class="line">    data.writeStrongBinder(receiver.asBinder());</span><br><span class="line">    intent.writeToParcel(data, <span class="number">0</span>);</span><br><span class="line">    data.writeInt(resultCode);</span><br><span class="line">    data.writeString(dataStr);</span><br><span class="line">    data.writeBundle(extras);</span><br><span class="line">    data.writeInt(ordered ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    data.writeInt(sticky ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    data.writeInt(sendingUser);</span><br><span class="line">    data.writeInt(processState);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Binder 通信：SCHEDULE_REGISTERED_RECEIVER_TRANSACTION</span></span><br><span class="line">    <span class="comment">// 这里是 FLAG_ONEWAY，异步传输，无需等待返回！</span></span><br><span class="line">    mRemote.transact(SCHEDULE_REGISTERED_RECEIVER_TRANSACTION, data, <span class="keyword">null</span>,</span><br><span class="line">            IBinder.FLAG_ONEWAY);</span><br><span class="line">    data.recycle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来就会进入接收者所在进程！</p>
<h3 id="2-5-2-发送给静态注册的接收者"><a href="#2-5-2-发送给静态注册的接收者" class="headerlink" title="2.5.2 发送给静态注册的接收者"></a>2.5.2 发送给静态注册的接收者</h3><p>对于静态注册的广播接收者（有序广播/普通广播），因为他的进程未必已经被启动，所以要分情况！</p>
<h4 id="2-5-2-1-进程已启动"><a href="#2-5-2-1-进程已启动" class="headerlink" title="2.5.2.1 进程已启动"></a>2.5.2.1 进程已启动</h4><p>如果接收者所在的进程被启动了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Is this receiver's application already running?</span></span><br><span class="line"> <span class="keyword">if</span> (app != <span class="keyword">null</span> &amp;&amp; app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         app.addPackage(info.activityInfo.packageName,</span><br><span class="line">                 info.activityInfo.applicationInfo.versionCode, mService.mProcessStats);</span><br><span class="line">         </span><br><span class="line">         <span class="comment">//【×2.5.2.1.1】那就调用 processCurBroadcastLocked 处理广播发送！</span></span><br><span class="line">         processCurBroadcastLocked(r, app);</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        </span><br><span class="line">     &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        </span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>我们继续看：</p>
<h5 id="2-5-2-1-1-BroadcastQueue-processCurBroadcastLocked"><a href="#2-5-2-1-1-BroadcastQueue-processCurBroadcastLocked" class="headerlink" title="2.5.2.1.1 BroadcastQueue.processCurBroadcastLocked"></a>2.5.2.1.1 BroadcastQueue.processCurBroadcastLocked</h5><p>发送当前的广播！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">processCurBroadcastLocked</span><span class="params">(BroadcastRecord r,</span></span></span><br><span class="line"><span class="function"><span class="params">        ProcessRecord app)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_BROADCAST)  Slog.v(TAG_BROADCAST,</span><br><span class="line">            <span class="string">"Process cur broadcast "</span> + r + <span class="string">" for app "</span> + app);</span><br><span class="line">    <span class="keyword">if</span> (app.thread == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RemoteException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】进程如果在进行备份还原操作，跳过该静态接收者！</span></span><br><span class="line">    <span class="keyword">if</span> (app.inFullBackup) &#123;</span><br><span class="line">        skipReceiverLocked(r);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【2】将广播的 r.receiver 设置为接收者进程的 ApplicationThreadProxy 对象！</span></span><br><span class="line">    r.receiver = app.thread.asBinder();</span><br><span class="line">    r.curApp = app;</span><br><span class="line">    app.curReceiver = r;</span><br><span class="line"></span><br><span class="line">    app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_RECEIVER);</span><br><span class="line">    mService.updateLruProcessLocked(app, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">    mService.updateOomAdjLocked();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【3】设置组件信息，由于前面 r.receiver 设置的是 ApplicationThreadProxy，</span></span><br><span class="line">    <span class="comment">// 所以为了拉起接收者，这里必须设置组件名！</span></span><br><span class="line">    r.intent.setComponent(r.curComponent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST,</span><br><span class="line">                <span class="string">"Delivering to component "</span> + r.curComponent</span><br><span class="line">                + <span class="string">": "</span> + r);</span><br><span class="line"></span><br><span class="line">        mService.notifyPackageUse(r.intent.getComponent().getPackageName(),</span><br><span class="line">                                  PackageManager.NOTIFY_PACKAGE_USE_BROADCAST_RECEIVER);</span><br><span class="line">                                  </span><br><span class="line">        <span class="comment">//【×3.2.1】通过 Binder 通信，进入应用进程，拉起接收者的 onReceive 方法！</span></span><br><span class="line">        <span class="comment">// one ways！</span></span><br><span class="line">        app.thread.scheduleReceiver(<span class="keyword">new</span> Intent(r.intent), r.curReceiver,</span><br><span class="line">                mService.compatibilityInfoForPackageLocked(r.curReceiver.applicationInfo),</span><br><span class="line">                r.resultCode, r.resultData, r.resultExtras, r.ordered, r.userId,</span><br><span class="line">                app.repProcState);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DEBUG_BROADCAST)  Slog.v(TAG_BROADCAST,</span><br><span class="line">                <span class="string">"Process cur broadcast "</span> + r + <span class="string">" DELIVERED for app "</span> + app);</span><br><span class="line"></span><br><span class="line">        started = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_BROADCAST)  Slog.v(TAG_BROADCAST,</span><br><span class="line">                    <span class="string">"Process cur broadcast "</span> + r + <span class="string">": NOT STARTED!"</span>);</span><br><span class="line">            r.receiver = <span class="keyword">null</span>;</span><br><span class="line">            r.curApp = <span class="keyword">null</span>;</span><br><span class="line">            app.curReceiver = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就会进入接收者所在的进程，我们后面再看！</p>
<h5 id="2-5-2-1-2-ApplicationThreadP-processCurBroadcastLocked"><a href="#2-5-2-1-2-ApplicationThreadP-processCurBroadcastLocked" class="headerlink" title="2.5.2.1.2 ApplicationThreadP.processCurBroadcastLocked"></a>2.5.2.1.2 ApplicationThreadP.processCurBroadcastLocked</h5><p>发送当前的广播！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleReceiver</span><span class="params">(Intent intent, ActivityInfo info,</span></span></span><br><span class="line"><span class="function"><span class="params">        CompatibilityInfo compatInfo, <span class="keyword">int</span> resultCode, String resultData,</span></span></span><br><span class="line"><span class="function"><span class="params">        Bundle map, <span class="keyword">boolean</span> sync, <span class="keyword">int</span> sendingUser, <span class="keyword">int</span> processState)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    Parcel data = Parcel.obtain();</span><br><span class="line">    data.writeInterfaceToken(IApplicationThread.descriptor);</span><br><span class="line">    intent.writeToParcel(data, <span class="number">0</span>);</span><br><span class="line">    info.writeToParcel(data, <span class="number">0</span>);</span><br><span class="line">    compatInfo.writeToParcel(data, <span class="number">0</span>);</span><br><span class="line">    data.writeInt(resultCode);</span><br><span class="line">    data.writeString(resultData);</span><br><span class="line">    data.writeBundle(map);</span><br><span class="line">    data.writeInt(sync ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    data.writeInt(sendingUser);</span><br><span class="line">    data.writeInt(processState);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【1】发送 SCHEDULE_RECEIVER_TRANSACTION 消息，one way！！</span></span><br><span class="line">    mRemote.transact(SCHEDULE_RECEIVER_TRANSACTION, data, <span class="keyword">null</span>,</span><br><span class="line">            IBinder.FLAG_ONEWAY);</span><br><span class="line">    data.recycle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面就进入了应用进程：</p>
<h4 id="2-5-2-2-进程未启动"><a href="#2-5-2-2-进程未启动" class="headerlink" title="2.5.2.2 进程未启动"></a>2.5.2.2 进程未启动</h4><p>对于进程没有启动这种情况，我们需要主动的拉起接收者所在的进程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((r.curApp=mService.startProcessLocked(targetProcess,</span><br><span class="line">        info.activityInfo.applicationInfo, <span class="keyword">true</span>,</span><br><span class="line">        r.intent.getFlags() | Intent.FLAG_FROM_BACKGROUND,</span><br><span class="line">        <span class="string">"broadcast"</span>, r.curComponent,</span><br><span class="line">        (r.intent.getFlags()&amp;Intent.FLAG_RECEIVER_BOOT_UPGRADE) != <span class="number">0</span>, <span class="keyword">false</span>, <span class="keyword">false</span>))</span><br><span class="line">                == <span class="keyword">null</span>) &#123;</span><br><span class="line">    ... ... ... ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//【1】将广播保存到 mPendingBroadcast 中！</span></span><br><span class="line">mPendingBroadcast = r;</span><br><span class="line">mPendingBroadcastRecvIndex = recIdx;</span><br></pre></td></tr></table></figure>
<p>对于进程的启动，我们这里不详细的介绍，请看其他的博文，这里我就直接上结果：</p>
<h5 id="2-5-2-2-1-ActivityManagerService-attachApplicationLocked"><a href="#2-5-2-2-1-ActivityManagerService-attachApplicationLocked" class="headerlink" title="2.5.2.2.1 ActivityManagerService.attachApplicationLocked"></a>2.5.2.2.1 ActivityManagerService.attachApplicationLocked</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">attachApplicationLocked</span><span class="params">(IApplicationThread thread,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> pid)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    ... ... ... ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【×2.5.2.2.1.1 】判读是否有等待该进程启动的广播</span></span><br><span class="line">    <span class="keyword">if</span> (!badApp &amp;&amp; isPendingBroadcastProcessLocked(pid)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【×2.5.2.2.1.2】发送广播！</span></span><br><span class="line">            didSomething |= sendPendingBroadcastsLocked(app);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// If the app died trying to launch the receiver we declare it 'bad'</span></span><br><span class="line">            Slog.wtf(TAG, <span class="string">"Exception thrown dispatching broadcasts in "</span> + app, e);</span><br><span class="line">            badApp = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ... ... ... ...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们继续来看：</p>
<h6 id="2-5-2-2-1-1-ActivityManagerS-isPendingBroadcastProcessLocked"><a href="#2-5-2-2-1-1-ActivityManagerS-isPendingBroadcastProcessLocked" class="headerlink" title="2.5.2.2.1.1 ActivityManagerS.isPendingBroadcastProcessLocked"></a>2.5.2.2.1.1 ActivityManagerS.isPendingBroadcastProcessLocked</h6><p>进程启动后，会判断该进程中是否有有需要分发的广播：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isPendingBroadcastProcessLocked</span><span class="params">(<span class="keyword">int</span> pid)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【×2.5.2.2.1.2】判读是否有等待该进程启动的广播</span></span><br><span class="line">    <span class="keyword">return</span> mFgBroadcastQueue.isPendingBroadcastProcessLocked(pid)</span><br><span class="line">            || mBgBroadcastQueue.isPendingBroadcastProcessLocked(pid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其实判断的依据很简单：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPendingBroadcastProcessLocked</span><span class="params">(<span class="keyword">int</span> pid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mPendingBroadcast != <span class="keyword">null</span> &amp;&amp; mPendingBroadcast.curApp.pid == pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果 <code>BroadcastQueue</code> 内部的 <code>mPendingBroadcast</code> 不为 <code>null</code>，且 <code>mPendingBroadcast.curApp.pid</code> 等于当前进程的 <code>pid</code>，就说明有目标为该进程的广播！</p>
<h6 id="2-5-2-2-1-2-ActivityManagerS-sendPendingBroadcastsLocked"><a href="#2-5-2-2-1-2-ActivityManagerS-sendPendingBroadcastsLocked" class="headerlink" title="2.5.2.2.1.2 ActivityManagerS.sendPendingBroadcastsLocked"></a>2.5.2.2.1.2 ActivityManagerS.sendPendingBroadcastsLocked</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">sendPendingBroadcastsLocked</span><span class="params">(ProcessRecord app)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> didSomething = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】遍历前台和后台广播队列！</span></span><br><span class="line">    <span class="keyword">for</span> (BroadcastQueue queue : mBroadcastQueues) &#123;</span><br><span class="line">        <span class="comment">//【×2.5.2.2.1.3】发送 pending broadcast！！</span></span><br><span class="line">        didSomething |= queue.sendPendingBroadcastsLocked(app);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> didSomething;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面我们去 <code>BroadcastQueue</code> 中去看看！</p>
<h6 id="2-5-2-2-1-3-BroadcastQueue-sendPendingBroadcastsLocked"><a href="#2-5-2-2-1-3-BroadcastQueue-sendPendingBroadcastsLocked" class="headerlink" title="2.5.2.2.1.3 BroadcastQueue.sendPendingBroadcastsLocked"></a>2.5.2.2.1.3 BroadcastQueue.sendPendingBroadcastsLocked</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendPendingBroadcastsLocked</span><span class="params">(ProcessRecord app)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> didSomething = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【1】将 mPendingBroadcast 赋给 br！</span></span><br><span class="line">    <span class="keyword">final</span> BroadcastRecord br = mPendingBroadcast;</span><br><span class="line">    <span class="keyword">if</span> (br != <span class="keyword">null</span> &amp;&amp; br.curApp.pid == app.pid) &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//【1】校验进程是否匹配！</span></span><br><span class="line">        <span class="keyword">if</span> (br.curApp != app) &#123;</span><br><span class="line">            Slog.e(TAG, <span class="string">"App mismatch when sending pending broadcast to "</span></span><br><span class="line">                    + app.processName + <span class="string">", intended target is "</span> + br.curApp.processName);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//【2】将 mPendingBroadcast 赋值为 null；</span></span><br><span class="line">            mPendingBroadcast = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【×2.5.2.1.1】发送广播！</span></span><br><span class="line">            processCurBroadcastLocked(br, app);</span><br><span class="line">            didSomething = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Exception in new application when starting receiver "</span></span><br><span class="line">                    + br.curComponent.flattenToShortString(), e);</span><br><span class="line"></span><br><span class="line">            logBroadcastReceiverDiscardLocked(br);</span><br><span class="line">            finishReceiverLocked(br, br.resultCode, br.resultData,</span><br><span class="line">                    br.resultExtras, br.resultAbort, <span class="keyword">false</span>);</span><br><span class="line">            scheduleBroadcastsLocked();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// We need to reset the state if we failed to start the receiver.</span></span><br><span class="line">            br.state = BroadcastRecord.IDLE;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> didSomething;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 <code>processCurBroadcastLocked</code> 又回到了进程已启动的发送流程了！！</p>
<h1 id="3-接收者进程"><a href="#3-接收者进程" class="headerlink" title="3 接收者进程"></a>3 接收者进程</h1><p>这里我们按照广播接收者的不同来分别看看：</p>
<h2 id="3-1-动态接收者进程"><a href="#3-1-动态接收者进程" class="headerlink" title="3.1 动态接收者进程"></a>3.1 动态接收者进程</h2><p>发送给动态注册的接收者有 <code>2</code> 种广播，首先会进入 <code>ApplicationThreadN</code> 中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> SCHEDULE_REGISTERED_RECEIVER_TRANSACTION: &#123;</span><br><span class="line">    data.enforceInterface(IApplicationThread.descriptor);</span><br><span class="line">    </span><br><span class="line">    IIntentReceiver receiver = IIntentReceiver.Stub.asInterface(</span><br><span class="line">            data.readStrongBinder());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里是将 IIntentReceiver Binder 对象转为 InnerReceiver 对象！</span></span><br><span class="line">    Intent intent = Intent.CREATOR.createFromParcel(data);</span><br><span class="line">    <span class="keyword">int</span> resultCode = data.readInt();</span><br><span class="line">    String dataStr = data.readString();</span><br><span class="line">    Bundle extras = data.readBundle();</span><br><span class="line">    <span class="keyword">boolean</span> ordered = data.readInt() != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> sticky = data.readInt() != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sendingUser = data.readInt();</span><br><span class="line">    <span class="keyword">int</span> processState = data.readInt();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【1】进入 ApplicationThread，调用 scheduleRegisteredReceiver 方法！</span></span><br><span class="line">    scheduleRegisteredReceiver(receiver, intent,</span><br><span class="line">            resultCode, dataStr, extras, ordered, sticky, sendingUser, processState);</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-1-1-ApplicationThread-scheduleRegisteredReceiver"><a href="#3-1-1-ApplicationThread-scheduleRegisteredReceiver" class="headerlink" title="3.1.1 ApplicationThread.scheduleRegisteredReceiver"></a>3.1.1 ApplicationThread.scheduleRegisteredReceiver</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleRegisteredReceiver</span><span class="params">(IIntentReceiver receiver, Intent intent,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> resultCode, String dataStr, Bundle extras, <span class="keyword">boolean</span> ordered,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> sendingUser, <span class="keyword">int</span> processState)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    updateProcessState(processState, <span class="keyword">false</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【×3.1.2】进入 InnerReceiver！</span></span><br><span class="line">    receiver.performReceive(intent, resultCode, dataStr, extras, ordered,</span><br><span class="line">            sticky, sendingUser);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-1-2-InnerReceiver-performReceive"><a href="#3-1-2-InnerReceiver-performReceive" class="headerlink" title="3.1.2 InnerReceiver.performReceive"></a>3.1.2 InnerReceiver.performReceive</h3><p>继续看：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performReceive</span><span class="params">(Intent intent, <span class="keyword">int</span> resultCode, String data,</span></span></span><br><span class="line"><span class="function"><span class="params">        Bundle extras, <span class="keyword">boolean</span> ordered, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> sendingUser)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> LoadedApk.ReceiverDispatcher rd;</span><br><span class="line">    <span class="keyword">if</span> (intent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Log.wtf(TAG, <span class="string">"Null intent received"</span>);</span><br><span class="line">        rd = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//【1】如果广播不为 null，就获得对应的 ReceiverDispatcher 对象，用于分发广播！</span></span><br><span class="line">        rd = mDispatcher.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ActivityThread.DEBUG_BROADCAST) &#123;</span><br><span class="line">        <span class="keyword">int</span> seq = intent.getIntExtra(<span class="string">"seq"</span>, -<span class="number">1</span>);</span><br><span class="line">        Slog.i(ActivityThread.TAG, <span class="string">"Receiving broadcast "</span> + intent.getAction()</span><br><span class="line">                + <span class="string">" seq="</span> + seq + <span class="string">" to "</span> + (rd != <span class="keyword">null</span> ? rd.mReceiver : <span class="keyword">null</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rd != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//【×3.1.3】调用 ReceiverDispatcher 的 performReceive 方法，分发广播！</span></span><br><span class="line">        rd.performReceive(intent, resultCode, data, extras,</span><br><span class="line">                ordered, sticky, sendingUser);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//【3】如果 rd 为 null，那就调用 AMS 的方法，立刻结束广播的发送！</span></span><br><span class="line">        <span class="keyword">if</span> (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG,</span><br><span class="line">                <span class="string">"Finishing broadcast to unregistered receiver"</span>);</span><br><span class="line">        IActivityManager mgr = ActivityManagerNative.getDefault();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (extras != <span class="keyword">null</span>) &#123;</span><br><span class="line">                extras.setAllowFds(<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//【4】调用了 ams 的 finish receiver 方法，这个方法我们在取消注册的时候会看！</span></span><br><span class="line">            mgr.finishReceiver(<span class="keyword">this</span>, resultCode, data, extras, <span class="keyword">false</span>, intent.getFlags());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-1-3-ReceiverDispatcher-performReceive"><a href="#3-1-3-ReceiverDispatcher-performReceive" class="headerlink" title="3.1.3 ReceiverDispatcher.performReceive"></a>3.1.3 ReceiverDispatcher.performReceive</h3><p>接着，进入 <code>ReceiverDispatcher</code>，我们都知道 <code>ReceiverDispatcher</code> 保存了 <code>BroadcastReceiver</code> 和 <code>InnerReceiver</code> 的映射关系：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performReceive</span><span class="params">(Intent intent, <span class="keyword">int</span> resultCode, String data,</span></span></span><br><span class="line"><span class="function"><span class="params">        Bundle extras, <span class="keyword">boolean</span> ordered, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> sendingUser)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【*3.1.3.1】创建了一个 Args 对象，用于封装广播参数信息！Args 继承了 Runnable 对象!</span></span><br><span class="line">    <span class="keyword">final</span> Args args = <span class="keyword">new</span> Args(intent, resultCode, data, extras, ordered,</span><br><span class="line">            sticky, sendingUser);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (intent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Log.wtf(TAG, <span class="string">"Null intent received"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ActivityThread.DEBUG_BROADCAST) &#123;</span><br><span class="line">            <span class="keyword">int</span> seq = intent.getIntExtra(<span class="string">"seq"</span>, -<span class="number">1</span>);</span><br><span class="line">            Slog.i(ActivityThread.TAG, <span class="string">"Enqueueing broadcast "</span> + intent.getAction()</span><br><span class="line">                    + <span class="string">" seq="</span> + seq + <span class="string">" to "</span> + mReceiver);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【×3.1.4】调用 mActivityThread.post 执行 Args 任务！post 如果返回 false，说明任务执行失败！</span></span><br><span class="line">    <span class="keyword">if</span> (intent == <span class="keyword">null</span> || !mActivityThread.post(args)) &#123;</span><br><span class="line">        <span class="comment">//【1】任务执行失败，如果该广播是通过有序的方式发送的，还要通知系统，广播已经分发完成！</span></span><br><span class="line">        <span class="comment">// 然后系统就会进行下一个广播的有序分发！</span></span><br><span class="line">        <span class="keyword">if</span> (mRegistered &amp;&amp; ordered) &#123;</span><br><span class="line">            IActivityManager mgr = ActivityManagerNative.getDefault();</span><br><span class="line">            <span class="keyword">if</span> (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG,</span><br><span class="line">                    <span class="string">"Finishing sync broadcast to "</span> + mReceiver);</span><br><span class="line">            <span class="comment">//【×3.3.2】调用了 args 父类 PendingResult 的 sendFinished 方法！</span></span><br><span class="line">            args.sendFinished(mgr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里我们回顾一下，采用有序的分发方式的广播有 <code>2</code> 种类型：</p>
<ul>
<li>目标是静态注册的接收者的普通广播；</li>
<li>另外一种是目标是静态或者动态注册的接收者的有序广播；</li>
</ul>
<p>这里的 <code>ordered</code> 如果是普通广播，那么为 <code>false</code>，如果是有序广播，那么为 <code>true</code>！</p>
<h4 id="3-1-3-1-new-Args"><a href="#3-1-3-1-new-Args" class="headerlink" title="3.1.3.1 new Args"></a>3.1.3.1 new Args</h4><p>创建了一个 Args 对象，其继承了 PendingResult：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Args</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span>.<span class="title">PendingResult</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Intent mCurIntent;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> mOrdered;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mDispatched;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Args</span><span class="params">(Intent intent, <span class="keyword">int</span> resultCode, String resultData, Bundle resultExtras,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> ordered, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> sendingUser)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【1】这里的 mIIntentReceiver 是 ReceiverDispatcher 的内部变量：InnerReceiver！</span></span><br><span class="line">        <span class="comment">// 显然，对于动态注册的接收者，mType 等于 TYPE_REGISTERED 或者 TYPE_UNREGISTERED；</span></span><br><span class="line">        <span class="keyword">super</span>(resultCode, resultData, resultExtras,</span><br><span class="line">                mRegistered ? TYPE_REGISTERED : TYPE_UNREGISTERED, ordered,</span><br><span class="line">                sticky, mIIntentReceiver.asBinder(), sendingUser, intent.getFlags());</span><br><span class="line"></span><br><span class="line">        mCurIntent = intent;</span><br><span class="line">        mOrdered = ordered;</span><br><span class="line">    &#125;</span><br><span class="line">    ... ... ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 <code>mRegistered</code> 是应用在动态注册接收者时，创建 <code>ReceiverDispatcher</code> 时设置为 <code>true</code> 的，这里显然为 <code>true</code>！</p>
<h3 id="3-1-4-Args-run"><a href="#3-1-4-Args-run" class="headerlink" title="3.1.4 Args.run"></a>3.1.4 Args.run</h3><p><code>mActivityThread.post</code> 方法，会在主线程执行任务 <code>Args</code>，下面我们来看看 <code>Args.run</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> BroadcastReceiver receiver = mReceiver;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> ordered = mOrdered; <span class="comment">// 是否有序！</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (ActivityThread.DEBUG_BROADCAST) &#123;</span><br><span class="line">        <span class="keyword">int</span> seq = mCurIntent.getIntExtra(<span class="string">"seq"</span>, -<span class="number">1</span>);</span><br><span class="line">        Slog.i(ActivityThread.TAG, <span class="string">"Dispatching broadcast "</span> + mCurIntent.getAction()</span><br><span class="line">                + <span class="string">" seq="</span> + seq + <span class="string">" to "</span> + mReceiver);</span><br><span class="line">        Slog.i(ActivityThread.TAG, <span class="string">"  mRegistered="</span> + mRegistered</span><br><span class="line">                + <span class="string">" mOrderedHint="</span> + ordered);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> IActivityManager mgr = ActivityManagerNative.getDefault();</span><br><span class="line">    <span class="keyword">final</span> Intent intent = mCurIntent;</span><br><span class="line">    <span class="keyword">if</span> (intent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Log.wtf(TAG, <span class="string">"Null intent being dispatched, mDispatched="</span> + mDispatched);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mCurIntent = <span class="keyword">null</span>;</span><br><span class="line">    mDispatched = <span class="keyword">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【1】如果动态注册的接收者为 null，或者广播为 null，或者已经通过 unregisterReceiver</span></span><br><span class="line">    <span class="comment">// 方法动态取消注册了接收者，并且如果是有序广播，就要通知系统，继续下一次分发！</span></span><br><span class="line">    <span class="keyword">if</span> (receiver == <span class="keyword">null</span> || intent == <span class="keyword">null</span> || mForgotten) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mRegistered &amp;&amp; ordered) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG,</span><br><span class="line">                    <span class="string">"Finishing null broadcast to "</span> + mReceiver);</span><br><span class="line">            <span class="comment">//【×3.3.2】调用了 args 父类 PendingResult 的 sendFinished 方法！</span></span><br><span class="line">            sendFinished(mgr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"broadcastReceiveReg"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//【2】通过反射的方式，拉起 onReceive 方法！</span></span><br><span class="line">        ClassLoader cl =  mReceiver.getClass().getClassLoader();</span><br><span class="line">        intent.setExtrasClassLoader(cl);</span><br><span class="line">        intent.prepareToEnterProcess();</span><br><span class="line">        setExtrasClassLoader(cl);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【3】设置 PendingResult 属性</span></span><br><span class="line">        receiver.setPendingResult(<span class="keyword">this</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【4】拉起 onReceive 方法！</span></span><br><span class="line">        receiver.onReceive(mContext, intent);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mRegistered &amp;&amp; ordered) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG,</span><br><span class="line">                    <span class="string">"Finishing failed broadcast to "</span> + mReceiver);</span><br><span class="line">            <span class="comment">//【×3.3.2】这里出现了异常，如果是有序广播，需要通知系统！</span></span><br><span class="line">            <span class="comment">// 调用了 args 父类 PendingResult 的 sendFinished 方法！</span></span><br><span class="line">            sendFinished(mgr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mInstrumentation == <span class="keyword">null</span> ||</span><br><span class="line">                !mInstrumentation.onException(mReceiver, e)) &#123;</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Error receiving broadcast "</span> + intent</span><br><span class="line">                + <span class="string">" in "</span> + mReceiver, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【3】显然，这里不为 null，调用 finish 结束广播！</span></span><br><span class="line">    <span class="keyword">if</span> (receiver.getPendingResult() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//【×3.3.1】调用了父类的 finish 方法！</span></span><br><span class="line">        finish();</span><br><span class="line">    &#125;</span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>mForgotten</code> 属性是在 <code>unregisterReceiver</code> 的时候被置为 <code>true</code> 的，这里终于进入了 <code>BroadcastReceiver</code> 的 <code>onReceive</code> 方法！</p>
<h2 id="3-2-静态接收者进程"><a href="#3-2-静态接收者进程" class="headerlink" title="3.2 静态接收者进程"></a>3.2 静态接收者进程</h2><p>发送给静态注册的接收者也有 <code>2</code> 种广播，首先会进入 <code>ApplicationThreadN</code> 中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> SCHEDULE_RECEIVER_TRANSACTION:</span><br><span class="line">&#123;</span><br><span class="line">    data.enforceInterface(IApplicationThread.descriptor);</span><br><span class="line">    Intent intent = Intent.CREATOR.createFromParcel(data);</span><br><span class="line">    ActivityInfo info = ActivityInfo.CREATOR.createFromParcel(data);</span><br><span class="line">    CompatibilityInfo compatInfo = CompatibilityInfo.CREATOR.createFromParcel(data);</span><br><span class="line">    <span class="keyword">int</span> resultCode = data.readInt();</span><br><span class="line">    String resultData = data.readString();</span><br><span class="line">    Bundle resultExtras = data.readBundle();</span><br><span class="line">    <span class="keyword">boolean</span> sync = data.readInt() != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sendingUser = data.readInt();</span><br><span class="line">    <span class="keyword">int</span> processState = data.readInt();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【1】进入 ApplicationThread 的 scheduleReceiver 方法！</span></span><br><span class="line">    scheduleReceiver(intent, info, compatInfo, resultCode, resultData,</span><br><span class="line">            resultExtras, sync, sendingUser, processState);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-1-ApplicationThread-scheduleReceiver"><a href="#3-2-1-ApplicationThread-scheduleReceiver" class="headerlink" title="3.2.1 ApplicationThread.scheduleReceiver"></a>3.2.1 ApplicationThread.scheduleReceiver</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleReceiver</span><span class="params">(Intent intent, ActivityInfo info,</span></span></span><br><span class="line"><span class="function"><span class="params">        CompatibilityInfo compatInfo, <span class="keyword">int</span> resultCode, String data, Bundle extras,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> sync, <span class="keyword">int</span> sendingUser, <span class="keyword">int</span> processState)</span> </span>&#123;</span><br><span class="line">    updateProcessState(processState, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【×3.2.1.1】创建了一个 ReceiverData 对象！</span></span><br><span class="line">    <span class="comment">// mAppThread 是当前进程的 ApplicationThread 对象，是一个 Binder 对象！</span></span><br><span class="line">    ReceiverData r = <span class="keyword">new</span> ReceiverData(intent, resultCode, data, extras,</span><br><span class="line">            sync, <span class="keyword">false</span>, mAppThread.asBinder(), sendingUser);</span><br><span class="line">    r.info = info;</span><br><span class="line">    r.compatInfo = compatInfo;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【×3.2.2】发送 H.RECEIVER 给主线程！</span></span><br><span class="line">    sendMessage(H.RECEIVER, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里创建了一个 <code>ReceiverData</code> 对象，用来封装接收者的数据信息！</p>
<h4 id="3-2-1-1-new-ReceiverData"><a href="#3-2-1-1-new-ReceiverData" class="headerlink" title="3.2.1.1 new ReceiverData"></a>3.2.1.1 new ReceiverData</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiverData</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span>.<span class="title">PendingResult</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReceiverData</span><span class="params">(Intent intent, <span class="keyword">int</span> resultCode, String resultData, Bundle resultExtras,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> ordered, <span class="keyword">boolean</span> sticky, IBinder token, <span class="keyword">int</span> sendingUser)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这个地方，传入的是 TYPE_COMPONENT，即 mType 是 TYPE_COMPONENT！</span></span><br><span class="line">        <span class="keyword">super</span>(resultCode, resultData, resultExtras, TYPE_COMPONENT, ordered, sticky,</span><br><span class="line">                token, sendingUser, intent.getFlags());</span><br><span class="line">        <span class="keyword">this</span>.intent = intent;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 广播 Intent 对象！</span></span><br><span class="line">    Intent intent;</span><br><span class="line">    <span class="comment">// 接收者的信息 ActivityInfo 对象！</span></span><br><span class="line">    ActivityInfo info;</span><br><span class="line">    CompatibilityInfo compatInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ReceiverData</code> 继承了 <code>BroadcastReceiver.PendingResult</code> 对象，用来封装静态接收者的数据信息！</p>
<p>这里就和 Args 类似了！</p>
<h3 id="3-2-2-H-handleMessage"><a href="#3-2-2-H-handleMessage" class="headerlink" title="3.2.2 H.handleMessage"></a>3.2.2 H.handleMessage</h3><p>我们去看看主线程 Handler H 是如何处理 H.RECEIVER 消息的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">H</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_MESSAGES) Slog.v(TAG, <span class="string">"&gt;&gt;&gt; handling: "</span> + codeToString(msg.what));</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="keyword">case</span> RECEIVER:</span><br><span class="line">                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"broadcastReceiveComp"</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//【×3.2.3】调用 handleReceiver 处理广播！</span></span><br><span class="line">                handleReceiver((ReceiverData)msg.obj);</span><br><span class="line"></span><br><span class="line">                maybeSnapshot();</span><br><span class="line">                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-3-ActivityThread-handleReceiver"><a href="#3-2-3-ActivityThread-handleReceiver" class="headerlink" title="3.2.3 ActivityThread.handleReceiver"></a>3.2.3 ActivityThread.handleReceiver</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleReceiver</span><span class="params">(ReceiverData data)</span> </span>&#123;</span><br><span class="line">    unscheduleGcIdler();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】获得组件名，用于反射！</span></span><br><span class="line">    String component = data.intent.getComponent().getClassName();</span><br><span class="line"></span><br><span class="line">    LoadedApk packageInfo = getPackageInfoNoCheck(</span><br><span class="line">            data.info.applicationInfo, data.compatInfo);</span><br><span class="line"></span><br><span class="line">    IActivityManager mgr = ActivityManagerNative.getDefault();</span><br><span class="line"> </span><br><span class="line">    BroadcastReceiver receiver;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【2】通过反射获得 BroadcastReceiver 对象的实例！</span></span><br><span class="line">        java.lang.ClassLoader cl = packageInfo.getClassLoader();</span><br><span class="line">        data.intent.setExtrasClassLoader(cl);</span><br><span class="line">        data.intent.prepareToEnterProcess();</span><br><span class="line">        data.setExtrasClassLoader(cl);</span><br><span class="line">        receiver = (BroadcastReceiver)cl.loadClass(component).newInstance();</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.i(TAG,</span><br><span class="line">                <span class="string">"Finishing failed broadcast to "</span> + data.intent.getComponent());</span><br><span class="line">        data.sendFinished(mgr);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">            <span class="string">"Unable to instantiate receiver "</span> + component</span><br><span class="line">            + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//【3】获得 Application 的上下文运行环境！</span></span><br><span class="line">        Application app = packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (localLOGV) Slog.v(</span><br><span class="line">            TAG, <span class="string">"Performing receive of "</span> + data.intent</span><br><span class="line">            + <span class="string">": app="</span> + app</span><br><span class="line">            + <span class="string">", appName="</span> + app.getPackageName()</span><br><span class="line">            + <span class="string">", pkg="</span> + packageInfo.getPackageName()</span><br><span class="line">            + <span class="string">", comp="</span> + data.intent.getComponent().toShortString()</span><br><span class="line">            + <span class="string">", dir="</span> + packageInfo.getAppDir());</span><br><span class="line"></span><br><span class="line">        ContextImpl context = (ContextImpl)app.getBaseContext();</span><br><span class="line">        sCurrentBroadcastIntent.set(data.intent);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【4】设置接收者的 PendingResult 属性！</span></span><br><span class="line">        receiver.setPendingResult(data);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【5】拉起广播接收者的 onReceive 方法！！</span></span><br><span class="line">        receiver.onReceive(context.getReceiverRestrictedContext(),</span><br><span class="line">                data.intent);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.i(TAG,</span><br><span class="line">                <span class="string">"Finishing failed broadcast to "</span> + data.intent.getComponent());</span><br><span class="line">        <span class="comment">//【×3.3.2】异常情况直接返回！     </span></span><br><span class="line">        data.sendFinished(mgr);</span><br><span class="line">        <span class="keyword">if</span> (!mInstrumentation.onException(receiver, e)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Unable to start receiver "</span> + component</span><br><span class="line">                + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        sCurrentBroadcastIntent.set(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【6】调用 ReceiverData 的 finish 函数，通知 AMS 广播处理完成！</span></span><br><span class="line">    <span class="keyword">if</span> (receiver.getPendingResult() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//【×3.3.1】实际上调用了 PendingResult 的 finish 方法！</span></span><br><span class="line">        data.finish();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面，我们进入到 <code>ReceiverData</code> 中去！！</p>
<h2 id="3-3-PendingResult"><a href="#3-3-PendingResult" class="headerlink" title="3.3 PendingResult"></a>3.3 PendingResult</h2><h3 id="3-3-1-PendingResult-finish"><a href="#3-3-1-PendingResult-finish" class="headerlink" title="3.3.1 PendingResult.finish"></a>3.3.1 PendingResult.finish</h3><p>接着，调用 <code>PendingResult .finish</code> 结束广播的分发，通知系统继续广播的分发！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果 mType 为 TYPE_COMPONENT，静态接收者，进入 IF 分支！</span></span><br><span class="line">    <span class="keyword">if</span> (mType == TYPE_COMPONENT) &#123;</span><br><span class="line">        <span class="keyword">final</span> IActivityManager mgr = ActivityManagerNative.getDefault();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 若主线程的 QueuedWork 中有事情还未处理完，则必须让事情做完后，才通知 AMS 结果！</span></span><br><span class="line">        <span class="keyword">if</span> (QueuedWork.hasPendingWork()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建一个任务，通过 singleThreadExecutor 单线程依次执行！</span></span><br><span class="line">            QueuedWork.singleThreadExecutor().execute( <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG,</span><br><span class="line">                            <span class="string">"Finishing broadcast after work to component "</span> + mToken);</span><br><span class="line">                    sendFinished(mgr);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG,</span><br><span class="line">                    <span class="string">"Finishing broadcast to component "</span> + mToken);</span><br><span class="line">                    </span><br><span class="line">                    </span><br><span class="line">            <span class="comment">//【×3.3.2】如果主线程无等待处理的事件，直接通知 AMS 结果！</span></span><br><span class="line">            sendFinished(mgr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mOrderedHint &amp;&amp; mType != TYPE_UNREGISTERED) &#123;</span><br><span class="line">        <span class="comment">//【1】如果 mType 为 TYPE_REGISTERED : TYPE_UNREGISTERED，动态接收者，</span></span><br><span class="line">        <span class="comment">// 所以会进入 ELSE IF， mOrderedHint 为 true，表示为有序广播，此时我们需要通知系统！！</span></span><br><span class="line">        <span class="keyword">if</span> (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG,</span><br><span class="line">                <span class="string">"Finishing broadcast to "</span> + mToken);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> IActivityManager mgr = ActivityManagerNative.getDefault();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【×3.3.2】发送结果！</span></span><br><span class="line">        sendFinished(mgr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>mOrderedHint</code> 是创建 <code>Args</code> 时赋值初始化的，他是父类 <code>PendingResult</code> 的成员变量，表示该广播是否是有序的！</p>
<h3 id="3-3-2-PendingResult-sendFinished"><a href="#3-3-2-PendingResult-sendFinished" class="headerlink" title="3.3.2 PendingResult.sendFinished"></a>3.3.2 PendingResult.sendFinished</h3><p>无论是 <code>Args</code>，还是 <code>ReceiverData</code> 他们都继承了 <code>PendingResult</code> 类，<code>sendFinished</code> 的实现是在 <code>PendingResult</code> 类中！</p>
<p>通过上面的方法可以看到，静态接收者由于都是有序分发，所以都要回调通知；但是动态接收者，只有广播是有序广播，才会回调通知系统，普通广播是不需要回调系统的！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendFinished</span><span class="params">(IActivityManager am)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">//【1】判断是否已经 finish 过，会抛出异常！</span></span><br><span class="line">        <span class="keyword">if</span> (mFinished) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Broadcast already finished"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mFinished = <span class="keyword">true</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mResultExtras != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mResultExtras.setAllowFds(<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//【1】有序发送的广播，mOrderedHint 为 true，进入该分支！</span></span><br><span class="line">            <span class="comment">// mAbortBroadcast 表示是否终止该广播的继续分发！</span></span><br><span class="line">            <span class="comment">// mOrderedHint 表示该广播是否是有序发送的！</span></span><br><span class="line">            <span class="keyword">if</span> (mOrderedHint) &#123;</span><br><span class="line">                am.finishReceiver(mToken, mResultCode, mResultData, mResultExtras,</span><br><span class="line">                        mAbortBroadcast, mFlags);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 普通广播但是是发送给静态接收者的，也会回调系统！</span></span><br><span class="line">                am.finishReceiver(mToken, <span class="number">0</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>, mFlags);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 <code>mToken</code> 要注意一下：</p>
<ul>
<li>如果是动态注册的接收者，<code>mToken</code> 是 <code>InnerReceiver</code> 对象；</li>
<li>如果是静态注册的接收者，<code>mToken</code> 是 <code>ApplicationThread</code> 对象；</li>
</ul>
<p>这里的 <code>mAbortBroadcast</code> 表示是否终止该广播的继续分发，对于有序发送的广播来说，当一个接收者接收到了该广播，可以通过以下方式来设置是否终止该广播的继续传递：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">abortBroadcast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    checkSynchronousHint();</span><br><span class="line">    mPendingResult.mAbortBroadcast = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以及：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final void clearAbortBroadcast() &#123;</span><br><span class="line">    if (mPendingResult != null) &#123;</span><br><span class="line">        mPendingResult.mAbortBroadcast = false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面就会进入系统进程！</p>
<h1 id="4-系统进程"><a href="#4-系统进程" class="headerlink" title="4 系统进程"></a>4 系统进程</h1><p>通过前面的分析，我们知道以下 2 种广播是通过有序的方式发送的：</p>
<ul>
<li>目标是静态接收者的普通广播；</li>
<li>有序广播；</li>
</ul>
<p>下面我们来看看有序发送的广播的后事处理：</p>
<h2 id="4-1-ActivityManagerS-finishReceiver"><a href="#4-1-ActivityManagerS-finishReceiver" class="headerlink" title="4.1 ActivityManagerS.finishReceiver"></a>4.1 ActivityManagerS.finishReceiver</h2><p>参数 IBinder who 表示的是句柄，代表我们广播的目标客户端！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finishReceiver</span><span class="params">(IBinder who, <span class="keyword">int</span> resultCode, String resultData,</span></span></span><br><span class="line"><span class="function"><span class="params">        Bundle resultExtras, <span class="keyword">boolean</span> resultAbort, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, <span class="string">"Finish receiver: "</span> + who);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】不能传递文件描述符！</span></span><br><span class="line">    <span class="keyword">if</span> (resultExtras != <span class="keyword">null</span> &amp;&amp; resultExtras.hasFileDescriptors()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"File descriptors passed in Bundle"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> doNext = <span class="keyword">false</span>;</span><br><span class="line">        BroadcastRecord r;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">//【2】根据广播的 Intent 是否设置了 FLAG_RECEIVER_FOREGROUND 标志位，选择前台/后台队列！</span></span><br><span class="line">            BroadcastQueue queue = (flags &amp; Intent.FLAG_RECEIVER_FOREGROUND) != <span class="number">0</span></span><br><span class="line">                    ? mFgBroadcastQueue : mBgBroadcastQueue;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//【×4.1.1】接着是在 mOrderedBroadcasts 匹配到 who 对应的广播，也就是我们这次分发的广播！</span></span><br><span class="line">            r = queue.getMatchingOrderedReceiver(who);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//【×4.1.2】判断是否需要继续分发该广播！</span></span><br><span class="line">                doNext = r.queue.finishReceiverLocked(r, resultCode,</span><br><span class="line">                    resultData, resultExtras, resultAbort, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【3】如果 doNext 为 true，继续下一次分发！</span></span><br><span class="line">        <span class="keyword">if</span> (doNext) &#123;</span><br><span class="line">            r.queue.processNextBroadcast(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 回收资源！</span></span><br><span class="line">        trimApplications();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>流程很简单，不多说了！</p>
<h3 id="4-1-1-BroadcastQueue-getMatchingOrderedReceiver"><a href="#4-1-1-BroadcastQueue-getMatchingOrderedReceiver" class="headerlink" title="4.1.1 BroadcastQueue.getMatchingOrderedReceiver"></a>4.1.1 BroadcastQueue.getMatchingOrderedReceiver</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BroadcastRecord <span class="title">getMatchingOrderedReceiver</span><span class="params">(IBinder receiver)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mOrderedBroadcasts.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> BroadcastRecord r = mOrderedBroadcasts.get(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//【1】匹配接收者处理的广播，并返回！</span></span><br><span class="line">        <span class="keyword">if</span> (r != <span class="keyword">null</span> &amp;&amp; r.receiver == receiver) &#123;</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>getMatchingOrderedReceiver</code> 逻辑很简单，这里就不多说了！</p>
<h3 id="4-1-2-BroadcastQueue-finishReceiverLocked"><a href="#4-1-2-BroadcastQueue-finishReceiverLocked" class="headerlink" title="4.1.2 BroadcastQueue.finishReceiverLocked"></a>4.1.2 BroadcastQueue.finishReceiverLocked</h3><p>接下来看看 finishReceiverLocked 方法做了什么！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">finishReceiverLocked</span><span class="params">(BroadcastRecord r, <span class="keyword">int</span> resultCode,</span></span></span><br><span class="line"><span class="function"><span class="params">        String resultData, Bundle resultExtras, <span class="keyword">boolean</span> resultAbort, <span class="keyword">boolean</span> waitForServices)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】保存之前的状态！</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> state = r.state;</span><br><span class="line">    <span class="keyword">final</span> ActivityInfo receiver = r.curReceiver;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【2】初始化广播的一些变量！</span></span><br><span class="line">    r.state = BroadcastRecord.IDLE;</span><br><span class="line">    <span class="keyword">if</span> (state == BroadcastRecord.IDLE) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"finishReceiver ["</span> + mQueueName + <span class="string">"] called but state is IDLE"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【3】将 r.receiver 置为 null，因为该接收者已经处理完了广播！</span></span><br><span class="line">    r.receiver = <span class="keyword">null</span>;</span><br><span class="line">    r.intent.setComponent(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.curApp != <span class="keyword">null</span> &amp;&amp; r.curApp.curReceiver == r) &#123;</span><br><span class="line">        r.curApp.curReceiver = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r.curFilter != <span class="keyword">null</span>) &#123;</span><br><span class="line">        r.curFilter.receiverList.curBroadcast = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    r.curFilter = <span class="keyword">null</span>;</span><br><span class="line">    r.curReceiver = <span class="keyword">null</span>;</span><br><span class="line">    r.curApp = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【4】将 mPendingBroadcast 置为 null;</span></span><br><span class="line">    mPendingBroadcast = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    r.resultCode = resultCode;</span><br><span class="line">    r.resultData = resultData;</span><br><span class="line">    r.resultExtras = resultExtras;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【5】判断是否需要终止该广播的继续分发！</span></span><br><span class="line">    <span class="comment">// 当 resultAbort 为 true，且广播没有设置 Intent.FLAG_RECEIVER_NO_ABORT 标志位，</span></span><br><span class="line">    <span class="comment">// 那么该广播就会终止继续传递！</span></span><br><span class="line">    <span class="keyword">if</span> (resultAbort &amp;&amp; (r.intent.getFlags()&amp;Intent.FLAG_RECEIVER_NO_ABORT) == <span class="number">0</span>) &#123;</span><br><span class="line">        r.resultAbort = resultAbort;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        r.resultAbort = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【6】这里的 waitForServices 传入的是 true，对于后台队列来说 mDelayBehindServices 为 true！</span></span><br><span class="line">    <span class="keyword">if</span> (waitForServices &amp;&amp; r.curComponent != <span class="keyword">null</span> &amp;&amp; r.queue.mDelayBehindServices</span><br><span class="line">            &amp;&amp; r.queue.mOrderedBroadcasts.size() &gt; <span class="number">0</span></span><br><span class="line">            &amp;&amp; r.queue.mOrderedBroadcasts.get(<span class="number">0</span>) == r) &#123;</span><br><span class="line"></span><br><span class="line">        ActivityInfo nextReceiver;</span><br><span class="line">        <span class="keyword">if</span> (r.nextReceiver &lt; r.receivers.size()) &#123;</span><br><span class="line">            <span class="comment">//【6.1】计算下一个接收者！</span></span><br><span class="line">            Object obj = r.receivers.get(r.nextReceiver);</span><br><span class="line">            nextReceiver = (obj <span class="keyword">instanceof</span> ActivityInfo) ? (ActivityInfo)obj : <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nextReceiver = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果本次接受广播的接收者和下一个接收者不在同一个进程，或者下一个接收者为 null</span></span><br><span class="line">        <span class="keyword">if</span> (receiver == <span class="keyword">null</span> || nextReceiver == <span class="keyword">null</span></span><br><span class="line">                || receiver.applicationInfo.uid != nextReceiver.applicationInfo.uid</span><br><span class="line">                || !receiver.processName.equals(nextReceiver.processName)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对于后台队列中的有序发送的广播，如果广播的目标设别用户下有需要后台延迟启动的服务</span></span><br><span class="line">            <span class="comment">// 那就不能继续分发，这里会将广播的状态改为 BroadcastRecord.WAITING_SERVICES，返回 false！</span></span><br><span class="line">            <span class="keyword">if</span> (mService.mServices.hasBackgroundServices(r.userId)) &#123;</span><br><span class="line">                Slog.i(TAG, <span class="string">"Delay finish: "</span> + r.curComponent.flattenToShortString());。。。。</span><br><span class="line">                r.state = BroadcastRecord.WAITING_SERVICES;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r.curComponent = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【7】前面我们知道，由于发送广播是异步操作，所以正常情况发送前，状态就改为了下面的状态；</span></span><br><span class="line">    <span class="comment">// 这是返回的是 true，那么 doNext 就是 true；如果需要等待 Service 启动，那么状态就为 WAITING_SERVICES；</span></span><br><span class="line">    <span class="comment">// 此时 doNext 就为 false；</span></span><br><span class="line">    <span class="keyword">return</span> state == BroadcastRecord.APP_RECEIVE</span><br><span class="line">            || state == BroadcastRecord.CALL_DONE_RECEIVE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于静态注册的接收者 r.state 被置为 BroadcastRecord.APP_RECEIVE；<br>对于动态注册的接收者 r.state 被置为 BroadcastRecord.CALL_DONE_RECEIVE；</p>
<p>这里的 <code>r.queue.mDelayBehindServices</code> 要解释一下，他是在创建前台和后台队列时初始化的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mFgBroadcastQueue = <span class="keyword">new</span> BroadcastQueue(<span class="keyword">this</span>, mHandler, <span class="string">"foreground"</span>, BROADCAST_FG_TIMEOUT, <span class="keyword">false</span>);</span><br><span class="line">mBgBroadcastQueue = <span class="keyword">new</span> BroadcastQueue(<span class="keyword">this</span>, mHandler, <span class="string">"background"</span>, BROADCAST_BG_TIMEOUT, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure></p>
<p>可以看到，对于后台队列，其 mDelayBehindServices 为 true！表示如果有后台延迟启动的服务，就延迟广播的发送！</p>
<p>那么我们如何判断目标设备用户下是否有后台延迟发送的广播，这就要调用 ActiveServices 的 hasBackgroundServices 方法了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasBackgroundServices</span><span class="params">(<span class="keyword">int</span> callingUser)</span> </span>&#123;</span><br><span class="line">    ServiceMap smap = mServiceMap.get(callingUser);</span><br><span class="line">    <span class="keyword">return</span> smap != <span class="keyword">null</span> ? smap.mStartingBackground.size() &gt;= mMaxStartingBackground : <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>和 <code>Service</code> 的生命周期相关的内容，请去看其他的博客！</p>
<p>最后又再次回到了 <code>processNextBroadcast</code> 方法中了！</p>
<h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h1><p>到这里，<code>sendBroadcast</code> 方法的流程就分析完了，下面我们来总结一下：</p>
<h2 id="5-1-广播的处理流程"><a href="#5-1-广播的处理流程" class="headerlink" title="5.1 广播的处理流程"></a>5.1 广播的处理流程</h2><p>在发送广播之前，都需要收集其目标接收者，包括静态接收者和动态接收者！</p>
<p>如果广播设置了 <code>Intent.FLAG_RECEIVER_FOREGROUND</code> 标志位，会被添加到前台队列 <code>mFgBroadcastQueue</code> 中，否则就被添加到后台队列 <code>mBgBroadcastQueue</code> 中！</p>
<p>如果广播设置了 <code>Intent.FLAG_RECEIVER_NO_ABORT</code> 标志位，有序发送的情况下不能被强制中断分发！</p>
<h3 id="5-1-1-普通广播的处理流程"><a href="#5-1-1-普通广播的处理流程" class="headerlink" title="5.1.1 普通广播的处理流程"></a>5.1.1 普通广播的处理流程</h3><ul>
<li><strong>1</strong> 先发送给<strong>动态接收者</strong>，并行分发，广播会被加入到 <code>mParallelBroadcasts</code> 集合中，通过一个 <code>while</code> 循环，不断遍历 <code>mParallelBroadcasts</code>，直到为空 。<ul>
<li><strong>1.1</strong> 设置广播开始分发时间：<code>r.dispatchTime = SystemClock.uptimeMillis();</code> 和 <code>r.dispatchClockTime = System.currentTimeMillis();</code></li>
<li><strong>1.2</strong> 设置当前接收者的分发状态：<code>r.delivery[index] = BroadcastRecord.DELIVERY_DELIVERED</code></li>
<li><strong>1.3</strong> 对于动态接收者来说，系统进程保存着其 <code>IIntentReceiver.Proxy</code> 对象！</li>
<li><strong>1.4</strong> 通过 <code>app.thread.scheduleRegisteredReceiver</code>，进入应用进程，调用 <code>InnerReceiver.performReceive</code> 拉起广播接收者的 <code>onReceive</code> 方法！如果 <code>app = null</code>，就直接通过 <code>IIntentReceiver.Proxy.performReceive</code>，进入应用进程！<pre><code>- **1.4.1** 这时会创建一个 `Args` 对象（继承了 `BroadcastReceiver.PendingResult` 实现了 `Runnable`），通过主线程执行 `Args.run` 方法！
- **1.4.2** `PendingResult` 有一个内部成员变量 `mType`，用来保存接收者的类型，对于动态接收者：`mType = TYPE_REGISTERED/TYPE_UNREGISTERED`！
- **1.4.3** 最后通过反射，拉起 `onReceive` 方法！
</code></pre></li>
</ul>
</li>
</ul>
<p><br>    </p>
<ul>
<li><p><strong>2</strong> 然后发送给<strong>静态接收者</strong>，广播会被加入到 <code>mOrderedBroadcasts</code> 集合中，有序发送！</p>
<ul>
<li><strong>2.1</strong> 如果已经有一个正在等待目标进程启动的广播 <code>mPendingBroadcast</code>，那就等待对应进程启动后处理！</li>
<li><strong>2.2</strong> 否则，计算本次该广播要分发的接收者的序号：<code>recIdx</code>，和下一个接收者的序号：<code>r.nextReceiver</code>，二者满足：<code>int recIdx = r.nextReceiver++</code></li>
<li><p><strong>2.3</strong> 设置广播开始分发时间（当 <code>recIdx</code> 为第一个接收者的时候）<code>r.dispatchTime = r.receiverTime;　r.dispatchClockTime = System.currentTimeMillis();</code></p>
<ul>
<li>设置当前接收者的分发状态：<code>r.delivery[recIdx] = BroadcastRecord.DELIVERY_DELIVERED;</code></li>
<li>设置广播的当前状态：<code>r.state = BroadcastRecord.APP_RECEIVE;</code></li>
<li>设置广播当前的目标组件：<code>r.curComponent = component;</code></li>
<li>设置广播当前的目标接收者：<code>r.curReceiver = info.activityInfo;</code></li>
</ul>
</li>
<li><p><strong>2.4</strong> 对于静态接收者，发送广播时候，其进程未必启动，所以要分情况处理：</p>
<pre><code>- **2.4.1** 如果进程未启动，就先启动其进程，并将广播添加到 `mPendingBroadcast` 中，等待进程启动后处理！
     进程启动后，会判断当前进程是否有 `mPendingBroadcast`，有的话，就将 `mPendingBroadcast` 发送目标接收者（2.4.2），并设置 `mPendingBroadcast = null;`！

  &lt;/br&gt;

- **2.4.2** 如果进程已启动，那就直接发送广播！
     - 设置广播的目标接收者通信对象：`r.receiver = app.thread.asBinder();`，即目标进程的 `ApplicationThreadProxy` 对象！
     - 设置广播的目标进程：`r.curApp = app;`
     - 设置目标进程的当前要接收广播的接收者：`app.curReceiver = r;`
     - 设置广播的组件信息；`r.intent.setComponent(r.curComponent);`

     - 通过 `app.thread.scheduleReceiver`，跨进程拉起接收者的 `onReceive` 方法！
         - 进入应用进程后，会创建一个 `ReceiverData` 对象（其继承了 `BroadcastReceiver.PendingResult`）
         - `PendingResult` 有一个内部成员变量 `mType`，用来保存接收者的类型，对于静态接收者：`mType =  TYPE_COMPONENT`！
         - 最后通过反射，拉起 `onReceive` 方法！
</code></pre></li>
<li><p><strong>2.5</strong> 最后，调用 <code>ActivityManagerService.finishReceiver</code>，通知系统进程，接收者完成了广播处理，继续分发!！</p>
<ul>
<li><p>初始化广播的状态：<code>r.state = BroadcastRecord.IDLE;</code></p>
<ul>
<li>清空广播的目标接收者：<code>Binder</code> 对象：<code>r.receiver = null;</code></li>
<li>清空广播组件信息：<code>r.intent.setComponent(null);</code></li>
<li>清空广播目标进程的当前接收者：<code>r.curApp.curReceiver = null;</code></li>
<li><p>清空广播过滤器的当前广播：<code>r.curFilter.receiverList.curBroadcast = null;</code></p>
</li>
<li><p>清空广播的过滤器：<code>r.curFilter = null;</code></p>
</li>
<li>清空广播接收者信息：<code>r.curReceiver = null;</code></li>
<li>清空广播的目标进程：<code>r.curApp = null;</code></li>
<li>清空广播的组件信息：<code>r.curComponent = null;</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="5-1-2-有序广播的处理流程"><a href="#5-1-2-有序广播的处理流程" class="headerlink" title="5.1.2 有序广播的处理流程"></a>5.1.2 有序广播的处理流程</h3><p>对于有序广播来说，会将收集到的静态接收者和动态接收者通过优先级的不同合并到同一个集合中去，然后将该集合添加到指定队列的 <code>mOrderedBroadcasts</code> 集合中！</p>
<ul>
<li><strong>1</strong> 如果已经有一个正在等待目标进程启动的广播 <code>mPendingBroadcast</code>，那就等待对应进程启动后处理，此时不能继续有序发送！</li>
</ul>
<p><br></p>
<ul>
<li><strong>2</strong> 从 <code>mOrderedBroadcasts</code> 中移除不需要发送的广播，比如：没有接收者，或者所有接收者都已接收了该广播或者被终止继续传递，或者超时了，找到下一个需要分发的广播 r！</li>
</ul>
<p><br></p>
<ul>
<li><strong>3</strong> 准备工作：<ul>
<li>计算本次该广播的目标接收者的序号：<code>recIdx</code>，和下一个接收者的序号：<code>r.nextReceiver</code>，二者满足：<code>int recIdx = r.nextReceiver++</code>；</li>
<li>初始化该广播的接收时间： <code>r.receiverTime = SystemClock.uptimeMillis();</code>，根据该事件设置超时任务！</li>
<li>设置广播开始分发时间： <code>r.dispatchTime = r.receiverTime;　r.dispatchClockTime = System.currentTimeMillis();</code>（当 <code>recIdx</code> 为第一个接收者的时候）</li>
</ul>
</li>
</ul>
<p><br></p>
<ul>
<li><p><strong>4</strong> 从广播的接收者列表中找到 <code>recIdx</code> 对应的目标接收者，接下来就是分发广播了：</p>
<ul>
<li><p><strong>4.1</strong> 如果是<strong>动态注册的接收者</strong>，<code>deliverToRegisteredReceiverLocked</code>！</p>
<ul>
<li><strong>4.1.1</strong> 设置目标接收者的分发状态： <code>r.delivery[index] = BroadcastRecord.DELIVERY_DELIVERED</code></li>
<li><p><strong>4.1.2</strong> 设置广播的属性：</p>
<ul>
<li>设置广播接收者对应的 <code>Binder</code> 通信对象：<code>r.receiver = filter.receiverList.receiver.asBinder();</code>，即 <code>IIntentReceiver.Proxy</code> 对象！</li>
<li>设置广播的过滤器对象： <code>r.curFilter = filter;</code></li>
<li>设置过滤器处理的广播：  <code>filter.receiverList.curBroadcast = r;</code></li>
<li>设置广播的状态： <code>r.state = BroadcastRecord.CALL_IN_RECEIVE;</code></li>
<li>设置广播的目标进程：  <code>r.curApp = filter.receiverList.app;</code></li>
<li><p>设置目标进程当前处理的广播：  <code>filter.receiverList.app.curReceiver = r;</code></p>
<ul>
<li><strong>4.1.3</strong> 立刻设置广播的状态：<code>r.state = BroadcastRecord.CALL_DONE_RECEIVE;</code> 表示接收完毕！</li>
<li><strong>4.1.4</strong> 发送广播！</li>
<li><strong>4.1.4.1</strong> 通过 <code>app.thread.scheduleRegisteredReceiver</code>，进入应用进程，调用 <code>InnerReceiver.performReceive</code> 拉起广播接收者的 <code>onReceive</code> 方法！如果 <code>app = null</code>，就直接通过 <code>IIntentReceiver.Proxy.performReceive</code>，进入应用进程！</li>
<li><p><strong>4.1.4.2</strong> 调用 <code>ReceiverDispatcher.performReceive</code> 方法，处理广播！      </p>
<ul>
<li>这时会创建一个 <code>Args</code> 对象（继承了 <code>BroadcastReceiver.PendingResult</code> 实现了 <code>Runnable</code>），通过主线程执行 <code>Args.run</code> 方法！</li>
<li><code>PendingResult</code> 有一个内部成员变量 <code>mType</code>，用来保存接收者的类型，对于动态接收者：<code>mType = TYPE_REGISTERED/TYPE_UNREGISTERED</code>！</li>
<li>最后通过反射，拉起 <code>onReceive</code> 方法！</li>
<li><p>调用 <code>ActivityManagerService.finishReceiver</code>，通知系统进程，接收者完成了广播处理，继续分发！</p>
<ul>
<li>初始化广播的状态：<code>r.state = BroadcastRecord.IDLE;</code></li>
<li>清空广播的目标接收者：Binder 对象：<code>r.receiver = null;</code></li>
<li>清空广播组件信息：<code>r.intent.setComponent(null);</code><ul>
<li>清空广播目标进程的当前接收者：<code>r.curApp.curReceiver = null;</code></li>
</ul>
</li>
<li><p>清空广播过滤器的当前广播：<code>r.curFilter.receiverList.curBroadcast = null;</code></p>
</li>
<li><p>清空广播的过滤器：<code>r.curFilter = null;</code></p>
</li>
<li>清空广播接收者信息：<code>r.curReceiver = null;</code></li>
<li>清空广播的目标进程：<code>r.curApp = null;</code></li>
<li>清空广播的组件信息：<code>r.curComponent = null;</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>- **4.2** 如果是**静态注册的接收者**，`deliverToRegisteredReceiverLocked`！
    - **4.1.1** 设置目标接收者的分发状态：  `r.delivery[index] = BroadcastRecord.DELIVERY_DELIVERED`
    - **4.1.2** 设置广播的属性：
         - 设置广播的状态：`r.state = BroadcastRecord.APP_RECEIVE;`
         - 设置广播的目标组件信息：`r.curComponent = component;`
         - 设置广播的目标接收者信息：`r.curReceiver = info.activityInfo;`

    - **4.1.3** 根据静态接收者的进程状态来做不同处理：
        - **4.1.3.1** 如果进程未启动，就先启动其进程，并将广播添加到 `mPendingBroadcast` 中，等待进程启动后处理！进程启动后，会判断当前进程是否有 `mPendingBroadcast`，有的话，就将 `mPendingBroadcast` 发送目标接收者（4.1.3.2），并设置 `mPendingBroadcast = null;`！

        - **4.1.3.2** 如果进程已启动，那就直接发送广播！
         - 设置广播的目标接收者通信对象：`r.receiver = app.thread.asBinder();`，即目标进程的 `ApplicationThreadProxy` 对象！
         - 设置广播的目标进程：`r.curApp = app;`
         - 设置目标进程的当前要接收广播的接收者：`app.curReceiver = r;`
         - 设置广播的组件信息；`r.intent.setComponent(r.curComponent);`

         - 通过 `app.thread.scheduleReceiver`，跨进程拉起接收者的 `onReceive` 方法！
         - 进入应用进程后，会创建一个 `ReceiverData` 对象（其继承了 `BroadcastReceiver.PendingResult`）
         - `PendingResult` 有一个内部成员变量 `mType`，用来保存接收者的类型，对于静态接收者：`mType =  TYPE_COMPONENT`！
         - 最后通过反射，拉起 `onReceive` 方法！

         - 调用 `ActivityManagerService.finishReceiver`，通知系统进程，接收者完成了广播处理，继续广播分发！
                - 初始化广播的状态：`r.state = BroadcastRecord.IDLE;`
                - 清空广播的目标接收者：`Binder` 对象：`r.receiver = null;`
                - 清空广播组件信息：`r.intent.setComponent(null);`
                - 清空广播目标进程的当前接收者：`r.curApp.curReceiver = null;`
                - 清空广播过滤器的当前广播：`r.curFilter.receiverList.curBroadcast = null;`

                - 清空广播的过滤器：`r.curFilter = null;`
                - 清空广播接收者信息：`r.curReceiver = null;`
                - 清空广播的目标进程：`r.curApp = null;`
                - 清空广播的组件信息：`r.curComponent = null;`
</code></pre><h3 id="5-1-3-粘性广播的处理流程"><a href="#5-1-3-粘性广播的处理流程" class="headerlink" title="5.1.3 粘性广播的处理流程"></a>5.1.3 粘性广播的处理流程</h3><p>粘性是一个附加的属性，和有序，普通不冲突，普通广播和有序广播都可以是粘性的，粘性广播的一个特性是，系统会将该粘性广播保存下来，以便分发给以后注册的接收者！</p>
<p>保存的集合为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> SparseArray&lt;ArrayMap&lt;String, ArrayList&lt;Intent&gt;&gt;&gt; mStickyBroadcasts =</span><br><span class="line">        <span class="keyword">new</span> SparseArray&lt;ArrayMap&lt;String, ArrayList&lt;Intent&gt;&gt;&gt;();</span><br></pre></td></tr></table></figure>
<p>除去这个特性之外，粘性广播的处理方式和普通广播、有序广播是一样的，这里就不多说了！</p>
<ul>
<li>如果要发送粘性广播，应用必须配置 android.Manifest.permission.BROADCAST_STICKY 权限！</li>
<li>对于粘性广播，不能强制广播接收者应该具有某些权限！</li>
<li>对于粘性广播，如果有相同的全局粘性广播，会产生冲突，抛出异常！</li>
<li>Android 7.1.1 上已经不推荐使用粘性广播了，因为会产生安全问题！</li>
</ul>
<h2 id="5-2-广播的状态周期"><a href="#5-2-广播的状态周期" class="headerlink" title="5.2 广播的状态周期"></a>5.2 广播的状态周期</h2><p>对于广播来说，会有如下的几种状态：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> IDLE = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> APP_RECEIVE = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CALL_IN_RECEIVE = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CALL_DONE_RECEIVE = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WAITING_SERVICES = <span class="number">4</span>;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>普通广播：</li>
</ul>
<p>如果是静态注册的接收者：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BroadcastReocrd.IDLE -&gt; BroadcastReocrd.IDLE.APP_RECEIVE -&gt; BroadcastReocrd.CALL_DONE_RECEIVE -&gt;（BroadcastReocrd.WAITING_SERVICES）-&gt; BroadcastReocrd.IDLE</span><br></pre></td></tr></table></figure></p>
<p>如果是动态注册的接收者：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BroadcastReocrd.IDLE</span><br></pre></td></tr></table></figure></p>
<ul>
<li>有序广播：</li>
</ul>
<p>如果是静态注册的接收者：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BroadcastReocrd.IDLE -&gt; BroadcastReocrd.APP_RECEIVE -&gt; BroadcastReocrd.CALL_DONE_RECEIVE -&gt;（BroadcastReocrd.WAITING_SERVICES）-&gt; BroadcastReocrd.IDLE</span><br></pre></td></tr></table></figure></p>
<p>如果是动态注册的接收者：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BroadcastReocrd.IDLE -&gt; BroadcastReocrd.CALL_IN_RECEIVE -&gt; BroadcastReocrd.CALL_DONE_RECEIVE -&gt;（BroadcastReocrd.WAITING_SERVICES）-&gt; BroadcastReocrd.IDLE</span><br></pre></td></tr></table></figure></p>
<p>这里的 <code>BroadcastReocrd.WAITING_SERVICES</code> 只会对后台队列中有序发送的广播有效，因为这些广播可能在等待一些后台服务的启动！</p>
<p>当后台服务启动后，<code>ActiveServices</code> 会通过 <code>rescheduleDelayedStarts</code> 方法拉起这些服务！这里不多说了！</p>
<h2 id="5-3-接收者的分发状态"><a href="#5-3-接收者的分发状态" class="headerlink" title="5.3 接收者的分发状态"></a>5.3 接收者的分发状态</h2><p>对于接收者来说，下面这些状态用来表示广播的分发状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DELIVERY_PENDING = <span class="number">0</span>; <span class="comment">// 没有用到！</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DELIVERY_DELIVERED = <span class="number">1</span>; <span class="comment">// 广播已经分发给该广播接收者</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DELIVERY_SKIPPED = <span class="number">2</span>; <span class="comment">// 广播跳过了该广播接收者</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DELIVERY_TIMEOUT = <span class="number">3</span>; <span class="comment">// 广播超时了</span></span><br></pre></td></tr></table></figure>
<p>关于广播的超时，我们会单独一篇博文中介绍！</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2016/05/08/BroadcastReceiver篇 4 - BroadcastReceiver 静态注册/">BroadcastReceiver篇 4 - BroadcastReceiver 静态注册</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2016-05-08</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/AndroidFramework源码分析/">AndroidFramework源码分析</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/AndroidFramework源码分析/BroadcastReceiver广播接收者/">BroadcastReceiver广播接收者</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/BroadcastReceiver广播接收者/">BroadcastReceiver广播接收者</a></span><div class="content"><p>[toc]</p>
<p>本文基于 Android 7.1.1 源码，分析 BroadcastReceiver 的静态注册过程，转载请说明出处，谢谢！</p>
<h1 id="0-综述"><a href="#0-综述" class="headerlink" title="0 综述"></a>0 综述</h1><p>广播接收者除了动态注册之外，还有静态注册，就是在 AndroidManifest.xml 文件中进行配置！</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;receiver </span><br><span class="line">    android:enabled=[<span class="string">"true"</span> | <span class="string">"false"</span>]</span><br><span class="line">    android:exported=[<span class="string">"true"</span> | <span class="string">"false"</span>]</span><br><span class="line">    android:icon=<span class="string">"drawable resource"</span></span><br><span class="line">    android:label=<span class="string">"string resource"</span></span><br><span class="line">    android:name=<span class="string">"string"</span></span><br><span class="line">    android:permission=<span class="string">"string"</span></span><br><span class="line">    android:process=<span class="string">"string"</span> &gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name=<span class="string">"android.intent.action.BOOT_COMPLETED"</span> /&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/receiver&gt;</span><br></pre></td></tr></table></figure>
<p>我们来简单地看看这些属性的意思： </p>
<ul>
<li>android:enabled：此 broadcastReceiver 是否可用，默认值为 true。</li>
<li>android:exported：此 broadcastReceiver 能否接收其它 App 的发出的广播，如果标签中定义了 intent-filter 字段，则此值默认值为 true，否则为 false。</li>
<li>android:name：此 BroadcastReceiver 的组件名。</li>
<li>android:permission：广播发送方应该具有的权限； </li>
<li>android:process：表示 broadcastReceiver 运行的进程，BroadcastReceiver 默认运行在当前 app 的进程中，也可以通过此字段指定其运行于其它独立的进程。</li>
<li>intent-filter：用于指定该broadcastReceiver接收广播的类型。</li>
</ul>
<p>静态注册的 BroadcastReceiver 不能作为内部类，必须要单独作为一个 BroadcastReceiver.java 文件！</p>
<p>其实，如果大家对于 PMS 熟悉的话，应该很清楚了，对于静态注册的方式，是会通过 PMS 的解析来获得 BroadcastReceiver 的信息的！！下面我们就到 PMS 中去看看：</p>
<h1 id="1-PackageParser-parseBaseApplication-解析-application"><a href="#1-PackageParser-parseBaseApplication-解析-application" class="headerlink" title="1 PackageParser.parseBaseApplication - 解析 application"></a>1 PackageParser.parseBaseApplication - 解析 application</h1><p>解析的关键的代码段如下，我们简单的回顾下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">parseBaseApplication</span><span class="params">(Package owner, Resources res,</span></span></span><br><span class="line"><span class="function"><span class="params">        XmlResourceParser parser, <span class="keyword">int</span> flags, String[] outError)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> XmlPullParserException, IOException </span>&#123;</span><br><span class="line">    ... ... ... ...</span><br><span class="line">    <span class="keyword">while</span> ((type = parser.next()) != XmlPullParser.END_DOCUMENT</span><br><span class="line">            &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; innerDepth)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String tagName = parser.getName();</span><br><span class="line">        <span class="keyword">if</span> (tagName.equals(<span class="string">"activity"</span>)) &#123;</span><br><span class="line">            Activity a = parseActivity(owner, res, parser, flags, outError, <span class="keyword">false</span>,</span><br><span class="line">                    owner.baseHardwareAccelerated);</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            owner.activities.add(a);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【2.1】解析 "receiver"，获得静态注册的广播接收者的信息！</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tagName.equals(<span class="string">"receiver"</span>)) &#123;</span><br><span class="line">            Activity a = parseActivity(owner, res, parser, flags, outError, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (a == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mParseError = PackageManager.INSTALL_PARSE_FAILED_MANIFEST_MALFORMED;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【1】将解析到的 receiver 加入到 Package owner 中！</span></span><br><span class="line">            owner.receivers.add(a);</span><br><span class="line"></span><br><span class="line">        &#125; </span><br><span class="line">        ... ... ...</span><br><span class="line">    &#125;</span><br><span class="line">    ... ... ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，这里会解析静态注册的广播接收者，并将其信息封装成 Activity 对象保存到了 Package.receivers 对象中去！</p>
<p>我们进入到 PackageParser 的 parseActivity 中去看看！</p>
<h2 id="2-1-PackageParser-parseActivity"><a href="#2-1-PackageParser-parseActivity" class="headerlink" title="2.1 PackageParser.parseActivity"></a>2.1 PackageParser.parseActivity</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">parseActivity</span><span class="params">(Package owner, Resources res,</span></span></span><br><span class="line"><span class="function"><span class="params">        XmlResourceParser parser, <span class="keyword">int</span> flags, String[] outError,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> receiver, <span class="keyword">boolean</span> hardwareAccelerated)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> XmlPullParserException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    TypedArray sa = res.obtainAttributes(parser, R.styleable.AndroidManifestActivity);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mParseActivityArgs == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mParseActivityArgs = <span class="keyword">new</span> ParseComponentArgs(owner, outError,</span><br><span class="line">                R.styleable.AndroidManifestActivity_name,</span><br><span class="line">                R.styleable.AndroidManifestActivity_label,</span><br><span class="line">                R.styleable.AndroidManifestActivity_icon,</span><br><span class="line">                R.styleable.AndroidManifestActivity_roundIcon,</span><br><span class="line">                R.styleable.AndroidManifestActivity_logo,</span><br><span class="line">                R.styleable.AndroidManifestActivity_banner,</span><br><span class="line">                mSeparateProcesses,</span><br><span class="line">                R.styleable.AndroidManifestActivity_process,</span><br><span class="line">                R.styleable.AndroidManifestActivity_description,</span><br><span class="line">                R.styleable.AndroidManifestActivity_enabled);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mParseActivityArgs.tag = receiver ? <span class="string">"&lt;receiver&gt;"</span> : <span class="string">"&lt;activity&gt;"</span>;</span><br><span class="line">    mParseActivityArgs.sa = sa;</span><br><span class="line">    mParseActivityArgs.flags = flags;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【1】创建了一个 Activity 对象！</span></span><br><span class="line">    Activity a = <span class="keyword">new</span> Activity(mParseActivityArgs, <span class="keyword">new</span> ActivityInfo());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (outError[<span class="number">0</span>] != <span class="keyword">null</span>) &#123;</span><br><span class="line">        sa.recycle();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ... ... ... ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> outerDepth = parser.getDepth();</span><br><span class="line">    <span class="keyword">int</span> type;</span><br><span class="line">    <span class="keyword">while</span> ((type=parser.next()) != XmlPullParser.END_DOCUMENT</span><br><span class="line">           &amp;&amp; (type != XmlPullParser.END_TAG</span><br><span class="line">                   || parser.getDepth() &gt; outerDepth)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 解析 "intent-filter" 标签！</span></span><br><span class="line">        <span class="keyword">if</span> (parser.getName().equals(<span class="string">"intent-filter"</span>)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【2】创建 ActivityIntentInfo 对象！</span></span><br><span class="line">            ActivityIntentInfo intent = <span class="keyword">new</span> ActivityIntentInfo(a);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//【2.2】解析 "intent-filter" 的子标签！</span></span><br><span class="line">            <span class="keyword">if</span> (!parseIntent(res, parser, <span class="keyword">true</span>, <span class="keyword">true</span>, intent, outError)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (intent.countActions() == <span class="number">0</span>) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"No actions in intent filter at "</span></span><br><span class="line">                        + mArchiveSourcePath + <span class="string">" "</span></span><br><span class="line">                        + parser.getPositionDescription());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//【4】如果设置了 intent 过滤属性，即 intent.countActions() != 0：</span></span><br><span class="line">                a.intents.add(intent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!receiver &amp;&amp; parser.getName().equals(<span class="string">"preferred"</span>)) &#123; <span class="comment">// 这个是和 activity 相关的</span></span><br><span class="line">            ActivityIntentInfo intent = <span class="keyword">new</span> ActivityIntentInfo(a);</span><br><span class="line">            <span class="keyword">if</span> (!parseIntent(res, parser, <span class="keyword">false</span>, <span class="keyword">false</span>, intent, outError)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (intent.countActions() == <span class="number">0</span>) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"No actions in preferred at "</span></span><br><span class="line">                        + mArchiveSourcePath + <span class="string">" "</span></span><br><span class="line">                        + parser.getPositionDescription());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (owner.preferredActivityFilters == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    owner.preferredActivityFilters = <span class="keyword">new</span> ArrayList&lt;ActivityIntentInfo&gt;();</span><br><span class="line">                &#125;</span><br><span class="line">                owner.preferredActivityFilters.add(intent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (parser.getName().equals(<span class="string">"meta-data"</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((a.metaData = parseMetaData(res, parser, a.metaData,</span><br><span class="line">                    outError)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!receiver &amp;&amp; parser.getName().equals(<span class="string">"layout"</span>)) &#123;</span><br><span class="line">            parseLayout(res, parser, a);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ... ... ... ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!setExported) &#123;</span><br><span class="line">        a.info.exported = a.intents.size() &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-PackageParser-parseIntent"><a href="#2-2-PackageParser-parseIntent" class="headerlink" title="2.2 PackageParser.parseIntent"></a>2.2 PackageParser.parseIntent</h2><p>我们来看看 parseIntent 方法中做过了些什么！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">parseIntent</span><span class="params">(Resources res, XmlResourceParser parser,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> allowGlobs, <span class="keyword">boolean</span> allowAutoVerify, IntentInfo outInfo, String[] outError)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> XmlPullParserException, IOException </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【1】这里是解析 "intent-filter" 标签的属性，我们这里不重点关注！</span></span><br><span class="line">    TypedArray sa = res.obtainAttributes(parser,</span><br><span class="line">            com.android.internal.R.styleable.AndroidManifestIntentFilter);</span><br><span class="line"></span><br><span class="line">    ... ... ... ...</span><br><span class="line"></span><br><span class="line">    sa.recycle();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> outerDepth = parser.getDepth();</span><br><span class="line">    <span class="keyword">int</span> type;</span><br><span class="line">    <span class="keyword">while</span> ((type = parser.next()) != XmlPullParser.END_DOCUMENT</span><br><span class="line">            &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; outerDepth)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        String nodeName = parser.getName();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【2】解析 "action"</span></span><br><span class="line">        <span class="keyword">if</span> (nodeName.equals(<span class="string">"action"</span>)) &#123;</span><br><span class="line">            String value = parser.getAttributeValue(</span><br><span class="line">                    ANDROID_RESOURCES, <span class="string">"name"</span>);</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="keyword">null</span> || value == <span class="string">""</span>) &#123;</span><br><span class="line">                outError[<span class="number">0</span>] = <span class="string">"No value supplied for &lt;android:name&gt;"</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            XmlUtils.skipCurrentTag(parser);</span><br><span class="line">            <span class="comment">//【1】设置 action 属性；</span></span><br><span class="line">            outInfo.addAction(value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【3】解析 "category"</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nodeName.equals(<span class="string">"category"</span>)) &#123;</span><br><span class="line">            String value = parser.getAttributeValue(</span><br><span class="line">                    ANDROID_RESOURCES, <span class="string">"name"</span>); <span class="comment">// android:na</span></span><br><span class="line">            <span class="keyword">if</span> (value == <span class="keyword">null</span> || value == <span class="string">""</span>) &#123;</span><br><span class="line">                outError[<span class="number">0</span>] = <span class="string">"No value supplied for &lt;android:name&gt;"</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            XmlUtils.skipCurrentTag(parser);</span><br><span class="line">            <span class="comment">//【2】设置 category 属性；</span></span><br><span class="line">            outInfo.addCategory(value);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【4】解析 "data"</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nodeName.equals(<span class="string">"data"</span>)) &#123;</span><br><span class="line">            sa = res.obtainAttributes(parser,</span><br><span class="line">                    com.android.internal.R.styleable.AndroidManifestData);</span><br><span class="line"></span><br><span class="line">            String str = sa.getNonConfigurationString(</span><br><span class="line">                    com.android.internal.R.styleable.AndroidManifestData_mimeType, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (str != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//【4.2】设置 dataType 属性；</span></span><br><span class="line">                    outInfo.addDataType(str);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IntentFilter.MalformedMimeTypeException e) &#123;</span><br><span class="line">                    outError[<span class="number">0</span>] = e.toString();</span><br><span class="line">                    sa.recycle();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ... ... ... ...</span><br><span class="line"></span><br><span class="line">            sa.recycle();</span><br><span class="line">            XmlUtils.skipCurrentTag(parser);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!RIGID_PARSER) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Unknown element under &lt;intent-filter&gt;: "</span></span><br><span class="line">                    + parser.getName() + <span class="string">" at "</span> + mArchiveSourcePath + <span class="string">" "</span></span><br><span class="line">                    + parser.getPositionDescription());</span><br><span class="line">            XmlUtils.skipCurrentTag(parser);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            outError[<span class="number">0</span>] = <span class="string">"Bad element under &lt;intent-filter&gt;: "</span> + parser.getName();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    outInfo.hasDefault = outInfo.hasCategory(Intent.CATEGORY_DEFAULT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG_PARSER) &#123;</span><br><span class="line"></span><br><span class="line">        ... ... ...</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实看到这里，我们已经能够看出静态注册的 broadcastReceiver 是如何被 PMS 解析了，解析的数据都会被保存到 PackageParser.Package 中！</p>
<h1 id="2-PMS-scanPackageDirtyLI"><a href="#2-PMS-scanPackageDirtyLI" class="headerlink" title="2 PMS.scanPackageDirtyLI"></a>2 PMS.scanPackageDirtyLI</h1><p>接下来，PMS 会进一步处理解析的数据！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> PackageParser.<span class="function">Package <span class="title">scanPackageDirtyLI</span><span class="params">(PackageParser.Package pkg,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> <span class="keyword">int</span> policyFlags, <span class="keyword">final</span> <span class="keyword">int</span> scanFlags, <span class="keyword">long</span> currentTime, UserHandle user)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> PackageManagerException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ... ... ...</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【1】将解析到的 BroadcastRecord 数据保存到 PMS 的内部变量 mReceivers 中！</span></span><br><span class="line">        N = pkg.receivers.size();</span><br><span class="line">        r = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【2】获得该 package 中静态注册的广播接收者的信息对象 Activity；</span></span><br><span class="line">            PackageParser.Activity a = pkg.receivers.get(i);</span><br><span class="line"></span><br><span class="line">            a.info.processName = fixProcessName(pkg.applicationInfo.processName,</span><br><span class="line">                    a.info.processName, pkg.applicationInfo.uid);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//【3】添加到 PMS.mReceivers 中;</span></span><br><span class="line">            mReceivers.addActivity(a, <span class="string">"receiver"</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> ((policyFlags&amp;PackageParser.PARSE_CHATTY) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (r == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    r = <span class="keyword">new</span> StringBuilder(<span class="number">256</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    r.append(<span class="string">' '</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                r.append(a.info.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_PACKAGE_SCANNING) Log.d(TAG, <span class="string">"  Receivers: "</span> + r);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        ... ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>将之前是扫描解析到的信息对象 Activity，保存到 PMS.mReceivers 对象中，mReceivers 是一个 ActivityIntentResolver 类的对象，用于保存系统中定义的所有的静态接收者：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// All available receivers, for your resolving pleasure.</span></span><br><span class="line"><span class="keyword">final</span> ActivityIntentResolver mReceivers =</span><br><span class="line">        <span class="keyword">new</span> ActivityIntentResolver();</span><br></pre></td></tr></table></figure>
<p>我们继续分析！</p>
<h2 id="2-1-PMS-ActivityIntentResolver"><a href="#2-1-PMS-ActivityIntentResolver" class="headerlink" title="2.1 PMS.ActivityIntentResolver"></a>2.1 PMS.ActivityIntentResolver</h2><p>我们来看下 ActivityIntentResolver 是如何处理静态接收者的注册的！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityIntentResolver</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">IntentResolver</span>&lt;<span class="title">PackageParser</span>.<span class="title">ActivityIntentInfo</span>, <span class="title">ResolveInfo</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    ... ... ... ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addActivity</span><span class="params">(PackageParser.Activity a, String type)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//【1】key 为广播接收者组件名，value 为 PackageParser.Activity 对象，保存到内部的 mActivities 哈希表中！</span></span><br><span class="line">        mActivities.put(a.getComponentName(), a);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DEBUG_SHOW_INFO)</span><br><span class="line">            Log.v(</span><br><span class="line">            TAG, <span class="string">"  "</span> + type + <span class="string">" "</span> +</span><br><span class="line">            (a.info.nonLocalizedLabel != <span class="keyword">null</span> ? a.info.nonLocalizedLabel : a.info.name) + <span class="string">":"</span>);</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_SHOW_INFO)</span><br><span class="line">            Log.v(TAG, <span class="string">"    Class="</span> + a.info.name);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【2】处理对应的 ActivityIntentInfo 对象！</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> NI = a.intents.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;NI; j++) &#123;</span><br><span class="line">            PackageParser.ActivityIntentInfo intent = a.intents.get(j);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"activity"</span>.equals(type)) &#123; <span class="comment">// 因为我们的 type 是 "receiver" ，所以不进入该分支！</span></span><br><span class="line">                <span class="keyword">final</span> PackageSetting ps =</span><br><span class="line">                        mSettings.getDisabledSystemPkgLPr(intent.activity.info.packageName);</span><br><span class="line">                <span class="keyword">final</span> List&lt;PackageParser.Activity&gt; systemActivities =</span><br><span class="line">                        ps != <span class="keyword">null</span> &amp;&amp; ps.pkg != <span class="keyword">null</span> ? ps.pkg.activities : <span class="keyword">null</span>;</span><br><span class="line">                adjustPriority(systemActivities, intent);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (DEBUG_SHOW_INFO) &#123;</span><br><span class="line">                Log.v(TAG, <span class="string">"    IntentFilter:"</span>);</span><br><span class="line">                intent.dump(<span class="keyword">new</span> LogPrinter(Log.VERBOSE, TAG), <span class="string">"      "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!intent.debugCheck()) &#123;</span><br><span class="line">                Log.w(TAG, <span class="string">"==&gt; For Activity "</span> + a.info.name);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//【2.2】调用了父类的 addFilter 方法；</span></span><br><span class="line">            addFilter(intent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ... ... ... ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内部集合，存储解析到的组件！</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ArrayMap&lt;ComponentName, PackageParser.Activity&gt; mActivities</span><br><span class="line">            = <span class="keyword">new</span> ArrayMap&lt;ComponentName, PackageParser.Activity&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mFlags;            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ActivityIntentResolver 继承了 IntentResolver，IntentResolver 是一个模板类：</p>
<h2 id="2-2-IntentResolver-addFilter"><a href="#2-2-IntentResolver-addFilter" class="headerlink" title="2.2 IntentResolver.addFilter"></a>2.2 IntentResolver.addFilter</h2><p>这里 F 是 PackageParser.ActivityIntentInfo， R 是 ResolveInfo：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">IntentResolver</span>&lt;<span class="title">F</span> <span class="keyword">extends</span> <span class="title">IntentFilter</span>, <span class="title">R</span> <span class="keyword">extends</span> <span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】调用了 addFilter 方法！</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFilter</span><span class="params">(F f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (localLOGV) &#123;</span><br><span class="line">            Slog.v(TAG, <span class="string">"Adding filter: "</span> + f);</span><br><span class="line">            f.dump(<span class="keyword">new</span> LogPrinter(Log.VERBOSE, TAG, Log.LOG_ID_SYSTEM), <span class="string">"      "</span>);</span><br><span class="line">            Slog.v(TAG, <span class="string">"    Building Lookup Maps:"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【2】添加到内部总集合 mFilters 中！</span></span><br><span class="line">        mFilters.add(f);</span><br><span class="line">        <span class="comment">//【3】根据 filter 属性配置，添加到不同的子集合中！</span></span><br><span class="line">        <span class="comment">//【3.1】处理 Scheme；</span></span><br><span class="line">        <span class="keyword">int</span> numS = register_intent_filter(f, f.schemesIterator(),</span><br><span class="line">                mSchemeToFilter, <span class="string">"      Scheme: "</span>);</span><br><span class="line">        <span class="comment">//【3.2】处理 Type；</span></span><br><span class="line">        <span class="keyword">int</span> numT = register_mime_types(f, <span class="string">"      Type: "</span>);</span><br><span class="line">        <span class="comment">//【3.3】处理 Action；</span></span><br><span class="line">        <span class="keyword">if</span> (numS == <span class="number">0</span> &amp;&amp; numT == <span class="number">0</span>) &#123;</span><br><span class="line">            register_intent_filter(f, f.actionsIterator(),</span><br><span class="line">                    mActionToFilter, <span class="string">"      Action: "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【3.4】处理 TypedAction；</span></span><br><span class="line">        <span class="keyword">if</span> (numT != <span class="number">0</span>) &#123;</span><br><span class="line">            register_intent_filter(f, f.actionsIterator(),</span><br><span class="line">                    mTypedActionToFilter, <span class="string">"      TypedAction: "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ArraySet&lt;F&gt; mFilters = <span class="keyword">new</span> ArraySet&lt;F&gt;(); <span class="comment">// 所有注册的 filter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里我们就是实现了对静态注册的广播接收者的处理！！</p>
<h3 id="2-2-1-IntentResolver-register-intent-filter"><a href="#2-2-1-IntentResolver-register-intent-filter" class="headerlink" title="2.2.1 IntentResolver.register_intent_filter"></a>2.2.1 IntentResolver.register_intent_filter</h3><p>register_intent_filter 用于注册 filter ，并返回注册的数量，对于参数，我们以 mSchemeToFilter 为例：</p>
<p><strong>F filter</strong>：这里是我们解析的 intentFilter 的 ActivityIntentInfo 对象！</p>
<p><strong>Iterator<string> i</string></strong>：f.schemesIterator()，是一个 Scheme 迭代器，用于遍历该 filter 设置的所有的 Scheme；</p>
<p><strong>ArrayMap&lt;String, F[]&gt; dest</strong>：是我们要加入集合，这里是 mSchemeToFilter；</p>
<p><strong>String prefix</strong>：用于 log，不过多关注！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">register_intent_filter</span><span class="params">(F filter, Iterator&lt;String&gt; i,</span></span></span><br><span class="line"><span class="function"><span class="params">        ArrayMap&lt;String, F[]&gt; dest, String prefix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">        <span class="comment">//【1】这里返回的就是 android:name 属性对应的值！</span></span><br><span class="line">        String name = i.next();</span><br><span class="line">        num++;</span><br><span class="line">        <span class="keyword">if</span> (localLOGV) Slog.v(TAG, prefix + name);</span><br><span class="line">        <span class="comment">//【2.2.2】继续处理！</span></span><br><span class="line">        addFilter(dest, name, filter);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-2-IntentResolver-addFilter"><a href="#2-2-2-IntentResolver-addFilter" class="headerlink" title="2.2.2 IntentResolver.addFilter"></a>2.2.2 IntentResolver.addFilter</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addFilter</span><span class="params">(ArrayMap&lt;String, F[]&gt; map, String name, F filter)</span> </span>&#123;</span><br><span class="line">    F[] array = map.get(name);</span><br><span class="line">    <span class="keyword">if</span> (array == <span class="keyword">null</span>) &#123;</span><br><span class="line">        array = newArray(<span class="number">2</span>);</span><br><span class="line">        map.put(name,  array);</span><br><span class="line">        array[<span class="number">0</span>] = filter; <span class="comment">//【1】保存到 array[0] 中！</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N = array.length;</span><br><span class="line">        <span class="keyword">int</span> i = N;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; array[i-<span class="number">1</span>] == <span class="keyword">null</span>) &#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; N) &#123;</span><br><span class="line">            <span class="comment">//【2】插入到末尾！</span></span><br><span class="line">            array[i] = filter;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//【3】扩充数组为之前的 3/2 倍，插入到末尾！</span></span><br><span class="line">            F[] newa = newArray((N*<span class="number">3</span>)/<span class="number">2</span>);</span><br><span class="line">            System.arraycopy(array, <span class="number">0</span>, newa, <span class="number">0</span>, N);</span><br><span class="line">            newa[N] = filter;</span><br><span class="line">            map.put(name, newa);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们要发送广播时，是要查找当前系统中所有已经静态注册的广播接收者的，那么我们去看看查询相关的方法：</p>
<h1 id="3-PMS-queryIntentReceivers-查询静态接收者"><a href="#3-PMS-queryIntentReceivers-查询静态接收者" class="headerlink" title="3 PMS.queryIntentReceivers - 查询静态接收者"></a>3 PMS.queryIntentReceivers - 查询静态接收者</h1><p>查询静态注册的广播接收者方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@NonNull</span> <span class="function">ParceledListSlice&lt;ResolveInfo&gt; <span class="title">queryIntentReceivers</span><span class="params">(Intent intent,</span></span></span><br><span class="line"><span class="function"><span class="params">        String resolvedType, <span class="keyword">int</span> flags, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ParceledListSlice&lt;&gt;(</span><br><span class="line">            queryIntentReceiversInternal(intent, resolvedType, flags, userId));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最终会调用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="meta">@NonNull</span> <span class="function">List&lt;ResolveInfo&gt; <span class="title">queryIntentReceiversInternal</span><span class="params">(Intent intent,</span></span></span><br><span class="line"><span class="function"><span class="params">        String resolvedType, <span class="keyword">int</span> flags, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】如果不存在这个设备用户 id，就返回一个数据为 null 的 list；</span></span><br><span class="line">    <span class="keyword">if</span> (!sUserManager.exists(userId)) <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line"></span><br><span class="line">    flags = updateFlagsForResolve(flags, userId, intent);</span><br><span class="line"></span><br><span class="line">    ComponentName comp = intent.getComponent();</span><br><span class="line">    <span class="keyword">if</span> (comp == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (intent.getSelector() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            intent = intent.getSelector();</span><br><span class="line">            comp = intent.getComponent();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】如果 Intent 设置了组件名，就通过组件名直接获取！</span></span><br><span class="line">    <span class="keyword">if</span> (comp != <span class="keyword">null</span>) &#123;</span><br><span class="line">        List&lt;ResolveInfo&gt; list = <span class="keyword">new</span> ArrayList&lt;ResolveInfo&gt;(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//【3.1】创建 ResolveInfo 的 list 列表，用于保存匹配结果！</span></span><br><span class="line">        ActivityInfo ai = getReceiverInfo(comp, flags, userId);</span><br><span class="line">        <span class="keyword">if</span> (ai != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ResolveInfo ri = <span class="keyword">new</span> ResolveInfo();</span><br><span class="line">            ri.activityInfo = ai;</span><br><span class="line">            list.add(ri);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mPackages) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【2】如果 Intent 没有设置组件名和包名，就调用 queryIntent 进行查询！</span></span><br><span class="line">        String pkgName = intent.getPackage();</span><br><span class="line">        <span class="keyword">if</span> (pkgName == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//【3.2】使用 queryIntent 方法！</span></span><br><span class="line">            <span class="keyword">return</span> mReceivers.queryIntent(intent, resolvedType, flags, userId);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【3】如果 Intent 没有设置组件名，但是设置了包名，就通过之前的扫描解析信息，查询！</span></span><br><span class="line">        <span class="keyword">final</span> PackageParser.Package pkg = mPackages.get(pkgName);</span><br><span class="line">        <span class="keyword">if</span> (pkg != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//【3.3】使用 queryIntentForPackage 根据包名查询，mReceivers 中保存了解析到的所有的；</span></span><br><span class="line">            <span class="keyword">return</span> mReceivers.queryIntentForPackage(intent, resolvedType, flags, pkg.receivers,</span><br><span class="line">                    userId);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面我们一个一个去看看：</p>
<h2 id="3-1-PackageManagerS-getReceiverInfo-组件名查询"><a href="#3-1-PackageManagerS-getReceiverInfo-组件名查询" class="headerlink" title="3.1 PackageManagerS.getReceiverInfo - 组件名查询"></a>3.1 PackageManagerS.getReceiverInfo - 组件名查询</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ActivityInfo <span class="title">getReceiverInfo</span><span class="params">(ComponentName component, <span class="keyword">int</span> flags, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!sUserManager.exists(userId)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    flags = updateFlagsForComponent(flags, userId, component);</span><br><span class="line">    enforceCrossUserPermission(Binder.getCallingUid(), userId,</span><br><span class="line">            <span class="keyword">false</span> <span class="comment">/* requireFullPermission */</span>, <span class="keyword">false</span> <span class="comment">/* checkShell */</span>, <span class="string">"get receiver info"</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (mPackages) &#123;</span><br><span class="line">        <span class="comment">//【1】直接通过组件名获得对应的 PackageParser.Activity 对象，封装了 receiver 的信息！</span></span><br><span class="line">        PackageParser.Activity a = mReceivers.mActivities.get(component);</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_PACKAGE_INFO) Log.v(</span><br><span class="line">            TAG, <span class="string">"getReceiverInfo "</span> + component + <span class="string">": "</span> + a);</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span> &amp;&amp; mSettings.isEnabledAndMatchLPr(a.info, flags, userId)) &#123;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">//【2】如果对应的 PackageSetting 对象为 null，说明应用没有安装，返回 null</span></span><br><span class="line">            PackageSetting ps = mSettings.mPackages.get(component.getPackageName());</span><br><span class="line">            <span class="keyword">if</span> (ps == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//【3.1.1】调用 PackageParser 的 generateActivityInfo 方法继续查询！</span></span><br><span class="line">            <span class="keyword">return</span> PackageParser.generateActivityInfo(a, flags, ps.readUserState(userId),</span><br><span class="line">                    userId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续看：</p>
<h3 id="3-1-1-PackageParser-generateActivityInfo"><a href="#3-1-1-PackageParser-generateActivityInfo" class="headerlink" title="3.1.1 PackageParser.generateActivityInfo"></a>3.1.1 PackageParser.generateActivityInfo</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ActivityInfo <span class="title">generateActivityInfo</span><span class="params">(Activity a, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">        PackageUserState state, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//【1】判断应用是否安装或者隐藏；</span></span><br><span class="line">    <span class="keyword">if</span> (!checkUseInstalledOrHidden(flags, state)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【2】判断是否需要 copy 一份数据，如果不需要就直接返回 mReceivers 中解析到的！</span></span><br><span class="line">    <span class="keyword">if</span> (!copyNeeded(flags, a.owner, state, a.metaData, userId)) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.info;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【3】获得 Activity 内部的 ActivityInfo 对象的拷贝！</span></span><br><span class="line">    ActivityInfo ai = <span class="keyword">new</span> ActivityInfo(a.info);</span><br><span class="line">    ai.metaData = a.metaData;</span><br><span class="line">    <span class="comment">//【4】拷贝封装需要的信息</span></span><br><span class="line">    ai.applicationInfo = generateApplicationInfo(a.owner, flags, state, userId);</span><br><span class="line">    <span class="keyword">return</span> ai;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里很简单，返回了之前解析获得的广播接收者的 ActivityInfo 对象 ai！</p>
<p>然后，创建 ResolveInfo ri = new ResolveInfo() 对象，然后初始化 ri.activityInfo = ai，将 ResolveInfo 对象 ri 添加到 List<resolveinfo> 返回！</resolveinfo></p>
<h2 id="3-2-ActivityIntentResolver-queryIntent-意图匹配查询"><a href="#3-2-ActivityIntentResolver-queryIntent-意图匹配查询" class="headerlink" title="3.2 ActivityIntentResolver.queryIntent - 意图匹配查询"></a>3.2 ActivityIntentResolver.queryIntent - 意图匹配查询</h2><p>这里先会调用子类 ActivityIntentResolver 的 queryIntent 方法！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;ResolveInfo&gt; <span class="title">queryIntent</span><span class="params">(Intent intent, String resolvedType, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】userId 不存在，返回 null</span></span><br><span class="line">    <span class="keyword">if</span> (!sUserManager.exists(userId)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    mFlags = flags;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【3.2.1】调用父类的 queryIntent 方法继续查询！</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.queryIntent(intent, resolvedType,</span><br><span class="line">            (flags &amp; PackageManager.MATCH_DEFAULT_ONLY) != <span class="number">0</span>, userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进入父类 IntentResolver：</p>
<h3 id="3-2-1-IntentResolver-queryIntent"><a href="#3-2-1-IntentResolver-queryIntent" class="headerlink" title="3.2.1 IntentResolver.queryIntent"></a>3.2.1 IntentResolver.queryIntent</h3><p>这里的模板参数 R 为 ResolveInfo 类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;R&gt; <span class="title">queryIntent</span><span class="params">(Intent intent, String resolvedType, <span class="keyword">boolean</span> defaultOnly,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    String scheme = intent.getScheme();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】最终要返回的 ArrayList&lt;R&gt; list 集合！</span></span><br><span class="line">    ArrayList&lt;R&gt; finalList = <span class="keyword">new</span> ArrayList&lt;R&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> debug = localLOGV ||</span><br><span class="line">            ((intent.getFlags() &amp; Intent.FLAG_DEBUG_LOG_RESOLUTION) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (debug) Slog.v(</span><br><span class="line">        TAG, <span class="string">"Resolving type="</span> + resolvedType + <span class="string">" scheme="</span> + scheme</span><br><span class="line">        + <span class="string">" defaultOnly="</span> + defaultOnly + <span class="string">" userId="</span> + userId + <span class="string">" of "</span> + intent);</span><br><span class="line"></span><br><span class="line">    F[] firstTypeCut = <span class="keyword">null</span>;</span><br><span class="line">    F[] secondTypeCut = <span class="keyword">null</span>;</span><br><span class="line">    F[] thirdTypeCut = <span class="keyword">null</span>;</span><br><span class="line">    F[] schemeCut = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】如果 intent 包含一个 MIME type，我们会手机所有能匹配该 MIME 的 filters！</span></span><br><span class="line">    <span class="comment">// MIME 是描述消息内容类型的因特网标准，格式如下：application/pdf</span></span><br><span class="line">    <span class="keyword">if</span> (resolvedType != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> slashpos = resolvedType.indexOf(<span class="string">'/'</span>);</span><br><span class="line">        <span class="comment">//【2.1】校验指定的 MIME 的格式是否正确，必须要有 / 隔开！</span></span><br><span class="line">        <span class="keyword">if</span> (slashpos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//【2.1.1】获得 MIME 的前半部分：application，针对其取值做不同的处理！</span></span><br><span class="line">            <span class="keyword">final</span> String baseType = resolvedType.substring(<span class="number">0</span>, slashpos);</span><br><span class="line">            <span class="keyword">if</span> (!baseType.equals(<span class="string">"*"</span>)) &#123;</span><br><span class="line">                <span class="comment">//【2.1.1.1】如果 baseType 不为 *，说明 intent 可能指定了一个 MIME，接下来，我们继续处理！</span></span><br><span class="line">                <span class="keyword">if</span> (resolvedType.length() != slashpos+<span class="number">2</span></span><br><span class="line">                        || resolvedType.charAt(slashpos+<span class="number">1</span>) != <span class="string">'*'</span>) &#123;</span><br><span class="line">                    <span class="comment">// Not a wild card, so we can just look for all filters that</span></span><br><span class="line">                    <span class="comment">// completely match or wildcards whose base type matches.</span></span><br><span class="line">                    <span class="comment">//【2.1.1.1.1】如果 resolvedType</span></span><br><span class="line">                    firstTypeCut = mTypeToFilter.get(resolvedType);</span><br><span class="line">                    <span class="keyword">if</span> (debug) Slog.v(TAG, <span class="string">"First type cut: "</span> + Arrays.toString(firstTypeCut));</span><br><span class="line">                    secondTypeCut = mWildTypeToFilter.get(baseType);</span><br><span class="line">                    <span class="keyword">if</span> (debug) Slog.v(TAG, <span class="string">"Second type cut: "</span></span><br><span class="line">                            + Arrays.toString(secondTypeCut));</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//【2.1.1.1.2】如果 resolvedType 的长度等于 slashpos + 2，且 slashpos + 1 为 "*"</span></span><br><span class="line">                    <span class="comment">// 那么其能够匹配所有的 "baseType/*"</span></span><br><span class="line">                    firstTypeCut = mBaseTypeToFilter.get(baseType);</span><br><span class="line">                    <span class="keyword">if</span> (debug) Slog.v(TAG, <span class="string">"First type cut: "</span> + Arrays.toString(firstTypeCut));</span><br><span class="line">                    secondTypeCut = mWildTypeToFilter.get(baseType);</span><br><span class="line">                    <span class="keyword">if</span> (debug) Slog.v(TAG, <span class="string">"Second type cut: "</span></span><br><span class="line">                            + Arrays.toString(secondTypeCut));</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Any */* types always apply, but we only need to do this</span></span><br><span class="line">                <span class="comment">// if the intent type was not already */*.</span></span><br><span class="line">                thirdTypeCut = mWildTypeToFilter.get(<span class="string">"*"</span>);</span><br><span class="line">                <span class="keyword">if</span> (debug) Slog.v(TAG, <span class="string">"Third type cut: "</span> + Arrays.toString(thirdTypeCut));</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (intent.getAction() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//【2.1.1.2】如果 baseType 为 *，说明是通过正则表达式匹配任何类型的 filters</span></span><br><span class="line">                <span class="comment">// 这种情况会有风险，那就使用 action 来匹配！</span></span><br><span class="line">                firstTypeCut = mTypedActionToFilter.get(intent.getAction());</span><br><span class="line">                <span class="keyword">if</span> (debug) Slog.v(TAG, <span class="string">"Typed Action list: "</span> + Arrays.toString(firstTypeCut));</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【3】如果 intent 设置了 scheme（data URI），收集所有能匹配该 scheme 的 filter！</span></span><br><span class="line">    <span class="keyword">if</span> (scheme != <span class="keyword">null</span>) &#123;</span><br><span class="line">        schemeCut = mSchemeToFilter.get(scheme);</span><br><span class="line">        <span class="keyword">if</span> (debug) Slog.v(TAG, <span class="string">"Scheme list: "</span> + Arrays.toString(schemeCut));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【4】intent 没有设置 Scheme 和 MIME，那就匹配 action！</span></span><br><span class="line">    <span class="keyword">if</span> (resolvedType == <span class="keyword">null</span> &amp;&amp; scheme == <span class="keyword">null</span> &amp;&amp; intent.getAction() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        firstTypeCut = mActionToFilter.get(intent.getAction());</span><br><span class="line">        <span class="keyword">if</span> (debug) Slog.v(TAG, <span class="string">"Action list: "</span> + Arrays.toString(firstTypeCut));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//【3.4】开始进一步的匹配，将结果保存到 finalList 中！</span></span><br><span class="line">    FastImmutableArraySet&lt;String&gt; categories = getFastIntentCategories(intent);</span><br><span class="line">    <span class="keyword">if</span> (firstTypeCut != <span class="keyword">null</span>) &#123;</span><br><span class="line">        buildResolveList(intent, categories, debug, defaultOnly,</span><br><span class="line">                resolvedType, scheme, firstTypeCut, finalList, userId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (secondTypeCut != <span class="keyword">null</span>) &#123;</span><br><span class="line">        buildResolveList(intent, categories, debug, defaultOnly,</span><br><span class="line">                resolvedType, scheme, secondTypeCut, finalList, userId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (thirdTypeCut != <span class="keyword">null</span>) &#123;</span><br><span class="line">        buildResolveList(intent, categories, debug, defaultOnly,</span><br><span class="line">                resolvedType, scheme, thirdTypeCut, finalList, userId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (schemeCut != <span class="keyword">null</span>) &#123;</span><br><span class="line">        buildResolveList(intent, categories, debug, defaultOnly,</span><br><span class="line">                resolvedType, scheme, schemeCut, finalList, userId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【3.5】对结果进行过滤；</span></span><br><span class="line">    filterResults(finalList);</span><br><span class="line">    <span class="comment">//【3.6】对结果进行排序；</span></span><br><span class="line">    sortResults(finalList);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (debug) &#123;</span><br><span class="line">        Slog.v(TAG, <span class="string">"Final result list:"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;finalList.size(); i++) &#123;</span><br><span class="line">            Slog.v(TAG, <span class="string">"  "</span> + finalList.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> finalList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后返回匹配的 intent filter！</p>
<h2 id="3-3-ActivityIntentResolver-queryIntentForPackage-包名查询"><a href="#3-3-ActivityIntentResolver-queryIntentForPackage-包名查询" class="headerlink" title="3.3 ActivityIntentResolver.queryIntentForPackage - 包名查询"></a>3.3 ActivityIntentResolver.queryIntentForPackage - 包名查询</h2><p>参数：</p>
<ul>
<li><strong>ArrayList&lt;PackageParser.Activity&gt; packageActivities</strong>：传入 PackageParser.Package.receivers list 集合！<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;ResolveInfo&gt; <span class="title">queryIntentForPackage</span><span class="params">(Intent intent, String resolvedType,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> flags, ArrayList&lt;PackageParser.Activity&gt; packageActivities, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】userId 不存在，返回 null；</span></span><br><span class="line">    <span class="keyword">if</span> (!sUserManager.exists(userId)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【2】如果 packageActivities 为 null，返回 null；</span></span><br><span class="line">    <span class="keyword">if</span> (packageActivities == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mFlags = flags;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> defaultOnly = (flags&amp;PackageManager.MATCH_DEFAULT_ONLY) != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> N = packageActivities.size();</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;PackageParser.ActivityIntentInfo[]&gt; listCut =</span><br><span class="line">        <span class="keyword">new</span> ArrayList&lt;PackageParser.ActivityIntentInfo[]&gt;(N);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【3】这里是找到 packageActivities 列表中所有 Activity 对象的 ActivityIntentInfo 数组！</span></span><br><span class="line">    <span class="comment">// 将其收集起来，保存到 listCut 列表中！</span></span><br><span class="line">    ArrayList&lt;PackageParser.ActivityIntentInfo&gt; intentFilters;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        intentFilters = packageActivities.get(i).intents;</span><br><span class="line">        <span class="keyword">if</span> (intentFilters != <span class="keyword">null</span> &amp;&amp; intentFilters.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            PackageParser.ActivityIntentInfo[] array =</span><br><span class="line">                    <span class="keyword">new</span> PackageParser.ActivityIntentInfo[intentFilters.size()];</span><br><span class="line">            intentFilters.toArray(array);</span><br><span class="line">            listCut.add(array);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【3.3.1】调用父类的 queryIntentFromList 方法继续查询！</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.queryIntentFromList(intent, resolvedType, defaultOnly, listCut, userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>进入父类 IntentResolver 中：</p>
<h3 id="3-3-1-ActivityIntentResolver-queryIntentFromList"><a href="#3-3-1-ActivityIntentResolver-queryIntentFromList" class="headerlink" title="3.3.1 ActivityIntentResolver.queryIntentFromList"></a>3.3.1 ActivityIntentResolver.queryIntentFromList</h3><p>这里的模板参数 R 为 ResolveInfo 类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;R&gt; <span class="title">queryIntentFromList</span><span class="params">(Intent intent, String resolvedType, </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> defaultOnly, ArrayList&lt;F[]&gt; listCut, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】用于保存查询的结果！</span></span><br><span class="line">    ArrayList&lt;R&gt; resultList = <span class="keyword">new</span> ArrayList&lt;R&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> debug = localLOGV ||</span><br><span class="line">            ((intent.getFlags() &amp; Intent.FLAG_DEBUG_LOG_RESOLUTION) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    FastImmutableArraySet&lt;String&gt; categories = getFastIntentCategories(intent);</span><br><span class="line">    <span class="keyword">final</span> String scheme = intent.getScheme();</span><br><span class="line">    <span class="keyword">int</span> N = listCut.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">        <span class="comment">//【3.4】遍历 ArrayList&lt;PackageParser.ActivityIntentInfo[]&gt; 列表 listCut</span></span><br><span class="line">        <span class="comment">// 处理每一个 ActivityIntentInfo 数组，也就是 IntentFliter 数组！</span></span><br><span class="line">        buildResolveList(intent, categories, debug, defaultOnly,</span><br><span class="line">                resolvedType, scheme, listCut.get(i), resultList, userId);</span><br><span class="line">    &#125;</span><br><span class="line">    filterResults(resultList);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【3】对结果进行排序！</span></span><br><span class="line">    sortResults(resultList);</span><br><span class="line">    <span class="keyword">return</span> resultList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="3-4-IntentResolver-buildResolveList"><a href="#3-4-IntentResolver-buildResolveList" class="headerlink" title="3.4 IntentResolver.buildResolveList"></a>3.4 IntentResolver.buildResolveList</h2><p>下面我们来看一下，查询静态注册的广播接收者信息的最重要的一个方法，如何通过 <code>ActivityIntentInfo[]</code> 数组 src，生成 <code>List&lt;ResolveList&gt;</code> 列表 dest：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildResolveList</span><span class="params">(Intent intent, FastImmutableArraySet&lt;String&gt; categories,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> debug, <span class="keyword">boolean</span> defaultOnly,</span></span></span><br><span class="line"><span class="function"><span class="params">        String resolvedType, String scheme, F[] src, List&lt;R&gt; dest, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】获得广播 Intent 的 action！</span></span><br><span class="line">    <span class="keyword">final</span> String action = intent.getAction();</span><br><span class="line">    <span class="comment">//【2】获得广播 Intent 的 uri 数据！</span></span><br><span class="line">    <span class="keyword">final</span> Uri data = intent.getData();</span><br><span class="line">    <span class="comment">//【3】获得广播 Intent 的 package 数据！</span></span><br><span class="line">    <span class="keyword">final</span> String packageName = intent.getPackage();</span><br><span class="line">    <span class="comment">//【4】广播是否设置了 FLAG_EXCLUDE_STOPPED_PACKAGES 标志！</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> excludingStopped = intent.isExcludingStopped();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Printer logPrinter;</span><br><span class="line">    <span class="keyword">final</span> PrintWriter logPrintWriter;</span><br><span class="line">    <span class="keyword">if</span> (debug) &#123;</span><br><span class="line">        logPrinter = <span class="keyword">new</span> LogPrinter(Log.VERBOSE, TAG, Log.LOG_ID_SYSTEM);</span><br><span class="line">        logPrintWriter = <span class="keyword">new</span> FastPrintWriter(logPrinter);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        logPrinter = <span class="keyword">null</span>;</span><br><span class="line">        logPrintWriter = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> N = src != <span class="keyword">null</span> ? src.length : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> hasNonDefaults = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    F filter;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【1】遍历传入的 ActivityIntentInfo[] 数组 src，选择能接受当前广播 Intent 的 ActivityIntentInfo！</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;N &amp;&amp; (filter=src[i]) != <span class="keyword">null</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> match;</span><br><span class="line">        <span class="keyword">if</span> (debug) Slog.v(TAG, <span class="string">"Matching against filter "</span> + filter);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【3.4.1】如果广播设置了 FLAG_EXCLUDE_STOPPED_PACKAGES 标签，那就要判断 filter 所属的应用是否被 stop 了！</span></span><br><span class="line">        <span class="comment">// isFilterStopped 方法是 IntentResolver 的子类中实现！</span></span><br><span class="line">        <span class="comment">// 如果满足，那么这个应用是不能接收到当前的广播的！</span></span><br><span class="line">        <span class="keyword">if</span> (excludingStopped &amp;&amp; isFilterStopped(filter, userId)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (debug) &#123;</span><br><span class="line">                Slog.v(TAG, <span class="string">"  Filter's target is stopped; skipping"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【3.4.2】如果广播 Intent 设置了包名，那就要判断当前 ActivityIntentInfo 所属的目标应用包名是否一致</span></span><br><span class="line">        <span class="comment">// 不一致，说明这个不是目标应用，isPackageForFilter 也是在 IntentResolver 的子类中实现！</span></span><br><span class="line">        <span class="keyword">if</span> (packageName != <span class="keyword">null</span> &amp;&amp; !isPackageForFilter(packageName, filter)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (debug) &#123;</span><br><span class="line">                Slog.v(TAG, <span class="string">"  Filter is not from package "</span> + packageName + <span class="string">"; skipping"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (filter.getAutoVerify()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (localVerificationLOGV || debug) &#123;</span><br><span class="line">                Slog.v(TAG, <span class="string">"  Filter verified: "</span> + isFilterVerified(filter));</span><br><span class="line">                <span class="keyword">int</span> authorities = filter.countDataAuthorities();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> z = <span class="number">0</span>; z &lt; authorities; z++) &#123;</span><br><span class="line">                    Slog.v(TAG, <span class="string">"   "</span> + filter.getDataAuthority(z).getHost());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【3.4.3】allowFilterResult 方法也是在 IntentResolver 的子类中实现！</span></span><br><span class="line">        <span class="comment">// 判断我们是否已经添加过这个 filter！</span></span><br><span class="line">        <span class="keyword">if</span> (!allowFilterResult(filter, dest)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (debug) &#123;</span><br><span class="line">                Slog.v(TAG, <span class="string">"  Filter's target already added"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【2】进行匹配操作，结果返回值 match &gt;= 0，说明匹配成功！</span></span><br><span class="line">        match = filter.match(action, resolvedType, scheme, data, categories, TAG);</span><br><span class="line">        <span class="keyword">if</span> (match &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (debug) Slog.v(TAG, <span class="string">"  Filter matched!  match=0x"</span> +</span><br><span class="line">                    Integer.toHexString(match) + <span class="string">" hasDefault="</span></span><br><span class="line">                    + filter.hasCategory(Intent.CATEGORY_DEFAULT));</span><br><span class="line">            <span class="keyword">if</span> (!defaultOnly || filter.hasCategory(Intent.CATEGORY_DEFAULT)) &#123;</span><br><span class="line">                <span class="comment">//【3.4.4】创建 ResolveList 对象！</span></span><br><span class="line">                <span class="comment">// newResult 方法也是在 IntentResolver 的子类中实现中实现</span></span><br><span class="line">                <span class="keyword">final</span> R oneResult = newResult(filter, match, userId);</span><br><span class="line">                <span class="keyword">if</span> (oneResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//【2.2】添加到目标集合 dest 中！</span></span><br><span class="line">                    dest.add(oneResult);</span><br><span class="line">                    <span class="keyword">if</span> (debug) &#123;</span><br><span class="line">                        dumpFilter(logPrintWriter, <span class="string">"    "</span>, filter);</span><br><span class="line">                        logPrintWriter.flush();</span><br><span class="line">                        filter.dump(logPrinter, <span class="string">"    "</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                hasNonDefaults = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (debug) &#123;</span><br><span class="line">                String reason;</span><br><span class="line">                <span class="keyword">switch</span> (match) &#123;</span><br><span class="line">                    <span class="keyword">case</span> IntentFilter.NO_MATCH_ACTION: reason = <span class="string">"action"</span>; <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> IntentFilter.NO_MATCH_CATEGORY: reason = <span class="string">"category"</span>; <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> IntentFilter.NO_MATCH_DATA: reason = <span class="string">"data"</span>; <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> IntentFilter.NO_MATCH_TYPE: reason = <span class="string">"type"</span>; <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">default</span>: reason = <span class="string">"unknown reason"</span>; <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                Slog.v(TAG, <span class="string">"  Filter did not match: "</span> + reason);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (debug &amp;&amp; hasNonDefaults) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dest.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            Slog.v(TAG, <span class="string">"resolveIntent failed: found match, but none with CATEGORY_DEFAULT"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dest.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            Slog.v(TAG, <span class="string">"resolveIntent: multiple matches, only some with CATEGORY_DEFAULT"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法流程很简单，我们来看一些细节！</p>
<h3 id="3-4-1-ActivityIntentResolver-ActivityIntentResolver-isFilterStopped"><a href="#3-4-1-ActivityIntentResolver-ActivityIntentResolver-isFilterStopped" class="headerlink" title="3.4.1 ActivityIntentResolver ActivityIntentResolver.isFilterStopped"></a>3.4.1 ActivityIntentResolver ActivityIntentResolver.isFilterStopped</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isFilterStopped</span><span class="params">(PackageParser.ActivityIntentInfo filter, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!sUserManager.exists(userId)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    PackageParser.Package p = filter.activity.owner;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        PackageSetting ps = (PackageSetting)p.mExtras;</span><br><span class="line">        <span class="keyword">if</span> (ps != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (ps.pkgFlags&amp;ApplicationInfo.FLAG_SYSTEM) == <span class="number">0</span></span><br><span class="line">                    &amp;&amp; ps.getStopped(userId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>isFilterStopped 方法用来判断 filter 所属的应用是否被强行停止了，返回 true 的情况如下：</p>
<ul>
<li>设备用户 id 不存在；</li>
<li>filter 所属的应用是非系统应用，且应用的 stoped 属性被置为 true；</li>
</ul>
<p>该方法返回  true，表示该应用在该设备用户下，被强制停止了！</p>
<h3 id="3-4-2-ActivityIntentResolver-isPackageForFilter"><a href="#3-4-2-ActivityIntentResolver-isPackageForFilter" class="headerlink" title="3.4.2 ActivityIntentResolver.isPackageForFilter"></a>3.4.2 ActivityIntentResolver.isPackageForFilter</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isPackageForFilter</span><span class="params">(String packageName,</span></span></span><br><span class="line"><span class="function"><span class="params">        PackageParser.ActivityIntentInfo info)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】就是匹配下 package name！</span></span><br><span class="line">    <span class="keyword">return</span> packageName.equals(info.activity.owner.packageName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法很简单，不用多说了，就是判断 Intent 设置的包名和 filter 所属的应用的包名是不是一样的！一样的话，说明该应用是广播的目标应用！</p>
<h3 id="3-4-3-ActivityIntentResolver-allowFilterResult"><a href="#3-4-3-ActivityIntentResolver-allowFilterResult" class="headerlink" title="3.4.3 ActivityIntentResolver.allowFilterResult"></a>3.4.3 ActivityIntentResolver.allowFilterResult</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">allowFilterResult</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        PackageParser.ActivityIntentInfo filter, List&lt;ResolveInfo&gt; dest)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【1】获得 filter 所属的组件的 ActivityInfo 对象！</span></span><br><span class="line">    ActivityInfo filterAi = filter.activity.info;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=dest.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">        ActivityInfo destAi = dest.get(i).activityInfo;</span><br><span class="line">        <span class="keyword">if</span> (destAi.name == filterAi.name</span><br><span class="line">                &amp;&amp; destAi.packageName == filterAi.packageName) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法的作用是是否重复添加过同一个 filter，判断依据是：要被添加的 filter 的组件名和包名是否和 dest 集合中的某个 filter 一样！！</p>
<p>ActivityInfo 是对应组件的信息对象，ActivityInfo.name 这个值来自于 android:name 属性！！</p>
<h3 id="3-4-4-ActivityIntentResolver-newResult"><a href="#3-4-4-ActivityIntentResolver-newResult" class="headerlink" title="3.4.4 ActivityIntentResolver.newResult"></a>3.4.4 ActivityIntentResolver.newResult</h3><p>最后，就是将 ActivityIntentInfo 对象封装为 ResolveInfo 对象了！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> ResolveInfo <span class="title">newResult</span><span class="params">(PackageParser.ActivityIntentInfo info,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> match, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【1】如果设备用户不存在，返回 null；</span></span><br><span class="line">    <span class="keyword">if</span> (!sUserManager.exists(userId)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (!mSettings.isEnabledAndMatchLPr(info.activity.info, mFlags, userId)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> PackageParser.Activity activity = info.activity;</span><br><span class="line">    PackageSetting ps = (PackageSetting) activity.owner.mExtras;</span><br><span class="line">    <span class="keyword">if</span> (ps == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【2】获得组件新的 ActivityInfo 拷贝对象 ai！</span></span><br><span class="line">    ActivityInfo ai = PackageParser.generateActivityInfo(activity, mFlags,</span><br><span class="line">            ps.readUserState(userId), userId);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ai == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【3】创建一个 ResolveInfo 对象 res，并设置 res.activityInfo 为 ai；</span></span><br><span class="line">    <span class="keyword">final</span> ResolveInfo res = <span class="keyword">new</span> ResolveInfo();</span><br><span class="line">    res.activityInfo = ai;</span><br><span class="line">    <span class="keyword">if</span> ((mFlags&amp;PackageManager.GET_RESOLVED_FILTER) != <span class="number">0</span>) &#123;</span><br><span class="line">        res.filter = info;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (info != <span class="keyword">null</span>) &#123;</span><br><span class="line">        res.handleAllWebDataURI = info.handleAllWebDataURI();</span><br><span class="line">    &#125;</span><br><span class="line">    res.priority = info.getPriority();</span><br><span class="line">    res.preferredOrder = activity.owner.mPreferredOrder;</span><br><span class="line">    <span class="comment">//System.out.println("Result: " + res.activityInfo.className +</span></span><br><span class="line">    <span class="comment">//                   " = " + res.priority);</span></span><br><span class="line">    res.match = match;</span><br><span class="line">    res.isDefault = info.hasDefault;</span><br><span class="line">    res.labelRes = info.labelRes;</span><br><span class="line">    res.nonLocalizedLabel = info.nonLocalizedLabel;</span><br><span class="line">    <span class="keyword">if</span> (userNeedsBadging(userId)) &#123;</span><br><span class="line">        res.noResourceId = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res.icon = info.icon;</span><br><span class="line">    &#125;</span><br><span class="line">    res.iconResourceId = info.icon;</span><br><span class="line">    <span class="comment">//【4】是否是系统应用！</span></span><br><span class="line">    res.system = res.activityInfo.applicationInfo.isSystemApp();</span><br><span class="line">    <span class="comment">//【5】返回我们创建的新的 ResolveInfo 对象！</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>到这里，我们就知道了如何查询系统中所有注册过的广播接收者了！</p>
<h1 id="4-总结！"><a href="#4-总结！" class="headerlink" title="4 总结！"></a>4 总结！</h1><p>我们来看看广播的静态注册的类关系图：</p>
<h2 id="4-1-静态注册类关系图"><a href="#4-1-静态注册类关系图" class="headerlink" title="4.1 静态注册类关系图"></a>4.1 静态注册类关系图</h2><p>PMS 解析了静态注册的广播接收者后，数据结婚间的关系图如下：</p>
<p><img src="http://static.zybuluo.com/Coolqi/rx01mfez26ljxjxoykphjyr7/%E5%B9%BF%E6%92%AD%E9%9D%99%E6%80%81%E6%B3%A8%E5%86%8C.png" alt="广播静态注册.png-169.5kB"></p>
<h2 id="4-2-查询注册结果关系图"><a href="#4-2-查询注册结果关系图" class="headerlink" title="4.2 查询注册结果关系图"></a>4.2 查询注册结果关系图</h2></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2016/05/04/BroadcastReceiver篇 3 - unregisterReceiver 和 TimeOut 流程分析/">BroadcastReceiver篇 3 - unregisterReceiver 和 TimeOut 流程分析</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2016-05-04</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/AndroidFramework源码分析/">AndroidFramework源码分析</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/AndroidFramework源码分析/BroadcastReceiver广播接收者/">BroadcastReceiver广播接收者</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/BroadcastReceiver广播接收者/">BroadcastReceiver广播接收者</a></span><div class="content"><p>[toc]</p>
<p>基于 Android 7.1.1 源码，分析 BroadcastReceiver <strong>动态注册</strong> 的过程，转载请说明出处！</p>
<h1 id="0-综述"><a href="#0-综述" class="headerlink" title="0 综述"></a>0 综述</h1><p>BroadcastReceiver 动态注册后，需要动态取消注册：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unregisterReceiver</span><span class="params">(BroadcastReceiver receiver)</span></span>;</span><br></pre></td></tr></table></figure>
<p>下面，我们来进入源码，分析 <code>unregisterReceiver</code> 的流程！</p>
<h1 id="1-应用进程"><a href="#1-应用进程" class="headerlink" title="1 应用进程"></a>1 应用进程</h1><p>我们先去应用进程来看下：</p>
<h2 id="1-1-ContextWrapper-unregisterReceiver"><a href="#1-1-ContextWrapper-unregisterReceiver" class="headerlink" title="1.1 ContextWrapper.unregisterReceiver"></a>1.1 ContextWrapper.unregisterReceiver</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unregisterReceiver</span><span class="params">(BroadcastReceiver receiver)</span> </span>&#123;</span><br><span class="line">    mBase.unregisterReceiver(receiver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 <code>mBase</code> 为 <code>ContextImpl</code> 实例！</p>
<h2 id="1-2-ContextImpl-unregisterReceiver"><a href="#1-2-ContextImpl-unregisterReceiver" class="headerlink" title="1.2 ContextImpl.unregisterReceiver"></a>1.2 ContextImpl.unregisterReceiver</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unregisterReceiver</span><span class="params">(BroadcastReceiver receiver)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mPackageInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//【*1.2.1】获得接收者对应的 InnerReceiver 对象！</span></span><br><span class="line">        IIntentReceiver rd = mPackageInfo.forgetReceiverDispatcher(</span><br><span class="line">                getOuterContext(), receiver);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【*1.2.2】进入系统进程，取消动态接收者的注册！</span></span><br><span class="line">            <span class="comment">// 这是同步调用！</span></span><br><span class="line">            ActivityManagerNative.getDefault().unregisterReceiver(rd);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Not supported in system context"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mPackageInfo 是 LoadedApk 实例，用来保存应用程序的加载信息，每一个进程都会有一个！</p>
<p>这里我们来分析下：</p>
<h3 id="1-2-1-LoadedApk-forgetReceiverDispatcher"><a href="#1-2-1-LoadedApk-forgetReceiverDispatcher" class="headerlink" title="1.2.1 LoadedApk.forgetReceiverDispatcher"></a>1.2.1 LoadedApk.forgetReceiverDispatcher</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IIntentReceiver <span class="title">forgetReceiverDispatcher</span><span class="params">(Context context,</span></span></span><br><span class="line"><span class="function"><span class="params">        BroadcastReceiver r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mReceivers) &#123;</span><br><span class="line">        <span class="comment">//【1】首先，获得当前设备用户下，动态注册的所有接收者的 map 表！</span></span><br><span class="line">        ArrayMap&lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&gt; map = mReceivers.get(context);</span><br><span class="line">        LoadedApk.ReceiverDispatcher rd = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//【1.2】获得该接收者对应的 ReceiverDispatcher 对象！</span></span><br><span class="line">            rd = map.get(r);</span><br><span class="line">            <span class="keyword">if</span> (rd != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//【1.3】从 map 表中移除该 rd 对象！</span></span><br><span class="line">                map.remove(r);</span><br><span class="line">                <span class="keyword">if</span> (map.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                    mReceivers.remove(context);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//【1.4】只有设置了 debug 模式，才会进入！</span></span><br><span class="line">                <span class="keyword">if</span> (r.getDebugUnregister()) &#123;</span><br><span class="line">                    ArrayMap&lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&gt; holder</span><br><span class="line">                            = mUnregisteredReceivers.get(context);</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//【1.5】会将该接触注册的接收者添加到 mUnregisteredReceivers 集合中！</span></span><br><span class="line">                    <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        holder = <span class="keyword">new</span> ArrayMap&lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&gt;();</span><br><span class="line">                        mUnregisteredReceivers.put(context, holder);</span><br><span class="line">                    &#125;</span><br><span class="line">                    RuntimeException ex = <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                            <span class="string">"Originally unregistered here:"</span>);</span><br><span class="line">                    ex.fillInStackTrace();</span><br><span class="line">                    rd.setUnregisterLocation(ex);</span><br><span class="line">                    holder.put(r, rd);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//【1.6】设置 ReceiverDispatcher 对象的 mForgotten 值为 true！</span></span><br><span class="line">                rd.mForgotten = <span class="keyword">true</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//【1.7】返回内部的 InnerReceiver 对象！</span></span><br><span class="line">                <span class="keyword">return</span> rd.getIIntentReceiver();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【2】每个动态注册的接收者都只能被 unregisteredReceivers 一次，不然会抛出异常！</span></span><br><span class="line">        ArrayMap&lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&gt; holder</span><br><span class="line">                = mUnregisteredReceivers.get(context);</span><br><span class="line">        <span class="keyword">if</span> (holder != <span class="keyword">null</span>) &#123;</span><br><span class="line">            rd = holder.get(r);</span><br><span class="line">            <span class="keyword">if</span> (rd != <span class="keyword">null</span>) &#123;</span><br><span class="line">                RuntimeException ex = rd.getUnregisterLocation();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                        <span class="string">"Unregistering Receiver "</span> + r</span><br><span class="line">                        + <span class="string">" that was already unregistered"</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (context == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unbinding Receiver "</span> + r</span><br><span class="line">                    + <span class="string">" from Context that is no longer in use: "</span> + context);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Receiver not registered: "</span> + r);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法的主要作用是：</p>
<ul>
<li>删除 ReceiverDispatcher 对象；</li>
<li>返回接收者对应的 InnerReceiver 对象；</li>
</ul>
<p>继续来看：</p>
<h3 id="1-2-2-ActivityManagerProxy-unregisterReceiver"><a href="#1-2-2-ActivityManagerProxy-unregisterReceiver" class="headerlink" title="1.2.2 ActivityManagerProxy.unregisterReceiver"></a>1.2.2 ActivityManagerProxy.unregisterReceiver</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unregisterReceiver</span><span class="params">(IIntentReceiver receiver)</span> <span class="keyword">throws</span> RemoteException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Parcel data = Parcel.obtain();</span><br><span class="line">    Parcel reply = Parcel.obtain();</span><br><span class="line">    data.writeInterfaceToken(IActivityManager.descriptor);</span><br><span class="line">    data.writeStrongBinder(receiver.asBinder());</span><br><span class="line">    <span class="comment">//【1】Binder 通信：UNREGISTER_RECEIVER_TRANSACTION</span></span><br><span class="line">    mRemote.transact(UNREGISTER_RECEIVER_TRANSACTION, data, reply, <span class="number">0</span>);</span><br><span class="line">    reply.readException();</span><br><span class="line">    data.recycle();</span><br><span class="line">    reply.recycle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面会进入系统进程，我们直接去看！</p>
<h1 id="2-系统进程"><a href="#2-系统进程" class="headerlink" title="2 系统进程"></a>2 系统进程</h1><p>首先会进入 ActivityManagerN 中去：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> UNREGISTER_RECEIVER_TRANSACTION:</span><br><span class="line">&#123;</span><br><span class="line">    data.enforceInterface(IActivityManager.descriptor);</span><br><span class="line">    IBinder b = data.readStrongBinder();</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【1】这里将客户端的 InnerReceiver 转为了服务端的 IIntentReceiver.Proxy 对象！</span></span><br><span class="line">    IIntentReceiver rec = IIntentReceiver.Stub.asInterface(b);</span><br><span class="line">    <span class="comment">//【2】继续调用 unregisterReceiver，解除注册！</span></span><br><span class="line">    unregisterReceiver(rec);</span><br><span class="line">    reply.writeNoException();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>进入 ActivityManagerS 中去！</p>
<h2 id="2-1-ActivityManagerS-unregisterReceiver"><a href="#2-1-ActivityManagerS-unregisterReceiver" class="headerlink" title="2.1 ActivityManagerS.unregisterReceiver"></a>2.1 ActivityManagerS.unregisterReceiver</h2><p>这里的 receiver 是接收者在系统进程中的 Binder 对象！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unregisterReceiver</span><span class="params">(IIntentReceiver receiver)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, <span class="string">"Unregister receiver: "</span> + receiver);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> doTrim = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">//【1】获得对应的 ReceiverList 过滤器对象！</span></span><br><span class="line">            ReceiverList rl = mRegisteredReceivers.get(receiver.asBinder());</span><br><span class="line">            <span class="keyword">if</span> (rl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//【2.1.1】判断接收者是否在处理有序发送的广播，如果在处理广播，就要立刻结束处理！</span></span><br><span class="line">                <span class="keyword">final</span> BroadcastRecord r = rl.curBroadcast;</span><br><span class="line">                <span class="keyword">if</span> (r != <span class="keyword">null</span> &amp;&amp; r == r.queue.getMatchingOrderedReceiver(r)) &#123;</span><br><span class="line">                    <span class="comment">//【×2.1.2】立刻结束广播处理！</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">boolean</span> doNext = r.queue.finishReceiverLocked(</span><br><span class="line">                            r, r.resultCode, r.resultData, r.resultExtras,</span><br><span class="line">                            r.resultAbort, <span class="keyword">false</span>);</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//【2】继续分发广播！</span></span><br><span class="line">                    <span class="keyword">if</span> (doNext) &#123;</span><br><span class="line">                        doTrim = <span class="keyword">true</span>;</span><br><span class="line">                        r.queue.processNextBroadcast(<span class="keyword">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (rl.app != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    rl.app.receivers.remove(rl);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//【×2.1.3】移除该广播接收者！</span></span><br><span class="line">                removeReceiverLocked(rl);</span><br><span class="line">                <span class="comment">//【5】如果绑定了死亡监听，就取消绑定！</span></span><br><span class="line">                <span class="keyword">if</span> (rl.linkedToDeath) &#123;</span><br><span class="line">                    rl.linkedToDeath = <span class="keyword">false</span>;</span><br><span class="line">                    rl.receiver.asBinder().unlinkToDeath(rl, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【6】回收资源！</span></span><br><span class="line">        <span class="keyword">if</span> (doTrim) &#123;</span><br><span class="line">            trimApplications();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码主要作用：</p>
<ul>
<li>如果当前接收者正在处理有序发送的广播，那就立刻结束处理；</li>
<li>对于有序发送的广播，继续分发广播；</li>
<li>移除当前接收者，同时解除绑定；</li>
</ul>
<p>我们继续分析细节！</p>
<h3 id="2-1-1-BroadcastQueue-getMatchingOrderedReceiver"><a href="#2-1-1-BroadcastQueue-getMatchingOrderedReceiver" class="headerlink" title="2.1.1 BroadcastQueue.getMatchingOrderedReceiver"></a>2.1.1 BroadcastQueue.getMatchingOrderedReceiver</h3><p>该方法用来判断当前是否有有序分发的广播发送给当前的广播！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BroadcastRecord <span class="title">getMatchingOrderedReceiver</span><span class="params">(IBinder receiver)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mOrderedBroadcasts.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> BroadcastRecord r = mOrderedBroadcasts.get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (r != <span class="keyword">null</span> &amp;&amp; r.receiver == receiver) &#123;</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>判断依据很简单：当有序发送的广播指定了某个动态接收者时，其 <code>r.receiver</code> 会保存接收者对应的 <code>IIntentReceiver.Proxy</code> 对象！</p>
<h3 id="2-1-2-BroadcastQueue-finishReceiverLocked"><a href="#2-1-2-BroadcastQueue-finishReceiverLocked" class="headerlink" title="2.1.2 BroadcastQueue.finishReceiverLocked"></a>2.1.2 BroadcastQueue.finishReceiverLocked</h3><p>立刻结束广播的处理，注意：这里的 <code>waitForServices</code> 传入的是 <code>false</code>，结果表示是否 finish 完成！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">finishReceiverLocked</span><span class="params">(BroadcastRecord r, <span class="keyword">int</span> resultCode,</span></span></span><br><span class="line"><span class="function"><span class="params">        String resultData, Bundle resultExtras, <span class="keyword">boolean</span> resultAbort, <span class="keyword">boolean</span> waitForServices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> state = r.state;</span><br><span class="line">    <span class="keyword">final</span> ActivityInfo receiver = r.curReceiver;</span><br><span class="line">    <span class="comment">//【1】初始化广播的状态为 BroadcastRecord.IDLE！</span></span><br><span class="line">    r.state = BroadcastRecord.IDLE;</span><br><span class="line">    <span class="keyword">if</span> (state == BroadcastRecord.IDLE) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"finishReceiver ["</span> + mQueueName + <span class="string">"] called but state is IDLE"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【2】清空广播的当前目标接收者 Binder 实体！</span></span><br><span class="line">    r.receiver = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//【3】清空广播的 Intent 组件信息！</span></span><br><span class="line">    r.intent.setComponent(<span class="keyword">null</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【4】清空广播目标进程的 curReceiver！</span></span><br><span class="line">    <span class="keyword">if</span> (r.curApp != <span class="keyword">null</span> &amp;&amp; r.curApp.curReceiver == r) &#123;</span><br><span class="line">        r.curApp.curReceiver = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【5】清空广播目标 filter 所在的接收者处理的当前广播；</span></span><br><span class="line">    <span class="keyword">if</span> (r.curFilter != <span class="keyword">null</span>) &#123;</span><br><span class="line">        r.curFilter.receiverList.curBroadcast = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    r.curFilter = <span class="keyword">null</span>;</span><br><span class="line">    r.curReceiver = <span class="keyword">null</span>;</span><br><span class="line">    r.curApp = <span class="keyword">null</span>;</span><br><span class="line">    mPendingBroadcast = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//【6】保存了和返回的结果码等信息；</span></span><br><span class="line">    r.resultCode = resultCode;</span><br><span class="line">    r.resultData = resultData;</span><br><span class="line">    r.resultExtras = resultExtras;</span><br><span class="line">    <span class="comment">//【7】是否忽视结果；</span></span><br><span class="line">    <span class="keyword">if</span> (resultAbort &amp;&amp; (r.intent.getFlags()&amp;Intent.FLAG_RECEIVER_NO_ABORT) == <span class="number">0</span>) &#123;</span><br><span class="line">        r.resultAbort = resultAbort;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        r.resultAbort = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【8】因为 waitForServices 不进入该分支！</span></span><br><span class="line">    <span class="keyword">if</span> (waitForServices &amp;&amp; r.curComponent != <span class="keyword">null</span> &amp;&amp; r.queue.mDelayBehindServices</span><br><span class="line">            &amp;&amp; r.queue.mOrderedBroadcasts.size() &gt; <span class="number">0</span></span><br><span class="line">            &amp;&amp; r.queue.mOrderedBroadcasts.get(<span class="number">0</span>) == r) &#123;</span><br><span class="line">        ActivityInfo nextReceiver;</span><br><span class="line">        <span class="keyword">if</span> (r.nextReceiver &lt; r.receivers.size()) &#123;</span><br><span class="line">            Object obj = r.receivers.get(r.nextReceiver);</span><br><span class="line">            nextReceiver = (obj <span class="keyword">instanceof</span> ActivityInfo) ? (ActivityInfo)obj : <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nextReceiver = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (receiver == <span class="keyword">null</span> || nextReceiver == <span class="keyword">null</span></span><br><span class="line">                || receiver.applicationInfo.uid != nextReceiver.applicationInfo.uid</span><br><span class="line">                || !receiver.processName.equals(nextReceiver.processName)) &#123;</span><br><span class="line">            <span class="comment">//【8.1】延迟结束该广播的本次分发！</span></span><br><span class="line">            <span class="keyword">if</span> (mService.mServices.hasBackgroundServices(r.userId)) &#123;</span><br><span class="line">                Slog.i(TAG, <span class="string">"Delay finish: "</span> + r.curComponent.flattenToShortString());</span><br><span class="line">                r.state = BroadcastRecord.WAITING_SERVICES;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r.curComponent = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【9】判断广播的状态！</span></span><br><span class="line">    <span class="keyword">return</span> state == BroadcastRecord.APP_RECEIVE</span><br><span class="line">            || state == BroadcastRecord.CALL_DONE_RECEIVE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个过程主要有以下的目的：</p>
<ul>
<li>初始化广播的属性，为下次分发做准备；</li>
<li>然后根据广播的状态，判断是否需要继续分发；</li>
</ul>
<p>对于有序发送广播，如果其目标接收者为动态注册，那么广播的状态为 <code>BroadcastRecord.CALL_DONE_RECEIVE</code>, 这里就会返回 true!</p>
<p>这里在 sendBroadcast 流程中有讲，这里就不再细说了！</p>
<h3 id="2-1-3-ActivityManagerS-removeReceiverLocked"><a href="#2-1-3-ActivityManagerS-removeReceiverLocked" class="headerlink" title="2.1.3 ActivityManagerS.removeReceiverLocked"></a>2.1.3 ActivityManagerS.removeReceiverLocked</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeReceiverLocked</span><span class="params">(ReceiverList rl)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】从动态注册的接收者列表中移除该接收者！</span></span><br><span class="line">    mRegisteredReceivers.remove(rl.receiver.asBinder());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = rl.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">//【2】移除该接收者的 filter！</span></span><br><span class="line">        mReceiverResolver.removeFilter(rl.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法逻辑很简单；</p>
<ul>
<li>从 <strong>mRegisteredReceivers</strong> 中删除该动态注册的接收者；</li>
<li>从 <strong>mReceiverResolver</strong> 中删除该动态注册的接收者对应的过滤器对象；</li>
</ul>
<h1 id="3-TimeOut-流程分析"><a href="#3-TimeOut-流程分析" class="headerlink" title="3 TimeOut 流程分析"></a>3 TimeOut 流程分析</h1><p>下面我们来看看广播的超时处理！</p>
<h2 id="3-1-设置超时"><a href="#3-1-设置超时" class="headerlink" title="3.1 设置超时"></a>3.1 设置超时</h2><p>对于有序发送的广播（注意：不是有序广播），是会设置超时处理，防止一个接收者的处理超时，导致其他接收者无法接收到广播。设置超时的地方是在 <code>processNextBroadcast</code> 方法中：</p>
<h3 id="3-1-1-BroadcastQueue-processNextBroadcast"><a href="#3-1-1-BroadcastQueue-processNextBroadcast" class="headerlink" title="3.1.1 BroadcastQueue.processNextBroadcast"></a>3.1.1 BroadcastQueue.processNextBroadcast</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">r.receiverTime = SystemClock.uptimeMillis();</span><br><span class="line"><span class="keyword">if</span> (recIdx == <span class="number">0</span>) &#123;</span><br><span class="line">    r.dispatchTime = r.receiverTime;</span><br><span class="line">    r.dispatchClockTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, <span class="string">"Processing ordered broadcast ["</span></span><br><span class="line">            + mQueueName + <span class="string">"] "</span> + r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!mPendingBroadcastTimeoutMessage) &#123;</span><br><span class="line">    <span class="comment">//【1】计算超时时间点，时间为 r.receiverTime 加上 mTimeoutPeriod！</span></span><br><span class="line">    <span class="keyword">long</span> timeoutTime = r.receiverTime + mTimeoutPeriod;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,</span><br><span class="line">            <span class="string">"Submitting BROADCAST_TIMEOUT_MSG ["</span></span><br><span class="line">            + mQueueName + <span class="string">"] for "</span> + r + <span class="string">" at "</span> + timeoutTime);</span><br><span class="line">            </span><br><span class="line">    <span class="comment">//【×3.1.2】设置超时任务！</span></span><br><span class="line">    setBroadcastTimeoutLocked(timeoutTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次在有序发送广播给接收者的时候，会设置 <code>r.receiverTime</code> 的值，超时是基于这个值来计算的！</p>
<p><code>mPendingBroadcastTimeoutMessage</code> 表示当前是否有超时的消息被处理，默认是为 false！</p>
<p><code>timeoutTime</code> 是超时任务的触发时间点，系统会该时间点发送 <code>BROADCAST_TIMEOUT_MSG</code>消息，系统进程主线程会处理该消息！</p>
<p><code>mTimeoutPeriod</code> 表示超时周期，是一段时间间隔！前台队列和后台队列的 <code>mTimeoutPeriod</code> 是不一样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mFgBroadcastQueue = <span class="keyword">new</span> BroadcastQueue(<span class="keyword">this</span>, mHandler,</span><br><span class="line">        <span class="string">"foreground"</span>, BROADCAST_FG_TIMEOUT, <span class="keyword">false</span>);</span><br><span class="line">mBgBroadcastQueue = <span class="keyword">new</span> BroadcastQueue(<span class="keyword">this</span>, mHandler,</span><br><span class="line">        <span class="string">"background"</span>, BROADCAST_BG_TIMEOUT, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>
<p>对于<strong>前台队列</strong>，超时周期为 10 s：<code>static final int BROADCAST_FG_TIMEOUT = 10*1000;</code></p>
<p>对于<strong>后台队列</strong>，超时周期为 60 s：<code>static final int BROADCAST_BG_TIMEOUT = 60*1000;</code></p>
<h3 id="3-1-2-BroadcastQueue-setBroadcastTimeoutLocked"><a href="#3-1-2-BroadcastQueue-setBroadcastTimeoutLocked" class="headerlink" title="3.1.2 BroadcastQueue.setBroadcastTimeoutLocked"></a>3.1.2 BroadcastQueue.setBroadcastTimeoutLocked</h3><p>设置超时消息！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setBroadcastTimeoutLocked</span><span class="params">(<span class="keyword">long</span> timeoutTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mPendingBroadcastTimeoutMessage) &#123;</span><br><span class="line">        Message msg = mHandler.obtainMessage(BROADCAST_TIMEOUT_MSG, <span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//【1】发送消息！</span></span><br><span class="line">        mHandler.sendMessageAtTime(msg, timeoutTime);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【2】将 mPendingBroadcastTimeoutMessage 置为 true！</span></span><br><span class="line">        mPendingBroadcastTimeoutMessage = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>超时时间点到了后，会发送 <code>BROADCAST_TIMEOUT_MSG</code> 消息给系统进程主线程的 Handler 处理！</p>
<h3 id="3-1-3-BroadcastHandler-handleMessage-BROADCAST-TIMEOUT-MSG"><a href="#3-1-3-BroadcastHandler-handleMessage-BROADCAST-TIMEOUT-MSG" class="headerlink" title="3.1.3 BroadcastHandler.handleMessage[BROADCAST_TIMEOUT_MSG]"></a>3.1.3 BroadcastHandler.handleMessage[BROADCAST_TIMEOUT_MSG]</h3><p>这里只列举重点的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">     <span class="keyword">case</span> BROADCAST_TIMEOUT_MSG: &#123;</span><br><span class="line">         <span class="keyword">synchronized</span> (mService) &#123;</span><br><span class="line">             <span class="comment">//【×3.1.4】处理广播超时！</span></span><br><span class="line">             broadcastTimeoutLocked(<span class="keyword">true</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-1-4-BroadcastQueue-broadcastTimeoutLocked"><a href="#3-1-4-BroadcastQueue-broadcastTimeoutLocked" class="headerlink" title="3.1.4 BroadcastQueue.broadcastTimeoutLocked"></a>3.1.4 BroadcastQueue.broadcastTimeoutLocked</h3><p>执行超时任务的处理，此时 fromMsg 为 true，因为是通过 BroadcastHandler 触发的超时处理！！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">broadcastTimeoutLocked</span><span class="params">(<span class="keyword">boolean</span> fromMsg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fromMsg) &#123;</span><br><span class="line">        mPendingBroadcastTimeoutMessage = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【1】有序发送的广播队列为空，不处理，返回！</span></span><br><span class="line">    <span class="keyword">if</span> (mOrderedBroadcasts.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】获得超时的广播，因为每次发送的时候，都是从 mOrderedBroadcasts 的 0 index 处获取广播！</span></span><br><span class="line">    BroadcastRecord r = mOrderedBroadcasts.get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fromMsg) &#123;</span><br><span class="line">        <span class="comment">//【2.1】如果系统正在进行 odex 优化，就延迟超时任务的处理，并返回！</span></span><br><span class="line">        <span class="keyword">if</span> (mService.mDidDexOpt) &#123;</span><br><span class="line">            mService.mDidDexOpt = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【×3.1.2】这里延长了 time out 的时间！</span></span><br><span class="line">            <span class="keyword">long</span> timeoutTime = SystemClock.uptimeMillis() + mTimeoutPeriod;</span><br><span class="line">            setBroadcastTimeoutLocked(timeoutTime);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【2.2】系统进程没有准备好，返回！</span></span><br><span class="line">        <span class="keyword">if</span> (!mService.mProcessesReady) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【2.3】如果当前时间没到超时时间点，说明没有超时，再次重置任务，返回！</span></span><br><span class="line">        <span class="keyword">long</span> timeoutTime = r.receiverTime + mTimeoutPeriod;</span><br><span class="line">        <span class="keyword">if</span> (timeoutTime &gt; now) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,</span><br><span class="line">                    <span class="string">"Premature timeout ["</span></span><br><span class="line">                    + mQueueName + <span class="string">"] @ "</span> + now + <span class="string">": resetting BROADCAST_TIMEOUT_MSG for "</span></span><br><span class="line">                    + timeoutTime);</span><br><span class="line">            <span class="comment">//【×3.1.2】重新设置超时时间点！</span></span><br><span class="line">            setBroadcastTimeoutLocked(timeoutTime);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BroadcastRecord br = mOrderedBroadcasts.get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【3】判断广播的状态，如果此时是 WAITING_SERVICES，说明当前的接收者已经处理完毕，</span></span><br><span class="line">    <span class="comment">// 但是需要等待目标进程后台服务启动后，才能发送给下一个接收者！</span></span><br><span class="line">    <span class="keyword">if</span> (br.state == BroadcastRecord.WAITING_SERVICES) &#123;</span><br><span class="line"></span><br><span class="line">        Slog.i(TAG, <span class="string">"Waited long enough for: "</span> + (br.curComponent != <span class="keyword">null</span></span><br><span class="line">                ? br.curComponent.flattenToShortString() : <span class="string">"(null)"</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【3.1】如果此时触发了该广播的超时任务，就直接初始化广播属性，发送给下一个接收者，然后返回！</span></span><br><span class="line">        br.curComponent = <span class="keyword">null</span>;</span><br><span class="line">        br.state = BroadcastRecord.IDLE;</span><br><span class="line">        <span class="comment">//【3.2】继续分发！</span></span><br><span class="line">        processNextBroadcast(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Slog.w(TAG, <span class="string">"Timeout of broadcast "</span> + r + <span class="string">" - receiver="</span> + r. receiver</span><br><span class="line">            + <span class="string">", started "</span> + (now - r.receiverTime) + <span class="string">"ms ago"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【4】广播的接收时间设置为当前！</span></span><br><span class="line">    r.receiverTime = now;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【5】广播的 ANR 次数加 1；</span></span><br><span class="line">    r.anrCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Current receiver has passed its expiration date.</span></span><br><span class="line">    <span class="keyword">if</span> (r.nextReceiver &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"Timeout on receiver with nextReceiver &lt;= 0"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ProcessRecord app = <span class="keyword">null</span>;</span><br><span class="line">    String anrMessage = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【7】设置广播的当前接收者的分发状态为 BroadcastRecord.DELIVERY_TIMEOUT，表示分发超时！</span></span><br><span class="line">    Object curReceiver = r.receivers.get(r.nextReceiver-<span class="number">1</span>);</span><br><span class="line">    r.delivery[r.nextReceiver-<span class="number">1</span>] = BroadcastRecord.DELIVERY_TIMEOUT;</span><br><span class="line"></span><br><span class="line">    Slog.w(TAG, <span class="string">"Receiver during timeout: "</span> + curReceiver);</span><br><span class="line"></span><br><span class="line">    logBroadcastReceiverDiscardLocked(r);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【8】获得广播接收者所在的进程！</span></span><br><span class="line">    <span class="keyword">if</span> (curReceiver <span class="keyword">instanceof</span> BroadcastFilter) &#123;</span><br><span class="line">        BroadcastFilter bf = (BroadcastFilter)curReceiver;</span><br><span class="line">        <span class="keyword">if</span> (bf.receiverList.pid != <span class="number">0</span></span><br><span class="line">                &amp;&amp; bf.receiverList.pid != ActivityManagerService.MY_PID) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mService.mPidsSelfLocked) &#123;</span><br><span class="line">                app = mService.mPidsSelfLocked.get(</span><br><span class="line">                        bf.receiverList.pid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        app = r.curApp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【9】广播处理超时后，会导致 ANR 的问题，这里是设置 ANR 的信息！</span></span><br><span class="line">    <span class="keyword">if</span> (app != <span class="keyword">null</span>) &#123;</span><br><span class="line">        anrMessage = <span class="string">"Broadcast of "</span> + r.intent.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【10】如果正在进程启动的广播！</span></span><br><span class="line">    <span class="keyword">if</span> (mPendingBroadcast == r) &#123;</span><br><span class="line">        mPendingBroadcast = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【11】结束当前的接收者；</span></span><br><span class="line">    finishReceiverLocked(r, r.resultCode, r.resultData,</span><br><span class="line">            r.resultExtras, r.resultAbort, <span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">//【12】将广播发送给下一个接收者；</span></span><br><span class="line">    scheduleBroadcastsLocked();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (anrMessage != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//【×3.1.5】发送 ANR 消息！</span></span><br><span class="line">        mHandler.post(<span class="keyword">new</span> AppNotResponding(app, anrMessage));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数的逻辑梳理如下：</p>
<ul>
<li><strong>1</strong> 如果有序列表集合 <code>mOrderedBroadcasts</code> 为空，不做任何处理，直接返回；</li>
<li><strong>2</strong> 如果系统正在进行 <code>odex</code> 优化，就延迟超时任务的处理，并返回；</li>
<li><strong>3</strong> 系统进程没有准备好，不做任何处理，直接返回；</li>
<li><strong>4</strong> 如果超时处理提前触发了，就重置超时处理，并返回；</li>
<li><strong>5</strong> 如果当前广播的状态是 <code>BroadcastRecord.WAITING_SERVICES</code>，说明当前接受者已经处理完毕了，但是该广播在等待后台服务的启动，那就初始化广播属性，直接发送给下一个接受者，返回！</li>
</ul>
<p>如果以上条件不满足，那么该广播处理超时会导致 <code>ANR</code> 的问题：</p>
<ul>
<li>设置当前接收者的分发状态为：<code>BroadcastRecord.DELIVERY_TIMEOUT</code></li>
<li>获得下一个广播接收者进程 <code>ProcessRecord</code></li>
<li>结束当前的接收者 <code>finishReceiverLocked</code>；</li>
<li>将广播发送给下一个接收者 <code>scheduleBroadcastsLocked</code>;</li>
</ul>
<p>最后，就是很关键的一步了：</p>
<ul>
<li>创建一个 <code>Runable</code>，主线程会执行该任务，抛出 <code>ANR</code> 异常！</li>
</ul>
<h3 id="3-1-5-new-AppNotResponding"><a href="#3-1-5-new-AppNotResponding" class="headerlink" title="3.1.5 new AppNotResponding"></a>3.1.5 new AppNotResponding</h3><p><code>AppNotResponding</code> 继承了 <code>Runnable</code>，我们来看看它的 <code>run</code> 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AppNotResponding</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ProcessRecord mApp;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String mAnnotation;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AppNotResponding</span><span class="params">(ProcessRecord app, String annotation)</span> </span>&#123;</span><br><span class="line">        mApp = app;</span><br><span class="line">        mAnnotation = annotation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mService.mAppErrors.appNotResponding(mApp, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>, mAnnotation);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>系统进程的主线程会执行该 <code>Runable</code>，<code>AppNotResponding</code> 会调用 <code>mAppErrors.appNotResponding</code> 方法处理接收者进程的 <code>ANR</code>!</p>
<p>这里我简单的提一下，<code>AppErrors</code> 是 <code>ActivityManagerService</code> 专门用来处理系统和应用的 <code>ANR</code> 和 <code>Crash</code> 的类！</p>
<p>后面会写一篇文章来详细分析其处理的过程，这里就不先不细说了！！</p>
<h2 id="3-2-取消超时"><a href="#3-2-取消超时" class="headerlink" title="3.2 取消超时"></a>3.2 取消超时</h2><p>当有序发送的广播及时处理后，我们会取消超时消息，我们回到 processNextBroadcast 方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">processNextBroadcast</span><span class="params">(<span class="keyword">boolean</span> fromMsg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(mService) &#123;</span><br><span class="line">        ... ... ...</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mOrderedBroadcasts.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                mService.scheduleAppGcsLocked();</span><br><span class="line">                <span class="keyword">if</span> (looped) &#123;</span><br><span class="line">                    mService.updateOomAdjLocked();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            r = mOrderedBroadcasts.get(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">boolean</span> forceReceive = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            ... ... ... ...</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//【1】当有序发送的广播发送完成或者被终止的时候，会 remove 掉该超时消息！</span></span><br><span class="line">            <span class="keyword">if</span> (r.receivers == <span class="keyword">null</span> || r.nextReceiver &gt;= numReceivers</span><br><span class="line">                    || r.resultAbort || forceReceive) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (r.resultTo != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.i(TAG_BROADCAST,</span><br><span class="line">                                <span class="string">"Finishing broadcast ["</span> + mQueueName + <span class="string">"] "</span></span><br><span class="line">                                + r.intent.getAction() + <span class="string">" app="</span> + r.callerApp);</span><br><span class="line">                        performReceiveLocked(r.callerApp, r.resultTo,</span><br><span class="line">                            <span class="keyword">new</span> Intent(r.intent), r.resultCode,</span><br><span class="line">                            r.resultData, r.resultExtras, <span class="keyword">false</span>, <span class="keyword">false</span>, r.userId);</span><br><span class="line">                        r.resultTo = <span class="keyword">null</span>;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                        r.resultTo = <span class="keyword">null</span>;</span><br><span class="line">                        Slog.w(TAG, <span class="string">"Failure ["</span></span><br><span class="line">                                + mQueueName + <span class="string">"] sending broadcast result of "</span></span><br><span class="line">                                + r.intent, e);</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//【3.2.1】移除超时消息！</span></span><br><span class="line">                cancelBroadcastTimeoutLocked();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST,</span><br><span class="line">                        <span class="string">"Finished with ordered broadcast "</span> + r);</span><br><span class="line"></span><br><span class="line">                addBroadcastToHistoryLocked(r);</span><br><span class="line">                <span class="keyword">if</span> (r.intent.getComponent() == <span class="keyword">null</span> &amp;&amp; r.intent.getPackage() == <span class="keyword">null</span></span><br><span class="line">                        &amp;&amp; (r.intent.getFlags()&amp;Intent.FLAG_RECEIVER_REGISTERED_ONLY) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// This was an implicit broadcast... let's record it for posterity.</span></span><br><span class="line">                    mService.addBroadcastStatLocked(r.intent.getAction(), r.callerPackage,</span><br><span class="line">                            r.manifestCount, r.manifestSkipCount, r.finishTime-r.dispatchTime);</span><br><span class="line">                &#125;</span><br><span class="line">                mOrderedBroadcasts.remove(<span class="number">0</span>);</span><br><span class="line">                r = <span class="keyword">null</span>;</span><br><span class="line">                looped = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (r == <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<p>这里可以看到，只有在广播发送完成或者被终止的时候，才会移除消息！</p>
<p>因为每次有序发送广播的时候，都会重新设置超时消息，具体的逻辑见：processNextBroadcast 方法！</p>
<h3 id="3-2-1-BroadcastQueue-cancelBroadcastTimeoutLocked"><a href="#3-2-1-BroadcastQueue-cancelBroadcastTimeoutLocked" class="headerlink" title="3.2.1 BroadcastQueue.cancelBroadcastTimeoutLocked"></a>3.2.1 BroadcastQueue.cancelBroadcastTimeoutLocked</h3><p>取消广播超时消息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">cancelBroadcastTimeoutLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mPendingBroadcastTimeoutMessage) &#123;</span><br><span class="line">        mHandler.removeMessages(BROADCAST_TIMEOUT_MSG, <span class="keyword">this</span>);</span><br><span class="line">        mPendingBroadcastTimeoutMessage = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h1><p>关于 <code>unregisterReceiver</code> 和 <code>TimeOut</code> 超时处理的逻辑就分析到这里！</p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2019 By Coolqi.Li</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.6"></script><script src="/js/fancybox.js?version=1.5.6"></script><script src="/js/sidebar.js?version=1.5.6"></script><script src="/js/copy.js?version=1.5.6"></script><script src="/js/fireworks.js?version=1.5.6"></script><script src="/js/transition.js?version=1.5.6"></script><script src="/js/scroll.js?version=1.5.6"></script><script src="/js/head.js?version=1.5.6"></script><script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"live2d-widget-model-hijiki"},"display":{"position":"right","width":110,"height":220},"mobile":{"show":false},"log":false});</script></body></html>