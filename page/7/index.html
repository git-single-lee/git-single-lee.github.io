<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="“你好，我是李帅奇，Android 系统工程师，MineCraft 忠实玩家，设计和绘画爱好者，缺妹纸晚期患者，熬夜星人。”"><meta name="keywords" content=""><meta name="author" content="Coolqi.Li,undefined"><meta name="copyright" content="Coolqi.Li"><title>Every day is always sleepy. | Coolqi`s Blog</title><link rel="shortcut icon" href="/my-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.5.6"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.5.6"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Coolqi.Li</div><div class="author-info__description text-center">“你好，我是李帅奇，Android 系统工程师，MineCraft 忠实玩家，设计和绘画爱好者，缺妹纸晚期患者，熬夜星人。”</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">64</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">14</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">15</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Coolqi`s Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">Coolqi`s Blog</div><div id="site-sub-title">Every day is always sleepy.</div></div></nav><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Coolqi.Li</div><div class="author-info__description text-center">“你好，我是李帅奇，Android 系统工程师，MineCraft 忠实玩家，设计和绘画爱好者，缺妹纸晚期患者，熬夜星人。”</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">64</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">14</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">15</span></a></div></div></div><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2016/03/19/Process篇 2 - Android 进程的创建/">Process篇 2 - Android 进程的创建</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2016-03-19</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/AndroidFramework源码分析/">AndroidFramework源码分析</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/AndroidFramework源码分析/Process进程/">Process进程</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Process进程/">Process进程</a></span><div class="content"><p>[toc]</p>
<p>基于 Android 7.1.1 源码，分析进程的创建！</p>
<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>当 Android 系统在启动一个应用进程时，如果发现某个进程没有创建，那就要先创建这个进程， Android 系统中每一个应用进程，包括 SystemServer 进程都是由 Zygote 直接孵化出来的！</p>
<p>本片文章，就来总结下进程的 fork 流程！</p>
<h1 id="2-Process-prepare-fork"><a href="#2-Process-prepare-fork" class="headerlink" title="2 Process - prepare fork"></a>2 Process - prepare fork</h1><p>我们来继续看：</p>
<h2 id="2-1-Process-start"><a href="#2-1-Process-start" class="headerlink" title="2.1 Process.start"></a>2.1 Process.start</h2><p>框架层开始创建进程会调用 Process.start 方法，我们进入这个方法来看看：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ProcessStartResult <span class="title">start</span><span class="params">(<span class="keyword">final</span> String processClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">final</span> String niceName,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> uid, <span class="keyword">int</span> gid, <span class="keyword">int</span>[] gids,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> debugFlags, <span class="keyword">int</span> mountExternal,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> targetSdkVersion,</span></span></span><br><span class="line"><span class="function"><span class="params">                              String seInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                              String abi,</span></span></span><br><span class="line"><span class="function"><span class="params">                              String instructionSet,</span></span></span><br><span class="line"><span class="function"><span class="params">                              String appDataDir,</span></span></span><br><span class="line"><span class="function"><span class="params">                              String[] zygoteArgs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//【1】这里是进入 Zygote 方法了！</span></span><br><span class="line">        <span class="keyword">return</span> startViaZygote(processClass, niceName, uid, gid, gids,</span><br><span class="line">                debugFlags, mountExternal, targetSdkVersion, seInfo,</span><br><span class="line">                abi, instructionSet, appDataDir, zygoteArgs);</span><br><span class="line">                </span><br><span class="line">    &#125; <span class="keyword">catch</span> (ZygoteStartFailedEx ex) &#123;</span><br><span class="line">        Log.e(LOG_TAG,</span><br><span class="line">                <span class="string">"Starting VM process through Zygote failed"</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Starting VM process through Zygote failed"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-2-Process-startViaZygote"><a href="#2-2-Process-startViaZygote" class="headerlink" title="2.2 Process.startViaZygote"></a>2.2 Process.startViaZygote</h2><p>我们接着来看，进入了：startViaZygote 方法，参数传递：</p>
<ul>
<li>final String processClass,</li>
<li>final String niceName,</li>
<li>final int uid, </li>
<li>final int gid,</li>
<li>final int[] gids,</li>
<li>int debugFlags, </li>
<li>int mountExternal,</li>
<li>int targetSdkVersion,</li>
<li>String seInfo,</li>
<li>tring abi,</li>
<li>String instructionSet,</li>
<li>String appDataDir,</li>
<li>String[] extraArgs<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ProcessStartResult <span class="title">startViaZygote</span><span class="params">(<span class="keyword">final</span> String processClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">final</span> String niceName,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">final</span> <span class="keyword">int</span> uid, <span class="keyword">final</span> <span class="keyword">int</span> gid,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">final</span> <span class="keyword">int</span>[] gids,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> debugFlags, <span class="keyword">int</span> mountExternal,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> targetSdkVersion,</span></span></span><br><span class="line"><span class="function"><span class="params">                              String seInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                              String abi,</span></span></span><br><span class="line"><span class="function"><span class="params">                              String instructionSet,</span></span></span><br><span class="line"><span class="function"><span class="params">                              String appDataDir,</span></span></span><br><span class="line"><span class="function"><span class="params">                              String[] extraArgs)</span></span></span><br><span class="line"><span class="function">                              <span class="keyword">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(Process.class) &#123;</span><br><span class="line">        <span class="comment">//【1】创建 cmd 命令libeia！ </span></span><br><span class="line">        ArrayList&lt;String&gt; argsForZygote = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// --runtime-args, --setuid=, --setgid=,</span></span><br><span class="line">        <span class="comment">// and --setgroups= must go first</span></span><br><span class="line">        argsForZygote.add(<span class="string">"--runtime-args"</span>);</span><br><span class="line">        argsForZygote.add(<span class="string">"--setuid="</span> + uid);</span><br><span class="line">        argsForZygote.add(<span class="string">"--setgid="</span> + gid);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> ((debugFlags &amp; Zygote.DEBUG_ENABLE_JNI_LOGGING) != <span class="number">0</span>) &#123;</span><br><span class="line">            argsForZygote.add(<span class="string">"--enable-jni-logging"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((debugFlags &amp; Zygote.DEBUG_ENABLE_SAFEMODE) != <span class="number">0</span>) &#123;</span><br><span class="line">            argsForZygote.add(<span class="string">"--enable-safemode"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((debugFlags &amp; Zygote.DEBUG_ENABLE_DEBUGGER) != <span class="number">0</span>) &#123;</span><br><span class="line">            argsForZygote.add(<span class="string">"--enable-debugger"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((debugFlags &amp; Zygote.DEBUG_ENABLE_CHECKJNI) != <span class="number">0</span>) &#123;</span><br><span class="line">            argsForZygote.add(<span class="string">"--enable-checkjni"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((debugFlags &amp; Zygote.DEBUG_GENERATE_DEBUG_INFO) != <span class="number">0</span>) &#123;</span><br><span class="line">            argsForZygote.add(<span class="string">"--generate-debug-info"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((debugFlags &amp; Zygote.DEBUG_ALWAYS_JIT) != <span class="number">0</span>) &#123;</span><br><span class="line">            argsForZygote.add(<span class="string">"--always-jit"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((debugFlags &amp; Zygote.DEBUG_NATIVE_DEBUGGABLE) != <span class="number">0</span>) &#123;</span><br><span class="line">            argsForZygote.add(<span class="string">"--native-debuggable"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((debugFlags &amp; Zygote.DEBUG_ENABLE_ASSERT) != <span class="number">0</span>) &#123;</span><br><span class="line">            argsForZygote.add(<span class="string">"--enable-assert"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mountExternal == Zygote.MOUNT_EXTERNAL_DEFAULT) &#123;</span><br><span class="line">            argsForZygote.add(<span class="string">"--mount-external-default"</span>);</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mountExternal == Zygote.MOUNT_EXTERNAL_READ) &#123;</span><br><span class="line">            argsForZygote.add(<span class="string">"--mount-external-read"</span>);</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mountExternal == Zygote.MOUNT_EXTERNAL_WRITE) &#123;</span><br><span class="line">            argsForZygote.add(<span class="string">"--mount-external-write"</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        argsForZygote.add(<span class="string">"--target-sdk-version="</span> + targetSdkVersion);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//TODO optionally enable debuger</span></span><br><span class="line">        <span class="comment">//argsForZygote.add("--enable-debugger");</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// --setgroups is a comma-separated list</span></span><br><span class="line">        <span class="keyword">if</span> (gids != <span class="keyword">null</span> &amp;&amp; gids.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            sb.append(<span class="string">"--setgroups="</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> sz = gids.length;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">                    sb.append(<span class="string">','</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                sb.append(gids[i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            argsForZygote.add(sb.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (niceName != <span class="keyword">null</span>) &#123;</span><br><span class="line">            argsForZygote.add(<span class="string">"--nice-name="</span> + niceName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (seInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">            argsForZygote.add(<span class="string">"--seinfo="</span> + seInfo);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (instructionSet != <span class="keyword">null</span>) &#123;</span><br><span class="line">            argsForZygote.add(<span class="string">"--instruction-set="</span> + instructionSet);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (appDataDir != <span class="keyword">null</span>) &#123;</span><br><span class="line">            argsForZygote.add(<span class="string">"--app-data-dir="</span> + appDataDir);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        argsForZygote.add(processClass);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (extraArgs != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String arg : extraArgs) &#123;</span><br><span class="line">                argsForZygote.add(arg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【2.3】接着调用 zygoteSendArgsAndGetResult 方法，让爱更进一步！</span></span><br><span class="line">        <span class="keyword">return</span> zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这个的过程是生成 argsForZygote 数组，里面分装了 Zygote 需要的参数！！</p>
<h3 id="2-2-1-Process-openZygoteSocketIfNeeded"><a href="#2-2-1-Process-openZygoteSocketIfNeeded" class="headerlink" title="2.2.1 Process.openZygoteSocketIfNeeded"></a>2.2.1 Process.openZygoteSocketIfNeeded</h3><p>这里调用了 openZygoteSocketIfNeeded 方法，根据当前的 abi 选择 Zygote 的位数：32 位还是 64 位的,然后连接 Zygote，并返回 Zygote 的引用对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ZygoteState <span class="title">openZygoteSocketIfNeeded</span><span class="params">(String abi)</span> <span class="keyword">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (primaryZygoteState == <span class="keyword">null</span> || primaryZygoteState.isClosed()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//【1】连接主zygote！ </span></span><br><span class="line">            primaryZygoteState = ZygoteState.connect(ZYGOTE_SOCKET);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(<span class="string">"Error connecting to primary zygote"</span>, ioe);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (primaryZygoteState.matches(abi)) &#123;</span><br><span class="line">        <span class="comment">//【2】主 Zygote 能和 abi 匹配，返回主 Zygote！</span></span><br><span class="line">        <span class="keyword">return</span> primaryZygoteState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (secondaryZygoteState == <span class="keyword">null</span> || secondaryZygoteState.isClosed()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//【3】主 Zygote 不能匹配，连接第二个zygote！ </span></span><br><span class="line">            secondaryZygoteState = ZygoteState.connect(SECONDARY_ZYGOTE_SOCKET);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(<span class="string">"Error connecting to secondary zygote"</span>, ioe);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (secondaryZygoteState.matches(abi)) &#123;</span><br><span class="line">        <span class="comment">//【4】返回第二个 Zygote！</span></span><br><span class="line">        <span class="keyword">return</span> secondaryZygoteState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(<span class="string">"Unsupported zygote ABI: "</span> + abi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们接着下面来看！</p>
<h2 id="2-3-Process-zygoteSendArgsAndGetResult"><a href="#2-3-Process-zygoteSendArgsAndGetResult" class="headerlink" title="2.3 Process.zygoteSendArgsAndGetResult"></a>2.3 Process.zygoteSendArgsAndGetResult</h2><p>最后，发送参数列表给 Zygote 进程，Zygote 进程会 fork 一个子进程，并返回子进程的 pid！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ProcessStartResult <span class="title">zygoteSendArgsAndGetResult</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ZygoteState zygoteState, ArrayList&lt;String&gt; args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//【1】判断输入参数格式是是否正确，中间不能有换行符！</span></span><br><span class="line">        <span class="keyword">int</span> sz = args.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (args.get(i).indexOf(<span class="string">'\n'</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(<span class="string">"embedded newlines not allowed"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> BufferedWriter writer = zygoteState.writer; <span class="comment">// 用于向 Zygote 写入数据！</span></span><br><span class="line">        <span class="keyword">final</span> DataInputStream inputStream = zygoteState.inputStream; <span class="comment">// 用于获得 Zygote 的返回数据！ </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//【2】首先，写入参数的个数！</span></span><br><span class="line">        writer.write(Integer.toString(args.size()));</span><br><span class="line">        writer.newLine();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            String arg = args.get(i);</span><br><span class="line">            <span class="comment">//【2.1】写入每一个参数</span></span><br><span class="line">            writer.write(arg);</span><br><span class="line">            writer.newLine();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【3】flush BufferedWriter，参数会被写到 ZygoteConnection 对象的 abiList 集合中！</span></span><br><span class="line">        writer.flush();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【4】创建 ProcessStartResult 实例，记录启动结果，包括 pid</span></span><br><span class="line">        ProcessStartResult result = <span class="keyword">new</span> ProcessStartResult();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【5】systemServer 进入阻塞等待状态，直到进程创建成功，返回子进程的 pid！</span></span><br><span class="line">        result.pid = inputStream.readInt();</span><br><span class="line">        result.usingWrapper = inputStream.readBoolean();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result.pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(<span class="string">"fork() failed"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        zygoteState.close();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法的主要功能：通过 socket 向 Zygote 进程发送一个参数列表，然后进入阻塞等待状态，直到远端的 Socket 服务端发送回来新创建的进程 pid 才返回！！</p>
<p>以上这些过程仍然在 SystemServer 进程中，接下来，就要进入 Zygote 进程了！！！</p>
<h1 id="3-Zygote-fork-Process"><a href="#3-Zygote-fork-Process" class="headerlink" title="3 Zygote - fork Process"></a>3 Zygote - fork Process</h1><h2 id="3-1-ZygoteInit-main"><a href="#3-1-ZygoteInit-main" class="headerlink" title="3.1 ZygoteInit.main"></a>3.1 ZygoteInit.main</h2><p>接着是，进入了 Zygote 进程，我们先去看看 Zygote 的 main 方法看看：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String argv[])</span> </span>&#123;</span><br><span class="line">    ZygoteHooks.startZygoteNoThreadCreation();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        ... ... ...<span class="comment">// 这部分代码是启动 Zygote 时触发的，这个省略不看！</span></span><br><span class="line"></span><br><span class="line">        Log.i(TAG, <span class="string">"Accepting command socket connections"</span>);</span><br><span class="line">        <span class="comment">//【3.2】进入 runSeletLoop 方法！</span></span><br><span class="line">        runSelectLoop(abiList);</span><br><span class="line"></span><br><span class="line">        closeServerSocket();</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (MethodAndArgsCaller caller) &#123;</span><br><span class="line">        <span class="comment">//【3.4】上面的 runSelectLoop 方法会抛出 MethodAndArgsCaller 异常就会进入 caller.run 方法</span></span><br><span class="line">        <span class="comment">// 我们后面再看！</span></span><br><span class="line">        caller.run();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"Zygote died with exception"</span>, ex);</span><br><span class="line">        closeServerSocket();</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接着来看，进入了 runSelectLoop 方法，runSelectLoop 是一个死循环，不断的读取发送到 Zygote 的消息！</p>
<h2 id="3-2-ZygoteInit-runSelectLoop"><a href="#3-2-ZygoteInit-runSelectLoop" class="headerlink" title="3.2 ZygoteInit.runSelectLoop"></a>3.2 ZygoteInit.runSelectLoop</h2><p>这个方法很关键，在 openZygoteSocketIfNeeded 方法中，System Sever 会通过 Socket 建立和 Zygote 进程的连接，并向 Zygote 写入执行参数！</p>
<p>而 ZygoteInit.runSelectLoop 会创建一个循环，不断的读取 abiList 中的指令，进行处理！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runSelectLoop</span><span class="params">(String abiList)</span> <span class="keyword">throws</span> MethodAndArgsCaller </span>&#123;</span><br><span class="line">    ArrayList&lt;FileDescriptor&gt; fds = <span class="keyword">new</span> ArrayList&lt;FileDescriptor&gt;();</span><br><span class="line">    ArrayList&lt;ZygoteConnection&gt; peers = <span class="keyword">new</span> ArrayList&lt;ZygoteConnection&gt;();</span><br><span class="line"></span><br><span class="line">    fds.add(sServerSocket.getFileDescriptor());</span><br><span class="line">    peers.add(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【1】采用 I / O 多路复用机制，当客户端发出连接请求或者数据处理请求时，跳过 continue，执行后面的代码</span></span><br><span class="line">        StructPollfd[] pollFds = <span class="keyword">new</span> StructPollfd[fds.size()];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pollFds.length; ++i) &#123;</span><br><span class="line">            pollFds[i] = <span class="keyword">new</span> StructPollfd();</span><br><span class="line">            pollFds[i].fd = fds.get(i);</span><br><span class="line">            pollFds[i].events = (<span class="keyword">short</span>) POLLIN;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Os.poll(pollFds, -<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ErrnoException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"poll failed"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = pollFds.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((pollFds[i].revents &amp; POLLIN) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//【2】接收到客户端的连接请求，创建 ZygoteConnection 对象！</span></span><br><span class="line">                ZygoteConnection newPeer = acceptCommandPeer(abiList);</span><br><span class="line"></span><br><span class="line">                peers.add(newPeer);</span><br><span class="line">                fds.add(newPeer.getFileDesciptor());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//【3.3】执行 ZygoteConnection 的 runOnce 方法！</span></span><br><span class="line">                <span class="keyword">boolean</span> done = peers.get(i).runOnce();</span><br><span class="line">                <span class="keyword">if</span> (done) &#123;</span><br><span class="line">                    peers.remove(i);</span><br><span class="line">                    fds.remove(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没有连接请求时会进入休眠状态，当有创建新进程的连接请求时，唤醒 Zygote 进程，创建 Socket 通道 ZygoteConnection，然后执行 ZygoteConnection 的 runOnce() 方法。</p>
<h2 id="3-3-ZygoteConnection-runOnce"><a href="#3-3-ZygoteConnection-runOnce" class="headerlink" title="3.3 ZygoteConnection.runOnce"></a>3.3 ZygoteConnection.runOnce</h2><p>这里我们看到 runOnce 方法会抛出一个 MethodAndArgsCaller 异常，但实际上 MethodAndArgsCaller 并不是在 runOnce 中抛出的！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">runOnce</span><span class="params">()</span> <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line"></span><br><span class="line">    String args[];</span><br><span class="line">    Arguments parsedArgs = <span class="keyword">null</span>;</span><br><span class="line">    FileDescriptor[] descriptors;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//【1】读取socket客户端发送过来的参数列表。</span></span><br><span class="line">        args = readArgumentList();</span><br><span class="line"></span><br><span class="line">        descriptors = mSocket.getAncillaryFileDescriptors();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">"IOException on command socket "</span> + ex.getMessage());</span><br><span class="line">        closeSocket();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (args == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// EOF reached.</span></span><br><span class="line">        closeSocket();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** the stderr of the most recent request, if avail */</span></span><br><span class="line">    PrintStream newStderr = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (descriptors != <span class="keyword">null</span> &amp;&amp; descriptors.length &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">        newStderr = <span class="keyword">new</span> PrintStream(</span><br><span class="line">                <span class="keyword">new</span> FileOutputStream(descriptors[<span class="number">2</span>]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pid = -<span class="number">1</span>;</span><br><span class="line">    FileDescriptor childPipeFd = <span class="keyword">null</span>;</span><br><span class="line">    FileDescriptor serverPipeFd = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//【2】将 Socket 客户端传递过来的参数，解析成 Arguments 对象格式。</span></span><br><span class="line">        parsedArgs = <span class="keyword">new</span> Arguments(args);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (parsedArgs.abiListQuery) &#123;</span><br><span class="line">            <span class="keyword">return</span> handleAbiListQuery();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (parsedArgs.permittedCapabilities != <span class="number">0</span> || parsedArgs.effectiveCapabilities != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteSecurityException(<span class="string">"Client may not specify capabilities: "</span> +</span><br><span class="line">                    <span class="string">"permitted=0x"</span> + Long.toHexString(parsedArgs.permittedCapabilities) +</span><br><span class="line">                    <span class="string">", effective=0x"</span> + Long.toHexString(parsedArgs.effectiveCapabilities));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        applyUidSecurityPolicy(parsedArgs, peer);</span><br><span class="line">        applyInvokeWithSecurityPolicy(parsedArgs, peer);</span><br><span class="line"></span><br><span class="line">        applyDebuggerSystemProperty(parsedArgs);</span><br><span class="line">        applyInvokeWithSystemProperty(parsedArgs);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] rlimits = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (parsedArgs.rlimits != <span class="keyword">null</span>) &#123;</span><br><span class="line">            rlimits = parsedArgs.rlimits.toArray(intArray2d);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (parsedArgs.invokeWith != <span class="keyword">null</span>) &#123;</span><br><span class="line">            FileDescriptor[] pipeFds = Os.pipe2(O_CLOEXEC);</span><br><span class="line">            childPipeFd = pipeFds[<span class="number">1</span>];</span><br><span class="line">            serverPipeFd = pipeFds[<span class="number">0</span>];</span><br><span class="line">            Os.fcntlInt(childPipeFd, F_SETFD, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> [] fdsToClose = &#123; -<span class="number">1</span>, -<span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line">        FileDescriptor fd = mSocket.getFileDescriptor();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fd != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fdsToClose[<span class="number">0</span>] = fd.getInt$();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fd = ZygoteInit.getServerSocketFileDescriptor();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fd != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fdsToClose[<span class="number">1</span>] = fd.getInt$();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fd = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【3.3.1】这边是 Zygote 处理传入的参数，fork 子进程，返回 2 次</span></span><br><span class="line">        <span class="comment">// 分别进入父进程 Zygote 和新子进程中去！</span></span><br><span class="line">        pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,</span><br><span class="line">                parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,</span><br><span class="line">                parsedArgs.niceName, fdsToClose, parsedArgs.instructionSet,</span><br><span class="line">                parsedArgs.appDataDir);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (ErrnoException ex) &#123;</span><br><span class="line">        logAndPrintError(newStderr, <span class="string">"Exception creating pipe"</span>, ex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">        logAndPrintError(newStderr, <span class="string">"Invalid zygote arguments"</span>, ex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ZygoteSecurityException ex) &#123;</span><br><span class="line">        logAndPrintError(newStderr,</span><br><span class="line">                <span class="string">"Zygote security policy prevents request: "</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//【4】fork一次，会返回两次，如果返回的是 0，表示当前是是在子进程中，</span></span><br><span class="line">        <span class="comment">// 如果返回值 &gt; 0，那当前就是在父进程中！</span></span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//【4.1】pid 为 0，在子进程中处理！</span></span><br><span class="line">            IoUtils.closeQuietly(serverPipeFd);</span><br><span class="line">            serverPipeFd = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【3.3.2】子进程执行，这里会抛出异常：MethodAndArgsCaller！</span></span><br><span class="line">            handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//【4.2】pid 大于 0，在父进程！</span></span><br><span class="line">            IoUtils.closeQuietly(childPipeFd);</span><br><span class="line">            childPipeFd = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【3.3.3】父进程 Zygote 执行！</span></span><br><span class="line">            <span class="keyword">return</span> handleParentProc(pid, descriptors, serverPipeFd, parsedArgs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        IoUtils.closeQuietly(childPipeFd);</span><br><span class="line">        IoUtils.closeQuietly(serverPipeFd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-1-Zygote-forkAndSpecialize-fork-子进程核心阶段"><a href="#3-3-1-Zygote-forkAndSpecialize-fork-子进程核心阶段" class="headerlink" title="3.3.1 Zygote.forkAndSpecialize - fork 子进程核心阶段"></a>3.3.1 Zygote.forkAndSpecialize - fork 子进程核心阶段</h3><p>这里开始 Fork 子进程！！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">forkAndSpecialize</span><span class="params">(<span class="keyword">int</span> uid, <span class="keyword">int</span> gid, <span class="keyword">int</span>[] gids, <span class="keyword">int</span> debugFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span>[][] rlimits, <span class="keyword">int</span> mountExternal, String seInfo, String niceName, <span class="keyword">int</span>[] fdsToClose,</span></span></span><br><span class="line"><span class="function"><span class="params">      String instructionSet, String appDataDir)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【3.3.1.1】fork 前的准备工作</span></span><br><span class="line">    VM_HOOKS.preFork();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【3.3.1.2】这里是 fork 子进程，调用了一个 naitve 方法。这个方法会返回 2 次！</span></span><br><span class="line">    <span class="keyword">int</span> pid = nativeForkAndSpecialize(</span><br><span class="line">              uid, gid, gids, debugFlags, rlimits, mountExternal, seInfo, niceName, fdsToClose,</span><br><span class="line">              instructionSet, appDataDir);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 监控子进程，直到 handleChildProc 结束！</span></span><br><span class="line">        Trace.setTracingEnabled(<span class="keyword">true</span>);</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"PostFork"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【3.3.1.3】fork 结束后的相关操作！</span></span><br><span class="line">    VM_HOOKS.postForkCommon();</span><br><span class="line">    <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里有一变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ZygoteHooks VM_HOOKS = <span class="keyword">new</span> ZygoteHooks();</span><br></pre></td></tr></table></figure>
<p>nativeForkAndSpecialize 方法会返回 2 次，一次 pid 为 0，表示是在子进程中；一次 pid 大于 0，表示是在 Zygote 进程中，意味着，postForkCommon 会执行 2 次！</p>
<p>接着来看：</p>
<h4 id="3-3-1-1-ZygoteHooks-preFork-fork-准备工作"><a href="#3-3-1-1-ZygoteHooks-preFork-fork-准备工作" class="headerlink" title="3.3.1.1 ZygoteHooks.preFork - fork 准备工作"></a>3.3.1.1 ZygoteHooks.preFork - fork 准备工作</h4><p>ZygoteHooks 的源码位于：D:\google\libcore\dalvik\src\main\java\dalvik\system\ZygoteHooks.java </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preFork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【3.3.1.1.1】停止 4 个 Daemon 子线程</span></span><br><span class="line">    Daemons.stop(); </span><br><span class="line">    <span class="comment">//【3.3.1.1.2】等待所有子线程结束</span></span><br><span class="line">    waitUntilAllThreadsStopped();</span><br><span class="line">    <span class="comment">//【3.3.1.1.3】完成 gc 堆的初始化工作</span></span><br><span class="line">    token = nativePreFork(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-3-1-1-1-Daemons-stop"><a href="#3-3-1-1-1-Daemons-stop" class="headerlink" title="3.3.1.1.1 Daemons.stop"></a>3.3.1.1.1 Daemons.stop</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HeapTaskDaemon.INSTANCE.stop();          <span class="comment">// Java堆整理线程</span></span><br><span class="line">    ReferenceQueueDaemon.INSTANCE.stop();    <span class="comment">// 引用队列线程</span></span><br><span class="line">    FinalizerDaemon.INSTANCE.stop();         <span class="comment">// 析构线程</span></span><br><span class="line">    FinalizerWatchdogDaemon.INSTANCE.stop(); <span class="comment">// 析构监控线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Zygote 是有 4 个子线程的，这里是需要停止这四个子线程，为 fork 操作空出资源来！</p>
<p>此处守护线程 Stop 方式是先调用目标线程 interrrupt 方法，然后再调用目标线程 join 方法，等待线程执行完成。</p>
<h5 id="3-3-1-1-2-ZygoteHooks-waitUntilAllThreadsStopped"><a href="#3-3-1-1-2-ZygoteHooks-waitUntilAllThreadsStopped" class="headerlink" title="3.3.1.1.2 ZygoteHooks.waitUntilAllThreadsStopped"></a>3.3.1.1.2 ZygoteHooks.waitUntilAllThreadsStopped</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">waitUntilAllThreadsStopped</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    File tasks = <span class="keyword">new</span> File(<span class="string">"/proc/self/task"</span>);</span><br><span class="line">    <span class="comment">//【1】判断 "/proc/self/task" 这个文件的长度！！</span></span><br><span class="line">    <span class="keyword">while</span> (tasks.list().length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">//【2】调用 yield 方法，出让 cpu！</span></span><br><span class="line">      Thread.yield();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-3-1-1-3-ZygoteHooks-nativePreFork"><a href="#3-3-1-1-3-ZygoteHooks-nativePreFork" class="headerlink" title="3.3.1.1.3 ZygoteHooks.nativePreFork"></a>3.3.1.1.3 ZygoteHooks.nativePreFork</h5><p>nativePreFork 通过 JNI 最终调用的是 dalvik_system_ZygoteHooks.cc 中的 ZygoteHooks_nativePreFork() 方法，如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">ZygoteHooks_nativePreFork</span><span class="params">(JNIEnv* env, jclass)</span> </span>&#123;</span><br><span class="line">    Runtime* runtime = Runtime::Current();</span><br><span class="line">    CHECK(runtime-&gt;IsZygote()) &lt;&lt; <span class="string">"runtime instance not started with -Xzygote"</span>;</span><br><span class="line">    <span class="comment">//【3.3.1.1.3.1】运行时堆的初始化！</span></span><br><span class="line">    runtime-&gt;PreZygoteFork(); </span><br><span class="line">    <span class="keyword">if</span> (Trace::GetMethodTracingMode() != TracingMode::kTracingInactive) &#123;</span><br><span class="line">        Trace::Pause();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【1】将线程类型转换为 long 型并保存到 token，该过程是非安全的。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(ThreadForEnv(env));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出：ZygoteHooks.preFork 方法主要的作用是：停止 Zygote 的停止这四个子线程，确保 fork 进程时，Zygote 是单线程的，同时初始化 gc 堆！！</p>
<p>ZygoteHooks_nativePreFork</p>
<h6 id="3-3-1-1-3-1-Runtime-nativePreFork"><a href="#3-3-1-1-3-1-Runtime-nativePreFork" class="headerlink" title="3.3.1.1.3.1 Runtime:nativePreFork"></a>3.3.1.1.3.1 Runtime:nativePreFork</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Runtime::PreZygoteFork() &#123;</span><br><span class="line">    <span class="comment">// 堆的初始化工作。这里是关于 art 虚拟机的，这里后面再说。</span></span><br><span class="line">    heap_-&gt;PreZygoteFork();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-1-2-Zygote-nativeForkAndSpecialize-fork-子进程"><a href="#3-3-1-2-Zygote-nativeForkAndSpecialize-fork-子进程" class="headerlink" title="3.3.1.2 Zygote.nativeForkAndSpecialize - fork 子进程"></a>3.3.1.2 Zygote.nativeForkAndSpecialize - fork 子进程</h4><p>调用这个方法 nativeForkAndSpecialize 来进行 fork 进程！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">native</span> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nativeForkAndSpecialize</span><span class="params">(<span class="keyword">int</span> uid, <span class="keyword">int</span> gid, <span class="keyword">int</span>[] gids,<span class="keyword">int</span> debugFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span>[][] rlimits, <span class="keyword">int</span> mountExternal, String seInfo, String niceName, <span class="keyword">int</span>[] fdsToClose,</span></span></span><br><span class="line"><span class="function"><span class="params">      String instructionSet, String appDataDir)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这是一个本地方法，最后调用的是  com_android_internal_os_Zygote_nativeForkAndSpecialize 方法，位于 frameworks\base\core\jni\com_android_internal_os_Zygote.cpp 中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jint <span class="title">com_android_internal_os_Zygote_nativeForkAndSpecialize</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        JNIEnv* env, jclass, jint uid, jint gid, jintArray gids,</span></span></span><br><span class="line"><span class="function"><span class="params">        jint debug_flags, jobjectArray rlimits,</span></span></span><br><span class="line"><span class="function"><span class="params">        jint mount_external, jstring se_info, jstring se_name,</span></span></span><br><span class="line"><span class="function"><span class="params">        jintArray fdsToClose, jstring instructionSet, jstring appDataDir)</span> </span>&#123;</span><br><span class="line">    jlong capabilities = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】这里对子进程的 uid 如果是 AID_BLUETOOTH 的情况做了处理！</span></span><br><span class="line">    <span class="comment">// 给你额外增加了一些权限和功能！！</span></span><br><span class="line">    <span class="keyword">if</span> (multiuser_get_app_id(uid) == AID_BLUETOOTH) &#123;</span><br><span class="line">      capabilities |= (<span class="number">1L</span>L &lt;&lt; CAP_WAKE_ALARM);</span><br><span class="line">      capabilities |= (<span class="number">1L</span>L &lt;&lt; CAP_NET_RAW);</span><br><span class="line">      capabilities |= (<span class="number">1L</span>L &lt;&lt; CAP_NET_BIND_SERVICE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】如果子进程的 gid 是 AID_WAKELOCK，我们会授予他 CAP_BLOCK_SUSPEND 的权限！</span></span><br><span class="line">    <span class="keyword">bool</span> gid_wakelock_found = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (gid == AID_WAKELOCK) &#123;</span><br><span class="line">      gid_wakelock_found = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (gids != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="comment">//【3】如果子进程的 gids 中有 AID_WAKELOCK，会授予他 CAP_BLOCK_SUSPEND 的权限！</span></span><br><span class="line">      jsize gids_num = env-&gt;GetArrayLength(gids);</span><br><span class="line">      <span class="function">ScopedIntArrayRO <span class="title">ar</span><span class="params">(env, gids)</span></span>;</span><br><span class="line">      <span class="keyword">if</span> (ar.get() == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        RuntimeAbort(env, __LINE__, <span class="string">"Bad gids array"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; gids_num; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ar[i] == AID_WAKELOCK) &#123;</span><br><span class="line">          gid_wakelock_found = <span class="literal">true</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (gid_wakelock_found) &#123;</span><br><span class="line">      capabilities |= (<span class="number">1L</span>L &lt;&lt; CAP_BLOCK_SUSPEND);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【next】继续调用 ForkAndSpecializeCommon 方法！</span></span><br><span class="line">    <span class="keyword">return</span> ForkAndSpecializeCommon(env, uid, gid, gids, debug_flags,</span><br><span class="line">            rlimits, capabilities, capabilities, mount_external, se_info,</span><br><span class="line">            se_name, <span class="literal">false</span>, fdsToClose, instructionSet, appDataDir);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着，继续调用：ForkAndSpecializeCommon 方法，继续 fork！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> pid_t <span class="title">ForkAndSpecializeCommon</span><span class="params">(JNIEnv* env, uid_t uid, gid_t gid, jintArray javaGids,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     jint debug_flags, jobjectArray javaRlimits,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     jlong permittedCapabilities, jlong effectiveCapabilities,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     jint mount_external,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     jstring java_se_info, jstring java_se_name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     bool is_system_server, jintArray fdsToClose,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     jstring instructionSet, jstring dataDir)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//【1】设置子进程的 signal 信号处理函数! </span></span><br><span class="line">  SetSigChldHandler();</span><br><span class="line"></span><br><span class="line">#ifdef ENABLE_SCHED_BOOST</span><br><span class="line">  SetForkLoad(<span class="keyword">true</span>);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">  sigset_t sigchld;</span><br><span class="line">  sigemptyset(&amp;sigchld);</span><br><span class="line">  sigaddset(&amp;sigchld, SIGCHLD);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用 sigprocmask() 来暂时屏蔽/阻塞 SIGCHLD 信号，不然 SIGCHLD 信号会产生log，而被我们关闭掉的</span></span><br><span class="line">  <span class="comment">// logging 文件描述符会对这个信号进行响应，所以会报错</span></span><br><span class="line">  <span class="comment">// 到这里，zygote 进程就只有一个线程了！</span></span><br><span class="line">  <span class="keyword">if</span> (sigprocmask(SIG_BLOCK, &amp;sigchld, nullptr) == -<span class="number">1</span>) &#123;</span><br><span class="line">    ALOGE(<span class="string">"sigprocmask(SIG_SETMASK, &#123; SIGCHLD &#125;) failed: %s"</span>, strerror(errno));</span><br><span class="line">    RuntimeAbort(env, __LINE__, <span class="string">"Call to sigprocmask(SIG_BLOCK, &#123; SIGCHLD &#125;) failed."</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 关闭 log 系统</span></span><br><span class="line">  __android_log_close();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果是第一次 fork 进程，那么会创建 open FD table；否则，只需要检查 open FD 是否变化！</span></span><br><span class="line">  <span class="keyword">if</span> (gOpenFdTable == NULL) &#123;</span><br><span class="line">    gOpenFdTable = FileDescriptorTable::Create();</span><br><span class="line">    <span class="keyword">if</span> (gOpenFdTable == NULL) &#123;</span><br><span class="line">      RuntimeAbort(env, __LINE__, <span class="string">"Unable to construct file descriptor table."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!gOpenFdTable-&gt;Restat()) &#123;</span><br><span class="line">    RuntimeAbort(env, __LINE__, <span class="string">"Unable to restat file descriptor table."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//【2】这里是调用了 Linux 的 fork 方法，fork 进程，返回 2 次！</span></span><br><span class="line">  pid_t pid = fork();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//【3】根据 fork 的返回值，进行不同的处理！</span></span><br><span class="line">  <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//【3.1】pid 返回 0，进入子进程中执行！</span></span><br><span class="line">    gMallocLeakZygoteChild = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理掉那些需要被立刻关闭的文件描述符</span></span><br><span class="line">    DetachDescriptors(env, fdsToClose);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Re-open all remaining open file descriptors so that they aren't shared</span></span><br><span class="line">    <span class="comment">// with the zygote across a fork.</span></span><br><span class="line">    <span class="keyword">if</span> (!gOpenFdTable-&gt;ReopenOrDetach()) &#123;</span><br><span class="line">      RuntimeAbort(env, __LINE__, <span class="string">"Unable to reopen whitelisted descriptors."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sigprocmask(SIG_UNBLOCK, &amp;sigchld, nullptr) == -<span class="number">1</span>) &#123;</span><br><span class="line">      ALOGE(<span class="string">"sigprocmask(SIG_SETMASK, &#123; SIGCHLD &#125;) failed: %s"</span>, strerror(errno));</span><br><span class="line">      RuntimeAbort(env, __LINE__, <span class="string">"Call to sigprocmask(SIG_UNBLOCK, &#123; SIGCHLD &#125;) failed."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【3.1.1】非 root，禁止动态改变进程权限！</span></span><br><span class="line">    <span class="keyword">if</span> (uid != <span class="number">0</span>) &#123;</span><br><span class="line">      EnableKeepCapabilities(env);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【3.1.2】取消进程已有的 Capabilities 权限</span></span><br><span class="line">    DropCapabilitiesBoundingSet(env);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否使用 native bridge，这个模块基本上就是为了在JNI调用时进行动态转码用的！</span></span><br><span class="line">    <span class="comment">// 要使用 native bridge，至少要满足一下条件：</span></span><br><span class="line">    <span class="comment">// 1、不是 SystemServer 进程，NativeBridge 主要是用来解决 JNI 函数的兼容性问题的，SystemServer 是 fork 自 Zygote，</span></span><br><span class="line">    <span class="comment">// 但是它属于系统的一部分，肯定是根据所在平台而编译的，因此肯定不需要转指令集；</span></span><br><span class="line">    <span class="comment">// 2、NativeBridge 已经准备好了；</span></span><br><span class="line">    <span class="comment">// 3、dataDir 也不能为 null；</span></span><br><span class="line">    bool use_native_bridge = !is_system_server &amp;&amp; (instructionSet != NULL)</span><br><span class="line">        &amp;&amp; android::NativeBridgeAvailable();</span><br><span class="line">    <span class="keyword">if</span> (use_native_bridge) &#123;</span><br><span class="line">      <span class="function">ScopedUtfChars <span class="title">isa_string</span><span class="params">(env, instructionSet)</span></span>;</span><br><span class="line">      use_native_bridge = android::NeedsNativeBridge(isa_string.c_str());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (use_native_bridge &amp;&amp; dataDir == NULL) &#123;.</span><br><span class="line">      use_native_bridge = <span class="keyword">false</span>;</span><br><span class="line">      ALOGW(<span class="string">"Native bridge will not be used because dataDir == NULL."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!MountEmulatedStorage(uid, mount_external, use_native_bridge)) &#123;</span><br><span class="line">      ALOGW(<span class="string">"Failed to mount emulated storage: %s"</span>, strerror(errno));</span><br><span class="line">      <span class="keyword">if</span> (errno == ENOTCONN || errno == EROFS) &#123;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        RuntimeAbort(env, __LINE__, <span class="string">"Cannot continue without emulated storage"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【3.1.3】如果当前 fork 的子进程不是 system server 而是普通的应用进程的话，我们会创建进程组！</span></span><br><span class="line">    <span class="keyword">if</span> (!is_system_server) &#123;</span><br><span class="line">        <span class="keyword">int</span> rc = createProcessGroup(uid, getpid());</span><br><span class="line">        <span class="keyword">if</span> (rc != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rc == -EROFS) &#123;</span><br><span class="line">                ALOGW(<span class="string">"createProcessGroup failed, kernel missing CONFIG_CGROUP_CPUACCT?"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ALOGE(<span class="string">"createProcessGroup(%d, %d) failed: %s"</span>, uid, pid, strerror(-rc));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【3.1.4】设置进程所属的 group！</span></span><br><span class="line">    SetGids(env, javaGids);</span><br><span class="line">    <span class="comment">//【3.1.5】设置资源 limit！</span></span><br><span class="line">    SetRLimits(env, javaRlimits);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (use_native_bridge) &#123;</span><br><span class="line">      <span class="function">ScopedUtfChars <span class="title">isa_string</span><span class="params">(env, instructionSet)</span></span>;</span><br><span class="line">      <span class="function">ScopedUtfChars <span class="title">data_dir</span><span class="params">(env, dataDir)</span></span>;</span><br><span class="line">      android::PreInitializeNativeBridge(data_dir.c_str(), isa_string.c_str());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【3.1.6】设置真实的、有效的和保存过的 gid</span></span><br><span class="line">    <span class="keyword">int</span> rc = setresgid(gid, gid, gid);</span><br><span class="line">    <span class="keyword">if</span> (rc == -<span class="number">1</span>) &#123;</span><br><span class="line">      ALOGE(<span class="string">"setresgid(%d) failed: %s"</span>, gid, strerror(errno));</span><br><span class="line">      RuntimeAbort(env, __LINE__, <span class="string">"setresgid failed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【3.1.7】设置真实的、有效的和保存过的 uid</span></span><br><span class="line">    rc = setresuid(uid, uid, uid);</span><br><span class="line">    <span class="keyword">if</span> (rc == -<span class="number">1</span>) &#123;</span><br><span class="line">      ALOGE(<span class="string">"setresuid(%d) failed: %s"</span>, uid, strerror(errno));</span><br><span class="line">      RuntimeAbort(env, __LINE__, <span class="string">"setresuid failed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (NeedsNoRandomizeWorkaround()) &#123;</span><br><span class="line">        <span class="comment">// Work around ARM kernel ASLR lossage (http://b/5817320).</span></span><br><span class="line">        <span class="keyword">int</span> old_personality = personality(<span class="number">0xffffffff</span>);</span><br><span class="line">        <span class="keyword">int</span> new_personality = personality(old_personality | ADDR_NO_RANDOMIZE);</span><br><span class="line">        <span class="keyword">if</span> (new_personality == -<span class="number">1</span>) &#123;</span><br><span class="line">            ALOGW(<span class="string">"personality(%d) failed: %s"</span>, new_personality, strerror(errno));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【3.1.8】设置新的 capabilities 权限</span></span><br><span class="line">    SetCapabilities(env, permittedCapabilities, effectiveCapabilities);</span><br><span class="line">    <span class="comment">//【3.1.9】设置调度策略</span></span><br><span class="line">    SetSchedulerPolicy(env);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得进程的主线程的 nice name</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* se_info_c_str = NULL;</span><br><span class="line">    ScopedUtfChars* se_info = NULL;</span><br><span class="line">    <span class="keyword">if</span> (java_se_info != NULL) &#123;</span><br><span class="line">        se_info = <span class="keyword">new</span> ScopedUtfChars(env, java_se_info);</span><br><span class="line">        se_info_c_str = se_info-&gt;c_str();</span><br><span class="line">        <span class="keyword">if</span> (se_info_c_str == NULL) &#123;</span><br><span class="line">          RuntimeAbort(env, __LINE__, <span class="string">"se_info_c_str == NULL"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* se_name_c_str = NULL;</span><br><span class="line">    ScopedUtfChars* se_name = NULL;</span><br><span class="line">    <span class="keyword">if</span> (java_se_name != NULL) &#123;</span><br><span class="line">        se_name = <span class="keyword">new</span> ScopedUtfChars(env, java_se_name);</span><br><span class="line">        se_name_c_str = se_name-&gt;c_str();</span><br><span class="line">        <span class="keyword">if</span> (se_name_c_str == NULL) &#123;</span><br><span class="line">          RuntimeAbort(env, __LINE__, <span class="string">"se_name_c_str == NULL"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【3.1.10】设置进程 selinux 上下文</span></span><br><span class="line">    rc = selinux_android_setcontext(uid, is_system_server, se_info_c_str, se_name_c_str);</span><br><span class="line">    <span class="keyword">if</span> (rc == -<span class="number">1</span>) &#123;</span><br><span class="line">      ALOGE(<span class="string">"selinux_android_setcontext(%d, %d, \"%s\", \"%s\") failed"</span>, uid,</span><br><span class="line">            is_system_server, se_info_c_str, se_name_c_str);</span><br><span class="line">      RuntimeAbort(env, __LINE__, <span class="string">"selinux_android_setcontext failed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【3.1.11】设置进程的主线程的 nice name，用于方便调试！</span></span><br><span class="line">    <span class="keyword">if</span> (se_info_c_str == NULL &amp;&amp; is_system_server) &#123;</span><br><span class="line">      se_name_c_str = <span class="string">"system_server"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (se_info_c_str != NULL) &#123;</span><br><span class="line">      SetThreadName(se_name_c_str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delete se_info;</span><br><span class="line">    delete se_name;</span><br><span class="line">    <span class="comment">// 将子进程的 SIGCHLD 信号的处理函数修改回系统默认函数</span></span><br><span class="line">    UnsetSigChldHandler();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【*3.3.1.2.1】JNI 调，相当于 zygote.callPostForkChildHooks()，在子进程中执行</span></span><br><span class="line">    env-&gt;CallStaticVoidMethod(gZygoteClass, gCallPostForkChildHooks, debug_flags,</span><br><span class="line">                              is_system_server, instructionSet);</span><br><span class="line">    <span class="keyword">if</span> (env-&gt;ExceptionCheck()) &#123;</span><br><span class="line">      RuntimeAbort(env, __LINE__, <span class="string">"Error calling post fork hooks."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//【3.2】pid 大于 0 ，在父进程中执行，返回的 pid 的子进程的 pid！</span></span><br><span class="line"></span><br><span class="line">#ifdef ENABLE_SCHED_BOOST</span><br><span class="line">    <span class="comment">// unset scheduler knob</span></span><br><span class="line">    SetForkLoad(<span class="keyword">false</span>);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 sigprocmask() 取消屏蔽/阻塞 SIGCHLD 信号</span></span><br><span class="line">    <span class="keyword">if</span> (sigprocmask(SIG_UNBLOCK, &amp;sigchld, nullptr) == -<span class="number">1</span>) &#123;</span><br><span class="line">      ALOGE(<span class="string">"sigprocmask(SIG_SETMASK, &#123; SIGCHLD &#125;) failed: %s"</span>, strerror(errno));</span><br><span class="line">      RuntimeAbort(env, __LINE__, <span class="string">"Call to sigprocmask(SIG_UNBLOCK, &#123; SIGCHLD &#125;) failed."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Zygote 进程是所有 Android 进程的母体，包括 system_server 进程以及 App 进程都是由 Zygote 进程孵化而来。</p>
<p>zygote 利用 fork() 方法生成新进程，对于新进程 A 复用 Zygote 进程本身的资源，再加上新进程 A 相关的资源，构成新的应用进程 A 。</p>
<p>关于 native bridge，我没有过多研究，大家可以看看这个博客：</p>
<p><a href="https://blog.csdn.net/sinat_38172893/article/details/73274591" target="_blank" rel="noopener">https://blog.csdn.net/sinat_38172893/article/details/73274591</a></p>
<h5 id="3-3-1-2-1-Zygote-CallPostForkChildHooks-子进程调用"><a href="#3-3-1-2-1-Zygote-CallPostForkChildHooks-子进程调用" class="headerlink" title="3.3.1.2.1 Zygote.CallPostForkChildHooks - 子进程调用"></a>3.3.1.2.1 Zygote.CallPostForkChildHooks - 子进程调用</h5><p>上面通过反射再次调用了 Zygote 的 CallPostForkChildHooks 方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">callPostForkChildHooks</span><span class="params">(<span class="keyword">int</span> debugFlags, boolean isSystemServer,</span></span></span><br><span class="line"><span class="function"><span class="params">        String instructionSet)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【3.3.1.2.1.1】继续调用！</span></span><br><span class="line">    VM_HOOKS.postForkChild(debugFlags, isSystemServer, instructionSet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这边有调用了 ZygoteHooks 的 postForkChild 方法：</p>
<h6 id="3-3-1-2-1-1-ZygoteHooks-postForkChild"><a href="#3-3-1-2-1-1-ZygoteHooks-postForkChild" class="headerlink" title="3.3.1.2.1.1 ZygoteHooks.postForkChild"></a>3.3.1.2.1.1 ZygoteHooks.postForkChild</h6><p>这个方法是在 Zygote fork 出的子进程中调用的！！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postForkChild</span><span class="params">(<span class="keyword">int</span> debugFlags, boolean isSystemServer, String instructionSet)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【3.3.1.2.1.2】继续调用！ </span></span><br><span class="line">    nativePostForkChild(token, debugFlags, isSystemServer, instructionSet);</span><br><span class="line"></span><br><span class="line">    Math.setRandomSeedInternal(System.currentTimeMillis());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，这里传入了一个 token，这是是一个 long 型的值，用来保存线程的类型，在前面：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.3</span>.1.1.3 ZygoteHooks.nativePreFork</span><br></pre></td></tr></table></figure></p>
<p>nativePreFork 会将 Zygote 主线程的类型转换为 long 型，保存到 ZygoteHooks.token 中！</p>
<h6 id="3-3-1-2-1-2-ZygoteHooks-nativePostForkChild"><a href="#3-3-1-2-1-2-ZygoteHooks-nativePostForkChild" class="headerlink" title="3.3.1.2.1.2 ZygoteHooks.nativePostForkChild"></a>3.3.1.2.1.2 ZygoteHooks.nativePostForkChild</h6><p>我们继续看：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativePostForkChild</span><span class="params">(<span class="keyword">long</span> token, <span class="keyword">int</span> debugFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               <span class="keyword">boolean</span> isSystemServer, String instructionSet)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>这是一个 navtive 方法，最终调用 <strong>“\art\runtime\native\dalvik_system_ZygoteHooks.cc”</strong> 的 ZygoteHooks_nativePostForkChild 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ZygoteHooks_nativePostForkChild</span><span class="params">(JNIEnv* env,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            jclass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            jlong token,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            jint debug_flags,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            jboolean is_system_server,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            jstring instruction_set)</span> </span>&#123;</span><br><span class="line">                                            </span><br><span class="line">  Thread* thread = reinterpret_cast&lt;Thread*&gt;(token);</span><br><span class="line">  <span class="comment">// Our system thread ID, etc, has changed so reset Thread state.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//【1】初始化子进程的主线程！</span></span><br><span class="line">  <span class="comment">// 该方法主要是获得主线程的 tid！</span></span><br><span class="line">  thread-&gt;InitAfterFork();</span><br><span class="line">  </span><br><span class="line">  EnableDebugFeatures(debug_flags);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Update tracing.</span></span><br><span class="line">  <span class="keyword">if</span> (Trace::GetMethodTracingMode() != TracingMode::kTracingInactive) &#123;</span><br><span class="line">     ... ... ... ... <span class="comment">// 这里是和 tracing 相关，不是重点！</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (instruction_set != nullptr &amp;&amp; !is_system_server) &#123;</span><br><span class="line">    <span class="comment">//【2.1】非 SystemServer 子进程，走这里！</span></span><br><span class="line">    <span class="function">ScopedUtfChars <span class="title">isa_string</span><span class="params">(env, instruction_set)</span></span>;</span><br><span class="line">    InstructionSet isa = GetInstructionSetFromString(isa_string.c_str());</span><br><span class="line">    Runtime::NativeBridgeAction action = Runtime::NativeBridgeAction::kUnload;</span><br><span class="line">    <span class="keyword">if</span> (isa != kNone &amp;&amp; isa != kRuntimeISA) &#123;</span><br><span class="line">      action = Runtime::NativeBridgeAction::kInitialize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【3.3.1.2.1.3】调用 Runtime 的 InitNonZygoteOrPostFork 方法！！</span></span><br><span class="line">    Runtime::Current()-&gt;InitNonZygoteOrPostFork(</span><br><span class="line">        env, is_system_server, action, isa_string.c_str());</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="comment">//【2.2】SystemServer 进程，走这里，请看开机流程相关的内容！</span></span><br><span class="line">    Runtime::Current()-&gt;InitNonZygoteOrPostFork(</span><br><span class="line">        env, is_system_server, Runtime::NativeBridgeAction::kUnload, nullptr);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们主要分析下，非 SystemServer 子进程的逻辑处理，对于 SystemServer 进程的处理，请看开机启动流程文章内容！</p>
<h6 id="3-3-1-2-1-3-Runtime-InitNonZygoteOrPostFork"><a href="#3-3-1-2-1-3-Runtime-InitNonZygoteOrPostFork" class="headerlink" title="3.3.1.2.1.3 Runtime.InitNonZygoteOrPostFork"></a>3.3.1.2.1.3 Runtime.InitNonZygoteOrPostFork</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Runtime::InitNonZygoteOrPostFork(</span><br><span class="line">    JNIEnv* env, <span class="keyword">bool</span> is_system_server, NativeBridgeAction action, <span class="keyword">const</span> <span class="keyword">char</span>* isa) &#123;</span><br><span class="line">  is_zygote_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (is_native_bridge_loaded_) &#123; <span class="comment">// native bridge 相关逻辑！</span></span><br><span class="line">    <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">      <span class="keyword">case</span> NativeBridgeAction::kUnload:</span><br><span class="line">        UnloadNativeBridge();</span><br><span class="line">        is_native_bridge_loaded_ = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> NativeBridgeAction::kInitialize:</span><br><span class="line">        InitializeNativeBridge(env, isa);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建堆处理的线程池！</span></span><br><span class="line">  heap_-&gt;CreateThreadPool();</span><br><span class="line">  <span class="comment">// Reset the gc performance data at zygote fork so that the GCs</span></span><br><span class="line">  <span class="comment">// before fork aren't attributed to an app.</span></span><br><span class="line">  heap_-&gt;ResetGcPerformanceInfo();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 非 SystemServer 进程会进入这里！</span></span><br><span class="line">  <span class="keyword">if</span> (!is_system_server &amp;&amp;</span><br><span class="line">      !safe_mode_ &amp;&amp;</span><br><span class="line">      (jit_options_-&gt;UseJitCompilation() || jit_options_-&gt;GetSaveProfilingInfo()) &amp;&amp;</span><br><span class="line">      jit_.get() == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// 创建 JIT!</span></span><br><span class="line">    CreateJit();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置信号处理函数！</span></span><br><span class="line">  StartSignalCatcher();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 启动 JDWP 线程，当命令行 debuger 的 flags 指定"suspend=y"时，则暂停 runtime</span></span><br><span class="line">  Dbg::StartJdwp();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-1-3-ZygoteHooks-postForkCommon-fork-结束"><a href="#3-3-1-3-ZygoteHooks-postForkCommon-fork-结束" class="headerlink" title="3.3.1.3 ZygoteHooks.postForkCommon - fork 结束"></a>3.3.1.3 ZygoteHooks.postForkCommon - fork 结束</h4><p>这个方法会在父进程 Zygote 和子进程中各调用一次，也就是说，在父进程 Zygote 中是恢复 4 个 Daemon 线程，而在子进程中，是启动 4 个 Daemon 线程！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postForkCommon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【3.3.1.3.1】启动 Deamons 线程！</span></span><br><span class="line">    Daemons.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-3-1-3-1-Daemons-start"><a href="#3-3-1-3-1-Daemons-start" class="headerlink" title="3.3.1.3.1 Daemons.start"></a>3.3.1.3.1 Daemons.start</h5><p>ZygoteHooks.postForkCommon 方法很简单，启动 4 个 Daemon 线程，java堆整理，引用队列，以及析构线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ReferenceQueueDaemon.INSTANCE.start();</span><br><span class="line">    FinalizerDaemon.INSTANCE.start();</span><br><span class="line">    FinalizerWatchdogDaemon.INSTANCE.start();</span><br><span class="line">    HeapTaskDaemon.INSTANCE.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-1-4-阶段总结"><a href="#3-3-1-4-阶段总结" class="headerlink" title="3.3.1.4 阶段总结"></a>3.3.1.4 阶段总结</h4><p>首先来看看调用函数流程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Zygote.forkAndSpecialize</span><br><span class="line">    ZygoteHooks.preFork  <span class="comment">// 停掉 zygote 的子线程，为 fork 做准备！</span></span><br><span class="line">        Daemons.stop</span><br><span class="line">        ZygoteHooks.nativePreFork</span><br><span class="line">            dalvik_system_ZygoteHooks.ZygoteHooks_nativePreFork</span><br><span class="line">                Runtime::PreZygoteFork</span><br><span class="line">                    heap_-&gt;PreZygoteFork()</span><br><span class="line">                    </span><br><span class="line">    Zygote.nativeForkAndSpecialize   <span class="comment">// fork 阶段，该这个方法会返回 2 次！</span></span><br><span class="line">        com_android_internal_os_Zygote.ForkAndSpecializeCommon</span><br><span class="line">            fork()</span><br><span class="line">            Zygote.callPostForkChildHooks</span><br><span class="line">                ZygoteHooks.postForkChild</span><br><span class="line">                    dalvik_system_ZygoteHooks.nativePostForkChild</span><br><span class="line">                        Runtime::InitNonZygoteOrPostFork</span><br><span class="line">                        </span><br><span class="line">    ZygoteHooks.postForkCommon    <span class="comment">// 启动 4 个 Deamon 子线程！</span></span><br><span class="line">        Daemons.start</span><br></pre></td></tr></table></figure>
<p>这个流程很清楚啦，不都说了啦，嘿嘿嘿！</p>
<h3 id="3-3-2-ZygoteConncection-handleChildProc-子进程处理"><a href="#3-3-2-ZygoteConncection-handleChildProc-子进程处理" class="headerlink" title="3.3.2 ZygoteConncection.handleChildProc - 子进程处理"></a>3.3.2 ZygoteConncection.handleChildProc - 子进程处理</h3><p>我们知道，Zygote.forkAndSpecialize 会返回 2 次，当返回值为 0 时，进入子进程：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleChildProc</span><span class="params">(Arguments parsedArgs,</span></span></span><br><span class="line"><span class="function"><span class="params">        FileDescriptor[] descriptors, FileDescriptor pipeFd, PrintStream newStderr)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123; <span class="comment">// 抛出异常！</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】进程创建完毕，关闭 Socket 连接！</span></span><br><span class="line">    closeSocket();</span><br><span class="line">    ZygoteInit.closeServerSocket();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (descriptors != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Os.dup2(descriptors[<span class="number">0</span>], STDIN_FILENO);</span><br><span class="line">            Os.dup2(descriptors[<span class="number">1</span>], STDOUT_FILENO);</span><br><span class="line">            Os.dup2(descriptors[<span class="number">2</span>], STDERR_FILENO);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (FileDescriptor fd: descriptors) &#123;</span><br><span class="line">                IoUtils.closeQuietly(fd);</span><br><span class="line">            &#125;</span><br><span class="line">            newStderr = System.err;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ErrnoException ex) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">"Error reopening stdio"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (parsedArgs.niceName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//【2】设置进程的 niceName</span></span><br><span class="line">        Process.setArgV0(parsedArgs.niceName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// End of the postFork event.</span></span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (parsedArgs.invokeWith != <span class="keyword">null</span>) &#123;</span><br><span class="line">        WrapperInit.execApplication(parsedArgs.invokeWith,</span><br><span class="line">                parsedArgs.niceName, parsedArgs.targetSdkVersion,</span><br><span class="line">                VMRuntime.getCurrentInstructionSet(),</span><br><span class="line">                pipeFd, parsedArgs.remainingArgs);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//【3.3.2.1】看前面的参数传递，parsedArgs.invokeWith 为 null，进入这个分支！</span></span><br><span class="line">        RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion,</span><br><span class="line">                parsedArgs.remainingArgs, <span class="keyword">null</span> <span class="comment">/* classLoader */</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们继续看：</p>
<h4 id="3-3-2-1-RuntimeInit-zygoteInit"><a href="#3-3-2-1-RuntimeInit-zygoteInit" class="headerlink" title="3.3.2.1 RuntimeInit.zygoteInit"></a>3.3.2.1 RuntimeInit.zygoteInit</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">zygoteInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, String[] argv, ClassLoader classLoader)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">"RuntimeInit: Starting application from zygote"</span>);</span><br><span class="line"></span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"RuntimeInit"</span>);</span><br><span class="line">    redirectLogStreams();</span><br><span class="line">    <span class="comment">//【3.3.2.1.1】进程的通用初始化</span></span><br><span class="line">    commonInit();</span><br><span class="line">    <span class="comment">//【3.3.2.1.2】本地的 Zygote 初始化</span></span><br><span class="line">    nativeZygoteInit();</span><br><span class="line">    <span class="comment">//【3.3.2.1.3】应用初始化！</span></span><br><span class="line">    applicationInit(targetSdkVersion, argv, classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>啦啦啦啦啦</p>
<h5 id="3-3-2-1-1-RuntimeInit-commonInit-进程通用初始化"><a href="#3-3-2-1-1-RuntimeInit-commonInit-进程通用初始化" class="headerlink" title="3.3.2.1.1 RuntimeInit.commonInit - 进程通用初始化"></a>3.3.2.1.1 RuntimeInit.commonInit - 进程通用初始化</h5><p>进程的通用初始化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">commonInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">"Entered RuntimeInit!"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】设置该进程中所有线程的默认 crash handler！！</span></span><br><span class="line">    Thread.setDefaultUncaughtExceptionHandler(<span class="keyword">new</span> UncaughtHandler());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】设置时区！</span></span><br><span class="line">    TimezoneGetter.setInstance(<span class="keyword">new</span> TimezoneGetter() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> SystemProperties.get(<span class="string">"persist.sys.timezone"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    TimeZone.setDefault(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【3】重置 LogManager</span></span><br><span class="line">    LogManager.getLogManager().reset();</span><br><span class="line">    <span class="keyword">new</span> AndroidConfig();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【4】设置默认的 http 用户代理，这个是 HttpURLConnection 必须的！</span></span><br><span class="line">    String userAgent = getDefaultUserAgent();</span><br><span class="line">    System.setProperty(<span class="string">"http.agent"</span>, userAgent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【5】安装网络</span></span><br><span class="line">    NetworkManagementSocketTagger.install();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【6】设置模拟器相关参数！</span></span><br><span class="line">    String trace = SystemProperties.get(<span class="string">"ro.kernel.android.tracing"</span>);</span><br><span class="line">    <span class="keyword">if</span> (trace.equals(<span class="string">"1"</span>)) &#123;</span><br><span class="line">        Slog.i(TAG, <span class="string">"NOTE: emulator trace profiling enabled"</span>);</span><br><span class="line">        Debug.enableEmulatorTraceOutput();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【7】表示初始化完成！</span></span><br><span class="line">    initialized = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-3-2-1-2-RuntimeInit-nativeZygoteInit-进程本地初始化"><a href="#3-3-2-1-2-RuntimeInit-nativeZygoteInit-进程本地初始化" class="headerlink" title="3.3.2.1.2 RuntimeInit.nativeZygoteInit - 进程本地初始化"></a>3.3.2.1.2 RuntimeInit.nativeZygoteInit - 进程本地初始化</h5><p>nativeZygoteInit 是一个 native 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativeZygoteInit</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>显然这是一个 native 方法，对应的 native 方法为 com_android_internal_os_RuntimeInit_nativeZygoteInit 方法，位于 AndroidRuntime.cpp 文件中：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">com_android_internal_os_RuntimeInit_nativeZygoteInit</span><span class="params">(JNIEnv* env, jobject clazz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//【1】调用了运行时的 onZygoteInit 方法！</span></span><br><span class="line">  gCurRuntime-&gt;onZygoteInit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接着，进入 App_main.cpp 文件中：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onZygoteInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//【1】获得当前进程的 ProcessState 对象！！</span></span><br><span class="line">    sp&lt;ProcessState&gt; proc = ProcessState::self();</span><br><span class="line">    ALOGV(<span class="string">"App process: starting thread pool.\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】创建一个新的 Binder 线程，不断的 talkWithDriver！！</span></span><br><span class="line">    proc-&gt;startThreadPool();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的 ProcessState 对象是一个单例模式，他会打开 /dev/binder 驱动设备，分配内核空间，然后 start 一个 binder 线程，不断地 talkWithDriver，用于进行进程间通信！</p>
<h5 id="3-3-2-1-3-RuntimeInit-applicationInit-初始化进程的-Application-对象"><a href="#3-3-2-1-3-RuntimeInit-applicationInit-初始化进程的-Application-对象" class="headerlink" title="3.3.2.1.3 RuntimeInit.applicationInit - 初始化进程的 Application 对象"></a>3.3.2.1.3 RuntimeInit.applicationInit - 初始化进程的 Application 对象</h5><p>这里很重要，初始化进程的 Application 对象！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">applicationInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, String[] argv, ClassLoader classLoader)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line">    <span class="comment">// If the application calls System.exit(), terminate the process</span></span><br><span class="line">    <span class="comment">// immediately without running any shutdown hooks.  It is not possible to</span></span><br><span class="line">    <span class="comment">// shutdown an Android application gracefully.  Among other things, the</span></span><br><span class="line">    <span class="comment">// Android runtime shutdown hooks close the Binder driver, which can cause</span></span><br><span class="line">    <span class="comment">// leftover running threads to crash before the process actually exits.</span></span><br><span class="line">    nativeSetExitWithoutCleanup(<span class="keyword">true</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【1】设置 java 堆内存的利用率为 75%，以及目标 sdk 平台的版本！</span></span><br><span class="line">    VMRuntime.getRuntime().setTargetHeapUtilization(<span class="number">0.75f</span>);</span><br><span class="line">    VMRuntime.getRuntime().setTargetSdkVersion(targetSdkVersion);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Arguments args;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//【2】解析参数！</span></span><br><span class="line">        args = <span class="keyword">new</span> Arguments(argv);</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">        Slog.e(TAG, ex.getMessage());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【3】结束对子进程的监控！</span></span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【3.3.2.1.3.1】进一步解析参数，执行 startClass 类的 main 方法！！</span></span><br><span class="line">    invokeStaticMain(args.startClass, args.startArgs, classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里有人要问了，这个 startClass 是什么类，此处 args.startClass 为 “android.app.ActivityThread”。</p>
<h6 id="3-3-2-1-3-1-RuntimeInit-invokeStaticMain"><a href="#3-3-2-1-3-1-RuntimeInit-invokeStaticMain" class="headerlink" title="3.3.2.1.3.1 RuntimeInit.invokeStaticMain"></a>3.3.2.1.3.1 RuntimeInit.invokeStaticMain</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeStaticMain</span><span class="params">(String className, String[] argv, ClassLoader classLoader)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line">    Class&lt;?&gt; cl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//【1】反射获得 ActivityThread 类！</span></span><br><span class="line">        cl = Class.forName(className, <span class="keyword">true</span>, classLoader);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Missing class when invoking static main "</span> + className,</span><br><span class="line">                ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Method m;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//【2】获得 ActivityThread 的 main 方法！</span></span><br><span class="line">        m = cl.getMethod(<span class="string">"main"</span>, <span class="keyword">new</span> Class[] &#123; String[].class &#125;);</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Missing static main on "</span> + className, ex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SecurityException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Problem getting static main on "</span> + className, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> modifiers = m.getModifiers();</span><br><span class="line">    <span class="keyword">if</span> (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Main method is not public and static on "</span> + className);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【3.4】这个地方抛出了 MethodAndArgsCaller 异常！！！</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteInit.MethodAndArgsCaller(m, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里通过反射，获得了 ActivityThread.main 方法，然后创建了一个异常：MethodAndArgsCaller，抛了出去！</p>
<p>这个异常会通过 ZygoteConnection.runOnce 方法传递出去，进入了 ZygoteInit.main 方法，那里会对这个异常进行 catch 并处理！</p>
<h3 id="3-3-3-ZygoteConncection-handleParentProc-父进程处理"><a href="#3-3-3-ZygoteConncection-handleParentProc-父进程处理" class="headerlink" title="3.3.3 ZygoteConncection.handleParentProc - 父进程处理"></a>3.3.3 ZygoteConncection.handleParentProc - 父进程处理</h3><p>当 fork 的返回值大于 0，那就进入父进程 Zygote，返回 pid 的值是子进程的进程值：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">handleParentProc</span><span class="params">(<span class="keyword">int</span> pid,</span></span></span><br><span class="line"><span class="function"><span class="params">        FileDescriptor[] descriptors, FileDescriptor pipeFd, Arguments parsedArgs)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】判断一下返回值，若大于 0，说明 fork 成功，</span></span><br><span class="line">    <span class="comment">// 设置子进程的 pgid！</span></span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//【*3.3.3.1】设置进程的 pgid！</span></span><br><span class="line">        setChildPgid(pid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (descriptors != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (FileDescriptor fd: descriptors) &#123;</span><br><span class="line">            IoUtils.closeQuietly(fd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> usingWrapper = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (pipeFd != <span class="keyword">null</span> &amp;&amp; pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        DataInputStream is = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> FileInputStream(pipeFd));</span><br><span class="line">        <span class="keyword">int</span> innerPid = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            innerPid = is.readInt();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">"Error reading pid from wrapped process, child may have died"</span>, ex);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                is.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Ensure that the pid reported by the wrapped process is either the</span></span><br><span class="line">        <span class="comment">// child process that we forked, or a descendant of it.</span></span><br><span class="line">        <span class="keyword">if</span> (innerPid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> parentPid = innerPid;</span><br><span class="line">            <span class="keyword">while</span> (parentPid &gt; <span class="number">0</span> &amp;&amp; parentPid != pid) &#123;</span><br><span class="line">                parentPid = Process.getParentPid(parentPid);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (parentPid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                Log.i(TAG, <span class="string">"Wrapped process has pid "</span> + innerPid);</span><br><span class="line">                pid = innerPid;</span><br><span class="line">                usingWrapper = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Log.w(TAG, <span class="string">"Wrapped process reported a pid that is not a child of "</span></span><br><span class="line">                        + <span class="string">"the process that we forked: childPid="</span> + pid</span><br><span class="line">                        + <span class="string">" innerPid="</span> + innerPid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mSocketOutStream.writeInt(pid);</span><br><span class="line">        mSocketOutStream.writeBoolean(usingWrapper);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"Error writing to command socket"</span>, ex);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="3-3-3-1-setChildPgid"><a href="#3-3-3-1-setChildPgid" class="headerlink" title="3.3.3.1 setChildPgid"></a>3.3.3.1 setChildPgid</h4><p>设置 fork 出的进程的 pgid：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setChildPgid</span><span class="params">(<span class="keyword">int</span> pid)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Try to move the new child into the peer's process group.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Os.setpgid(pid, Os.getpgid(peer.getPid()));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ErrnoException ex) &#123;</span><br><span class="line">        <span class="comment">// This exception is expected in the case where</span></span><br><span class="line">        <span class="comment">// the peer is not in our session</span></span><br><span class="line">        <span class="comment">// TODO get rid of this log message in the case where</span></span><br><span class="line">        <span class="comment">// getsid(0) != getsid(peer.getPid())</span></span><br><span class="line">        Log.i(TAG, <span class="string">"Zygote: setpgid failed. This is "</span></span><br><span class="line">            + <span class="string">"normal if peer is not in our session"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-4-MethodAndArgsCaller-run-处理异常"><a href="#3-4-MethodAndArgsCaller-run-处理异常" class="headerlink" title="3.4 MethodAndArgsCaller.run - 处理异常"></a>3.4 MethodAndArgsCaller.run - 处理异常</h2><p>MethodAndArgsCaller 类位于 ZygoteInit.java 中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAndArgsCaller</span> <span class="keyword">extends</span> <span class="title">Exception</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** method to call */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Method mMethod;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** argument array */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String[] mArgs;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MethodAndArgsCaller</span><span class="params">(Method method, String[] args)</span> </span>&#123;</span><br><span class="line">        mMethod = method;</span><br><span class="line">        mArgs = args;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//【1】执行进程的 ActivityThread.main 方法！！</span></span><br><span class="line">            mMethod.invoke(<span class="keyword">null</span>, <span class="keyword">new</span> Object[] &#123; mArgs &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">            Throwable cause = ex.getCause();</span><br><span class="line">            <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (RuntimeException) cause;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (Error) cause;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就正式进入了新进程的 ActivityThread.main 方法，我们知道 ActivityThread.main 是应用程序进程的入口，到这里就将从 native 进入 java 层了，进行进一步的进程启动！</p>
<h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h1><h2 id="4-1-通信方式总结"><a href="#4-1-通信方式总结" class="headerlink" title="4.1 通信方式总结"></a>4.1 通信方式总结</h2><p>可以看出，主要有以下的两种通信方式：Binder 和 Socket !!</p>
<ul>
<li>启动方进程 -&gt; SystemServer 进程: Binder</li>
<li>SystemServer 进程 -&gt; Zygote 进程：Socket</li>
<li>Zygote 进程 -&gt; 被启动进程：Socket</li>
</ul>
<p>主要的流程图如下：</p>
<p><img src="http://static.zybuluo.com/Coolqi/f50nyubiawx51w6dc4hqy5hd/Process%20%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="Process 创建流程图.png-19.8kB"></p>
<h2 id="4-2-调用流程总结"><a href="#4-2-调用流程总结" class="headerlink" title="4.2 调用流程总结"></a>4.2 调用流程总结</h2><p>UML 序列图先埋坑，以后再填。。</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2016/03/13/Process篇 1 - Android 进程的启动/">Process篇 1 - Android 进程的启动</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2016-03-13</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/AndroidFramework源码分析/">AndroidFramework源码分析</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/AndroidFramework源码分析/Process进程/">Process进程</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Process进程/">Process进程</a></span><div class="content"><p>[toc]</p>
<p>基于 Android 7.1.1 源码分析，进程</p>
<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>我们知道，在 Android 系统中，每一个 app 都至少运行在一个进程中的，可以通过配置 Android:process 属性，来使 app 的某个组件运行在不同的进程中的，从而达到一个 app 在运行在多个进程中！</p>
<p>本文将总结和分析 Android 进程启动进程的主要流程，更深入地理解 Android 系统的架构！</p>
<h1 id="2-启动进程的方法"><a href="#2-启动进程的方法" class="headerlink" title="2 启动进程的方法"></a>2 启动进程的方法</h1><p>AMS 中进程启动相关的方法有如下的 2 组：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">startProcessLocked</span><span class="params">(ProcessRecord app,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      String hostingType, String hostingNameStr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//【1】进一步调用                              </span></span><br><span class="line">        startProcessLocked(app, hostingType, </span><br><span class="line">                           hostingNameStr, <span class="keyword">null</span> <span class="comment">/* abiOverride */</span>,</span><br><span class="line">                           <span class="keyword">null</span> <span class="comment">/* entryPoint */</span>, <span class="keyword">null</span> <span class="comment">/* entryPointArgs */</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">startProcessLocked</span><span class="params">(ProcessRecord app, String hostingType,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      String hostingNameStr, String abiOverride,                                                  String entryPoint, String[] entryPointArgs)</span> </span>&#123;</span><br><span class="line">       ... ... ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第一组，可以看出启动方式是通过进程的 ProcessRecord 对象来启动的！<br>参数传递：</p>
<ul>
<li><strong>ProcessRecord app</strong>：进程对应的 ProcessRecord 对象！</li>
<li><strong>String hostingType</strong>：</li>
<li><strong>String hostingNameStr</strong>：</li>
<li><strong>String abiOverride：null</strong></li>
<li><strong>String entryPoint：null</strong></li>
<li><strong>String[] entryPointArgs：null</strong></li>
</ul>
<p>接着来看：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ProcessRecord <span class="title">startProcessLocked</span><span class="params">(String processName, ApplicationInfo info，</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">boolean</span> knownToBeDead, <span class="keyword">int</span> intentFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       String hostingType, ComponentName hostingName, </span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">boolean</span> allowWhileBooting,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">boolean</span> isolated, <span class="keyword">boolean</span> keepIfLarge)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 进一步调用</span></span><br><span class="line">    <span class="keyword">return</span> startProcessLocked(processName, info, </span><br><span class="line">                              knownToBeDead, intentFlags, hostingType,</span><br><span class="line">                              hostingName, allowWhileBooting, isolated, </span><br><span class="line">                              <span class="number">0</span> <span class="comment">/* isolatedUid */</span>, keepIfLarge,</span><br><span class="line">                              <span class="keyword">null</span> <span class="comment">/* ABI override */</span>, <span class="keyword">null</span> <span class="comment">/* entryPoint */</span>,</span><br><span class="line">                              <span class="keyword">null</span> <span class="comment">/* entryPointArgs */</span>,<span class="keyword">null</span> <span class="comment">/* crashHandler */</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> ProcessRecord <span class="title">startProcessLocked</span><span class="params">(String processName, ApplicationInfo info,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">boolean</span> knownToBeDead, <span class="keyword">int</span> intentFlags, </span></span></span><br><span class="line"><span class="function"><span class="params">                                       String hostingType, ComponentName hostingName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">boolean</span> allowWhileBooting, <span class="keyword">boolean</span> isolated, </span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">int</span> isolatedUid, <span class="keyword">boolean</span> keepIfLarge,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       String abiOverride, String entryPoint, </span></span></span><br><span class="line"><span class="function"><span class="params">                                       String[] entryPointArgs, Runnable crashHandler)</span> </span>&#123;</span><br><span class="line">                                       </span><br><span class="line">   ... ... ... ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后又调用了第一组方法中的第二个方法！！</span></span><br><span class="line">    startProcessLocked(app, hostingType, hostingNameStr, abiOverride,   </span><br><span class="line">                                              entryPoint, entryPointArgs);</span><br><span class="line"></span><br><span class="line">    checkTime(startTime, <span class="string">"startProcess: done starting proc!"</span>);</span><br><span class="line">    <span class="keyword">return</span> (app.pid != <span class="number">0</span>) ? app : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第二组，可以看出启动方式是通过应用的进程名和 ApplicationInfo来启动进程的！<br>参数传递：</p>
<ul>
<li><strong>String processName</strong>：进程名字，默认为包名！</li>
<li><strong>ApplicationInfo info</strong>：进程所属应用的信息对象！</li>
<li><strong>boolean knownToBeDead</strong>：父进程是否需要在该进程死亡后接到通知！</li>
<li><strong>int intentFlags</strong>：intent 启动的 flags 参数！</li>
<li><strong>String hostingType</strong>：值为 “activity”，“service”，“broadcast” 或者 “content provider”；</li>
<li><strong>String hostingNameStr</strong>：数据类型为 ComponentName，代表的是具体相对应的组件名！</li>
<li><strong>boolean allowWhileBooting</strong>：这个在AMS的启动篇里有涉及过，表示开机时是否拉起该进程!</li>
<li><strong>boolean isolated</strong>：表示该进程是否是一个隔离进程！</li>
<li><strong>int isolatedUid</strong>：0 隔离进程的 uid！</li>
<li><strong>boolean keepIfLarge</strong>：</li>
<li><strong>String abiOverride：null</strong></li>
<li><strong>String entryPoint：null</strong></li>
<li><strong>String[] entryPointArgs：null</strong></li>
<li><strong>Runnable crashHandler：null</strong></li>
</ul>
<p>最后，都调用了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">startProcessLocked</span><span class="params">(ProcessRecord app, String hostingType,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  String hostingNameStr, String abiOverride,                                                  String entryPoint, String[] entryPointArgs)</span> </span>&#123;</span><br><span class="line">   ... ... ... ...</span><br></pre></td></tr></table></figure></p>
<p>接着，我们进入今天的正文，进程的启动！！</p>
<h1 id="3-startProcessLocked-启动"><a href="#3-startProcessLocked-启动" class="headerlink" title="3 startProcessLocked - 启动"></a>3 startProcessLocked - 启动</h1><p>接下来，我们来看看用进程名 precessName 和应用的 ApplicationInfo 对象启动进程的方法，这个方法略微有些长，我们来仔细的分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ProcessRecord <span class="title">startProcessLocked</span><span class="params">(String processName, ApplicationInfo info,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> knownToBeDead, <span class="keyword">int</span> intentFlags, String hostingType, ComponentName hostingName,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> allowWhileBooting, <span class="keyword">boolean</span> isolated, <span class="keyword">int</span> isolatedUid, <span class="keyword">boolean</span> keepIfLarge,</span></span></span><br><span class="line"><span class="function"><span class="params">        String abiOverride, String entryPoint, String[] entryPointArgs, Runnable crashHandler)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">long</span> startTime = SystemClock.elapsedRealtime();</span><br><span class="line">    ProcessRecord app;</span><br><span class="line">    <span class="comment">//【1】如果该进程不是一个隔离进程！</span></span><br><span class="line">    <span class="keyword">if</span> (!isolated) &#123; </span><br><span class="line">        <span class="comment">//【1】尝试获得其对应的 ProcessRecord 对象！</span></span><br><span class="line">        app = getProcessRecordLocked(processName, info.uid, keepIfLarge);</span><br><span class="line">        checkTime(startTime, <span class="string">"startProcess: after getProcessRecord"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> ((intentFlags &amp; Intent.FLAG_FROM_BACKGROUND) != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果是后台操作启动该进程，需要判断该进程是否是一个 bad 进程，如果是，启动失败！</span></span><br><span class="line">            <span class="keyword">if</span> (mAppErrors.isBadProcessLocked(info)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_PROCESSES) Slog.v(TAG, <span class="string">"Bad process: "</span> + info.uid</span><br><span class="line">                        + <span class="string">"/"</span> + info.processName);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (DEBUG_PROCESSES) Slog.v(TAG, <span class="string">"Clearing bad process: "</span> + info.uid</span><br><span class="line">                    + <span class="string">"/"</span> + info.processName);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果是用户交互，主动启动这个进程，那么，就要清空这个进程的 crash  次数</span></span><br><span class="line">            <span class="comment">// 并且将该进程从 bad 列表中移除，变为一个 good 进程！</span></span><br><span class="line">            <span class="comment">// 直到下一次再次 crash 才会变成一个 bad 进程！</span></span><br><span class="line">            mAppErrors.resetProcessCrashTimeLocked(info);</span><br><span class="line">            <span class="keyword">if</span> (mAppErrors.isBadProcessLocked(info)) &#123;</span><br><span class="line">                EventLog.writeEvent(EventLogTags.AM_PROC_GOOD,</span><br><span class="line">                        UserHandle.getUserId(info.uid), info.uid,</span><br><span class="line">                        info.processName);</span><br><span class="line"></span><br><span class="line">                mAppErrors.clearBadProcessLocked(info);</span><br><span class="line">                <span class="keyword">if</span> (app != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    app.bad = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对于隔离进程，不能利用已存在的 ProcessRecord！</span></span><br><span class="line">        app = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// app launch boost for big.little configurations</span></span><br><span class="line">    <span class="comment">// use cpusets to migrate freshly launched tasks to big cores</span></span><br><span class="line">    nativeMigrateToBoost();</span><br><span class="line">    mIsBoosted = <span class="keyword">true</span>;</span><br><span class="line">    mBoostStartTime = SystemClock.uptimeMillis();</span><br><span class="line">    Message msg = mHandler.obtainMessage(APP_BOOST_DEACTIVATE_MSG);</span><br><span class="line">    mHandler.sendMessageDelayed(msg, APP_BOOST_MESSAGE_DELAY);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG_PROCESSES) Slog.v(TAG_PROCESSES, <span class="string">"startProcess: name="</span> + processName</span><br><span class="line">            + <span class="string">" app="</span> + app + <span class="string">" knownToBeDead="</span> + knownToBeDead</span><br><span class="line">            + <span class="string">" thread="</span> + (app != <span class="keyword">null</span> ? app.thread : <span class="keyword">null</span>)</span><br><span class="line">            + <span class="string">" pid="</span> + (app != <span class="keyword">null</span> ? app.pid : -<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 如果 app 不为 null，且 pid 大于 0，说明这个进程已经或者正在启动！</span></span><br><span class="line">    <span class="keyword">if</span> (app != <span class="keyword">null</span> &amp;&amp; app.pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 如果调用者不知道该进程已死亡，并且进程并没有被 kill（正在运行）</span></span><br><span class="line">        <span class="comment">// 或是该 ProcessRecord 没有绑定应用程序进程的 ApplicationThread 对象！</span></span><br><span class="line">        <span class="keyword">if</span> ((!knownToBeDead &amp;&amp; !app.killed) || app.thread == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (DEBUG_PROCESSES) Slog.v(TAG_PROCESSES, <span class="string">"App already running: "</span> + app);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果这是该进程中的一个新应用 package，将其加入到进程的列表中！</span></span><br><span class="line">            app.addPackage(info.packageName, info.versionCode, mProcessStats);</span><br><span class="line">            checkTime(startTime, <span class="string">"startProcess: done, added package to proc"</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 直接返回这个已经存在的 ProcessRecord，退出！</span></span><br><span class="line">            <span class="keyword">return</span> app;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// An application record is attached to a previous process,</span></span><br><span class="line">        <span class="comment">// clean it up now.</span></span><br><span class="line">        <span class="keyword">if</span> (DEBUG_PROCESSES || DEBUG_CLEANUP) Slog.v(TAG_PROCESSES, <span class="string">"App died: "</span> + app);</span><br><span class="line">        checkTime(startTime, <span class="string">"startProcess: bad proc running, killing"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 该 ProcessRecord 已经绑定了上一个进程，杀死并清理该进程！</span></span><br><span class="line">        killProcessGroup(app.uid, app.pid);</span><br><span class="line">        handleAppDiedLocked(app, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">        checkTime(startTime, <span class="string">"startProcess: done killing old proc"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String hostingNameStr = hostingName != <span class="keyword">null</span></span><br><span class="line">            ? hostingName.flattenToShortString() : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (app == <span class="keyword">null</span>) &#123; <span class="comment">// 如果 app 为 null，那说明这是一个新进程！</span></span><br><span class="line">        checkTime(startTime, <span class="string">"startProcess: creating new process record"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建新进程对应的 ProcessRecord 对象！</span></span><br><span class="line">        app = newProcessRecordLocked(info, processName, isolated, isolatedUid);</span><br><span class="line">        <span class="keyword">if</span> (app == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Failed making new process record for "</span></span><br><span class="line">                    + processName + <span class="string">"/"</span> + info.uid + <span class="string">" isolated="</span> + isolated);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置进程的 crashHandler，默认为 null！</span></span><br><span class="line">        app.crashHandler = crashHandler;</span><br><span class="line">        checkTime(startTime, <span class="string">"startProcess: done creating new process record"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果这是该进程中的一个新应用 package，将其加入到进程的列表中！</span></span><br><span class="line">        app.addPackage(info.packageName, info.versionCode, mProcessStats);</span><br><span class="line">        checkTime(startTime, <span class="string">"startProcess: added package to existing proc"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果系统还没准备好，则将当前进程加入到 mPorcessOnHold 中！</span></span><br><span class="line">    <span class="keyword">if</span> (!mProcessesReady</span><br><span class="line">            &amp;&amp; !isAllowedWhileBooting(info)</span><br><span class="line">            &amp;&amp; !allowWhileBooting) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!mProcessesOnHold.contains(app)) &#123;</span><br><span class="line">            mProcessesOnHold.add(app);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_PROCESSES) Slog.v(TAG_PROCESSES,</span><br><span class="line">                <span class="string">"System not ready, putting on hold: "</span> + app);</span><br><span class="line">        checkTime(startTime, <span class="string">"startProcess: returning with proc on hold"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回这个进程对应的 ProcessRecord 对象！</span></span><br><span class="line">        <span class="keyword">return</span> app;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    checkTime(startTime, <span class="string">"startProcess: stepping in to startProcess"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里，说明进程还没有创建，接着调用 startRrocessLocked 方法，进行进一步的启动！</span></span><br><span class="line">    startProcessLocked(</span><br><span class="line">            app, hostingType, hostingNameStr, abiOverride, entryPoint, entryPointArgs);</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">    checkTime(startTime, <span class="string">"startProcess: done starting proc!"</span>);</span><br><span class="line">    <span class="keyword">return</span> (app.pid != <span class="number">0</span>) ? app : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续分析！</p>
<h2 id="3-1-AMS-newProcessRecordLocked"><a href="#3-1-AMS-newProcessRecordLocked" class="headerlink" title="3.1 AMS.newProcessRecordLocked"></a>3.1 AMS.newProcessRecordLocked</h2><p>创建进程对应的 ProcessRecord 结构体，参数传递：</p>
<ul>
<li>ApplicationInfo info：应用程序的 info 对象！</li>
<li>String customProcess：进程名</li>
<li>boolean isolated：是否是隔离进程！</li>
<li>int isolatedUid：隔离进程的 uid，默认传入 0！</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ProcessRecord <span class="title">newProcessRecordLocked</span><span class="params">(ApplicationInfo info, String customProcess,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> isolated, <span class="keyword">int</span> isolatedUid)</span> </span>&#123;</span><br><span class="line">    String proc = customProcess != <span class="keyword">null</span> ? customProcess : info.processName;</span><br><span class="line">    BatteryStatsImpl stats = mBatteryStatsService.getActiveStatistics();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> userId = UserHandle.getUserId(info.uid);</span><br><span class="line">    <span class="keyword">int</span> uid = info.uid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isolated) &#123; <span class="comment">// 隔离进程！</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isolatedUid == <span class="number">0</span>) &#123; <span class="comment">//如果传入的值的是默认值 0，系统会给隔离进程分配 uid！</span></span><br><span class="line">            <span class="keyword">int</span> stepsLeft = Process.LAST_ISOLATED_UID - Process.FIRST_ISOLATED_UID + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mNextIsolatedProcessUid &lt; Process.FIRST_ISOLATED_UID</span><br><span class="line">                        || mNextIsolatedProcessUid &gt; Process.LAST_ISOLATED_UID) &#123;</span><br><span class="line">                    mNextIsolatedProcessUid = Process.FIRST_ISOLATED_UID;</span><br><span class="line">                &#125;</span><br><span class="line">                uid = UserHandle.getUid(userId, mNextIsolatedProcessUid);</span><br><span class="line">                mNextIsolatedProcessUid++;</span><br><span class="line">                <span class="keyword">if</span> (mIsolatedProcesses.indexOfKey(uid) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// No process for this uid, use it.</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                stepsLeft--;</span><br><span class="line">                <span class="keyword">if</span> (stepsLeft &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果传入的不是默认值 0，那隔离进程的 uid 就由传入参数指定！</span></span><br><span class="line">            uid = isolatedUid;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Register the isolated UID with this application so BatteryStats knows to</span></span><br><span class="line">        <span class="comment">// attribute resource usage to the application.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> This is done here before addProcessNameLocked, which will tell BatteryStats</span></span><br><span class="line">        <span class="comment">// about the process state of the isolated UID *before* it is registered with the</span></span><br><span class="line">        <span class="comment">// owning application.</span></span><br><span class="line">        mBatteryStatsService.addIsolatedUid(uid, info.uid);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 创建 ProcessRecord 对象！</span></span><br><span class="line">    <span class="keyword">final</span> ProcessRecord r = <span class="keyword">new</span> ProcessRecord(stats, info, proc, uid);</span><br><span class="line">    <span class="keyword">if</span> (!mBooted &amp;&amp; !mBooting</span><br><span class="line">            &amp;&amp; userId == UserHandle.USER_SYSTEM</span><br><span class="line">            &amp;&amp; (info.flags &amp; PERSISTENT_MASK) == PERSISTENT_MASK) &#123;</span><br><span class="line">        <span class="comment">// 设置其 persistent 属性 为 true！</span></span><br><span class="line">        r.persistent = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 见 3.1.1</span></span><br><span class="line">    addProcessNameLocked(r);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-1-1-AMS-addProcessNameLocked"><a href="#3-1-1-AMS-addProcessNameLocked" class="headerlink" title="3.1.1 AMS.addProcessNameLocked"></a>3.1.1 AMS.addProcessNameLocked</h3><p>接着，调用该方法，将新创建的 ProcessRecord 加入到 AMS 对应的集合：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addProcessNameLocked</span><span class="params">(ProcessRecord proc)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// We shouldn't already have a process under this name, but just in case we</span></span><br><span class="line">    <span class="comment">// need to clean up whatever may be there now.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 移除相同的之前被添加过的进程！</span></span><br><span class="line">    ProcessRecord old = removeProcessNameLocked(proc.processName, proc.uid);</span><br><span class="line">    <span class="keyword">if</span> (old == proc &amp;&amp; proc.persistent) &#123;</span><br><span class="line">        <span class="comment">// We are re-adding a persistent process.  Whatevs!  Just leave it there.</span></span><br><span class="line">        Slog.w(TAG, <span class="string">"Re-adding persistent process "</span> + proc);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (old != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Slog.wtf(TAG, <span class="string">"Already have existing proc "</span> + old + <span class="string">" when adding "</span> + proc);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 给这个进程的所属 uid 创建 UidRecord 对象，如果已创建过了，就不创建！！</span></span><br><span class="line">    UidRecord uidRec = mActiveUids.get(proc.uid);</span><br><span class="line">    <span class="keyword">if</span> (uidRec == <span class="keyword">null</span>) &#123;</span><br><span class="line">        uidRec = <span class="keyword">new</span> UidRecord(proc.uid);</span><br><span class="line">        <span class="comment">// This is the first appearance of the uid, report it now!</span></span><br><span class="line">        <span class="keyword">if</span> (DEBUG_UID_OBSERVERS) Slog.i(TAG_UID_OBSERVERS,</span><br><span class="line">                <span class="string">"Creating new process uid: "</span> + uidRec);</span><br><span class="line">        <span class="comment">// 第一次创建时，要加入到 mActiveUids 集合中去！        </span></span><br><span class="line">        mActiveUids.put(proc.uid, uidRec);</span><br><span class="line">        noteUidProcessState(uidRec.uid, uidRec.curProcState);</span><br><span class="line">        enqueueUidChangeLocked(uidRec, -<span class="number">1</span>, UidRecord.CHANGE_ACTIVE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加 proc 对 UidRecord 引用！</span></span><br><span class="line">    proc.uidRecord = uidRec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Reset render thread tid if it was already set, so new process can set it again.</span></span><br><span class="line">    proc.renderThreadTid = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// UidRecord 的被引用计数加 1</span></span><br><span class="line">    uidRec.numProcs++;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将新创建的 ProcessRecord 对象加入到 ams 的 ProcessNames 中！</span></span><br><span class="line">    mProcessNames.put(proc.processName, proc.uid, proc);</span><br><span class="line">    <span class="keyword">if</span> (proc.isolated) &#123;</span><br><span class="line">        <span class="comment">// 如果该进程是隔离进程，还要添加到 mIsolatedProcesses 集合中去！！</span></span><br><span class="line">        mIsolatedProcesses.put(proc.uid, proc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里有提到 AMS 的几个成员对象：</p>
<ul>
<li>mActiveUids：当前活跃的 uid 集合；</li>
<li>mProcessNames：以进程的 processName 为 key，存储所有的 ProcessRecord 对象！</li>
<li>mIsolatedProcesses：以进程的 pid 为 key，存储所有的 ProcessRecord 对象！</li>
</ul>
<h1 id="4-startProcessLocked-ProcessRecord"><a href="#4-startProcessLocked-ProcessRecord" class="headerlink" title="4 startProcessLocked - ProcessRecord"></a>4 startProcessLocked - ProcessRecord</h1><p>接着们就要进入最关键的一个方法哦，启动进程！<br>参数传递：</p>
<ul>
<li>ProcessRecord app, </li>
<li>String hostingType,</li>
<li>String hostingNameStr：</li>
<li>String abiOverride：</li>
<li>String entryPoint：null</li>
<li>String[] entryPointArg：null</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">startProcessLocked</span><span class="params">(ProcessRecord app, String hostingType,</span></span></span><br><span class="line"><span class="function"><span class="params">        String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> startTime = SystemClock.elapsedRealtime();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果要启动的进程不是 systemServer 进程，也就是应用进程！</span></span><br><span class="line">    <span class="keyword">if</span> (app.pid &gt; <span class="number">0</span> &amp;&amp; app.pid != MY_PID) &#123;</span><br><span class="line">        checkTime(startTime, <span class="string">"startProcess: removing from pids map"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (mPidsSelfLocked) &#123;</span><br><span class="line">            <span class="comment">// 将进程从 mPidsSelfLocked 中移除！</span></span><br><span class="line">            mPidsSelfLocked.remove(app.pid);</span><br><span class="line">            mHandler.removeMessages(PROC_START_TIMEOUT_MSG, app);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        checkTime(startTime, <span class="string">"startProcess: done removing from pids map"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先设置进程的 pid 为 0！</span></span><br><span class="line">        app.setPid(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG_PROCESSES &amp;&amp; mProcessesOnHold.contains(app)) Slog.v(TAG_PROCESSES,</span><br><span class="line">            <span class="string">"startProcessLocked removing on hold: "</span> + app);</span><br><span class="line">            </span><br><span class="line">    <span class="comment">// 记得前面的 mProcessesOnHold 吗？也要把进程从这里 remove 掉！</span></span><br><span class="line">    mProcessesOnHold.remove(app);</span><br><span class="line"></span><br><span class="line">    checkTime(startTime, <span class="string">"startProcess: starting to update cpu stats"</span>);</span><br><span class="line">    updateCpuStats();</span><br><span class="line">    checkTime(startTime, <span class="string">"startProcess: done updating cpu stats"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获得设备用户 id!</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> userId = UserHandle.getUserId(app.uid);</span><br><span class="line">            AppGlobals.getPackageManager().checkPackageStartable(app.info.packageName, userId);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e.rethrowAsRuntimeException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> uid = app.uid;</span><br><span class="line">        <span class="keyword">int</span>[] gids = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> mountExternal = Zygote.MOUNT_EXTERNAL_NONE;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!app.isolated) &#123; <span class="comment">// 对于非隔离的进程！</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span>[] permGids = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                checkTime(startTime, <span class="string">"startProcess: getting gids from package manager"</span>);</span><br><span class="line">                <span class="keyword">final</span> IPackageManager pm = AppGlobals.getPackageManager();</span><br><span class="line"></span><br><span class="line">                permGids = pm.getPackageGids(app.info.packageName,</span><br><span class="line">                        MATCH_DEBUG_TRIAGED_MISSING, app.userId);</span><br><span class="line"></span><br><span class="line">                MountServiceInternal mountServiceInternal = LocalServices.getService(</span><br><span class="line">                        MountServiceInternal.class);</span><br><span class="line"></span><br><span class="line">                mountExternal = mountServiceInternal.getExternalStorageMountMode(uid,</span><br><span class="line">                        app.info.packageName);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e.rethrowAsRuntimeException();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Add shared application and profile GIDs so applications can share some</span></span><br><span class="line"><span class="comment">             * resources like shared libraries and access user-wide resources</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (ArrayUtils.isEmpty(permGids)) &#123;</span><br><span class="line">                gids = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                gids = <span class="keyword">new</span> <span class="keyword">int</span>[permGids.length + <span class="number">2</span>];</span><br><span class="line">                System.arraycopy(permGids, <span class="number">0</span>, gids, <span class="number">2</span>, permGids.length);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            gids[<span class="number">0</span>] = UserHandle.getSharedAppGid(UserHandle.getAppId(uid));</span><br><span class="line">            gids[<span class="number">1</span>] = UserHandle.getUserGid(UserHandle.getUserId(uid));</span><br><span class="line">        &#125;</span><br><span class="line">        checkTime(startTime, <span class="string">"startProcess: building args"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mFactoryTest != FactoryTest.FACTORY_TEST_OFF) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mFactoryTest == FactoryTest.FACTORY_TEST_LOW_LEVEL</span><br><span class="line">                    &amp;&amp; mTopComponent != <span class="keyword">null</span></span><br><span class="line">                    &amp;&amp; app.processName.equals(mTopComponent.getPackageName())) &#123;</span><br><span class="line">                uid = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mFactoryTest == FactoryTest.FACTORY_TEST_HIGH_LEVEL</span><br><span class="line">                    &amp;&amp; (app.info.flags&amp;ApplicationInfo.FLAG_FACTORY_TEST) != <span class="number">0</span>) &#123;</span><br><span class="line">                uid = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理 debugFlags 相关的取值！</span></span><br><span class="line">        <span class="keyword">int</span> debugFlags = <span class="number">0</span>;</span><br><span class="line">       </span><br><span class="line">        ... ... ... ...<span class="comment">// 此处是设置调试相关的代码，暂时省略！ </span></span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 设置 app 要运行的硬件环境！</span></span><br><span class="line">        String requiredAbi = (abiOverride != <span class="keyword">null</span>) ? abiOverride : app.info.primaryCpuAbi;</span><br><span class="line">        <span class="keyword">if</span> (requiredAbi == <span class="keyword">null</span>) &#123;</span><br><span class="line">            requiredAbi = Build.SUPPORTED_ABIS[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String instructionSet = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (app.info.primaryCpuAbi != <span class="keyword">null</span>) &#123;</span><br><span class="line">            instructionSet = VMRuntime.getInstructionSet(app.info.primaryCpuAbi);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置进程的 gids，运行的环境等等！</span></span><br><span class="line">        app.gids = gids;</span><br><span class="line">        app.requiredAbi = requiredAbi;</span><br><span class="line">        app.instructionSet = instructionSet;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置新进程创建后的入口："android.app.ActivityThread"</span></span><br><span class="line">        <span class="keyword">boolean</span> isActivityProcess = (entryPoint == <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (entryPoint == <span class="keyword">null</span>) entryPoint = <span class="string">"android.app.ActivityThread"</span>;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"Start proc: "</span> +</span><br><span class="line">                app.processName);</span><br><span class="line"></span><br><span class="line">        checkTime(startTime, <span class="string">"startProcess: asking zygote to start proc"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里很关键！！调用了 Process.Start 方法，创建新进程，并返回创建结果！</span></span><br><span class="line">        <span class="comment">// 这类返回 startResult 包含子进程的 pid 等信息！</span></span><br><span class="line">        Process.ProcessStartResult startResult = Process.start(entryPoint,</span><br><span class="line">                app.processName, uid, uid, gids, debugFlags, mountExternal,</span><br><span class="line">                app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet,</span><br><span class="line">                app.info.dataDir, entryPointArgs);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        checkTime(startTime, <span class="string">"startProcess: returned from zygote!"</span>);</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line"></span><br><span class="line">        mBatteryStatsService.noteProcessStart(app.processName, app.info.uid);</span><br><span class="line">        checkTime(startTime, <span class="string">"startProcess: done updating battery stats"</span>);</span><br><span class="line"></span><br><span class="line">        EventLog.writeEvent(EventLogTags.AM_PROC_START,</span><br><span class="line">                UserHandle.getUserId(uid), startResult.pid, uid,</span><br><span class="line">                app.processName, hostingType,</span><br><span class="line">                hostingNameStr != <span class="keyword">null</span> ? hostingNameStr : <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            AppGlobals.getPackageManager().logAppProcessStartIfNeeded(app.processName, app.uid,</span><br><span class="line">                    app.info.seinfo, app.info.sourceDir, startResult.pid);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">            <span class="comment">// Ignore</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (app.persistent) &#123; <span class="comment">// 如果是 persistent 的进程，启动 WathDog 进行监控！</span></span><br><span class="line">            Watchdog.getInstance().processStarted(app.processName, startResult.pid);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        checkTime(startTime, <span class="string">"startProcess: building log message"</span>);</span><br><span class="line">        StringBuilder buf = mStringBuilder;</span><br><span class="line">        buf.setLength(<span class="number">0</span>);</span><br><span class="line">        buf.append(<span class="string">"Start proc "</span>);</span><br><span class="line">        buf.append(startResult.pid);</span><br><span class="line">        buf.append(<span class="string">':'</span>);</span><br><span class="line">        buf.append(app.processName);</span><br><span class="line">        buf.append(<span class="string">'/'</span>);</span><br><span class="line">        UserHandle.formatUid(buf, uid);</span><br><span class="line">        <span class="keyword">if</span> (!isActivityProcess) &#123;</span><br><span class="line">            buf.append(<span class="string">" ["</span>);</span><br><span class="line">            buf.append(entryPoint);</span><br><span class="line">            buf.append(<span class="string">"]"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        buf.append(<span class="string">" for "</span>);</span><br><span class="line">        buf.append(hostingType);</span><br><span class="line">        <span class="keyword">if</span> (hostingNameStr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            buf.append(<span class="string">" "</span>);</span><br><span class="line">            buf.append(hostingNameStr);</span><br><span class="line">        &#125;</span><br><span class="line">        Slog.i(TAG, buf.toString());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 根据创建进程的返回结果设置对应的 ProcessRecord 的参数：pid 等等！</span></span><br><span class="line">        app.setPid(startResult.pid);</span><br><span class="line">        app.usingWrapper = startResult.usingWrapper;</span><br><span class="line">        app.removed = <span class="keyword">false</span>;</span><br><span class="line">        app.killed = <span class="keyword">false</span>;</span><br><span class="line">        app.killedByAm = <span class="keyword">false</span>;</span><br><span class="line">        checkTime(startTime, <span class="string">"startProcess: starting to update pids map"</span>);</span><br><span class="line"></span><br><span class="line">        ProcessRecord oldApp;</span><br><span class="line">        <span class="keyword">synchronized</span> (mPidsSelfLocked) &#123;</span><br><span class="line">            oldApp = mPidsSelfLocked.get(startResult.pid);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果已经有一个应用进程占用了分配的 pid，那就对这个进程进行清理！</span></span><br><span class="line">        <span class="keyword">if</span> (oldApp != <span class="keyword">null</span> &amp;&amp; !app.isolated) &#123;</span><br><span class="line">            <span class="comment">// Clean up anything relating to this pid first</span></span><br><span class="line">            Slog.w(TAG, <span class="string">"Reusing pid "</span> + startResult.pid</span><br><span class="line">                    + <span class="string">" while app is still mapped to it"</span>);</span><br><span class="line">            cleanUpApplicationRecordLocked(oldApp, <span class="keyword">false</span>, <span class="keyword">false</span>, -<span class="number">1</span>,</span><br><span class="line">                    <span class="keyword">true</span> <span class="comment">/*replacingPid*/</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (mPidsSelfLocked) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将新创建的进程加入到 mPidsSelfLocked，用于 AMS 进行管理！ </span></span><br><span class="line">            <span class="keyword">this</span>.mPidsSelfLocked.put(startResult.pid, app);</span><br><span class="line">            <span class="keyword">if</span> (isActivityProcess) &#123;</span><br><span class="line">                Message msg = mHandler.obtainMessage(PROC_START_TIMEOUT_MSG);</span><br><span class="line">                msg.obj = app;</span><br><span class="line">                mHandler.sendMessageDelayed(msg, startResult.usingWrapper</span><br><span class="line">                        ? PROC_START_TIMEOUT_WITH_WRAPPER : PROC_START_TIMEOUT);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        checkTime(startTime, <span class="string">"startProcess: done updating pids map"</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        Slog.e(TAG, <span class="string">"Failure starting process "</span> + app.processName, e);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 进程启动失败：比如，进程被冻结了等等，就调用  forceStopPackageLocked 清理进程！</span></span><br><span class="line">        forceStopPackageLocked(app.info.packageName, UserHandle.getAppId(app.uid), <span class="keyword">false</span>,</span><br><span class="line">                <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, UserHandle.getUserId(app.userId), <span class="string">"start failure"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法很长，我们回顾一下它的主要作用：</p>
<ul>
<li>先将进程的 pid 设置为 0，</li>
<li>根据不同参数，设置相应的 debugFlags，比如在 AndroidManifest.xml 中设置 androidd:debuggable 为 true，代表 app 运行在 debug 模式，则增加 debugger 标识以及开启 JNI check 功能等等。</li>
<li>调用 <strong>Process.start</strong> 进入 Zygote，来创建新进程，并返回创建的结果 ProcessStartResult 。</li>
<li>根据 fork 的结果，再次设置 ProcessRecord 的成员变量， 包括 pid， killded，killedByAm 等等属性！</li>
</ul>
<p>可以看出，这个方法的关键，就在于 Process.start 方法，是用来创建进程的，这个方法我们在第二篇：进程的创建一文中有讲，这里因为篇幅关系，就省略了！</p>
<p>接着就要进入这个新进程的 ActivityThread.main 方法了：</p>
<h1 id="5-ActivityThread-main"><a href="#5-ActivityThread-main" class="headerlink" title="5 ActivityThread.main"></a>5 ActivityThread.main</h1><p>这个方法是应用程序进程的入口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"ActivityThreadMain"</span>);</span><br><span class="line">    SamplingProfilerIntegration.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CloseGuard defaults to true and can be quite spammy.  We</span></span><br><span class="line">    <span class="comment">// disable it here, but selectively enable it later (via</span></span><br><span class="line">    <span class="comment">// StrictMode) on debug builds, but using DropBox, not logs.</span></span><br><span class="line">    CloseGuard.setEnabled(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前进程所在 userId 赋值给 sCurrentUser</span></span><br><span class="line">    Environment.initForCurrentUser();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the reporter for event logging in libcore</span></span><br><span class="line">    EventLogger.setReporter(<span class="keyword">new</span> EventLoggingReporter());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure TrustedCertificateStore looks in the right place for CA certificates</span></span><br><span class="line">    <span class="keyword">final</span> File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());</span><br><span class="line">    TrustedCertificateStore.setDefaultUserDirectory(configDir);</span><br><span class="line"></span><br><span class="line">    Process.setArgV0(<span class="string">"&lt;pre-initialized&gt;"</span>);</span><br><span class="line">    <span class="comment">// 创建主线程的 Looper 对象！</span></span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建该进程的  ActivityThread 对象！</span></span><br><span class="line">    ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// attach 到 ActiviyManagerService ，保持进程和 SystemServer 的 binder 通信！</span></span><br><span class="line">    <span class="comment">// 这里我们下面重点讲！</span></span><br><span class="line">    thread.attach(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 获得主线程的 Handler 对象 mH；</span></span><br><span class="line">        sMainThreadHandler = thread.getHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">false</span>) &#123; <span class="comment">// 当设置为 true 时，可打开消息队列的 debug log 信息</span></span><br><span class="line">        Looper.myLooper().setMessageLogging(<span class="keyword">new</span></span><br><span class="line">                LogPrinter(Log.DEBUG, <span class="string">"ActivityThread"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// End of event ActivityThreadMain.</span></span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 进入消息循环，没消息进入休眠状态，有消息进入唤醒状态!</span></span><br><span class="line">    Looper.loop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法的作用有如下：</p>
<ul>
<li>创建主线程的 Looper 对象，主线程的 Looper 对象是在进程创建后自动创建的！</li>
<li>创建该进程的 ActivityThread 对象，每一个进程都有一个 ActivityThread 对象！<ul>
<li>mAppThread = new ApplicationThread()，创建 ApplicationThread 对象，他是应用进程和 AMS 通信的桥梁；</li>
<li>mLooper = Looper.myLooper()，获得主线程的 Looper 对象；</li>
<li>mH = new H()，H 继承于 Handler 对象，主线程的 Handler，用于处理组件的生命周期！</li>
<li>… … …</li>
</ul>
</li>
<li>获得主线程的 Handler 对象 mH：</li>
<li>进入消息循环：Looper.loop，没有消息进入休眠，有消息就被唤醒，处理消息！</li>
</ul>
<blockquote>
<p><strong>注意</strong>：这里要先说一下：ActivityThread 和 ApplicationThread 对象，二者都不是线程对象！一个应用程序进程对应一个 ActivityThread 实例，应用程序进程由 ActivityThread.main 打开消息循环；同时，一个应用程序进程也对应一个 ApplicationThread 对象，此对象是 ActivityThread 与 ActivityManagerService 连接的桥梁！</p>
</blockquote>
<h1 id="6-ActivityThread-attach"><a href="#6-ActivityThread-attach" class="headerlink" title="6 ActivityThread.attach"></a>6 ActivityThread.attach</h1><p>参数传递：</p>
<ul>
<li>system：表示是否是系统进程的 ActivityThread，调用传入 false。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(<span class="keyword">boolean</span> system)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 表示当前进程的 ActivityThread</span></span><br><span class="line">    sCurrentActivityThread = <span class="keyword">this</span>;</span><br><span class="line">    mSystemThread = system;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!system) &#123; <span class="comment">// 应用进程，进入这个分支。</span></span><br><span class="line">        ViewRootImpl.addFirstDrawHandler(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 开启虚拟机的 jit 即时编译功能</span></span><br><span class="line">                ensureJitEnabled();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        android.ddm.DdmHandleAppName.setAppName(<span class="string">"&lt;pre-initialized&gt;"</span>,</span><br><span class="line">                                                UserHandle.myUserId());</span><br><span class="line">        RuntimeInit.setApplicationObject(mAppThread.asBinder());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得 AMS </span></span><br><span class="line">        <span class="keyword">final</span> IActivityManager mgr = ActivityManagerNative.getDefault();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">// 调用 ams 的 attachApplication 方法</span></span><br><span class="line">            mgr.attachApplication(mAppThread);</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Watch for getting close to heap limit.</span></span><br><span class="line">        <span class="comment">// 观察是否快接近 heap 的上限</span></span><br><span class="line">        BinderInternal.addGcWatcher(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (!mSomeActivitiesChanged) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                Runtime runtime = Runtime.getRuntime();</span><br><span class="line">                <span class="keyword">long</span> dalvikMax = runtime.maxMemory();</span><br><span class="line">                <span class="keyword">long</span> dalvikUsed = runtime.totalMemory() - runtime.freeMemory();</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 当进程虚拟机的已用内存超过最大内存的 3/4</span></span><br><span class="line">                <span class="keyword">if</span> (dalvikUsed &gt; ((<span class="number">3</span>*dalvikMax)/<span class="number">4</span>)) &#123;</span><br><span class="line">                </span><br><span class="line">                    <span class="keyword">if</span> (DEBUG_MEMORY_TRIM) Slog.d(TAG, <span class="string">"Dalvik max="</span> + (dalvikMax/<span class="number">1024</span>)</span><br><span class="line">                            + <span class="string">" total="</span> + (runtime.totalMemory()/<span class="number">1024</span>)</span><br><span class="line">                            + <span class="string">" used="</span> + (dalvikUsed/<span class="number">1024</span>));</span><br><span class="line">                            </span><br><span class="line">                    mSomeActivitiesChanged = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 调用 AMS 的 releaseSomeActivities 方法释放进程的内存！</span></span><br><span class="line">                        mgr.releaseSomeActivities(mAppThread);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 这里是处理系统进程的：SystemServer，这里不看</span></span><br><span class="line">        android.ddm.DdmHandleAppName.setAppName(<span class="string">"system_process"</span>,</span><br><span class="line">                UserHandle.myUserId());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mInstrumentation = <span class="keyword">new</span> Instrumentation();</span><br><span class="line">            ContextImpl context = ContextImpl.createAppContext(<span class="keyword">this</span>, getSystemContext().mPackageInfo);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建系统进程的 Application 对象！        </span></span><br><span class="line">            mInitialApplication = context.mPackageInfo.makeApplication(<span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line">            mInitialApplication.onCreate();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="string">"Unable to instantiate Application():"</span> + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// add dropbox logging to libcore</span></span><br><span class="line">    DropBox.setReporter(<span class="keyword">new</span> DropBoxReporter());</span><br><span class="line">    <span class="comment">// 添加 Config 回调接口</span></span><br><span class="line">    ViewRootImpl.addConfigCallback(<span class="keyword">new</span> ComponentCallbacks2() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConfigurationChanged</span><span class="params">(Configuration newConfig)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mResourcesManager) &#123;</span><br><span class="line">                <span class="comment">// We need to apply this change to the resources</span></span><br><span class="line">                <span class="comment">// immediately, because upon returning the view</span></span><br><span class="line">                <span class="comment">// hierarchy will be informed about it.</span></span><br><span class="line">                <span class="keyword">if</span> (mResourcesManager.applyConfigurationToResourcesLocked(newConfig, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    updateLocaleListFromAppContext(mInitialApplication.getApplicationContext(),</span><br><span class="line">                            mResourcesManager.getConfiguration().getLocales());</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// This actually changed the resources!  Tell</span></span><br><span class="line">                    <span class="comment">// everyone about it.</span></span><br><span class="line">                    <span class="keyword">if</span> (mPendingConfiguration == <span class="keyword">null</span> ||</span><br><span class="line">                            mPendingConfiguration.isOtherSeqNewer(newConfig)) &#123;</span><br><span class="line">                        mPendingConfiguration = newConfig;</span><br><span class="line"></span><br><span class="line">                        sendMessage(H.CONFIGURATION_CHANGED, newConfig);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLowMemory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTrimMemory</span><span class="params">(<span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于应用进程的 attach 主要流程：</p>
<ul>
<li>创建线程来开启虚拟机的 JIT 即时编译。</li>
<li><strong>通过 binder，调用到 AMS.attachApplication，其参数 mAppThread 的数据类型为 ApplicationThread</strong>。</li>
<li>观察是否快接近 heap 的上限，当已用内存超过最大内存的 3 / 4，则请求释放内存空间。</li>
<li>添加 dropbox 日志到 libcore。</li>
<li>添加 Config 回调接口。</li>
</ul>
<h1 id="7-ActivityManagerProxy-attachApplication"><a href="#7-ActivityManagerProxy-attachApplication" class="headerlink" title="7 ActivityManagerProxy.attachApplication"></a>7 ActivityManagerProxy.attachApplication</h1><ul>
<li>参数传递：IApplicationThread app，这里传入的是 ApplicationThread 对象！</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public void attachApplication(IApplicationThread app) throws RemoteException</span><br><span class="line">&#123;</span><br><span class="line">    Parcel data = Parcel.obtain();</span><br><span class="line">    Parcel reply = Parcel.obtain();</span><br><span class="line">    data.writeInterfaceToken(IActivityManager.descriptor);</span><br><span class="line">    data.writeStrongBinder(app.asBinder());</span><br><span class="line">    // binder 通信！</span><br><span class="line">    mRemote.transact(ATTACH_APPLICATION_TRANSACTION, data, reply, 0);</span><br><span class="line">    reply.readException();</span><br><span class="line">    data.recycle();</span><br><span class="line">    reply.recycle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上是在应用进程里面，下面就要通过 Binder 通信，进入系统进程中：<br>此处：descriptor = “android.app.IActivityManager”，用来校验使用的！</p>
<h1 id="8-ActivityManagerNative-onTransact"><a href="#8-ActivityManagerNative-onTransact" class="headerlink" title="8 ActivityManagerNative.onTransact"></a>8 ActivityManagerNative.onTransact</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (code) &#123;</span><br><span class="line"></span><br><span class="line">    ... ... ... ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> ATTACH_APPLICATION_TRANSACTION: &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 校验 binder 通信是否匹配!</span></span><br><span class="line">        data.enforceInterface(IActivityManager.descriptor);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通过 asInterface 接口，将 ApplicationThread 对象转为 ApplicationTreadProxy 对象！</span></span><br><span class="line">        IApplicationThread app = ApplicationThreadNative.asInterface(</span><br><span class="line">                data.readStrongBinder());</span><br><span class="line">                </span><br><span class="line">        <span class="keyword">if</span> (app != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用 IActivityManager 的方法，接下来，进入 AMS！</span></span><br><span class="line">            attachApplication(app);</span><br><span class="line">        &#125;</span><br><span class="line">        reply.writeNoException();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ... ... ... ...</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 Binder 通信，调用 AMS 的方法：！</p>
<h1 id="9-ActivityManagerService-attachApplication"><a href="#9-ActivityManagerService-attachApplication" class="headerlink" title="9 ActivityManagerService.attachApplication"></a>9 ActivityManagerService.attachApplication</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attachApplication</span><span class="params">(IApplicationThread thread)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得调用方的 pid，这里是应用进程的 pid！</span></span><br><span class="line">        <span class="keyword">int</span> callingPid = Binder.getCallingPid();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用 attachApplicationLocked 继续处理！</span></span><br><span class="line">        attachApplicationLocked(thread, callingPid);</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里简单，再获得应用进程的 pid！</p>
<h1 id="10-ActivityManagerService-attachApplicationLocked"><a href="#10-ActivityManagerService-attachApplicationLocked" class="headerlink" title="10 ActivityManagerService.attachApplicationLocked"></a>10 ActivityManagerService.attachApplicationLocked</h1><p>传入参数：</p>
<ul>
<li>ApplicationThreadProxy 对象，应用程序进程的 pid</li>
</ul>
<p>删掉了部分的注释！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">attachApplicationLocked</span><span class="params">(IApplicationThread thread,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> pid)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ProcessRecord app;</span><br><span class="line">    <span class="keyword">if</span> (pid != MY_PID &amp;&amp; pid &gt;= <span class="number">0</span>) &#123; <span class="comment">// 显然，调用方进程不是 SystemServer 进程！</span></span><br><span class="line">        <span class="keyword">synchronized</span> (mPidsSelfLocked) &#123;</span><br><span class="line"></span><br><span class="line">            app = mPidsSelfLocked.get(pid); <span class="comment">// 获得该进程的 ProcessRecord 对象！</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        app = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (app == <span class="keyword">null</span>) &#123;  <span class="comment">// 如果获得的 ProcessRecord 为 null，这里是属于异常情况！</span></span><br><span class="line">       </span><br><span class="line">        Slog.w(TAG, <span class="string">"No pending application record for pid "</span> + pid</span><br><span class="line">                + <span class="string">" (IApplicationThread "</span> + thread + <span class="string">"); dropping process"</span>);</span><br><span class="line">        EventLog.writeEvent(EventLogTags.AM_DROP_PROCESS, pid);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pid &gt; <span class="number">0</span> &amp;&amp; pid != MY_PID) &#123; <span class="comment">// 如果调用方不是 SystemServer 进程，杀掉进程组！</span></span><br><span class="line"></span><br><span class="line">            Process.killProcessQuiet(pid);</span><br><span class="line">            <span class="comment">//<span class="doctag">TODO:</span> killProcessGroup(app.info.uid, pid);</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                thread.scheduleExit(); </span><br><span class="line">                </span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// Ignore exceptions.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 ProcessRecord 不为 null，且 ProcessRecord.thread 不为 null</span></span><br><span class="line">    <span class="comment">// 说明该 ProcessRecord 已经 attach 了另外一个进程，需要立即清空这个 ProcessRecord！</span></span><br><span class="line">    <span class="keyword">if</span> (app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handleAppDiedLocked(app, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Tell the process all about itself.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG_ALL) Slog.v(</span><br><span class="line">            TAG, <span class="string">"Binding process pid "</span> + pid + <span class="string">" to record "</span> + app);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得进程的名称!</span></span><br><span class="line">    <span class="keyword">final</span> String processName = app.processName;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建进程死亡通知对象，并绑定死亡通知对象！</span></span><br><span class="line">        AppDeathRecipient adr = <span class="keyword">new</span> AppDeathRecipient(</span><br><span class="line">                app, pid, thread);</span><br><span class="line">        thread.asBinder().linkToDeath(adr, <span class="number">0</span>);</span><br><span class="line">        app.deathRecipient = adr;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line"></span><br><span class="line">        app.resetPackageList(mProcessStats);</span><br><span class="line">        startProcessLocked(app, <span class="string">"link fail"</span>, processName);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    EventLog.writeEvent(EventLogTags.AM_PROC_BOUND, app.userId, app.pid, app.processName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置进程的信息！ </span></span><br><span class="line">    <span class="comment">// 这里将传入的 ApplicationThreadProxy 对象赋给 app.thread，完成 attach 操作！！</span></span><br><span class="line">    <span class="comment">// 这里进程开始处于 active 状态!</span></span><br><span class="line">    app.makeActive(thread, mProcessStats);</span><br><span class="line"></span><br><span class="line">    app.curAdj = app.setAdj = app.verifiedAdj = ProcessList.INVALID_ADJ;</span><br><span class="line">    app.curSchedGroup = app.setSchedGroup = ProcessList.SCHED_GROUP_DEFAULT;</span><br><span class="line">    app.forcingToForeground = <span class="keyword">null</span>;</span><br><span class="line">    updateProcessForegroundLocked(app, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">    app.hasShownUi = <span class="keyword">false</span>;</span><br><span class="line">    app.debugging = <span class="keyword">false</span>;</span><br><span class="line">    app.cached = <span class="keyword">false</span>;</span><br><span class="line">    app.killedByAm = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    app.unlocked = StorageManager.isUserKeyUnlocked(app.userId);</span><br><span class="line"></span><br><span class="line">    mHandler.removeMessages(PROC_START_TIMEOUT_MSG, app);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 进程处于 ready 状态或者该进程为 FLAG_PERSISTENT 进程，即常驻进程，则 normalMode 为 true！</span></span><br><span class="line">    <span class="keyword">boolean</span> normalMode = mProcessesReady || isAllowedWhileBooting(app.info);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得该进程中的 providers！</span></span><br><span class="line">    List&lt;ProviderInfo&gt; providers = normalMode ? generateApplicationProvidersLocked(app) : <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查新进程是否存在正在启动中的 provider，</span></span><br><span class="line">    <span class="comment">// 如果有，则超时 10s 后发送 CONTENT_PROVIDER_PUBLISH_TIMEOUT_MSG 消息！</span></span><br><span class="line">    <span class="keyword">if</span> (providers != <span class="keyword">null</span> &amp;&amp; checkAppInLaunchingProvidersLocked(app)) &#123;</span><br><span class="line">        Message msg = mHandler.obtainMessage(CONTENT_PROVIDER_PUBLISH_TIMEOUT_MSG);</span><br><span class="line">        msg.obj = app;</span><br><span class="line">        mHandler.sendMessageDelayed(msg, CONTENT_PROVIDER_PUBLISH_TIMEOUT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!normalMode) &#123;</span><br><span class="line">        Slog.i(TAG, <span class="string">"Launching preboot mode app: "</span> + app);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG_ALL) Slog.v(</span><br><span class="line">        TAG, <span class="string">"New app record "</span> + app</span><br><span class="line">        + <span class="string">" thread="</span> + thread.asBinder() + <span class="string">" pid="</span> + pid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> testMode = IApplicationThread.DEBUG_OFF;</span><br><span class="line">        <span class="keyword">if</span> (mDebugApp != <span class="keyword">null</span> &amp;&amp; mDebugApp.equals(processName)) &#123;</span><br><span class="line">            testMode = mWaitForDebugger</span><br><span class="line">                ? IApplicationThread.DEBUG_WAIT</span><br><span class="line">                : IApplicationThread.DEBUG_ON;</span><br><span class="line">            app.debugging = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (mDebugTransient) &#123;</span><br><span class="line">                mDebugApp = mOrigDebugApp;</span><br><span class="line">                mWaitForDebugger = mOrigWaitForDebugger;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String profileFile = app.instrumentationProfileFile;</span><br><span class="line">        ParcelFileDescriptor profileFd = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> samplingInterval = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> profileAutoStop = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (mProfileApp != <span class="keyword">null</span> &amp;&amp; mProfileApp.equals(processName)) &#123;</span><br><span class="line">            mProfileProc = app;</span><br><span class="line">            profileFile = mProfileFile;</span><br><span class="line">            profileFd = mProfileFd;</span><br><span class="line">            samplingInterval = mSamplingInterval;</span><br><span class="line">            profileAutoStop = mAutoStopProfiler;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> enableTrackAllocation = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (mTrackAllocationApp != <span class="keyword">null</span> &amp;&amp; mTrackAllocationApp.equals(processName)) &#123;</span><br><span class="line">            enableTrackAllocation = <span class="keyword">true</span>;</span><br><span class="line">            mTrackAllocationApp = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the app is being launched for restore or full backup, set it up specially</span></span><br><span class="line">        <span class="keyword">boolean</span> isRestrictedBackupMode = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (mBackupTarget != <span class="keyword">null</span> &amp;&amp; mBackupAppName.equals(processName)) &#123;</span><br><span class="line">            isRestrictedBackupMode = mBackupTarget.appInfo.uid &gt;= Process.FIRST_APPLICATION_UID</span><br><span class="line">                    &amp;&amp; ((mBackupTarget.backupMode == BackupRecord.RESTORE)</span><br><span class="line">                            || (mBackupTarget.backupMode == BackupRecord.RESTORE_FULL)</span><br><span class="line">                            || (mBackupTarget.backupMode == BackupRecord.BACKUP_FULL));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (app.instrumentationClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">            notifyPackageUse(app.instrumentationClass.getPackageName(),</span><br><span class="line">                             PackageManager.NOTIFY_PACKAGE_USE_INSTRUMENTATION);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_CONFIGURATION) Slog.v(TAG_CONFIGURATION, <span class="string">"Binding proc "</span></span><br><span class="line">                + processName + <span class="string">" with config "</span> + mConfiguration);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得进程的所有者应用程序的信息！        </span></span><br><span class="line">        ApplicationInfo appInfo = app.instrumentationInfo != <span class="keyword">null</span></span><br><span class="line">                ? app.instrumentationInfo : app.info;</span><br><span class="line">                </span><br><span class="line">        app.compat = compatibilityInfoForPackageLocked(appInfo);</span><br><span class="line">        <span class="keyword">if</span> (profileFd != <span class="keyword">null</span>) &#123;</span><br><span class="line">            profileFd = profileFd.dup();</span><br><span class="line">        &#125;</span><br><span class="line">        ProfilerInfo profilerInfo = profileFile == <span class="keyword">null</span> ? <span class="keyword">null</span></span><br><span class="line">                : <span class="keyword">new</span> ProfilerInfo(profileFile, profileFd, samplingInterval, profileAutoStop);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这里很关键了，之前通过 attach 的方式，实现了从 SystemServer 进程到应用程序进程的单向 bind </span></span><br><span class="line">        <span class="comment">// 通信，而这里的 bind 操作最终的结果，是实现了 SystemServer 进程和应用程序进程的双向 bind 通信！</span></span><br><span class="line">        thread.bindApplication(processName, appInfo, providers, app.instrumentationClass,</span><br><span class="line">                profilerInfo, app.instrumentationArguments, app.instrumentationWatcher,</span><br><span class="line">                app.instrumentationUiAutomationConnection, testMode,</span><br><span class="line">                mBinderTransactionTrackingEnabled, enableTrackAllocation,</span><br><span class="line">                isRestrictedBackupMode || !normalMode, app.persistent,</span><br><span class="line">                <span class="keyword">new</span> Configuration(mConfiguration), app.compat,</span><br><span class="line">                getCommonServicesLocked(app.isolated),</span><br><span class="line">                mCoreSettingsObserver.getCoreSettingsLocked());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新进程 LRU 队列！</span></span><br><span class="line">        updateLruProcessLocked(app, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        app.lastRequestedGc = app.lastLowMemory = SystemClock.uptimeMillis();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        app.resetPackageList(mProcessStats);</span><br><span class="line">        app.unlinkDeathRecipient();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每当 bind 操作失败，则重新启动进程, 此处有可能会导致进程无限重启。</span></span><br><span class="line">        startProcessLocked(app, <span class="string">"bind fail"</span>, processName);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前已经被启动的新进程的 ProcessRecord 从正在启动的进程集合 mPersistentStartingProcesses！</span></span><br><span class="line">    <span class="comment">// 和等待启动的进程集合 mProcessesOnHold 中移除！</span></span><br><span class="line">    mPersistentStartingProcesses.remove(app);</span><br><span class="line">    mProcessesOnHold.remove(app);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> badApp = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> didSomething = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (normalMode) &#123; <span class="comment">// 如果是正常启动的情况下！</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查是否有 activity 组件要在这个新进程中运行！</span></span><br><span class="line">            <span class="keyword">if</span> (mStackSupervisor.attachApplicationLocked(app)) &#123;</span><br><span class="line">                didSomething = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Slog.wtf(TAG, <span class="string">"Exception thrown launching activities in "</span> + app, e);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 检查异常，将 badApp 置为 true！</span></span><br><span class="line">            badApp = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!badApp) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 检查是否有 sevvce 组件要在这个新进程中运行！</span></span><br><span class="line">            didSomething |= mServices.attachApplicationLocked(app, processName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Slog.wtf(TAG, <span class="string">"Exception thrown starting services in "</span> + app, e);</span><br><span class="line">            badApp = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否有 broadcast 组件要在这个新进程中运行！</span></span><br><span class="line">    <span class="keyword">if</span> (!badApp &amp;&amp; isPendingBroadcastProcessLocked(pid)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            didSomething |= sendPendingBroadcastsLocked(app);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// If the app died trying to launch the receiver we declare it 'bad'</span></span><br><span class="line">            Slog.wtf(TAG, <span class="string">"Exception thrown dispatching broadcasts in "</span> + app, e);</span><br><span class="line">            badApp = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否在这个新进程中有下一个 backup 代理！</span></span><br><span class="line">    <span class="keyword">if</span> (!badApp &amp;&amp; mBackupTarget != <span class="keyword">null</span> &amp;&amp; mBackupTarget.appInfo.uid == app.uid) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_BACKUP) Slog.v(TAG_BACKUP,</span><br><span class="line">                <span class="string">"New app is backup target, launching agent for "</span> + app);</span><br><span class="line">        notifyPackageUse(mBackupTarget.appInfo.packageName,</span><br><span class="line">                         PackageManager.NOTIFY_PACKAGE_USE_BACKUP);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            thread.scheduleCreateBackupAgent(mBackupTarget.appInfo,</span><br><span class="line">                    compatibilityInfoForPackageLocked(mBackupTarget.appInfo),</span><br><span class="line">                    mBackupTarget.backupMode);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Slog.wtf(TAG, <span class="string">"Exception thrown creating backup agent in "</span> + app, e);</span><br><span class="line">            badApp = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (badApp) &#123; <span class="comment">// badApp 为 true，就杀掉这个进程</span></span><br><span class="line">        app.kill(<span class="string">"error during init"</span>, <span class="keyword">true</span>);</span><br><span class="line">        handleAppDiedLocked(app, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!didSomething) &#123; <span class="comment">// 检查后发现，没有任何组件要运行在新进程，更新 OomAdj 的值！</span></span><br><span class="line">        updateOomAdjLocked();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来回顾一下这个方法：</p>
<ul>
<li>根据 pid 从 mPidsSelfLocked 中查询到相应的 ProcessRecord 对象 app。<ul>
<li>当 app==null，意味着本次创建的进程不存在，则直接返回，这属于异常。</li>
</ul>
</li>
<li>判断 app.thread 是否为 null，此时 thread 应该为 null，若不为 null 则表示该 app 附到上一个进程，则调用 handleAppDiedLocked 清理。</li>
<li>绑定死亡通知，当进程 pid 死亡时会通过 binder 死亡回调，来通知 system_server 进程死亡的消息。</li>
<li><strong>重置 ProcessRecord 进程信息，并设置 app.thread 为新进程的 ApplicationThreadProxy ，attach 操作完成</strong> 。</li>
<li>app 进程存在正在启动中的 provider，则超时 10s 后发送 CONTENT_PROVIDER_PUBLISH_TIMEOUT_MSG 消息。</li>
<li>调用 thread.bindApplication 绑定应用进程，后面再进一步说明。</li>
<li>检查是否有 Provider，Activity，Service，Broadcast 等组件运行在该新进程。</li>
</ul>
<h2 id="10-1-new-AppDeathRecipient"><a href="#10-1-new-AppDeathRecipient" class="headerlink" title="10.1 new AppDeathRecipient"></a>10.1 new AppDeathRecipient</h2><p>我们来看看死亡通知对象的创建！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AppDeathRecipient</span> <span class="keyword">implements</span> <span class="title">IBinder</span>.<span class="title">DeathRecipient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ProcessRecord mApp; <span class="comment">// 进程对应的 ProcessRecord 对象！</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> mPid; <span class="comment">// 进程的 pid</span></span><br><span class="line">    <span class="keyword">final</span> IApplicationThread mAppThread; <span class="comment">// 进程的 ApplicationThreadProxy 对象！</span></span><br><span class="line"></span><br><span class="line">    AppDeathRecipient(ProcessRecord app, <span class="keyword">int</span> pid,</span><br><span class="line">            IApplicationThread thread) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_ALL) Slog.v(</span><br><span class="line">            TAG, <span class="string">"New death recipient "</span> + <span class="keyword">this</span></span><br><span class="line">            + <span class="string">" for thread "</span> + thread.asBinder());</span><br><span class="line">        mApp = app;</span><br><span class="line">        mPid = pid;</span><br><span class="line">        mAppThread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">binderDied</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_ALL) Slog.v(</span><br><span class="line">            TAG, <span class="string">"Death received in "</span> + <span class="keyword">this</span></span><br><span class="line">            + <span class="string">" for thread "</span> + mAppThread.asBinder());</span><br><span class="line">        <span class="keyword">synchronized</span>(ActivityManagerService.<span class="keyword">this</span>) &#123;</span><br><span class="line">            appDiedLocked(mApp, mPid, mAppThread, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当进程死亡后，其对应的死亡通知对象就会收到通知，其 binderDied 方法就会被调用，接着进入 appDiedLocked 方法：</p>
<h2 id="10-1-AMS-appDiedLocked"><a href="#10-1-AMS-appDiedLocked" class="headerlink" title="10.1 AMS.appDiedLocked"></a>10.1 AMS.appDiedLocked</h2><p>参数 fromBinderDied 置为 true！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">appDiedLocked</span><span class="params">(ProcessRecord app, <span class="keyword">int</span> pid, IApplicationThread thread,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> fromBinderDied)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// First check if this ProcessRecord is actually active for the pid.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mPidsSelfLocked) &#123;</span><br><span class="line">        ProcessRecord curProc = mPidsSelfLocked.get(pid);</span><br><span class="line">        <span class="keyword">if</span> (curProc != app) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Spurious death for "</span> + app + <span class="string">", curProc for "</span> + pid + <span class="string">": "</span> + curProc);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BatteryStatsImpl stats = mBatteryStatsService.getActiveStatistics();</span><br><span class="line">    <span class="keyword">synchronized</span> (stats) &#123;</span><br><span class="line">        stats.noteProcessDiedLocked(app.info.uid, pid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里 killed 值为 false；</span></span><br><span class="line">    <span class="keyword">if</span> (!app.killed) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!fromBinderDied) &#123;</span><br><span class="line">            Process.killProcessQuiet(pid);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 杀掉进程所在的进程组！</span></span><br><span class="line">        killProcessGroup(app.uid, pid);</span><br><span class="line">        app.killed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clean up already done if the process has been re-started.</span></span><br><span class="line">    <span class="keyword">if</span> (app.pid == pid &amp;&amp; app.thread != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            app.thread.asBinder() == thread.asBinder()) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> doLowMem = app.instrumentationClass == <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> doOomAdj = doLowMem;</span><br><span class="line">        <span class="keyword">if</span> (!app.killedByAm) &#123;</span><br><span class="line">            Slog.i(TAG, <span class="string">"Process "</span> + app.processName + <span class="string">" (pid "</span> + pid</span><br><span class="line">                    + <span class="string">") has died"</span>);</span><br><span class="line">            mAllowLowerMemLevel = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Note that we always want to do oom adj to update our state with the</span></span><br><span class="line">            <span class="comment">// new number of procs.</span></span><br><span class="line">            mAllowLowerMemLevel = <span class="keyword">false</span>;</span><br><span class="line">            doLowMem = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        EventLog.writeEvent(EventLogTags.AM_PROC_DIED, app.userId, app.pid, app.processName);</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_CLEANUP) Slog.v(TAG_CLEANUP,</span><br><span class="line">            <span class="string">"Dying app: "</span> + app + <span class="string">", pid: "</span> + pid + <span class="string">", thread: "</span> + thread.asBinder());</span><br><span class="line">            </span><br><span class="line">        <span class="comment">// 杀掉进程后继续调用 handleAppDiedLocked 方法！</span></span><br><span class="line">        handleAppDiedLocked(app, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (doOomAdj) &#123;</span><br><span class="line">            updateOomAdjLocked();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (doLowMem) &#123;</span><br><span class="line">            doLowMemReportIfNeededLocked(app);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (app.pid != pid) &#123;</span><br><span class="line">        <span class="comment">// A new process has already been started.</span></span><br><span class="line">        Slog.i(TAG, <span class="string">"Process "</span> + app.processName + <span class="string">" (pid "</span> + pid</span><br><span class="line">                + <span class="string">") has died and restarted (pid "</span> + app.pid + <span class="string">")."</span>);</span><br><span class="line">        EventLog.writeEvent(EventLogTags.AM_PROC_DIED, app.userId, app.pid, app.processName);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (DEBUG_PROCESSES) &#123;</span><br><span class="line">        Slog.d(TAG_PROCESSES, <span class="string">"Received spurious death notification for thread "</span></span><br><span class="line">                + thread.asBinder());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="10-2-AMS-handleAppDiedLocked"><a href="#10-2-AMS-handleAppDiedLocked" class="headerlink" title="10.2 AMS.handleAppDiedLocked"></a>10.2 AMS.handleAppDiedLocked</h2><ul>
<li>参数 restarting 表示进程是否在重启，这里传入 false；</li>
<li>参数 allowRestart 表示是否允许进程重启，这里传入 true；<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">handleAppDiedLocked</span><span class="params">(ProcessRecord app,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> restarting, <span class="keyword">boolean</span> allowRestart)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pid = app.pid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> kept = cleanUpApplicationRecordLocked(app, restarting, allowRestart, -<span class="number">1</span>,</span><br><span class="line">            <span class="keyword">false</span> <span class="comment">/*replacingPid*/</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!kept &amp;&amp; !restarting) &#123;</span><br><span class="line">        removeLruProcessLocked(app);</span><br><span class="line">        <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ProcessList.remove(pid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mProfileProc == app) &#123;</span><br><span class="line">        clearProfilerLocked();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove this application's activities from active lists.</span></span><br><span class="line">    <span class="keyword">boolean</span> hasVisibleActivities = mStackSupervisor.handleAppDiedLocked(app);</span><br><span class="line"></span><br><span class="line">    app.activities.clear();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (app.instrumentationClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"Crash of app "</span> + app.processName</span><br><span class="line">              + <span class="string">" running instrumentation "</span> + app.instrumentationClass);</span><br><span class="line"></span><br><span class="line">        Bundle info = <span class="keyword">new</span> Bundle();</span><br><span class="line">        info.putString(<span class="string">"shortMsg"</span>, <span class="string">"Process crashed."</span>);</span><br><span class="line">        finishInstrumentationLocked(app, Activity.RESULT_CANCELED, info);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!restarting &amp;&amp; hasVisibleActivities</span><br><span class="line">            &amp;&amp; !mStackSupervisor.resumeFocusedStackTopActivityLocked()) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If there was nothing to resume, and we are not already restarting this process, but</span></span><br><span class="line">        <span class="comment">// there is a visible activity that is hosted by the process...  then make sure all</span></span><br><span class="line">        <span class="comment">// visible activities are running, taking care of restarting this process.</span></span><br><span class="line">        mStackSupervisor.ensureActivitiesVisibleLocked(<span class="keyword">null</span>, <span class="number">0</span>, !PRESERVE_WINDOWS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="10-2-1-AMS-cleanUpApplicationRecordLocked"><a href="#10-2-1-AMS-cleanUpApplicationRecordLocked" class="headerlink" title="10.2.1 AMS.cleanUpApplicationRecordLocked"></a>10.2.1 AMS.cleanUpApplicationRecordLocked</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">cleanUpApplicationRecordLocked</span><span class="params">(ProcessRecord app,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> restarting, <span class="keyword">boolean</span> allowRestart, <span class="keyword">int</span> index, <span class="keyword">boolean</span> replacingPid)</span> </span>&#123;</span><br><span class="line">    Slog.d(TAG, <span class="string">"cleanUpApplicationRecord -- "</span> + app.pid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        removeLruProcessLocked(app);</span><br><span class="line">        ProcessList.remove(app.pid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mProcessesToGc.remove(app);</span><br><span class="line">    mPendingPssProcesses.remove(app);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取消掉这个进程所有已经可见的 Dialog！</span></span><br><span class="line">    <span class="keyword">if</span> (app.crashDialog != <span class="keyword">null</span> &amp;&amp; !app.forceCrashReport) &#123;</span><br><span class="line">        app.crashDialog.dismiss();</span><br><span class="line">        app.crashDialog = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (app.anrDialog != <span class="keyword">null</span>) &#123;</span><br><span class="line">        app.anrDialog.dismiss();</span><br><span class="line">        app.anrDialog = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (app.waitDialog != <span class="keyword">null</span>) &#123;</span><br><span class="line">        app.waitDialog.dismiss();</span><br><span class="line">        app.waitDialog = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    app.crashing = <span class="keyword">false</span>;</span><br><span class="line">    app.notResponding = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    app.resetPackageList(mProcessStats);</span><br><span class="line">    app.unlinkDeathRecipient();</span><br><span class="line">    app.makeInactive(mProcessStats);</span><br><span class="line">    app.waitingToKill = <span class="keyword">null</span>;</span><br><span class="line">    app.forcingToForeground = <span class="keyword">null</span>;</span><br><span class="line">    updateProcessForegroundLocked(app, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">    app.foregroundActivities = <span class="keyword">false</span>;</span><br><span class="line">    app.hasShownUi = <span class="keyword">false</span>;</span><br><span class="line">    app.treatLikeActivity = <span class="keyword">false</span>;</span><br><span class="line">    app.hasAboveClient = <span class="keyword">false</span>;</span><br><span class="line">    app.hasClientActivities = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 杀掉进程中所有的 Service！</span></span><br><span class="line">    mServices.killServicesLocked(app, allowRestart);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// restart 表示是否重启这个进程！</span></span><br><span class="line">    <span class="keyword">boolean</span> restart = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除这个进程的所有 publish 的 provider！</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = app.pubProviders.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        ContentProviderRecord cpr = app.pubProviders.valueAt(i);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> always = app.bad || !allowRestart;</span><br><span class="line">        <span class="keyword">boolean</span> inLaunching = removeDyingProviderLocked(app, cpr, always);</span><br><span class="line">        <span class="keyword">if</span> ((inLaunching || always) &amp;&amp; cpr.hasConnectionOrHandle()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// We left the provider in the launching list, need to</span></span><br><span class="line">            <span class="comment">// restart it.</span></span><br><span class="line">            restart = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cpr.provider = <span class="keyword">null</span>;</span><br><span class="line">        cpr.proc = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    app.pubProviders.clear();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除这个进程的所有正在启动的 provider！</span></span><br><span class="line">    <span class="keyword">if</span> (cleanupAppInLaunchingProvidersLocked(app, <span class="keyword">false</span>)) &#123;</span><br><span class="line">        restart = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取消所有的 ContentProviderConnection 对象！</span></span><br><span class="line">    <span class="keyword">if</span> (!app.conProviders.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = app.conProviders.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line"></span><br><span class="line">            ContentProviderConnection conn = app.conProviders.get(i);</span><br><span class="line">            conn.provider.connections.remove(conn);</span><br><span class="line">            stopAssociationLocked(app.uid, app.processName, conn.provider.uid,</span><br><span class="line">                    conn.provider.name);</span><br><span class="line">        &#125;</span><br><span class="line">        app.conProviders.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// At this point there may be remaining entries in mLaunchingProviders</span></span><br><span class="line">    <span class="comment">// where we were the only one waiting, so they are no longer of use.</span></span><br><span class="line">    <span class="comment">// Look for these and clean up if found.</span></span><br><span class="line">    <span class="comment">// XXX Commented out for now.  Trying to figure out a way to reproduce</span></span><br><span class="line">    <span class="comment">// the actual situation to identify what is actually going on.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = mLaunchingProviders.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            ContentProviderRecord cpr = mLaunchingProviders.get(i);</span><br><span class="line">            <span class="keyword">if</span> (cpr.connections.size() &lt;= <span class="number">0</span> &amp;&amp; !cpr.hasExternalProcessHandles()) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (cpr) &#123;</span><br><span class="line">                    cpr.launchingApp = <span class="keyword">null</span>;</span><br><span class="line">                    cpr.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    skipCurrentReceiverLocked(app);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Unregister any receivers.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = app.receivers.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        removeReceiverLocked(app.receivers.valueAt(i));</span><br><span class="line">    &#125;</span><br><span class="line">    app.receivers.clear();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the app is undergoing backup, tell the backup manager about it</span></span><br><span class="line">    <span class="keyword">if</span> (mBackupTarget != <span class="keyword">null</span> &amp;&amp; app.pid == mBackupTarget.app.pid) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_BACKUP || DEBUG_CLEANUP) Slog.d(TAG_CLEANUP, <span class="string">"App "</span></span><br><span class="line">                + mBackupTarget.appInfo + <span class="string">" died during backup"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            IBackupManager bm = IBackupManager.Stub.asInterface(</span><br><span class="line">                    ServiceManager.getService(Context.BACKUP_SERVICE));</span><br><span class="line">            bm.agentDisconnected(app.info.packageName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="comment">// can't happen; backup manager is local</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mPendingProcessChanges.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        ProcessChangeItem item = mPendingProcessChanges.get(i);</span><br><span class="line">        <span class="keyword">if</span> (item.pid == app.pid) &#123;</span><br><span class="line">            mPendingProcessChanges.remove(i);</span><br><span class="line">            mAvailProcessChanges.add(item);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mUiHandler.obtainMessage(DISPATCH_PROCESS_DIED_UI_MSG, app.pid, app.info.uid,</span><br><span class="line">            <span class="keyword">null</span>).sendToTarget();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the caller is restarting this app, then leave it in its</span></span><br><span class="line">    <span class="comment">// current lists and let the caller take care of it.</span></span><br><span class="line">    <span class="keyword">if</span> (restarting) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!app.persistent || app.isolated) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_PROCESSES || DEBUG_CLEANUP) Slog.v(TAG_CLEANUP,</span><br><span class="line">                <span class="string">"Removing non-persistent process during cleanup: "</span> + app);</span><br><span class="line">        <span class="keyword">if</span> (!replacingPid) &#123;</span><br><span class="line">            removeProcessNameLocked(app.processName, app.uid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mHeavyWeightProcess == app) &#123;</span><br><span class="line">            mHandler.sendMessage(mHandler.obtainMessage(CANCEL_HEAVY_NOTIFICATION_MSG,</span><br><span class="line">                    mHeavyWeightProcess.userId, <span class="number">0</span>));</span><br><span class="line">            mHeavyWeightProcess = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!app.removed) &#123;</span><br><span class="line">        <span class="comment">// This app is persistent, so we need to keep its record around.</span></span><br><span class="line">        <span class="comment">// If it is not already on the pending app list, add it there</span></span><br><span class="line">        <span class="comment">// and start a new process for it.</span></span><br><span class="line">        <span class="keyword">if</span> (mPersistentStartingProcesses.indexOf(app) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            mPersistentStartingProcesses.add(app);</span><br><span class="line">            restart = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((DEBUG_PROCESSES || DEBUG_CLEANUP) &amp;&amp; mProcessesOnHold.contains(app)) Slog.v(</span><br><span class="line">            TAG_CLEANUP, <span class="string">"Clean-up removing on hold: "</span> + app);</span><br><span class="line">    mProcessesOnHold.remove(app);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (app == mHomeProcess) &#123;</span><br><span class="line">        mHomeProcess = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (app == mPreviousProcess) &#123;</span><br><span class="line">        mPreviousProcess = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (restart &amp;&amp; !app.isolated) &#123;</span><br><span class="line">        <span class="comment">// We have components that still need to be running in the</span></span><br><span class="line">        <span class="comment">// process, so re-launch it.</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            ProcessList.remove(app.pid);</span><br><span class="line">        &#125;</span><br><span class="line">        addProcessNameLocked(app);</span><br><span class="line">        startProcessLocked(app, <span class="string">"restart"</span>, app.processName);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (app.pid &gt; <span class="number">0</span> &amp;&amp; app.pid != MY_PID) &#123;</span><br><span class="line">        <span class="comment">// Goodbye!</span></span><br><span class="line">        <span class="keyword">boolean</span> removed;</span><br><span class="line">        <span class="keyword">synchronized</span> (mPidsSelfLocked) &#123;</span><br><span class="line">            mPidsSelfLocked.remove(app.pid);</span><br><span class="line">            mHandler.removeMessages(PROC_START_TIMEOUT_MSG, app);</span><br><span class="line">        &#125;</span><br><span class="line">        mBatteryStatsService.noteProcessFinish(app.processName, app.info.uid);</span><br><span class="line">        <span class="keyword">if</span> (app.isolated) &#123;</span><br><span class="line">            mBatteryStatsService.removeIsolatedUid(app.uid, app.info.uid);</span><br><span class="line">        &#125;</span><br><span class="line">        app.setPid(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面可以看到，如果已经进程是 persistent 进程，死亡通知对象接收到通知后会重启这个进程！</p>
<p>attach 结束了，接下来，是 SystemServer 进程 bind 应用程序进程！</p>
<h1 id="11-ApplicationThreadProxy-bindApplication"><a href="#11-ApplicationThreadProxy-bindApplication" class="headerlink" title="11 ApplicationThreadProxy.bindApplication"></a>11 ApplicationThreadProxy.bindApplication</h1><p>这里是在 SystemServer 进程中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApplicationThreadProxy</span> <span class="keyword">implements</span> <span class="title">IApplicationThread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> IBinder mRemote;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ApplicationThreadProxy</span><span class="params">(IBinder remote)</span> </span>&#123;</span><br><span class="line">        mRemote = remote;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mRemote;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ... ... ...<span class="comment">// 省略其他暂时不需要的方法！ </span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里是 bind 操作！</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">bindApplication</span><span class="params">(String packageName, ApplicationInfo info,</span></span></span><br><span class="line"><span class="function"><span class="params">            List&lt;ProviderInfo&gt; providers, ComponentName testName, ProfilerInfo profilerInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">            Bundle testArgs, IInstrumentationWatcher testWatcher,</span></span></span><br><span class="line"><span class="function"><span class="params">            IUiAutomationConnection uiAutomationConnection, <span class="keyword">int</span> debugMode,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> enableBinderTracking, <span class="keyword">boolean</span> trackAllocation, <span class="keyword">boolean</span> restrictedBackupMode,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> persistent, Configuration config, CompatibilityInfo compatInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">            Map&lt;String, IBinder&gt; services, Bundle coreSettings)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Parcel data = Parcel.obtain();</span><br><span class="line">        data.writeInterfaceToken(IApplicationThread.descriptor);</span><br><span class="line">        data.writeString(packageName);</span><br><span class="line">        info.writeToParcel(data, <span class="number">0</span>);</span><br><span class="line">        data.writeTypedList(providers);</span><br><span class="line">        <span class="keyword">if</span> (testName == <span class="keyword">null</span>) &#123;</span><br><span class="line">            data.writeInt(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            data.writeInt(<span class="number">1</span>);</span><br><span class="line">            testName.writeToParcel(data, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (profilerInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">            data.writeInt(<span class="number">1</span>);</span><br><span class="line">            profilerInfo.writeToParcel(data, Parcelable.PARCELABLE_WRITE_RETURN_VALUE);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            data.writeInt(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        data.writeBundle(testArgs);</span><br><span class="line">        data.writeStrongInterface(testWatcher);</span><br><span class="line">        data.writeStrongInterface(uiAutomationConnection);</span><br><span class="line">        data.writeInt(debugMode);</span><br><span class="line">        data.writeInt(enableBinderTracking ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        data.writeInt(trackAllocation ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        data.writeInt(restrictedBackupMode ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        data.writeInt(persistent ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        config.writeToParcel(data, <span class="number">0</span>);</span><br><span class="line">        compatInfo.writeToParcel(data, <span class="number">0</span>);</span><br><span class="line">        data.writeMap(services);</span><br><span class="line">        data.writeBundle(coreSettings);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// binder 通信！</span></span><br><span class="line">        mRemote.transact(BIND_APPLICATION_TRANSACTION, data, <span class="keyword">null</span>,</span><br><span class="line">                IBinder.FLAG_ONEWAY);</span><br><span class="line">        data.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ... ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>参数 Map&lt;String, IBinder&gt; services 是通过 AMS 的 getCommonServicesLocked 方法获得的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> HashMap&lt;String, IBinder&gt; <span class="title">getCommonServicesLocked</span><span class="params">(<span class="keyword">boolean</span> isolated)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isolated) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mIsolatedAppBindArgs == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mIsolatedAppBindArgs = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            mIsolatedAppBindArgs.put(<span class="string">"package"</span>, ServiceManager.getService(<span class="string">"package"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mIsolatedAppBindArgs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mAppBindArgs == <span class="keyword">null</span>) &#123; <span class="comment">// 对于非隔离进程，这里会获得一些常用服务的 binder 对象！！</span></span><br><span class="line">        mAppBindArgs = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Setup the application init args</span></span><br><span class="line">        mAppBindArgs.put(<span class="string">"package"</span>, ServiceManager.getService(<span class="string">"package"</span>));</span><br><span class="line">        mAppBindArgs.put(<span class="string">"window"</span>, ServiceManager.getService(<span class="string">"window"</span>));</span><br><span class="line">        mAppBindArgs.put(Context.ALARM_SERVICE,</span><br><span class="line">                ServiceManager.getService(Context.ALARM_SERVICE));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mAppBindArgs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的 IApplicationThread.descriptor = “android.app.IApplicationThread”<br>ATP 经过 binder ipc 传递到 ATN 的 onTransact 方法。</p>
<h1 id="12-ApplicationThreadNative-onTransact"><a href="#12-ApplicationThreadNative-onTransact" class="headerlink" title="12 ApplicationThreadNative.onTransact"></a>12 ApplicationThreadNative.onTransact</h1><p>进入到 ATN 的 onTransact 方法中，这里进入了应用程序的进程中了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> BIND_APPLICATION_TRANSACTION:</span><br><span class="line">    &#123;</span><br><span class="line">        data.enforceInterface(IApplicationThread.descriptor);</span><br><span class="line">        <span class="comment">// 获得应用程序的包名！</span></span><br><span class="line">        String packageName = data.readString();</span><br><span class="line">        ApplicationInfo info =</span><br><span class="line">            ApplicationInfo.CREATOR.createFromParcel(data);</span><br><span class="line">        List&lt;ProviderInfo&gt; providers =</span><br><span class="line">            data.createTypedArrayList(ProviderInfo.CREATOR);</span><br><span class="line">        ComponentName testName = (data.readInt() != <span class="number">0</span>)</span><br><span class="line">            ? <span class="keyword">new</span> ComponentName(data) : <span class="keyword">null</span>;</span><br><span class="line">        ProfilerInfo profilerInfo = data.readInt() != <span class="number">0</span></span><br><span class="line">                ? ProfilerInfo.CREATOR.createFromParcel(data) : <span class="keyword">null</span>;</span><br><span class="line">        Bundle testArgs = data.readBundle();</span><br><span class="line"></span><br><span class="line">        IBinder binder = data.readStrongBinder();</span><br><span class="line">        IInstrumentationWatcher testWatcher = IInstrumentationWatcher.Stub.asInterface(binder);</span><br><span class="line"></span><br><span class="line">        binder = data.readStrongBinder();</span><br><span class="line">        IUiAutomationConnection uiAutomationConnection =</span><br><span class="line">                IUiAutomationConnection.Stub.asInterface(binder);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> testMode = data.readInt();</span><br><span class="line">        <span class="keyword">boolean</span> openGlTrace = data.readInt() != <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> restrictedBackupMode = (data.readInt() != <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">boolean</span> persistent = (data.readInt() != <span class="number">0</span>);</span><br><span class="line">        Configuration config = Configuration.CREATOR.createFromParcel(data);</span><br><span class="line">        CompatibilityInfo compatInfo = CompatibilityInfo.CREATOR.createFromParcel(data);</span><br><span class="line">        HashMap&lt;String, IBinder&gt; services = data.readHashMap(<span class="keyword">null</span>);</span><br><span class="line">        Bundle coreSettings = data.readBundle();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// [见流程3.11]</span></span><br><span class="line">        bindApplication(packageName, info, providers, testName, profilerInfo, testArgs,</span><br><span class="line">                testWatcher, uiAutomationConnection, testMode, openGlTrace,</span><br><span class="line">                restrictedBackupMode, persistent, config, compatInfo, services, coreSettings);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="13-ApplicationThread-bindApplication"><a href="#13-ApplicationThread-bindApplication" class="headerlink" title="13 ApplicationThread.bindApplication"></a>13 ApplicationThread.bindApplication</h1><p>我们接着看：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">bindApplication</span><span class="params">(String processName, ApplicationInfo appInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">        List&lt;ProviderInfo&gt; providers, ComponentName instrumentationName,</span></span></span><br><span class="line"><span class="function"><span class="params">        ProfilerInfo profilerInfo, Bundle instrumentationArgs,</span></span></span><br><span class="line"><span class="function"><span class="params">        IInstrumentationWatcher instrumentationWatcher,</span></span></span><br><span class="line"><span class="function"><span class="params">        IUiAutomationConnection instrumentationUiConnection, <span class="keyword">int</span> debugMode,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> enableBinderTracking, <span class="keyword">boolean</span> trackAllocation,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> isRestrictedBackupMode, <span class="keyword">boolean</span> persistent, Configuration config,</span></span></span><br><span class="line"><span class="function"><span class="params">        CompatibilityInfo compatInfo, Map&lt;String, IBinder&gt; services, Bundle coreSettings)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (services != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里将前面获得的系统公共 services 缓存到 ServiceManager 的 sCache 中, </span></span><br><span class="line">        <span class="comment">// 减少 binder 检索服务的次数.</span></span><br><span class="line">        ServiceManager.initServiceCache(services);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送消息 H.SET_CORE_SETTINGS</span></span><br><span class="line">    setCoreSettings(coreSettings);</span><br><span class="line"></span><br><span class="line">    AppBindData data = <span class="keyword">new</span> AppBindData(); <span class="comment">// 初始化 AppBindData</span></span><br><span class="line">    data.processName = processName;</span><br><span class="line">    data.appInfo = appInfo;</span><br><span class="line">    data.providers = providers;</span><br><span class="line">    </span><br><span class="line">    data.instrumentationName = instrumentationName;</span><br><span class="line">    data.instrumentationArgs = instrumentationArgs;</span><br><span class="line">    data.instrumentationWatcher = instrumentationWatcher;</span><br><span class="line">    data.instrumentationUiAutomationConnection = instrumentationUiConnection;</span><br><span class="line">    </span><br><span class="line">    data.debugMode = debugMode;</span><br><span class="line">    data.enableBinderTracking = enableBinderTracking;</span><br><span class="line">    data.trackAllocation = trackAllocation;</span><br><span class="line">    data.restrictedBackupMode = isRestrictedBackupMode;</span><br><span class="line">    data.persistent = persistent;</span><br><span class="line">    data.config = config;</span><br><span class="line">    data.compatInfo = compatInfo;</span><br><span class="line">    data.initProfilerInfo = profilerInfo;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送 H.BIND_APPLICATION 消息！</span></span><br><span class="line">    sendMessage(H.BIND_APPLICATION, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中 setCoreSettings() 过程就是调用 sendMessage(H.SET_CORE_SETTINGS, coreSettings) 来向主线程发送 SET_CORE_SETTINGS 消息，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCoreSettings</span><span class="params">(Bundle coreSettings)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    sendMessage(H.SET_CORE_SETTINGS, coreSettings);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结一下：bindApplication 方法的主要功能是依次向主线程发送消息 H.SET_CORE_SETTINGS 和 H.BIND_APPLICATION。</p>
<h1 id="14-ActivityThread-H-消息处理"><a href="#14-ActivityThread-H-消息处理" class="headerlink" title="14 ActivityThread.H - 消息处理"></a>14 ActivityThread.H - 消息处理</h1><p>进入到应用程序进程的主线程 Handler “H”：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">H</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       ... ... ...</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">               ... ... ...</span><br><span class="line">               </span><br><span class="line">               <span class="keyword">case</span> SET_CORE_SETTINGS:</span><br><span class="line">               </span><br><span class="line">                   Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"setCoreSettings"</span>);</span><br><span class="line">                   </span><br><span class="line">                   handleSetCoreSettings((Bundle) msg.obj);</span><br><span class="line">                   </span><br><span class="line">                   Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">                   </span><br><span class="line">               ... ... ... </span><br><span class="line">               </span><br><span class="line">               <span class="keyword">case</span> BIND_APPLICATION:</span><br><span class="line"></span><br><span class="line">                   Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"bindApplication"</span>);</span><br><span class="line">                   AppBindData data = (AppBindData)msg.obj;</span><br><span class="line">                   </span><br><span class="line">                   handleBindApplication(data);</span><br><span class="line">                   </span><br><span class="line">                   Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">                   </span><br><span class="line">               ... ... ...    </span><br><span class="line">               </span><br><span class="line">       &#125; </span><br><span class="line">       </span><br><span class="line">       ... ... ...</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们继续来看吧：</p>
<h2 id="14-1-消息-H-SET-CORE-SETTINGS"><a href="#14-1-消息-H-SET-CORE-SETTINGS" class="headerlink" title="14.1 消息 H.SET_CORE_SETTINGS"></a>14.1 消息 H.SET_CORE_SETTINGS</h2><p>处理 H.SET_CORE_SETTINGS 消息，调用 handleSetCoreSettings 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleSetCoreSettings</span><span class="params">(Bundle coreSettings)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mResourcesManager) &#123;</span><br><span class="line">        mCoreSettings = coreSettings;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    onCoreSettingsChange();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onCoreSettingsChange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> debugViewAttributes =</span><br><span class="line">            mCoreSettings.getInt(Settings.Global.DEBUG_VIEW_ATTRIBUTES, <span class="number">0</span>) != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (debugViewAttributes != View.mDebugViewAttributes) &#123;</span><br><span class="line">        View.mDebugViewAttributes = debugViewAttributes;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// request all activities to relaunch for the changes to take place</span></span><br><span class="line">        <span class="comment">// 由于发生改变, 请求所有的 activities 重启启动！</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;IBinder, ActivityClientRecord&gt; entry : mActivities.entrySet()) &#123;</span><br><span class="line">            requestRelaunchActivity(entry.getKey(), <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="keyword">false</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>,</span><br><span class="line">                    <span class="keyword">false</span> <span class="comment">/* preserveWindow */</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="14-2-消息-H-BIND-APPLICATION"><a href="#14-2-消息-H-BIND-APPLICATION" class="headerlink" title="14.2 消息 H.BIND_APPLICATION"></a>14.2 消息 H.BIND_APPLICATION</h2><p>处理 H.BIND_APPLICATION 消息，调用 handleBindApplication 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleBindApplication</span><span class="params">(AppBindData data)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 UI 线程注册到 VMRuntime 中！</span></span><br><span class="line">    VMRuntime.registerSensitiveThread();</span><br><span class="line">    <span class="keyword">if</span> (data.trackAllocation) &#123;</span><br><span class="line">        DdmVmInternal.enableRecentAllocations(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录进程的开始时间！</span></span><br><span class="line">    Process.setStartTimes(SystemClock.elapsedRealtime(), SystemClock.uptimeMillis());</span><br><span class="line"></span><br><span class="line">    mBoundApplication = data;</span><br><span class="line">    mConfiguration = <span class="keyword">new</span> Configuration(data.config);</span><br><span class="line">    mCompatConfiguration = <span class="keyword">new</span> Configuration(data.config);</span><br><span class="line"></span><br><span class="line">    mProfiler = <span class="keyword">new</span> Profiler();</span><br><span class="line">    <span class="keyword">if</span> (data.initProfilerInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mProfiler.profileFile = data.initProfilerInfo.profileFile;</span><br><span class="line">        mProfiler.profileFd = data.initProfilerInfo.profileFd;</span><br><span class="line">        mProfiler.samplingInterval = data.initProfilerInfo.samplingInterval;</span><br><span class="line">        mProfiler.autoStopProfiler = data.initProfilerInfo.autoStopProfiler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置进程名, 也就是说进程名是在进程真正创建以后的 BIND_APPLICATION 过程中才取名!</span></span><br><span class="line">    Process.setArgV0(data.processName);</span><br><span class="line">    android.ddm.DdmHandleAppName.setAppName(data.processName,</span><br><span class="line">                                            UserHandle.myUserId());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (data.persistent) &#123; </span><br><span class="line">        <span class="comment">// 如果常驻进程，在低内存设备, 不采用硬件加速绘制,以节省内存使用量！</span></span><br><span class="line">        <span class="keyword">if</span> (!ActivityManager.isHighEndGfx()) &#123;</span><br><span class="line">            ThreadedRenderer.disable(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mProfiler.profileFd != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mProfiler.startProfiling();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果应用程序的目标 sdk 小于等于 Honeycomb MR1</span></span><br><span class="line">    <span class="comment">// 设置 AsyncTask 默认的线程池为 THREAD_POOL_EXECUTOR！</span></span><br><span class="line">    <span class="keyword">if</span> (data.appInfo.targetSdkVersion &lt;= android.os.Build.VERSION_CODES.HONEYCOMB_MR1) &#123;</span><br><span class="line">        AsyncTask.setDefaultExecutor(AsyncTask.THREAD_POOL_EXECUTOR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Message.updateCheckRecycle(data.appInfo.targetSdkVersion);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置进程时区为系统时区！</span></span><br><span class="line">    TimeZone.setDefault(<span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 设置语言环境列表！</span></span><br><span class="line">    LocaleList.setDefault(data.config.getLocales());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mResourcesManager) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新系统配置</span></span><br><span class="line">        mResourcesManager.applyConfigurationToResourcesLocked(data.config, data.compatInfo);</span><br><span class="line">        mCurDefaultDisplayDpi = data.config.densityDpi;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This calls mResourcesManager so keep it within the synchronized block.</span></span><br><span class="line">        applyCompatConfiguration(mCurDefaultDisplayDpi);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建应用程序的 LoadedApk 对象，每个进程都有一个。</span></span><br><span class="line">    data.info = getPackageInfoNoCheck(data.appInfo, data.compatInfo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果需要的话，设置该进程为像素</span></span><br><span class="line">    <span class="keyword">if</span> ((data.appInfo.flags&amp;ApplicationInfo.FLAG_SUPPORTS_SCREEN_DENSITIES)</span><br><span class="line">            == <span class="number">0</span>) &#123;</span><br><span class="line">        mDensityCompatMode = <span class="keyword">true</span>;</span><br><span class="line">        Bitmap.setDefaultDensity(DisplayMetrics.DENSITY_DEFAULT);</span><br><span class="line">    &#125;</span><br><span class="line">    updateDefaultDensity();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置时间显示的格式！</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> is24Hr = <span class="string">"24"</span>.equals(mCoreSettings.getString(Settings.System.TIME_12_24));</span><br><span class="line">    DateFormat.set24HourTimePref(is24Hr);</span><br><span class="line"></span><br><span class="line">    View.mDebugViewAttributes =</span><br><span class="line">            mCoreSettings.getInt(Settings.Global.DEBUG_VIEW_ATTRIBUTES, <span class="number">0</span>) != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于 userdebug/eng 编译方式的系统应用来说，使用 dropbox 工具来分析 log 堆栈！</span></span><br><span class="line">    <span class="keyword">if</span> ((data.appInfo.flags &amp;</span><br><span class="line">         (ApplicationInfo.FLAG_SYSTEM |</span><br><span class="line">          ApplicationInfo.FLAG_UPDATED_SYSTEM_APP)) != <span class="number">0</span>) &#123;</span><br><span class="line">        StrictMode.conditionallyEnableDebugLogging();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果应用的目标平台大于等于Honeycomb，就不允许在主线程使用网络相关功能</span></span><br><span class="line">    <span class="comment">// 不然会抛出 NetworkOnMainThreadException 异常！</span></span><br><span class="line">    <span class="keyword">if</span> (data.appInfo.targetSdkVersion &gt;= Build.VERSION_CODES.HONEYCOMB) &#123;</span><br><span class="line">        StrictMode.enableDeathOnNetwork();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果应用的目标平台不低于 Android N，那就不允许应用将 “file://” 这样的 Uri</span></span><br><span class="line">    <span class="comment">// 直接暴露出去，比如跨包传递等等，不然会抛出 FileUriExposedException</span></span><br><span class="line">    <span class="keyword">if</span> (data.appInfo.targetSdkVersion &gt;= Build.VERSION_CODES.N) &#123;</span><br><span class="line">        StrictMode.enableDeathOnFileUriExposure();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NetworkSecurityPolicy.getInstance().setCleartextTrafficPermitted(</span><br><span class="line">            (data.appInfo.flags &amp; ApplicationInfo.FLAG_USES_CLEARTEXT_TRAFFIC) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (data.debugMode != IApplicationThread.DEBUG_OFF) &#123;</span><br><span class="line">        <span class="comment">// XXX should have option to change the port.</span></span><br><span class="line">        Debug.changeDebugPort(<span class="number">8100</span>);</span><br><span class="line">        <span class="keyword">if</span> (data.debugMode == IApplicationThread.DEBUG_WAIT) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Application "</span> + data.info.getPackageName()</span><br><span class="line">                  + <span class="string">" is waiting for the debugger on port 8100..."</span>);</span><br><span class="line"></span><br><span class="line">            IActivityManager mgr = ActivityManagerNative.getDefault();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mgr.showWaitingForDebugger(mAppThread, <span class="keyword">true</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Debug.waitForDebugger();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mgr.showWaitingForDebugger(mAppThread, <span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Application "</span> + data.info.getPackageName()</span><br><span class="line">                  + <span class="string">" can be debugged on port 8100..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当处于调试模式,则运行应用生成 systrace 信息</span></span><br><span class="line">    <span class="keyword">boolean</span> isAppDebuggable = (data.appInfo.flags &amp; ApplicationInfo.FLAG_DEBUGGABLE) != <span class="number">0</span>;</span><br><span class="line">    Trace.setAppTracingAllowed(isAppDebuggable);</span><br><span class="line">    <span class="keyword">if</span> (isAppDebuggable &amp;&amp; data.enableBinderTracking) &#123;</span><br><span class="line">        Binder.enableTracing();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initialize the default http proxy in this process for the reasons we set the time zone.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 初始化默认的 http 代理！</span></span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"Setup proxies"</span>);</span><br><span class="line">    <span class="keyword">final</span> IBinder b = ServiceManager.getService(Context.CONNECTIVITY_SERVICE);</span><br><span class="line">    <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// In pre-boot mode (doing initial launch to collect password), not</span></span><br><span class="line">        <span class="comment">// all system is up.  This includes the connectivity service, so don't</span></span><br><span class="line">        <span class="comment">// crash if we can't get it.</span></span><br><span class="line">        <span class="keyword">final</span> IConnectivityManager service = IConnectivityManager.Stub.asInterface(b);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> ProxyInfo proxyInfo = service.getProxyForNetwork(<span class="keyword">null</span>);</span><br><span class="line">            Proxy.setHttpProxySystemProperty(proxyInfo);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">            <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Instrumentation 是谷歌提供的一个基本测试类，具有监控交互的作用！</span></span><br><span class="line">    <span class="comment">// 每个进程都有一个 Instrumentation 对象，这里我们不看测试相关的！</span></span><br><span class="line">    <span class="keyword">final</span> InstrumentationInfo ii;</span><br><span class="line">    <span class="keyword">if</span> (data.instrumentationName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ... ... ... ...</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ii = <span class="keyword">null</span>; <span class="comment">// 进入此分支！</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建应用的上下文实例，更新本地语言平台列表！</span></span><br><span class="line">    <span class="keyword">final</span> ContextImpl appContext = ContextImpl.createAppContext(<span class="keyword">this</span>, data.info);</span><br><span class="line">    updateLocaleListFromAppContext(appContext,</span><br><span class="line">            mResourcesManager.getConfiguration().getLocales());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!Process.isIsolated() &amp;&amp; !<span class="string">"android"</span>.equals(appContext.getPackageName())) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对于非隔离且所属包名不是 “android”（即系统进程）的进程</span></span><br><span class="line">        <span class="comment">// 创建缓存目录，来存放模板文集，和图形编译相关的代码！</span></span><br><span class="line">        <span class="keyword">final</span> File cacheDir = appContext.getCacheDir();</span><br><span class="line">        <span class="keyword">if</span> (cacheDir != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Provide a usable directory for temporary files</span></span><br><span class="line">            System.setProperty(<span class="string">"java.io.tmpdir"</span>, cacheDir.getAbsolutePath());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Log.v(TAG, <span class="string">"Unable to initialize \"java.io.tmpdir\" property "</span></span><br><span class="line">                    + <span class="string">"due to missing cache directory"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Context deviceContext = appContext.createDeviceProtectedStorageContext();</span><br><span class="line">        <span class="keyword">final</span> File codeCacheDir = deviceContext.getCodeCacheDir();</span><br><span class="line">        <span class="keyword">if</span> (codeCacheDir != <span class="keyword">null</span>) &#123;</span><br><span class="line">            setupGraphicsSupport(data.info, codeCacheDir);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">"Unable to setupGraphicsSupport due to missing code-cache directory"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"NetworkSecurityConfigProvider.install"</span>);</span><br><span class="line">    NetworkSecurityConfigProvider.install(appContext);</span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Continue loading instrumentation.</span></span><br><span class="line">    <span class="keyword">if</span> (ii != <span class="keyword">null</span>) &#123;</span><br><span class="line">    </span><br><span class="line">        ... ... ... ...</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 进入此分支，非测试情况，默认会创建一个 Instrumentation ！</span></span><br><span class="line">        mInstrumentation = <span class="keyword">new</span> Instrumentation(); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((data.appInfo.flags&amp;ApplicationInfo.FLAG_LARGE_HEAP) != <span class="number">0</span>) &#123;</span><br><span class="line">        dalvik.system.VMRuntime.getRuntime().clearGrowthLimit();</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dalvik.system.VMRuntime.getRuntime().clampGrowthLimit();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allow disk access during application and provider setup. This could</span></span><br><span class="line">    <span class="comment">// block processing ordered broadcasts, but later processing would</span></span><br><span class="line">    <span class="comment">// probably end up doing the same disk access.</span></span><br><span class="line">    <span class="keyword">final</span> StrictMode.ThreadPolicy savedPolicy = StrictMode.allowThreadDiskWrites();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 通过反射，创建目标应用程序的 Application 对象！</span></span><br><span class="line">        Application app = data.info.makeApplication(data.restrictedBackupMode, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存到 ActivityThread.mInitialApplication 中！</span></span><br><span class="line">        mInitialApplication = app;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// don't bring up providers in restricted mode; they may depend on the</span></span><br><span class="line">        <span class="comment">// app's custom Application class</span></span><br><span class="line">        <span class="keyword">if</span> (!data.restrictedBackupMode) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!ArrayUtils.isEmpty(data.providers)) &#123;</span><br><span class="line">                installContentProviders(app, data.providers);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// For process that contains content providers, we want to</span></span><br><span class="line">                <span class="comment">// ensure that the JIT is enabled "at some point".</span></span><br><span class="line">                mH.sendEmptyMessageDelayed(H.ENABLE_JIT, <span class="number">10</span>*<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mInstrumentation.onCreate(data.instrumentationArgs);</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Exception thrown in onCreate() of "</span></span><br><span class="line">                + data.instrumentationName + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用 Application.onCreate() 回调方法.</span></span><br><span class="line">            mInstrumentation.callApplicationOnCreate(app);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mInstrumentation.onException(app, e)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="string">"Unable to create application "</span> + app.getClass().getName()</span><br><span class="line">                    + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        StrictMode.setThreadPolicy(savedPolicy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>总结一下，上面的方法的主要流程：</p>
<ul>
<li>设置新进程的名字；</li>
<li>创建应用程序的 LoadedApk 对象；</li>
<li>创建应用的 ContextIpml 上下文实例；</li>
<li>创建应用程序的 Application 对象；</li>
<li>调用 Application.onCreate() 回调方法，初始化 app；</li>
</ul>
<p>上面是这个方法的主要作用，下面我们一个一个看：</p>
<h3 id="14-2-1-ContextImpl-createAppContext"><a href="#14-2-1-ContextImpl-createAppContext" class="headerlink" title="14.2.1 ContextImpl.createAppContext"></a>14.2.1 ContextImpl.createAppContext</h3><p>创建应用程序的上下文实例，参数传递：</p>
<ul>
<li>ActivityThread mainThread：当前进程的 ActivityThread 对象！</li>
<li>LoadedApk packageInfo：应用程序的信息对象;</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ContextImpl <span class="title">createAppContext</span><span class="params">(ActivityThread mainThread, LoadedApk packageInfo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (packageInfo == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"packageInfo"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ContextImpl(<span class="keyword">null</span>, mainThread,</span><br><span class="line">            packageInfo, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, Display.INVALID_DISPLAY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里调用了 new ContextImpl，创建了 ContextImpl 对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ContextImpl</span><span class="params">(ContextImpl container, ActivityThread mainThread,</span></span></span><br><span class="line"><span class="function"><span class="params">        LoadedApk packageInfo, IBinder activityToken, UserHandle user, <span class="keyword">boolean</span> restricted,</span></span></span><br><span class="line"><span class="function"><span class="params">        Display display, Configuration overrideConfiguration, <span class="keyword">int</span> createDisplayWithId)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    mOuterContext = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    mMainThread = mainThread;</span><br><span class="line">    mActivityToken = activityToken;</span><br><span class="line">    mRestricted = restricted;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (user == <span class="keyword">null</span>) &#123;</span><br><span class="line">        user = Process.myUserHandle();</span><br><span class="line">    &#125;</span><br><span class="line">    mUser = user;</span><br><span class="line"></span><br><span class="line">    mPackageInfo = packageInfo;</span><br><span class="line">    mResourcesManager = ResourcesManager.getInstance();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> displayId = (createDisplayWithId != Display.INVALID_DISPLAY)</span><br><span class="line">            ? createDisplayWithId</span><br><span class="line">            : (display != <span class="keyword">null</span>) ? display.getDisplayId() : Display.DEFAULT_DISPLAY;</span><br><span class="line"></span><br><span class="line">    CompatibilityInfo compatInfo = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (container != <span class="keyword">null</span>) &#123;</span><br><span class="line">        compatInfo = container.getDisplayAdjustments(displayId).getCompatibilityInfo();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (compatInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">        compatInfo = (displayId == Display.DEFAULT_DISPLAY)</span><br><span class="line">                ? packageInfo.getCompatibilityInfo()</span><br><span class="line">                : CompatibilityInfo.DEFAULT_COMPATIBILITY_INFO;</span><br><span class="line">    &#125;</span><br><span class="line">    mDisplayAdjustments.setCompatibilityInfo(compatInfo);</span><br><span class="line">    mDisplayAdjustments.setConfiguration(overrideConfiguration);</span><br><span class="line"></span><br><span class="line">    mDisplay = (createDisplayWithId == Display.INVALID_DISPLAY) ? display</span><br><span class="line">            : ResourcesManager.getInstance().getAdjustedDisplay(displayId, mDisplayAdjustments);</span><br><span class="line"></span><br><span class="line">    Resources resources = packageInfo.getResources(mainThread);</span><br><span class="line">    <span class="keyword">if</span> (resources != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (displayId != Display.DEFAULT_DISPLAY</span><br><span class="line">                || overrideConfiguration != <span class="keyword">null</span></span><br><span class="line">                || (compatInfo != <span class="keyword">null</span> &amp;&amp; compatInfo.applicationScale</span><br><span class="line">                        != resources.getCompatibilityInfo().applicationScale)) &#123;</span><br><span class="line">            resources = mResourcesManager.getTopLevelResources(packageInfo.getResDir(),</span><br><span class="line">                    packageInfo.getSplitResDirs(), packageInfo.getOverlayDirs(),</span><br><span class="line">                    packageInfo.getApplicationInfo().sharedLibraryFiles, displayId,</span><br><span class="line">                    overrideConfiguration, compatInfo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mResources = resources;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (container != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mBasePackageName = container.mBasePackageName;</span><br><span class="line">        mOpPackageName = container.mOpPackageName;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mBasePackageName = packageInfo.mPackageName;</span><br><span class="line">        ApplicationInfo ainfo = packageInfo.getApplicationInfo();</span><br><span class="line">        <span class="keyword">if</span> (ainfo.uid == Process.SYSTEM_UID &amp;&amp; ainfo.uid != Process.myUid()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Special case: system components allow themselves to be loaded in to other</span></span><br><span class="line">            <span class="comment">// processes.  For purposes of app ops, we must then consider the context as</span></span><br><span class="line">            <span class="comment">// belonging to the package of this process, not the system itself, otherwise</span></span><br><span class="line">            <span class="comment">// the package+uid verifications in app ops will fail.</span></span><br><span class="line">            mOpPackageName = ActivityThread.currentPackageName();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mOpPackageName = mBasePackageName;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mContentResolver = <span class="keyword">new</span> ApplicationContentResolver(<span class="keyword">this</span>, mainThread, user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="14-2-2-LoadedApk-makeApplication"><a href="#14-2-2-LoadedApk-makeApplication" class="headerlink" title="14.2.2 LoadedApk.makeApplication"></a>14.2.2 LoadedApk.makeApplication</h3><p>调用了 LoadedApk.makeApplication 方法，利用反射创建应用的 Application 对象，参数传入：</p>
<ul>
<li>boolean forceDefaultAppClass：data.restrictedBackupMode</li>
<li>Instrumentation instrumentation：null<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">public Application makeApplication(boolean forceDefaultAppClass,</span><br><span class="line">        Instrumentation instrumentation) &#123;</span><br><span class="line">    if (mApplication != null) &#123;</span><br><span class="line"></span><br><span class="line">        // 如果已经创建，就直接返回！</span><br><span class="line">        return mApplication;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Application app = null;</span><br><span class="line"></span><br><span class="line">    String appClass = mApplicationInfo.className;</span><br><span class="line">    if (forceDefaultAppClass || (appClass == null)) &#123;</span><br><span class="line"></span><br><span class="line">        // 要反射的类！</span><br><span class="line">        appClass = &quot;android.app.Application&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        java.lang.ClassLoader cl = getClassLoader();</span><br><span class="line">        if (!mPackageName.equals(&quot;android&quot;)) &#123; // 如果应用不是 framework-res.apk</span><br><span class="line">            initializeJavaContextClassLoader();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 创建应用的上下文实例！</span><br><span class="line">        ContextImpl appContext = ContextImpl.createAppContext(mActivityThread, this);</span><br><span class="line"></span><br><span class="line">        // 利用上下文实例，创建应用的 Application 对象！</span><br><span class="line">        app = mActivityThread.mInstrumentation.newApplication(</span><br><span class="line">                cl, appClass, appContext);</span><br><span class="line"></span><br><span class="line">        // 这里是实现 Context 和 Application 的相互引用！</span><br><span class="line">        appContext.setOuterContext(app);</span><br><span class="line">        </span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        if (!mActivityThread.mInstrumentation.onException(app, e)) &#123;</span><br><span class="line">            throw new RuntimeException(</span><br><span class="line">                &quot;Unable to instantiate application &quot; + appClass</span><br><span class="line">                + &quot;: &quot; + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mActivityThread.mAllApplications.add(app);</span><br><span class="line">    mApplication = app;</span><br><span class="line"></span><br><span class="line">    if (instrumentation != null) &#123; //这里不看！</span><br><span class="line">       ... ... ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Rewrite the R &apos;constants&apos; for all library apks.</span><br><span class="line">    SparseArray&lt;String&gt; packageIdentifiers = getAssets(mActivityThread)</span><br><span class="line">            .getAssignedPackageIdentifiers();</span><br><span class="line">            </span><br><span class="line">    final int N = packageIdentifiers.size();</span><br><span class="line">    for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">        final int id = packageIdentifiers.keyAt(i);</span><br><span class="line">        if (id == 0x01 || id == 0x7f) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        rewriteRValues(getClassLoader(), packageIdentifiers.valueAt(i), id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这里调用了 Instrumentation.newApplication 方法，创建 Application 的实例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Application <span class="title">newApplication</span><span class="params">(ClassLoader cl, String className, Context context)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InstantiationException, IllegalAccessException, </span></span><br><span class="line"><span class="function">        ClassNotFoundException </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 继续调用 newApplication 方法！  </span></span><br><span class="line">    <span class="keyword">return</span> newApplication(cl.loadClass(className), context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">public</span> Application <span class="title">newApplication</span><span class="params">(Class&lt;?&gt; clazz, Context context)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InstantiationException, IllegalAccessException, </span></span><br><span class="line"><span class="function">        ClassNotFoundException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 Application 对象！</span></span><br><span class="line">    Application app = (Application)clazz.newInstance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 context 和 Application 绑定，我们直接通过 getApplicationContext</span></span><br><span class="line">    <span class="comment">// 获得的就是这个 context 实例！</span></span><br><span class="line">    app.attach(context);</span><br><span class="line">    <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="14-2-3-Instrumentation-callApplicationOnCreate"><a href="#14-2-3-Instrumentation-callApplicationOnCreate" class="headerlink" title="14.2.3 Instrumentation.callApplicationOnCreate"></a>14.2.3 Instrumentation.callApplicationOnCreate</h3><p>这个方法很简单：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callApplicationOnCreate</span><span class="params">(Application app)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 onCreate 方法！</span></span><br><span class="line">    app.onCreate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用 Application 的 onCreate 方法！</p>
<p>到这里，bind 操作也完成了<strong>，应用程序进程已经启动，并且完成了和 SystemServer 进程的双向 Binder 绑定，也创建了应用程序的 Application 对象，调用了Application.onCreate  方法</strong>，接下来，就是启动指定的组件了！</p>
<p>回到 ActivityManagerService.attachApplicationLocked 方法中，bind 成功后，就会检测新进程中的组件了，组件的启动就在那里！！</p>
<p>关于组件的启动，以后在说！！</p>
<h1 id="15-总结"><a href="#15-总结" class="headerlink" title="15 总结"></a>15 总结</h1><p>其实，我们可以看到，进程的启动和创建，还是相当复杂的，其中涉及的细节很多，当时，阅读源码，最忌讳死扣细节，我们需要对框架有个整体的理解，下面，我们来通过几张图来总结一下，进程的启动！！</p>
<h2 id="15-1-进程的创建和启动"><a href="#15-1-进程的创建和启动" class="headerlink" title="15.1 进程的创建和启动"></a>15.1 进程的创建和启动</h2><p>下面我们用一张图来回顾下这个流程：</p>
<p><img src="http://static.zybuluo.com/Coolqi/7aj6yzbtt7yk3h70qjps38w0/Process%20%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="Process 创建流程图.png-33.2kB"></p>
<p>其中，check/start 指定组件，也存在系统进程和应用进程间的多次 Binder 通信，这里我们不重点讨论，在后面分析四大组件时，会详细分析他们的生命周期过程，会重点分析这个部分！</p>
<h2 id="15-2-ActivityThread-关系图"><a href="#15-2-ActivityThread-关系图" class="headerlink" title="15.2 ActivityThread 关系图"></a>15.2 ActivityThread 关系图</h2></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2016/03/01/Service 篇 2 - startService 流程分析/">Service 篇 2 - startService 流程分析</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2016-03-01</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/AndroidFramework源码分析/">AndroidFramework源码分析</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/AndroidFramework源码分析/Service服务/">Service服务</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Service服务/">Service服务</a></span><div class="content"><p>基于 <code>Android 7.1.1</code> 源码分析 <code>startService</code> 的流程，本文为作者原创，转载请说明出处！</p>
<h1 id="0-综述"><a href="#0-综述" class="headerlink" title="0 综述"></a>0 综述</h1><p>我们在应用中经常会启动 <code>Service</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startService(intent);</span><br></pre></td></tr></table></figure>
<p>这个方法最终会拉起 <code>Service</code> 的 <code>onStartCommand</code> 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">    OppoLog.d(TAG, <span class="string">"onStartCommand"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onStartCommand(intent, flags, startId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该方法有三个参数：</p>
<ul>
<li><strong>Intent intent</strong>: 启动服务的 <code>Intent</code>！</li>
<li><strong>int flags</strong>: 启动时的额外参数，取值可以为 <code>0</code>，<code>START_FLAG_REDELIVERY</code> 和 <code>START_FLAG_RETRY</code>！</li>
<li><strong>int startId</strong>: 当前服务的唯一 <code>ID</code>，和 <code>StopSelfResult(int startId)</code> 配合使用！</li>
</ul>
<p><strong>1、</strong>下面我们来看看 <code>onStartCommand</code> 的 <code>flag</code> 参数：</p>
<p><br></p>
<ul>
<li><strong>START_FLAG_REDELIVERY</strong> <ul>
<li><strong>取值</strong>：<code>x0001</code></li>
<li><strong>解释</strong>：如果 <code>Service</code> 的 <code>onStartCommand</code> 返回值是 <code>START_REDELIVER_INTENT</code>，当服务被杀掉，服务会重启，这时 <code>flag</code> 会被传入这个值！</li>
</ul>
</li>
</ul>
<p><br></p>
<ul>
<li><strong>START_FLAG_RETRY</strong><ul>
<li><strong>取值</strong>：<code>0x0002</code></li>
<li><strong>解释</strong>：当 <code>onStartCommand</code> 方法调用后一直没有返回时，会尝试重新去调用 <code>onStartCommand</code> 方法，这时 <code>flag</code> 会被传入这个值！</li>
</ul>
</li>
</ul>
<p><strong>2、</strong>而 <code>onStartCommand</code> 有如下的返回值，这里先简单的介绍下：</p>
<p><br></p>
<ul>
<li><strong>START_STICKY_COMPATIBILITY</strong> <ul>
<li><strong>取值</strong>：<code>0</code></li>
</ul>
</li>
<li><strong>START_STICKY</strong><ul>
<li><strong>取值</strong>：<code>1</code></li>
<li><strong>说明</strong>：<ul>
<li>如果 <code>Service</code> 进程启动后被杀掉了，服务被启动的状态会被保留并抛弃本次启动的 <code>Intent</code>，然后系统会尝试重新创建和启动一个新的服务实例!</li>
<li>如果在重启期间，没有任何新的启动项 <code>Intent</code> 传递给 <code>Service</code>，那么会传递一个空的 <code>Intent</code> 对象，所以在 <code>onStartCommand</code> 方法中要做 <code>Intent</code> 非空的判断！ </li>
</ul>
</li>
<li><strong>用途</strong>：<ul>
<li>比较适用于不执行命令、但无限期运行并等待作业的媒体播放器或类似服务。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><br></p>
<ul>
<li><strong>START_NOT_STICKY</strong><ul>
<li><strong>取值</strong>：<code>2</code></li>
<li><strong>说明</strong>：<ul>
<li>如果 <code>Service</code> 进程启动后被杀掉了，并且没有新的启动 <code>Intent</code> 分发给服务，那么会移除服务被启动的状态，也不会重新创建服务，直到下一次显示地通过 <code>startService</code> 启动服务！</li>
<li>这种情况下，<code>onStartCommand</code> 不会传入空的 <code>Intent</code> 对象（因为在没有正在等待分发的 Intent 的情况下，该服务不会重启）！</li>
</ul>
</li>
<li><strong>用途</strong>：<ul>
<li>该模式比较适用于启动后需要做一些工作，但是在内存不够的情况下可以被停止，然后通过显示地再次启动去继续工作的情况！</li>
<li>一个简单的例子：从服务器获得数据的服务，通过设置一个 <code>alarm</code>，间隔一定时间启动服务<code>onStartCommand</code>，然后设置新的 <code>alarm</code>，如果服务进程被杀掉，那服务不会被触发，知道下一次 <code>alarm</code> 触发！</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><br></p>
<ul>
<li><strong>START_REDELIVER_INTENT</strong> <ul>
<li><strong>取值</strong>： <code>3</code></li>
<li><strong>说明</strong>：<ul>
<li>如果 <code>Service</code> 进程启动后被杀掉了，该 <code>Service</code> 将会被重启，并且会将最后启动（<code>startService</code>）分发过的 <code>Intent</code> 再次通过 <code>onStartCommand</code> 方法传递给 <code>Service</code> ，该 <code>Intent</code> 将会被保留用于下一次的重启分发，除非 <code>Service</code> 调用 <code>stopSelf(int startId)</code> 方法停止运行！</li>
<li>这种情况下，<code>onStartCommand</code> 也不会传入空的 <code>Intent</code> 对象，因为服务只有在没有完成处理所有分发给它的 <code>Intent</code> 的情况下或重启，一旦重启，就会将最后启动（<code>startService</code>）分发过的 <code>Intent</code> 再次通过 <code>onStartCommand</code> 方法传递给服务！</li>
</ul>
</li>
<li><strong>用途</strong>：<ul>
<li>这个模式适用于主动执行应该立即恢复的作业（例如下载文件）的服务。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><br></p>
<ul>
<li><strong>START_CONTINUATION_MASK</strong> 0xf</li>
</ul>
<p>这里是 <code>Android</code> 文档中的对这些参数的做的简单说明，下面我们来分析 startService 的过程！</p>
<h1 id="1-启动端进程"><a href="#1-启动端进程" class="headerlink" title="1 启动端进程"></a>1 启动端进程</h1><h2 id="1-1-ContextWrapper-startService"><a href="#1-1-ContextWrapper-startService" class="headerlink" title="1.1 ContextWrapper.startService"></a>1.1 ContextWrapper.startService</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ComponentName <span class="title">startService</span><span class="params">(Intent service)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mBase.startService(service);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ComponentName <span class="title">startServiceAsUser</span><span class="params">(Intent service, UserHandle user)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mBase.startServiceAsUser(service, user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ContextWrapper</code> 提供了两个方法来启动 <code>Service</code>，其中一个是隐藏方法：<code>startServiceAsUser</code>！</p>
<p><code>mBase</code> 是 <code>ContextImpl</code> 对象，继续看！</p>
<h2 id="1-2-ContextImpl-startService"><a href="#1-2-ContextImpl-startService" class="headerlink" title="1.2 ContextImpl.startService"></a>1.2 ContextImpl.startService</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContextImpl</span> <span class="keyword">extends</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ComponentName <span class="title">startService</span><span class="params">(Intent service)</span> </span>&#123;</span><br><span class="line">        warnIfCallingFromSystemProcess();</span><br><span class="line">        <span class="keyword">return</span> startServiceCommon(service, mUser);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ComponentName <span class="title">startServiceAsUser</span><span class="params">(Intent service, UserHandle user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> startServiceCommon(service, user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ContextImpl</code> 和 <code>ContextWrapper</code> 的具体关系，请看博文，这里我们不再详细说明！</p>
<p><code>mUser</code> 表示的是当前的设备 <code>user</code>！</p>
<p>最终，调用了 <code>startServiceCommon</code> 方法；</p>
<h2 id="1-3-ContextImpl-startServiceCommon"><a href="#1-3-ContextImpl-startServiceCommon" class="headerlink" title="1.3 ContextImpl.startServiceCommon"></a>1.3 ContextImpl.startServiceCommon</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ComponentName <span class="title">startServiceCommon</span><span class="params">(Intent service, UserHandle user)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果系统版本不低于 L，那就要抛出异常，提示必须是显示启动！</span></span><br><span class="line">        validateServiceIntent(service);</span><br><span class="line">        service.prepareToLeaveProcess(<span class="keyword">this</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【1】启动指定的 Service！</span></span><br><span class="line">        ComponentName cn = ActivityManagerNative.getDefault().startService(</span><br><span class="line">            mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded(</span><br><span class="line">                        getContentResolver()), getOpPackageName(), user.getIdentifier());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cn != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cn.getPackageName().equals(<span class="string">"!"</span>)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(</span><br><span class="line">                        <span class="string">"Not allowed to start service "</span> + service</span><br><span class="line">                        + <span class="string">" without permission "</span> + cn.getClassName());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cn.getPackageName().equals(<span class="string">"!!"</span>)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(</span><br><span class="line">                        <span class="string">"Unable to start service "</span> + service</span><br><span class="line">                        + <span class="string">": "</span> + cn.getClassName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cn;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>validateServiceIntent</code> 方法用用来校验启动用的 <code>intent</code> 是否安全：</p>
<h3 id="1-3-1-ContextImpl-validateServiceIntent"><a href="#1-3-1-ContextImpl-validateServiceIntent" class="headerlink" title="1.3.1 ContextImpl.validateServiceIntent"></a>1.3.1 ContextImpl.validateServiceIntent</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">c</span><span class="params">(Intent service)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (service.getComponent() == <span class="keyword">null</span> &amp;&amp; service.getPackage() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (getApplicationInfo().targetSdkVersion &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">            IllegalArgumentException ex = <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    <span class="string">"Service Intent must be explicit: "</span> + service);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">"Implicit intents with startService are not safe: "</span> + service</span><br><span class="line">                    + <span class="string">" "</span> + Debug.getCallers(<span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 <code>intent</code> 既没有设置 <code>component</code> 也没有设置 <code>package</code>，那就要判断一下系统的版本了: </p>
<ul>
<li>如果系统版本不低于 <code>L</code>，那就要抛出异常，提示必须是显示启动；</li>
<li>如果系统版本低于 <code>L</code>，那只提示隐式启动不安全；</li>
</ul>
<p>这里可以看出，<code>Intent</code> 必须要设置 <code>component</code> 或者 <code>package</code> 中的一个！</p>
<h3 id="1-3-2-ContextImpl-getOpPackageName"><a href="#1-3-2-ContextImpl-getOpPackageName" class="headerlink" title="1.3.2 ContextImpl.getOpPackageName"></a>1.3.2 ContextImpl.getOpPackageName</h3><p>通过 <code>getOpPackageName</code> 来获得启动者所在的包名：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getOpPackageName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mOpPackageName != <span class="keyword">null</span> ? mOpPackageName : getBasePackageName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的 <code>mOpPackageName</code> 是在创建 <code>ContextImpl</code> 的时候初始化的！</p>
<h2 id="1-4-ActivityManagerP-startService"><a href="#1-4-ActivityManagerP-startService" class="headerlink" title="1.4 ActivityManagerP.startService"></a>1.4 ActivityManagerP.startService</h2><p>接着，通过 <code>ActivityManagerP.startService</code> 方法，启动服务！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ComponentName <span class="title">startService</span><span class="params">(IApplicationThread caller, Intent service,</span></span></span><br><span class="line"><span class="function"><span class="params">     String resolvedType, String callingPackage, <span class="keyword">int</span> userId)</span> <span class="keyword">throws</span> RemoteException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Parcel data = Parcel.obtain();</span><br><span class="line">    Parcel reply = Parcel.obtain();</span><br><span class="line">    data.writeInterfaceToken(IActivityManager.descriptor);</span><br><span class="line"></span><br><span class="line">    data.writeStrongBinder(caller != <span class="keyword">null</span> ? caller.asBinder() : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    service.writeToParcel(data, <span class="number">0</span>);</span><br><span class="line">    data.writeString(resolvedType);</span><br><span class="line">    data.writeString(callingPackage);</span><br><span class="line">    data.writeInt(userId);</span><br><span class="line">    mRemote.transact(START_SERVICE_TRANSACTION, data, reply, <span class="number">0</span>);</span><br><span class="line">    reply.readException();</span><br><span class="line"></span><br><span class="line">    ComponentName res = ComponentName.readFromParcel(reply);</span><br><span class="line"></span><br><span class="line">    data.recycle();</span><br><span class="line">    reply.recycle();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过 <code>binder</code> 进程间通信，进入系统进程，参数分析：</p>
<ul>
<li><code>IApplicationThread caller</code>： 调用者进程的 <code>ApplicationThread</code> 对象，实现了 <code>IApplicationThread</code> 接口；</li>
<li><code>Intent service</code>： 启动的 <code>intent</code></li>
<li><code>String resolvedType</code>： 这个 <code>intent</code> 的 <code>MIME</code> 类型；</li>
<li><code>String callingPackage</code>： 启动者所属包名；</li>
<li><code>int userId</code>： 设备用户 <code>id</code>；</li>
</ul>
<h1 id="2-系统进程"><a href="#2-系统进程" class="headerlink" title="2 系统进程"></a>2 系统进程</h1><p>接下来，进入系统进程的 <code>ActivityManagerService</code> 中！</p>
<p>首先要进入 <code>ActivityManagerN.onTransact</code> 方法！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> START_SERVICE_TRANSACTION: &#123;</span><br><span class="line">    data.enforceInterface(IActivityManager.descriptor);</span><br><span class="line">    </span><br><span class="line">    IBinder b = data.readStrongBinder();</span><br><span class="line">    IApplicationThread app = ApplicationThreadNative.asInterface(b);</span><br><span class="line"></span><br><span class="line">    Intent service = Intent.CREATOR.createFromParcel(data);</span><br><span class="line">    String resolvedType = data.readString();</span><br><span class="line">    String callingPackage = data.readString();</span><br><span class="line">    <span class="keyword">int</span> userId = data.readInt();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【1】继续 startService！</span></span><br><span class="line">    ComponentName cn = startService(app, service, resolvedType, callingPackage, userId);</span><br><span class="line"></span><br><span class="line">    reply.writeNoException();</span><br><span class="line">    ComponentName.writeToParcel(cn, reply);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-1-ActivityManagerS-startService"><a href="#2-1-ActivityManagerS-startService" class="headerlink" title="2.1 ActivityManagerS.startService"></a>2.1 ActivityManagerS.startService</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ComponentName <span class="title">startService</span><span class="params">(IApplicationThread caller, Intent service,</span></span></span><br><span class="line"><span class="function"><span class="params">        String resolvedType, String callingPackage, <span class="keyword">int</span> userId)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用来校验启动者进程是否是隔离的，如果是隔离进程，抛出异常！！</span></span><br><span class="line">    enforceNotIsolatedCaller(<span class="string">"startService"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不能通过 intent 传递文件描述符，否则抛出非法异常！</span></span><br><span class="line">    <span class="keyword">if</span> (service != <span class="keyword">null</span> &amp;&amp; service.hasFileDescriptors() == <span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"File descriptors passed in Intent"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用者 package 为 null，抛出异常！</span></span><br><span class="line">    <span class="keyword">if</span> (callingPackage == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"callingPackage cannot be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE,</span><br><span class="line">            <span class="string">"startService: "</span> + service + <span class="string">" type="</span> + resolvedType);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得调用者的 uid 和 pid！</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> callingPid = Binder.getCallingPid();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> callingUid = Binder.getCallingUid();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【1】进入 ActiveServices，继续启动！</span></span><br><span class="line">        ComponentName res = mServices.startServiceLocked(caller, service,</span><br><span class="line">                resolvedType, callingPid, callingUid, callingPackage, userId);</span><br><span class="line"></span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>mServices</code> 是 <code>ActivityManagerService</code> 的一个内部管理对象，用于管理所有的 <code>Service</code>！</p>
<h2 id="2-2-ActiveServices-startServiceLoced"><a href="#2-2-ActiveServices-startServiceLoced" class="headerlink" title="2.2 ActiveServices.startServiceLoced"></a>2.2 ActiveServices.startServiceLoced</h2><p>参数和前面保持一致！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ComponentName <span class="title">startServiceLocked</span><span class="params">(IApplicationThread caller, Intent service, String resolvedType,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> callingPid, <span class="keyword">int</span> callingUid, String callingPackage, <span class="keyword">final</span> <span class="keyword">int</span> userId)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE, <span class="string">"startService: "</span> + service</span><br><span class="line">            + <span class="string">" type="</span> + resolvedType + <span class="string">" args="</span> + service.getExtras());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【1】判断是否是前台调用！</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> callerFg;</span><br><span class="line">    <span class="keyword">if</span> (caller != <span class="keyword">null</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获得调用者进程的 ProcessRecord 对象！</span></span><br><span class="line">        <span class="keyword">final</span> ProcessRecord callerApp = mAm.getRecordForAppLocked(caller);</span><br><span class="line">        <span class="keyword">if</span> (callerApp == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(</span><br><span class="line">                    <span class="string">"Unable to find app for caller "</span> + caller</span><br><span class="line">                    + <span class="string">" (pid="</span> + Binder.getCallingPid()</span><br><span class="line">                    + <span class="string">") when starting service "</span> + service);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        callerFg = callerApp.setSchedGroup != ProcessList.SCHED_GROUP_BACKGROUND;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        callerFg = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】检索要启动的服务的信息！</span></span><br><span class="line">    ServiceLookupResult res =</span><br><span class="line">        retrieveServiceLocked(service, resolvedType, callingPackage,</span><br><span class="line">                callingPid, callingUid, userId, <span class="keyword">true</span>, callerFg, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res.record == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ComponentName(<span class="string">"!"</span>, res.permission != <span class="keyword">null</span></span><br><span class="line">                ? res.permission : <span class="string">"private to package"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【3】获得要启动的服务的数据对象：ServiceRecord！</span></span><br><span class="line">    ServiceRecord r = res.record;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果服务所属的设备用户不存在，直接返回！</span></span><br><span class="line">    <span class="keyword">if</span> (!mAm.mUserController.exists(r.userId)) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"Trying to start service with non-existent user! "</span> + r.userId);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【4】如果服务还没有被请求启动，要先判断服务是否允许在后台启动，如果不允许就直接返回！</span></span><br><span class="line">    <span class="keyword">if</span> (!r.startRequested) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> token = Binder.clearCallingIdentity();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> allowed = mAm.checkAllowBackgroundLocked(</span><br><span class="line">                    r.appInfo.uid, r.packageName, callingPid, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (allowed != ActivityManager.APP_START_MODE_NORMAL) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Background start not allowed: service "</span></span><br><span class="line">                        + service + <span class="string">" to "</span> + r.name.flattenToShortString()</span><br><span class="line">                        + <span class="string">" from pid="</span> + callingPid + <span class="string">" uid="</span> + callingUid</span><br><span class="line">                        + <span class="string">" pkg="</span> + callingPackage);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Binder.restoreCallingIdentity(token);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NeededUriGrants neededGrants = mAm.checkGrantUriPermissionFromIntentLocked(</span><br><span class="line">            callingUid, r.packageName, service, service.getFlags(), <span class="keyword">null</span>, r.userId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【5】如果启动者属于前台应用，并且启动服务组件是需要校验权限，就需要弹出权限校验界面！</span></span><br><span class="line">    <span class="comment">// 只有权限校验成功，才会继续启动！</span></span><br><span class="line">    <span class="keyword">if</span> (Build.PERMISSIONS_REVIEW_REQUIRED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!requestStartTargetPermissionsReviewIfNeededLocked(r, callingPackage,</span><br><span class="line">                callingUid, service, callerFg, userId)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【6】取消服务重启的任务！</span></span><br><span class="line">    <span class="keyword">if</span> (unscheduleServiceRestartLocked(r, callingUid, <span class="keyword">false</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">"START SERVICE WHILE RESTART PENDING: "</span> + r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【7】设置服务 ServiceRecord 的属性值；</span></span><br><span class="line">    r.lastActivity = SystemClock.uptimeMillis();</span><br><span class="line">    <span class="comment">// 设置 startRequested 为 true，表示被请求启动！</span></span><br><span class="line">    r.startRequested = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 设置 delayedStop 为 false；表示服务没有被延迟停止，只对后台服务有效！</span></span><br><span class="line">    r.delayedStop = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将本次启动需要的数据，包括 intent，封装成 StartItem，保存到 pendingStarts 列表中！</span></span><br><span class="line">    r.pendingStarts.add(<span class="keyword">new</span> ServiceRecord.StartItem(r, <span class="keyword">false</span>, r.makeNextStartId(),</span><br><span class="line">            service, neededGrants));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获得 userId 下的所有 Service 的 Map 集合！</span></span><br><span class="line">    <span class="keyword">final</span> ServiceMap smap = getServiceMap(r.userId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示是否将服务添加到后台启动列表中；</span></span><br><span class="line">    <span class="keyword">boolean</span> addToStarting = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【8】对于后台启动的服务，需要做一些条件判断，看是延迟启动，还是立刻后台启动！</span></span><br><span class="line">    <span class="keyword">if</span> (!callerFg &amp;&amp; r.app == <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; mAm.mUserController.hasStartedUserState(r.userId)) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获得被启动的服务所在进程的 ProcessRecord 数据对象！</span></span><br><span class="line">        ProcessRecord proc = mAm.getProcessRecordLocked(r.processName, r.appInfo.uid, <span class="keyword">false</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 下面判断当前启动服务的进程状态来确定是否需要延时启动这个服务！</span></span><br><span class="line">        <span class="comment">// 对于非前台的启动，尝试延迟启动服务！ </span></span><br><span class="line">        <span class="keyword">if</span> (proc == <span class="keyword">null</span> || proc.curProcState &gt; ActivityManager.PROCESS_STATE_RECEIVER) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_DELAYED_SERVICE) Slog.v(TAG_SERVICE, <span class="string">"Potential start delay of "</span></span><br><span class="line">                    + r + <span class="string">" in "</span> + proc);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (r.delayed) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果该服务已经延迟启动，说明他已经被加入到了 smap.mDelayedStartList 列表中等待启动，直接返回！</span></span><br><span class="line">                <span class="keyword">if</span> (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE, <span class="string">"Continuing to delay: "</span> + r);</span><br><span class="line">                <span class="keyword">return</span> r.name;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 当同一时间正在后台启动的服务数超过了最大后台启动服务数，延迟启动！</span></span><br><span class="line">            <span class="keyword">if</span> (smap.mStartingBackground.size() &gt;= mMaxStartingBackground) &#123;</span><br><span class="line">                Slog.i(TAG_SERVICE, <span class="string">"Delaying start of: "</span> + r);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 就要将该服务加入 smap.mDelayedStartList 中；</span></span><br><span class="line">                smap.mDelayedStartList.add(r);</span><br><span class="line">                <span class="comment">// 设置其 r.delayed 为 true！</span></span><br><span class="line">                r.delayed = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> r.name;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE, <span class="string">"Not delaying: "</span> + r);</span><br><span class="line">            </span><br><span class="line">            addToStarting = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (proc.curProcState &gt;= ActivityManager.PROCESS_STATE_SERVICE) &#123;</span><br><span class="line"></span><br><span class="line">            addToStarting = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE,</span><br><span class="line">                    <span class="string">"Not delaying, but counting as bg: "</span> + r);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (DEBUG_DELAYED_STARTS) &#123; <span class="comment">// 和 debug 相关，只是输出一些 log 信息！</span></span><br><span class="line"></span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="number">128</span>);</span><br><span class="line">            sb.append(<span class="string">"Not potential delay (state="</span>).append(proc.curProcState)</span><br><span class="line">                    .append(<span class="string">' '</span>).append(proc.adjType);</span><br><span class="line">            String reason = proc.makeAdjReason();</span><br><span class="line">            <span class="keyword">if</span> (reason != <span class="keyword">null</span>) &#123;</span><br><span class="line">                sb.append(<span class="string">' '</span>);</span><br><span class="line">                sb.append(reason);</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(<span class="string">"): "</span>);</span><br><span class="line">            sb.append(r.toString());</span><br><span class="line">            Slog.v(TAG_SERVICE, sb.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (DEBUG_DELAYED_STARTS) &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 和 debug 相关，只是输出一些 log 信息！</span></span><br><span class="line">        <span class="keyword">if</span> (callerFg) &#123;</span><br><span class="line">            Slog.v(TAG_SERVICE, <span class="string">"Not potential delay (callerFg="</span> + callerFg + <span class="string">" uid="</span></span><br><span class="line">                    + callingUid + <span class="string">" pid="</span> + callingPid + <span class="string">"): "</span> + r);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.app != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Slog.v(TAG_SERVICE, <span class="string">"Not potential delay (cur app="</span> + r.app + <span class="string">"): "</span> + r);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Slog.v(TAG_SERVICE,</span><br><span class="line">                    <span class="string">"Not potential delay (user "</span> + r.userId + <span class="string">" not started): "</span> + r);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【9】进一步调用！</span></span><br><span class="line">    <span class="keyword">return</span> startServiceInnerLocked(smap, service, r, callerFg, addToStarting);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该方法的主要流程：</p>
<ul>
<li>判断是前台启动，还是后台启动；</li>
<li>检索需要启动的服务的信息；</li>
<li>如果不满足启动条件就取消本次启动；</li>
<li>创建本次启动对应的启动项；</li>
<li>对于后台启动的服务，需要判读是否延迟启动；</li>
<li>进一步启动服务！</li>
</ul>
<p>如何判断后台启动的服务是否需要延迟启动呢，依据如下：</p>
<p>这个地方会对进程的状态做一个判断：</p>
<ul>
<li>如果是前台进程的调度，就直接进行启动；</li>
<li>如果是后台进程的调度，就要先判断一下，是否延迟执行；</li>
</ul>
<p>对于如何判断进程是否是前台进程，还是后台进程，我会在另外一篇文章中说明！！</p>
<h3 id="2-2-1-ActiveServices-unscheduleServiceRestartLocked"><a href="#2-2-1-ActiveServices-unscheduleServiceRestartLocked" class="headerlink" title="2.2.1 ActiveServices.unscheduleServiceRestartLocked"></a>2.2.1 ActiveServices.unscheduleServiceRestartLocked</h3><p>这里有一个方法，取消上一次的重启任务，参数传入：</p>
<ul>
<li>boolean force：传入 false！<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">unscheduleServiceRestartLocked</span><span class="params">(ServiceRecord r, <span class="keyword">int</span> callingUid,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> force)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!force &amp;&amp; r.restartDelay == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】将服务从重启列表中移除！</span></span><br><span class="line">    <span class="keyword">boolean</span> removed = mRestartingServices.remove(r);</span><br><span class="line">    <span class="keyword">if</span> (removed || callingUid != r.appInfo.uid) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 清空 restartCount，restartDelay，restartTime！</span></span><br><span class="line">        r.resetRestartCounter();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (removed) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 让 restartTracker 对 ServiceRecord 重新监控！</span></span><br><span class="line">        clearRestartingIfNeededLocked(r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【2】移除重启任务！</span></span><br><span class="line">    mAm.mHandler.removeCallbacks(r.restarter);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这里有一个数据结构：r.restarter，他是在创建 ServiceRecord 时传入的，他是一个 ServiceRestarter 对象！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceRestarter</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServiceRecord mService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setService</span><span class="params">(ServiceRecord service)</span> </span>&#123;</span><br><span class="line">        mService = service;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(mAm) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//【1】执行重启操作！</span></span><br><span class="line">            performServiceRestartLocked(mService);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们再去看看 performServiceRestartLocked 方法，是如何实现服务的重启的！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performServiceRestartLocked</span><span class="params">(ServiceRecord r)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】mRestartingServices 没有当前服务，无法执行重启！</span></span><br><span class="line">    <span class="keyword">if</span> (!mRestartingServices.contains(r)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【2】不需要重启服务！</span></span><br><span class="line">    <span class="keyword">if</span> (!isServiceNeeded(r, <span class="keyword">false</span>, <span class="keyword">false</span>)) &#123;</span><br><span class="line">        Slog.wtf(TAG, <span class="string">"Restarting service that is not needed: "</span> + r);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//【3】再次拉起服务！！</span></span><br><span class="line">        bringUpServiceLocked(r, r.intent.getIntent().getFlags(), r.createdFromFg, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (TransactionTooLargeException e) &#123;</span><br><span class="line">        <span class="comment">// Ignore, it's been logged and nothing upstack cares.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>用于执行重启操作，这里我们只是简单地看看！</p>
<h2 id="2-3-ActiveServices-startServiceInnerLocked"><a href="#2-3-ActiveServices-startServiceInnerLocked" class="headerlink" title="2.3 ActiveServices.startServiceInnerLocked"></a>2.3 ActiveServices.startServiceInnerLocked</h2><p>接下来，进一步地启动服务，如果 addToStarting 为 true，表示该服务是后台启动的，需要将其添加到 mStartingBackground 集合中！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ComponentName <span class="title">startServiceInnerLocked</span><span class="params">(ServiceMap smap, Intent service, ServiceRecord r,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> callerFg, <span class="keyword">boolean</span> addToStarting)</span> <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line"></span><br><span class="line">    ServiceState stracker = r.getTracker();</span><br><span class="line">    <span class="keyword">if</span> (stracker != <span class="keyword">null</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通知服务的 tracker 对象，开始监控服务!</span></span><br><span class="line">        stracker.setStarted(<span class="keyword">true</span>, mAm.mProcessStats.getMemFactorLocked(), r.lastActivity);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 表示是否被启动了，在启动前初始化为 false！</span></span><br><span class="line">    r.callStart = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (r.stats.getBatteryStats()) &#123;</span><br><span class="line">        r.stats.startRunningLocked();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//【1】拉起服务，这个方法会拉起服务的 onCreate 和 onStartCommand 方法！</span></span><br><span class="line">    String error = bringUpServiceLocked(r, service.getFlags(), callerFg, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (error != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ComponentName(<span class="string">"!!"</span>, error);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【2】如果服务已经被请求启动（startRequested 为 true），且是后台启动（addToStarting 为 true）</span></span><br><span class="line">    <span class="keyword">if</span> (r.startRequested &amp;&amp; addToStarting) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">boolean</span> first = smap.mStartingBackground.size() == <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将服务添加到 mStartingBackground 列表中，表示正在后台启动！</span></span><br><span class="line">        smap.mStartingBackground.add(r);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置后台启动服务的超时时间！</span></span><br><span class="line">        r.startingBgTimeout = SystemClock.uptimeMillis() + BG_START_TIMEOUT;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DEBUG_DELAYED_SERVICE) &#123;</span><br><span class="line"></span><br><span class="line">            RuntimeException here = <span class="keyword">new</span> RuntimeException(<span class="string">"here"</span>);</span><br><span class="line">            here.fillInStackTrace();</span><br><span class="line">            Slog.v(TAG_SERVICE, <span class="string">"Starting background (first="</span> + first + <span class="string">"): "</span> + r, here);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (DEBUG_DELAYED_STARTS) &#123;</span><br><span class="line">            Slog.v(TAG_SERVICE, <span class="string">"Starting background (first="</span> + first + <span class="string">"): "</span> + r);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【2.1】如果 first 为 true，表示这是第一个后台启动的服务！那就需要初始化延迟启动的任务调度！</span></span><br><span class="line">        <span class="keyword">if</span> (first) &#123;</span><br><span class="line">            smap.rescheduleDelayedStarts();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (callerFg) &#123;</span><br><span class="line">        <span class="comment">//【2.2】如果是前台启动该服务，就取消该服务之前的后台运行任务！</span></span><br><span class="line">        smap.ensureNotStartingBackground(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于前台启动的方式：<code>callerFg</code> 为 <code>true</code>，<code>addToStarting</code> 为 <code>false</code>，就会执行 <code>ensureNotStartingBackground</code> 取消服务后台启动！<br>对于后台启动的方式：<code>callerFg</code> 为 <code>false</code>，<code>addToStarting</code> 为 <code>true</code>，就会将服务添加到 <code>mStartingBackground</code> 集合中！</p>
<h3 id="2-3-1-ServiceMap-rescheduleDelayedStart"><a href="#2-3-1-ServiceMap-rescheduleDelayedStart" class="headerlink" title="2.3.1 ServiceMap.rescheduleDelayedStart"></a>2.3.1 ServiceMap.rescheduleDelayedStart</h3><p>对于后台启动的方式，如果 <code>mStartingBackground.size() == 0</code>，那就需要对延迟启动的调度做一次初始化，我们先来看看 <code>rescheduleDelayedStarts</code> 方法！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rescheduleDelayedStarts</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 移除 MSG_BG_START_TIMEOUT 后台启动超时消息！</span></span><br><span class="line">        removeMessages(MSG_BG_START_TIMEOUT);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【1】对于后台启动的服务，如果后台启动超时，就从移除该服务！ 为延迟后台启动的服务腾出位置！</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>, N=mStartingBackground.size(); i&lt;N; i++) &#123;</span><br><span class="line">            ServiceRecord r = mStartingBackground.get(i);</span><br><span class="line">            <span class="keyword">if</span> (r.startingBgTimeout &lt;= now) &#123;</span><br><span class="line">                Slog.i(TAG, <span class="string">"Waited long enough for: "</span> + r);</span><br><span class="line">                mStartingBackground.remove(i);</span><br><span class="line">                N--;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【2】处理后台延迟启动的服务，如果此时延迟启动列表不为空，且正在后台启动的服务数不超过最大后台启动数</span></span><br><span class="line">        <span class="comment">// 那这个时候就要处理后台延迟服务的启动了！</span></span><br><span class="line">        <span class="keyword">while</span> (mDelayedStartList.size() &gt; <span class="number">0</span></span><br><span class="line">                &amp;&amp; mStartingBackground.size() &lt; mMaxStartingBackground) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//【2.1】从 mDelayedStartList 移除该服务，保存到 r 中！</span></span><br><span class="line">            ServiceRecord r = mDelayedStartList.remove(<span class="number">0</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE,</span><br><span class="line">                    <span class="string">"REM FR DELAY LIST (exec next): "</span> + r);</span><br><span class="line">            <span class="keyword">if</span> (r.pendingStarts.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"**** NO PENDING STARTS! "</span> + r + <span class="string">" startReq="</span> + r.startRequested</span><br><span class="line">                        + <span class="string">" delayedStop="</span> + r.delayedStop);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (DEBUG_DELAYED_SERVICE) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mDelayedStartList.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    Slog.v(TAG_SERVICE, <span class="string">"Remaining delayed list:"</span>);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;mDelayedStartList.size(); i++) &#123;</span><br><span class="line">                        Slog.v(TAG_SERVICE, <span class="string">"  #"</span> + i + <span class="string">": "</span> + mDelayedStartList.get(i));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将 r.delayed 设为 false；</span></span><br><span class="line">            r.delayed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//【2.2】后台启动该服务（callerFg 为 false，addStarting 为 true）</span></span><br><span class="line">                <span class="comment">// 服务会被添加到 mStartingBackground 列表中！</span></span><br><span class="line">                startServiceInnerLocked(<span class="keyword">this</span>, r.pendingStarts.get(<span class="number">0</span>).intent, r, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (TransactionTooLargeException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【3】设置后台启动的超时处理！</span></span><br><span class="line">        <span class="keyword">if</span> (mStartingBackground.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// 设置后台超时消息的发送的时间 when 为 startingBgTimeout 和 now 中的最大值！</span></span><br><span class="line">            ServiceRecord next = mStartingBackground.get(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">long</span> when = next.startingBgTimeout &gt; now ? next.startingBgTimeout : now;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (DEBUG_DELAYED_SERVICE) Slog.v(TAG_SERVICE, <span class="string">"Top bg start is "</span> + next</span><br><span class="line">                    + <span class="string">", can delay others up to "</span> + when);</span><br><span class="line"></span><br><span class="line">            Message msg = obtainMessage(MSG_BG_START_TIMEOUT);</span><br><span class="line">            sendMessageAtTime(msg, when);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【4】发送那些等待后台服务启动的后台广播！</span></span><br><span class="line">        <span class="keyword">if</span> (mStartingBackground.size() &lt; mMaxStartingBackground) &#123;</span><br><span class="line">            mAm.backgroundServicesFinishedLocked(mUserId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到，对于延迟后台启动的服务，最后又会调用 <code>startServiceInnerLocked</code> 后台启动，然后，该服务会被添加到 <code>mStartingBackground</code> 列表中，表示正在启动，这个我们后面会分析到！</p>
<p>该方法的主要作用是：</p>
<ul>
<li>移除 <code>mStartingBackground</code> 中已经启动超时的服务；</li>
<li>如果后台启动的服务数小于最大允许后台启动的服务数，且 <code>mDelayedStartList</code> 中有延迟启动的服务，就立刻启动并移除 <code>mDelayedStartList</code> 中的服务，然后将其添加到 <code>mStartingBackground</code> 列表中！</li>
<li>设置后台启动的超时处理！</li>
<li>发送那些等待后台服务启动的后台广播！</li>
</ul>
<p><br></p>
<p>这里要简单的说一下 <strong>ServiceMap</strong>：</p>
<p><code>ServiceMap</code> 是 <code>Handler</code> 的子类，其内部封装了指定设备用户所有的服务信息对象，还有后台启动的服务对象列表 <code>mStartingBackground</code>，以及延迟后台启动的服务对象列表 <code>mDelayedStartList</code>！</p>
<p>其本身是 <code>Handler</code>，用于处理 <code>MSG_BG_START_TIMEOUT</code>消息：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">        <span class="keyword">case</span> MSG_BG_START_TIMEOUT: &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mAm) &#123;</span><br><span class="line">                <span class="comment">//【1】</span></span><br><span class="line">                rescheduleDelayedStarts();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>ServiceMap</code> 收到该消息后，会再次触发 <code>rescheduleDelayedStart</code> 方法，该内部又会发送 <code>MSG_BG_START_TIMEOUT</code> 消息，这样就会不断的循环发送 <code>MSG_BG_START_TIMEOUT</code> 消息，不断的处理  <code>mDelayedStartList</code> 和 <code>mStartingBackground</code><br>列表，保证所有的后台延迟启动的服务能够即使启动，同时设置后台启动的超时处理！</p>
<h3 id="2-3-2-ServiceMap-ensureNotStartingBackground"><a href="#2-3-2-ServiceMap-ensureNotStartingBackground" class="headerlink" title="2.3.2 ServiceMap.ensureNotStartingBackground"></a>2.3.2 ServiceMap.ensureNotStartingBackground</h3><p>对于前台启动的方式，就需要更新 <code>mStartingBackground</code> 和 <code>mDelayedStartList</code> 集合中的元素了，尝试将当前的服务从这两个集合中删除，因为这里是前台启动，我们继续看：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ensureNotStartingBackground</span><span class="params">(ServiceRecord r)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】从 mStartingBackground 中删除当前服务；</span></span><br><span class="line">    <span class="keyword">if</span> (mStartingBackground.remove(r)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE,</span><br><span class="line">                <span class="string">"No longer background starting: "</span> + r);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【1.1】再次启动后台延迟服务的调度！</span></span><br><span class="line">        rescheduleDelayedStarts();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】从 mDelayedStartList 中删除当前服务；</span></span><br><span class="line">    <span class="keyword">if</span> (mDelayedStartList.remove(r)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE, <span class="string">"No longer delaying start: "</span> + r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先是尝试从 <code>mStartingBackground</code> 中删除当前服务，如果删除成功，就要再次调用 <code>rescheduleDelayedStarts</code> 方法，尝试后台启动被延迟后台启动的服务，并再次发送 <code>MSG_BG_START_TIMEOUT</code> 消息！</p>
<h3 id="2-3-3-阶段总结"><a href="#2-3-3-阶段总结" class="headerlink" title="2.3.3 阶段总结"></a>2.3.3 阶段总结</h3><p>对于立刻后台启动的服务 <code>r</code>，启动时，都会被添加到 <code>mStartingBackground</code> 列表中，并且设置 <code>r.startingBgTimeout</code> 后台启动超时时间为 <code>now + 15s</code>；每个后台启动的服务 <code>r</code>，当其 <code>r.startingBgTimeout</code> 时间到了后，会从 <code>mStartingBackground</code> 列表中删除；</p>
<p>对于延迟后台启动的服务 <code>r</code>，都会添加到 <code>mDelayedStartList</code> 列表中，并且设置 <code>r.delayed</code> 为 <code>true</code>，每个延迟后台启动的服务的启动都依赖于一个条件：<code>mStartingBackground.size() &lt; mMaxStartingBackground</code>；</p>
<p>通过上面的分析，我们可以知道 <code>rescheduleDelayedStarts</code> 和 <code>ensureNotStartingBackground</code> 作用是什么了:</p>
<p>就是不断处理 <code>mStartingBackground</code> 中的服务，不断的根据 <code>mStartingBackground</code> 中服务的 <code>r.startingBgTimeout</code> 发送 <code>MSG_BG_START_TIMEOUT</code> 消息，不断的处理该消息，删除对应的服务，使得 <code>mStartingBackground.size() &lt; mMaxStartingBackground</code>，为 <code>mDelayedStartList</code> 中的服务腾出位置，保证这些延迟后台启动的服务能够后台启动！</p>
<h2 id="2-4-ActiveServices-bringUpServiceLocked"><a href="#2-4-ActiveServices-bringUpServiceLocked" class="headerlink" title="2.4 ActiveServices.bringUpServiceLocked"></a>2.4 ActiveServices.bringUpServiceLocked</h2><p>下面我们来看看，系统进程是如何拉起 Serivce 的，传入参数分析：</p>
<ul>
<li><strong>ServiceRecord r</strong>：服务的 ServiceRecord 对象；</li>
<li><strong>int intentFlags</strong>：启动服务的 intent 的 flag，通过 getFlags 获得；</li>
<li><strong>boolean execInFg</strong>：传入 callFg，表示本次启动是前台调用还是后台调用；</li>
<li><strong>boolean whileRestarting</strong>：表示是否是正在重启，传入 false；</li>
<li><strong>boolean permissionsReviewRequired</strong>：false；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">bringUpServiceLocked</span><span class="params">(ServiceRecord r, <span class="keyword">int</span> intentFlags, <span class="keyword">boolean</span> execInFg,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> whileRestarting, <span class="keyword">boolean</span> permissionsReviewRequired)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】如果 r.app 和 r.app.thread 都不为 null。说明不仅服务所在进程已经被启动，服务也已经被创建（onCreate）；</span></span><br><span class="line">    <span class="comment">// 那就直接拉起 onStartCommand() 方法！这里我们先假设服务所在的进程还没有被启动！</span></span><br><span class="line">    <span class="keyword">if</span> (r.app != <span class="keyword">null</span> &amp;&amp; r.app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        sendServiceArgsLocked(r, execInFg, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】如果服务正在等待重启，就退出！</span></span><br><span class="line">    <span class="keyword">if</span> (!whileRestarting &amp;&amp; r.restartDelay &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">"Bringing up "</span> + r + <span class="string">" "</span> + r.intent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【3】如果服务是被启动了，所以要从 mRestartingServices 列表中移除它，并清除内部的启动计数！</span></span><br><span class="line">    <span class="keyword">if</span> (mRestartingServices.remove(r)) &#123;</span><br><span class="line">        r.resetRestartCounter();</span><br><span class="line">        clearRestartingIfNeededLocked(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【4】如果这个服务被延迟后台启动，即 delayed 为 true，那就从 mDelayedStartList 中移除它，</span></span><br><span class="line">    <span class="comment">// 并置 r.delayed 为 false；</span></span><br><span class="line">    <span class="keyword">if</span> (r.delayed) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE, <span class="string">"REM FR DELAY LIST (bring up): "</span> + r);</span><br><span class="line">        getServiceMap(r.userId).mDelayedStartList.remove(r);</span><br><span class="line">        r.delayed = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果这个服务所在的设备用户没有被启动，那就不允许启动这个服务！</span></span><br><span class="line">    <span class="keyword">if</span> (!mAm.mUserController.hasStartedUserState(r.userId)) &#123;</span><br><span class="line">        String msg = <span class="string">"Unable to launch app "</span></span><br><span class="line">                + r.appInfo.packageName + <span class="string">"/"</span></span><br><span class="line">                + r.appInfo.uid + <span class="string">" for service "</span></span><br><span class="line">                + r.intent.getIntent() + <span class="string">": user "</span> + r.userId + <span class="string">" is stopped"</span>;</span><br><span class="line">        Slog.w(TAG, msg);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 停止这个服务！</span></span><br><span class="line">        bringDownServiceLocked(r);</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 服务将要被启动，所以要设置其 package 的停止状态为 false；</span></span><br><span class="line">        AppGlobals.getPackageManager().setPackageStoppedState(</span><br><span class="line">                r.packageName, <span class="keyword">false</span>, r.userId);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"Failed trying to unstop package "</span></span><br><span class="line">                + r.packageName + <span class="string">": "</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断这个服务是否属于隔离进程；</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isolated = (r.serviceInfo.flags&amp;ServiceInfo.FLAG_ISOLATED_PROCESS) != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【5】获得要启动的服务的目标进程名和进程对象；</span></span><br><span class="line">    <span class="keyword">final</span> String procName = r.processName;</span><br><span class="line">    ProcessRecord app;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isolated) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对于非隔离进程，先获得所在进程的 ProcessRecord 对象；</span></span><br><span class="line">        app = mAm.getProcessRecordLocked(procName, r.appInfo.uid, <span class="keyword">false</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (DEBUG_MU) Slog.v(TAG_MU, <span class="string">"bringUpServiceLocked: appInfo.uid="</span> + r.appInfo.uid</span><br><span class="line">                    + <span class="string">" app="</span> + app);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (app != <span class="keyword">null</span> &amp;&amp; app.thread != <span class="keyword">null</span>) &#123; <span class="comment">// 如果进程已经启动；</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                app.addPackage(r.appInfo.packageName, r.appInfo.versionCode, mAm.mProcessStats);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//【5.1】启动指定服务！</span></span><br><span class="line">                realStartServiceLocked(r, app, execInFg);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (TransactionTooLargeException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Exception when starting service "</span> + r.shortName, e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对于隔离进程，获得服务之前所在的进程！</span></span><br><span class="line">        app = r.isolatedProc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果服务所在的进程没有启动！</span></span><br><span class="line">    <span class="keyword">if</span> (app == <span class="keyword">null</span> &amp;&amp; !permissionsReviewRequired) &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//【6】首先要启动服务所在的进程，这里请去看进程启动和创建的博文！</span></span><br><span class="line">        <span class="keyword">if</span> ((app=mAm.startProcessLocked(procName, r.appInfo, <span class="keyword">true</span>, intentFlags,</span><br><span class="line">                <span class="string">"service"</span>, r.name, <span class="keyword">false</span>, isolated, <span class="keyword">false</span>)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            String msg = <span class="string">"Unable to launch app "</span></span><br><span class="line">                    + r.appInfo.packageName + <span class="string">"/"</span></span><br><span class="line">                    + r.appInfo.uid + <span class="string">" for service "</span></span><br><span class="line">                    + r.intent.getIntent() + <span class="string">": process is bad"</span>;</span><br><span class="line">            Slog.w(TAG, msg);</span><br><span class="line"></span><br><span class="line">            bringDownServiceLocked(r); <span class="comment">// 进程启动失败；</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> msg;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果服务要运行在隔离进程中，就把创建的 ProcessRecord 保存到 r.isolatedProc 中！</span></span><br><span class="line">        <span class="keyword">if</span> (isolated) &#123;</span><br><span class="line">            r.isolatedProc = app;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【7】将这个服务加入到 mPendingServices 中，表示该服务正在其所在的进程启动；</span></span><br><span class="line">    <span class="keyword">if</span> (!mPendingServices.contains(r)) &#123;</span><br><span class="line">        mPendingServices.add(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.delayedStop) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Oh and hey we've already been asked to stop!</span></span><br><span class="line">        r.delayedStop = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (r.startRequested) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE,</span><br><span class="line">                    <span class="string">"Applying delayed stop (in bring up): "</span> + r);</span><br><span class="line">            stopServiceLocked(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来总结一下，这个方法的流程：</p>
<blockquote>
<p>第一阶段： </p>
</blockquote>
<ul>
<li>如果服务所在的进程已经启动，就调用 <code>sendServiceArgsLocked</code>，通过 <code>ApplicationThread</code> 拉起 <code>onStartCommand</code> 的方法，<strong>结束流程</strong>；</li>
<li>如果服务所在的进程没有被启动，进入下面的流程：</li>
</ul>
<blockquote>
<p>第二阶段： </p>
</blockquote>
<ul>
<li>如果服务正在等待重启，不处理，<strong>结束流程</strong>；</li>
<li>否则，进入下面的流程：</li>
</ul>
<blockquote>
<p>第三阶段： </p>
</blockquote>
<ul>
<li>当前服务要被启动了，就从等待重启 <code>mRestartingServices</code> 中移除它；</li>
<li>如果这个服务是被延迟启动（<code>delayed</code> 的值为 <code>true</code>）的，就从 <code>mDelayedStartList</code> 中移除它，并置其 <code>delayed</code> 为 <code>false</code>；</li>
<li>当前服务将要被启动，所以要设置其 <code>package</code> 的停止状态为 <code>false</code>；</li>
<li>判断这个进程是否是隔离进程：<ul>
<li>如果是非隔离进程，根据进程名和 <code>uid</code>，获得其所在进程的 <code>ProcessRecord</code> 对象，如果进程已经启动，就启动指定服务，<strong>结束流程</strong>；</li>
<li>如果是隔离进程，获得服务之前所在的隔离进程的 <code>ProcessRecord</code> 对象；</li>
</ul>
</li>
</ul>
<blockquote>
<p>第四阶段： </p>
</blockquote>
<ul>
<li>根据获得的 <code>ProcessRecord</code> 对象，判断，如果之前服务所在进程没有启动，就需要先启动进程；</li>
<li>将服务添加到 <code>mPendingServices</code> 中，表示正在启动该服务；</li>
</ul>
<p>之前我们有说，我们假设要启动的服务所在的进程没有被启动，那么就要先启动目标进程，具体的启动过程，大家可以去看我的其他几篇博客：<br><strong>Android 进程的创建和启动</strong></p>
<p>这里我们直接用之前的结果，进入 <code>AMS.attachApplicationLocked</code> 方法！</p>
<h2 id="2-5-ActivityManagerS-attachApplicationLocked"><a href="#2-5-ActivityManagerS-attachApplicationLocked" class="headerlink" title="2.5 ActivityManagerS.attachApplicationLocked"></a>2.5 ActivityManagerS.attachApplicationLocked</h2><p>当应用进程启动后，会通过 Binder 通信，调用 AMS.attachApplicationLocked，我们去看看：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">attachApplicationLocked</span><span class="params">(IApplicationThread thread,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> pid)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ... ... ... ...</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这里会回到应用进程中，创建 Applicaiton 对象，并调用其 onCreate 方法，这里我们先不说！</span></span><br><span class="line">        thread.bindApplication(processName, appInfo, providers, app.instrumentationClass,</span><br><span class="line">                profilerInfo, app.instrumentationArguments, app.instrumentationWatcher,</span><br><span class="line">                app.instrumentationUiAutomationConnection, testMode,</span><br><span class="line">                mBinderTransactionTrackingEnabled, enableTrackAllocation,</span><br><span class="line">                isRestrictedBackupMode || !normalMode, app.persistent,</span><br><span class="line">                <span class="keyword">new</span> Configuration(mConfiguration), app.compat,</span><br><span class="line">                getCommonServicesLocked(app.isolated),</span><br><span class="line">                mCoreSettingsObserver.getCoreSettingsLocked());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新进程 LRU 队列！</span></span><br><span class="line">        updateLruProcessLocked(app, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        app.lastRequestedGc = app.lastLowMemory = SystemClock.uptimeMillis();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        app.resetPackageList(mProcessStats);</span><br><span class="line">        app.unlinkDeathRecipient();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每当 bind 操作失败，则重新启动进程, 此处有可能会导致进程无限重启。</span></span><br><span class="line">        startProcessLocked(app, <span class="string">"bind fail"</span>, processName);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前已经被启动的新进程的 ProcessRecord 从正在启动的进程集合 mPersistentStartingProcesses</span></span><br><span class="line">    <span class="comment">// 和等待启动的进程集合 mProcessesOnHold 中移除！</span></span><br><span class="line">    mPersistentStartingProcesses.remove(app);</span><br><span class="line">    mProcessesOnHold.remove(app);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> badApp = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> didSomething = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    ... ... ... ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!badApp) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 检查是否有 sevvce 组件要在这个新进程中运行！</span></span><br><span class="line">            didSomething |= mServices.attachApplicationLocked(app, processName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Slog.wtf(TAG, <span class="string">"Exception thrown starting services in "</span> + app, e);</span><br><span class="line">            badApp = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ... ... ... ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (badApp) &#123; <span class="comment">// badApp 为 true，就杀掉这个进程</span></span><br><span class="line">        app.kill(<span class="string">"error during init"</span>, <span class="keyword">true</span>);</span><br><span class="line">        handleAppDiedLocked(app, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!didSomething) &#123; <span class="comment">// 检查后发现，没有任何组件要运行在新进程，更新 OomAdj 的值！</span></span><br><span class="line">        updateOomAdjLocked();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>bindApplication</code> 方法会回到应用进程中，创建 <code>Applicaiton</code> 对象，并调用其 <code>onCreate</code> 方法，这里我们不看！</p>
<p>这里会调用 <code>ActiveServices</code> 的 <code>attachApplicationLocked</code> 方法！</p>
<h2 id="2-6-ActiveServices-attachApplicationLocked"><a href="#2-6-ActiveServices-attachApplicationLocked" class="headerlink" title="2.6 ActiveServices.attachApplicationLocked"></a>2.6 ActiveServices.attachApplicationLocked</h2><p>当应用进程启动成功，并且 Application 对象已经创建，其 onCreate 方法已经调用后，就要启动指定的服务了！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">attachApplicationLocked</span><span class="params">(ProcessRecord proc, String processName)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> didSomething = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【1】启动该进程中所有的服务！</span></span><br><span class="line">    <span class="keyword">if</span> (mPendingServices.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        ServiceRecord sr = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历 mPendingServices 集合中的所有服务，启动属于这个进程的所有服务！</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;mPendingServices.size(); i++) &#123;</span><br><span class="line">                sr = mPendingServices.get(i);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (proc != sr.isolatedProc &amp;&amp; (proc.uid != sr.appInfo.uid</span><br><span class="line">                        || !processName.equals(sr.processName))) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                mPendingServices.remove(i);</span><br><span class="line"></span><br><span class="line">                i--;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 将服务的包名，版本号以及 AMS 的进程状态对象保存到进程对象中！</span></span><br><span class="line">                proc.addPackage(sr.appInfo.packageName, sr.appInfo.versionCode,</span><br><span class="line">                        mAm.mProcessStats);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//【1】启动服务，这里又回到了之前的方法中！</span></span><br><span class="line">                realStartServiceLocked(sr, proc, sr.createdFromFg);</span><br><span class="line"></span><br><span class="line">                didSomething = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!isServiceNeeded(sr, <span class="keyword">false</span>, <span class="keyword">false</span>)) &#123; <span class="comment">// 如果已经不需要启动了，就取消启动！</span></span><br><span class="line"></span><br><span class="line">                    bringDownServiceLocked(sr);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Exception in new application when starting service "</span></span><br><span class="line">                    + sr.shortName, e);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】接着启动那些需要重启的服务，重启的服务都会保存到 mRestartingServices 服务中！</span></span><br><span class="line">    <span class="comment">// 因为重启的时间可能还没有到，所以这里并不是立刻启动它们，而是启动了一个任务，交给了 AMS 的 MainHandler 去做！</span></span><br><span class="line">    <span class="keyword">if</span> (mRestartingServices.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ServiceRecord sr;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;mRestartingServices.size(); i++) &#123;</span><br><span class="line"></span><br><span class="line">            sr = mRestartingServices.get(i);</span><br><span class="line">            <span class="keyword">if</span> (proc != sr.isolatedProc &amp;&amp; (proc.uid != sr.appInfo.uid</span><br><span class="line">                    || !processName.equals(sr.processName))) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// sr.restarter 是一个 ServiceRestarter 对象，是一个 Runnable，这里会执行重启！</span></span><br><span class="line">            mAm.mHandler.removeCallbacks(sr.restarter);</span><br><span class="line">            mAm.mHandler.post(sr.restarter);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> didSomething;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里有一个方法 <code>isServiceNeeded</code> 是否需要启动服务：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isServiceNeeded</span><span class="params">(ServiceRecord r, <span class="keyword">boolean</span> knowConn, <span class="keyword">boolean</span> hasConn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r.startRequested) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!knowConn) &#123;</span><br><span class="line">        hasConn = r.hasAutoCreateConnections();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hasConn) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>判断依据很简单:</p>
<ul>
<li><code>r.startRequested</code> 为 <code>true</code>，说明服务被请求启动，那么就需要；</li>
<li><code>r.hasAutoCreateConnections</code> 为 <code>true</code>；说明有应用已经和该服务建立了自动创建的连接，那么就需要；</li>
</ul>
<p>我们发现无论进程是否已经被创建，最终都会调用 <code>realStartServiceLocked</code> 方法！</p>
<h2 id="2-7-AS-realStartServiceLocked"><a href="#2-7-AS-realStartServiceLocked" class="headerlink" title="2.7 AS.realStartServiceLocked"></a>2.7 AS.realStartServiceLocked</h2><p>通过调用 realStartServiceLocked 方法来启动进程中的指定服务：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">realStartServiceLocked</span><span class="params">(ServiceRecord r,</span></span></span><br><span class="line"><span class="function"><span class="params">        ProcessRecord app, <span class="keyword">boolean</span> execInFg)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (app.thread == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RemoteException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG_MU)</span><br><span class="line">        Slog.v(TAG_MU, <span class="string">"realStartServiceLocked, ServiceRecord.uid = "</span> + r.appInfo.uid</span><br><span class="line">                + <span class="string">", ProcessRecord.uid = "</span> + app.uid);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置服务的进程对象；</span></span><br><span class="line">    r.app = app;</span><br><span class="line">    <span class="comment">// 设置服务的启动和活跃时间；</span></span><br><span class="line">    r.restartTime = r.lastActivity = SystemClock.uptimeMillis();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将被启动服务的 ServiceRecord 对象添加到所属进程的 app.services 中！</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> newService = app.services.add(r);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【1】针对 onCreate 方法，设置超时处理！</span></span><br><span class="line">    bumpServiceExecutingLocked(r, execInFg, <span class="string">"create"</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 更新 LruProcess 和 OomAdj！</span></span><br><span class="line">    mAm.updateLruProcessLocked(app, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">    mAm.updateOomAdjLocked();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> created = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (LOG_SERVICE_START_STOP) &#123; <span class="comment">// log 相关！</span></span><br><span class="line">            String nameTerm;</span><br><span class="line">            <span class="keyword">int</span> lastPeriod = r.shortName.lastIndexOf(<span class="string">'.'</span>);</span><br><span class="line">            nameTerm = lastPeriod &gt;= <span class="number">0</span> ? r.shortName.substring(lastPeriod) : r.shortName;</span><br><span class="line">            EventLogTags.writeAmCreateService(</span><br><span class="line">                    r.userId, System.identityHashCode(r), nameTerm, r.app.uid, r.app.pid);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (r.stats.getBatteryStats()) &#123;</span><br><span class="line">            r.stats.startLaunchedLocked();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mAm.notifyPackageUse(r.serviceInfo.packageName,</span><br><span class="line">                             PackageManager.NOTIFY_PACKAGE_USE_SERVICE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将进程的状态更新为 ActivityManager.PROCESS_STATE_SERVICE！</span></span><br><span class="line">        app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【2】通过 binder 通信，拉起服务的 onCreate 方法！</span></span><br><span class="line">        app.thread.scheduleCreateService(r, r.serviceInfo,</span><br><span class="line">                mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),</span><br><span class="line">                app.repProcState);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果服务通过 setForeground 方法设置了通知，就显示通知！</span></span><br><span class="line">        r.postNotification();</span><br><span class="line"></span><br><span class="line">        created = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (DeadObjectException e) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"Application dead when creating service "</span> + r);</span><br><span class="line">        mAm.appDiedLocked(app); <span class="comment">// 如果在服务启动时，应用进程死了，调用 appDiedLocked 通知死亡仆告对象！</span></span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!created) &#123; <span class="comment">// 如果启动失败，并且不死一个被销毁的服务，那就尝试重启他！</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> inDestroying = mDestroyingServices.contains(r);</span><br><span class="line">            serviceDoneExecutingLocked(r, inDestroying, inDestroying);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (newService) &#123;</span><br><span class="line">                app.services.remove(r);</span><br><span class="line">                r.app = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!inDestroying) &#123;</span><br><span class="line">                scheduleServiceRestartLocked(r, <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.whitelistManager) &#123;</span><br><span class="line">        app.whitelistManager = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 拉起 onBind 相关的方法，但是这里是不会触发的，因为 r.bindings 集合只有在 bindService 才会有元素！</span></span><br><span class="line">    <span class="comment">// 但是，如果之前 bindService 的标志位设置的不是 Context.BIND_AUTO_CREATE，而是其他参数，那么其 r.bindings</span></span><br><span class="line">    <span class="comment">// 是有元素的，这里才会调用服务的 onBind 方法，为之前的 bindService 返回代理对象！</span></span><br><span class="line">    requestServiceBindingsLocked(r, execInFg);</span><br><span class="line"></span><br><span class="line">    updateServiceClientActivitiesLocked(app, <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果服务被请求启动，但是其内部的启动项为 0，那就创建一个启动项，保证 Service 的 onStartCommand 可以被调用；</span></span><br><span class="line">    <span class="keyword">if</span> (r.startRequested &amp;&amp; r.callStart &amp;&amp; r.pendingStarts.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        r.pendingStarts.add(<span class="keyword">new</span> ServiceRecord.StartItem(r, <span class="keyword">false</span>, r.makeNextStartId(),</span><br><span class="line">                <span class="keyword">null</span>, <span class="keyword">null</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【2】通过 binder 通信，拉起服务的 onStartCommand 方法！</span></span><br><span class="line">    sendServiceArgsLocked(r, execInFg, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是延迟启动的话，在这里将其移除！</span></span><br><span class="line">    <span class="keyword">if</span> (r.delayed) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE, <span class="string">"REM FR DELAY LIST (new proc): "</span> + r);</span><br><span class="line">        getServiceMap(r.userId).mDelayedStartList.remove(r);</span><br><span class="line">        r.delayed = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.delayedStop) &#123;</span><br><span class="line">        <span class="comment">// Oh and hey we've already been asked to stop!</span></span><br><span class="line">        r.delayedStop = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (r.startRequested) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE,</span><br><span class="line">                    <span class="string">"Applying delayed stop (from start): "</span> + r);</span><br><span class="line">            stopServiceLocked(r);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>这里要注意</strong>：</p>
<p>方法 <code>requestServiceBindingsLocked</code>，一般是不会触发的，因为 <code>r.bindings</code> 集合只有在 <code>bindService</code> 的情况才会被添加元素！但是，如果之前 <code>bindService</code> 的标志位没有设置 <code>Context.BIND_AUTO_CREATE</code>，而是其他标志位，那么其 <code>r.bindings</code> 是有元素的，这里就会调用服务的 <code>onBind</code> 方法，为之前的 <code>bindService</code> 返回代理对象！</p>
<h3 id="2-7-1-AS-bumpServiceExecutingLocked"><a href="#2-7-1-AS-bumpServiceExecutingLocked" class="headerlink" title="2.7.1 AS.bumpServiceExecutingLocked"></a>2.7.1 AS.bumpServiceExecutingLocked</h3><p>针对 <code>onCreate</code> 方法，设置超时处理，参数 <code>fg</code> 表示这个服务是前台执行，还是后台执行的！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">bumpServiceExecutingLocked</span><span class="params">(ServiceRecord r, <span class="keyword">boolean</span> fg, String why)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">"&gt;&gt;&gt; EXECUTING "</span></span><br><span class="line">            + why + <span class="string">" of "</span> + r + <span class="string">" in app "</span> + r.app);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (DEBUG_SERVICE_EXECUTING) Slog.v(TAG_SERVICE_EXECUTING, <span class="string">"&gt;&gt;&gt; EXECUTING "</span></span><br><span class="line">            + why + <span class="string">" of "</span> + r.shortName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.executeNesting == <span class="number">0</span>) &#123; <span class="comment">// executeNesting 用来记录是否有超时处理操作！</span></span><br><span class="line"></span><br><span class="line">        r.executeFg = fg;</span><br><span class="line">        ServiceState stracker = r.getTracker();</span><br><span class="line">        <span class="keyword">if</span> (stracker != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对该服务进行内存监控处理！</span></span><br><span class="line">            stracker.setExecuting(<span class="keyword">true</span>, mAm.mProcessStats.getMemFactorLocked(), now);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (r.app != <span class="keyword">null</span>) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将服务添加到 ProcessRecord 的 executingServices 集合中，表示服务正在执行某段代码！</span></span><br><span class="line">            r.app.executingServices.add(r);</span><br><span class="line">            r.app.execServicesFg |= fg;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果正在执行指定函数的服务个数为 1，设置超时处理！</span></span><br><span class="line">            <span class="keyword">if</span> (r.app.executingServices.size() == <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">                scheduleServiceTimeoutLocked(r.app);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.app != <span class="keyword">null</span> &amp;&amp; fg &amp;&amp; !r.app.execServicesFg) &#123;</span><br><span class="line"></span><br><span class="line">        r.app.execServicesFg = <span class="keyword">true</span>;</span><br><span class="line">        scheduleServiceTimeoutLocked(r.app);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r.executeFg |= fg;</span><br><span class="line">    r.executeNesting++;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录启动时间！</span></span><br><span class="line">    r.executingStart = now;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们来看看超市处理的操作！</p>
<h4 id="2-7-1-1-AS-scheduleServiceTimeoutLocked"><a href="#2-7-1-1-AS-scheduleServiceTimeoutLocked" class="headerlink" title="2.7.1.1 AS.scheduleServiceTimeoutLocked"></a>2.7.1.1 AS.scheduleServiceTimeoutLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleServiceTimeoutLocked</span><span class="params">(ProcessRecord proc)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果进程没有正在执行某段代码的服务就返回！</span></span><br><span class="line">    <span class="keyword">if</span> (proc.executingServices.size() == <span class="number">0</span> || proc.thread == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">    Message msg = mAm.mHandler.obtainMessage(</span><br><span class="line">            ActivityManagerService.SERVICE_TIMEOUT_MSG);</span><br><span class="line">    msg.obj = proc;</span><br><span class="line"></span><br><span class="line">    mAm.mHandler.sendMessageAtTime(msg,</span><br><span class="line">            proc.execServicesFg ? (now+SERVICE_TIMEOUT) : (now+ SERVICE_BACKGROUND_TIMEOUT));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到：</p>
<ul>
<li>对于前台服务：超时时间是 20s</li>
<li>对于后台服务：超市时间是 200s</li>
</ul>
<p>最后发送 SERVICE_TIMEOUT_MSG 消息到 AMS 的 MainHandler 中！</p>
<h4 id="2-7-1-2-ActivityServiceS-MainHandler"><a href="#2-7-1-2-ActivityServiceS-MainHandler" class="headerlink" title="2.7.1.2 ActivityServiceS.MainHandler"></a>2.7.1.2 ActivityServiceS.MainHandler</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MainHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line"></span><br><span class="line">        ... ... ... ...</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">case</span> SERVICE_TIMEOUT_MSG: &#123;</span><br><span class="line">            <span class="keyword">if</span> (mDidDexOpt) &#123; <span class="comment">// 表示是否延迟执行 odex</span></span><br><span class="line">                mDidDexOpt = <span class="keyword">false</span>;</span><br><span class="line">                Message nmsg = mHandler.obtainMessage(SERVICE_TIMEOUT_MSG);</span><br><span class="line">                nmsg.obj = msg.obj;</span><br><span class="line">                mHandler.sendMessageDelayed(nmsg, ActiveServices.SERVICE_TIMEOUT);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 调用 serviceTimeout，设置超时处理！</span></span><br><span class="line">            mServices.serviceTimeout((ProcessRecord)msg.obj);</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        ... ... ... ...</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着进入 ActiveServices 中！</p>
<h4 id="2-7-1-3-ActiveServices-serviceTimeout"><a href="#2-7-1-3-ActiveServices-serviceTimeout" class="headerlink" title="2.7.1.3 ActiveServices.serviceTimeout"></a>2.7.1.3 ActiveServices.serviceTimeout</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serviceTimeout</span><span class="params">(ProcessRecord proc)</span> </span>&#123;</span><br><span class="line">    String anrMessage = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span>(mAm) &#123;</span><br><span class="line">        <span class="keyword">if</span> (proc.executingServices.size() == <span class="number">0</span> || proc.thread == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> maxTime =  now -</span><br><span class="line">                (proc.execServicesFg ? SERVICE_TIMEOUT : SERVICE_BACKGROUND_TIMEOUT);</span><br><span class="line"></span><br><span class="line">        ServiceRecord timeout = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">long</span> nextTime = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从正在执行代码逻辑的服务列表中，获得判断是否超时的服务！</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=proc.executingServices.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            ServiceRecord sr = proc.executingServices.valueAt(i);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (sr.executingStart &lt; maxTime) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 服务启动已经超时，timeout 不为 null；</span></span><br><span class="line">                timeout = sr;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sr.executingStart &gt; nextTime) &#123;</span><br><span class="line">                nextTime = sr.executingStart;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (timeout != <span class="keyword">null</span> &amp;&amp; mAm.mLruProcesses.contains(proc)) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Timeout executing service: "</span> + timeout);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 启动服务超时了，进入这个分支!</span></span><br><span class="line">            StringWriter sw = <span class="keyword">new</span> StringWriter();</span><br><span class="line">            PrintWriter pw = <span class="keyword">new</span> FastPrintWriter(sw, <span class="keyword">false</span>, <span class="number">1024</span>);</span><br><span class="line">            pw.println(timeout);</span><br><span class="line">            timeout.dump(pw, <span class="string">"    "</span>);</span><br><span class="line">            pw.close();</span><br><span class="line">            mLastAnrDump = sw.toString();</span><br><span class="line">            mAm.mHandler.removeCallbacks(mLastAnrDumpClearer);</span><br><span class="line">            mAm.mHandler.postDelayed(mLastAnrDumpClearer, LAST_ANR_LIFETIME_DURATION_MSECS);</span><br><span class="line">            anrMessage = <span class="string">"executing service "</span> + timeout.shortName;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">// 继续发送超时消息，进行下一轮超时判断！</span></span><br><span class="line">            Message msg = mAm.mHandler.obtainMessage(</span><br><span class="line">                    ActivityManagerService.SERVICE_TIMEOUT_MSG);</span><br><span class="line"></span><br><span class="line">            msg.obj = proc;</span><br><span class="line">            mAm.mHandler.sendMessageAtTime(msg, proc.execServicesFg</span><br><span class="line">                    ? (nextTime+SERVICE_TIMEOUT) : (nextTime + SERVICE_BACKGROUND_TIMEOUT));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (anrMessage != <span class="keyword">null</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 捕捉到 ANR！</span></span><br><span class="line">        mAm.mAppErrors.appNotResponding(proc, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>, anrMessage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，判断启动服务是否超时：不断的给 AMS 的 MainHandler 发送  SERVICE_TIMEOUT_MSG 消息，不断的判断时间是否超时！</p>
<p>如果超时的话，会触发 AppErrors.appNotResponding 方法，这个我们以后再看！</p>
<h3 id="2-7-2-ApplicationThreadP-scheduleCreateService"><a href="#2-7-2-ApplicationThreadP-scheduleCreateService" class="headerlink" title="2.7.2 ApplicationThreadP.scheduleCreateService"></a>2.7.2 ApplicationThreadP.scheduleCreateService</h3><p>拉起其 onCreate 方法，参数说明：</p>
<ul>
<li>IBinder token：服务的 ServiceRecord 对象，实现了 IBinder 接口！</li>
<li>erviceInfo info：服务的组件信息；</li>
<li>CompatibilityInfo compatInfo：</li>
<li>int processState：服务所在进程的状态；<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApplicationThreadProxy</span> <span class="keyword">implements</span> <span class="title">IApplicationThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleCreateService</span><span class="params">(IBinder token, ServiceInfo info,</span></span></span><br><span class="line"><span class="function"><span class="params">            CompatibilityInfo compatInfo, <span class="keyword">int</span> processState)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Parcel data = Parcel.obtain();</span><br><span class="line">        data.writeInterfaceToken(IApplicationThread.descriptor);</span><br><span class="line">        data.writeStrongBinder(token);</span><br><span class="line">        info.writeToParcel(data, <span class="number">0</span>);</span><br><span class="line">        compatInfo.writeToParcel(data, <span class="number">0</span>);</span><br><span class="line">        data.writeInt(processState);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">// 通过 binder 通信！</span></span><br><span class="line">            mRemote.transact(SCHEDULE_CREATE_SERVICE_TRANSACTION, data, <span class="keyword">null</span>,</span><br><span class="line">                    IBinder.FLAG_ONEWAY);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (TransactionTooLargeException e) &#123;</span><br><span class="line">            Log.e(<span class="string">"CREATE_SERVICE"</span>, <span class="string">"Binder failure starting service; service="</span> + info);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        data.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>binder 通信，进入应用进程！</p>
<h3 id="2-7-3-AS-sendServiceArgsLocked"><a href="#2-7-3-AS-sendServiceArgsLocked" class="headerlink" title="2.7.3 AS.sendServiceArgsLocked"></a>2.7.3 AS.sendServiceArgsLocked</h3><p>拉起其 onStartCommand 方法：</p>
<p>参数传递：</p>
<ul>
<li>ServiceRecord r：被启动的服务的数据对象，它实现了 Binder 接口，可以跨进程传递；</li>
<li>boolean execInFg：callFg，表示本次启动是前台调用还是后台调用；</li>
<li>oomAdjusted：传入 false；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">sendServiceArgsLocked</span><span class="params">(ServiceRecord r, <span class="keyword">boolean</span> execInFg,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> oomAdjusted)</span> <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 还记得 pendingStarts 吗，在前面启动的时候，</span></span><br><span class="line">    <span class="comment">// 会将 intent 等等的数据封装成 StartItem，保存到 pendingStarts 中；</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> N = r.pendingStarts.size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (N == <span class="number">0</span>) &#123; <span class="comment">// 如果 N 为 null，说明没有启动操作；</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (r.pendingStarts.size() &gt; <span class="number">0</span>) &#123; <span class="comment">// 遍历要启动服务 ServiceRecord 的 pendingStarts！</span></span><br><span class="line">        Exception caughtException = <span class="keyword">null</span>;</span><br><span class="line">        ServiceRecord.StartItem si = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 将要处理的启动项从 pendingStarts 中移除！</span></span><br><span class="line">            si = r.pendingStarts.remove(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">"Sending arguments to: "</span></span><br><span class="line">                    + r + <span class="string">" "</span> + r.intent + <span class="string">" args="</span> + si.intent);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (si.intent == <span class="keyword">null</span> &amp;&amp; N &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果有启动项的 intent 为 null，且启动项目总数大于 1，那就会忽视掉这个 intent！</span></span><br><span class="line">                 <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将要处理的启动项添加到 deliveredStarts 中，表示启动项已经分发处理！</span></span><br><span class="line">            si.deliveredTime = SystemClock.uptimeMillis();</span><br><span class="line">            r.deliveredStarts.add(si);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 增加启动项目的 deliveryCount 计数，表示这个启动项的处理次数！</span></span><br><span class="line">            si.deliveryCount++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (si.neededGrants != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mAm.grantUriPermissionUncheckedFromIntentLocked(si.neededGrants,</span><br><span class="line">                        si.getUriPermissionsLocked());</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 为 onStartCommand 方法设置超时任务！</span></span><br><span class="line">            bumpServiceExecutingLocked(r, execInFg, <span class="string">"start"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!oomAdjusted) &#123; <span class="comment">// 更新服务所在进程的 abj 值；</span></span><br><span class="line">                oomAdjusted = <span class="keyword">true</span>;</span><br><span class="line">                mAm.updateOomAdjLocked(r.app);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> flags = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (si.deliveryCount &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                flags |= Service.START_FLAG_RETRY;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (si.doneExecutingCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                flags |= Service.START_FLAG_REDELIVERY;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// thread 是 ApplicationThreadProxy 对象；</span></span><br><span class="line">            r.app.thread.scheduleServiceArgs(r, si.taskRemoved, si.id, flags, si.intent);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (TransactionTooLargeException e) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">"Transaction too large: intent="</span></span><br><span class="line">                    + si.intent);</span><br><span class="line">            caughtException = e;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Remote process gone...  we'll let the normal cleanup take care of this.</span></span><br><span class="line">            <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">"Crashed while sending args: "</span> + r);</span><br><span class="line">            caughtException = e;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Unexpected exception"</span>, e);</span><br><span class="line">            caughtException = e;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (caughtException != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Keep nesting count correct</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> inDestroying = mDestroyingServices.contains(r);</span><br><span class="line">            serviceDoneExecutingLocked(r, inDestroying, inDestroying);</span><br><span class="line">            <span class="keyword">if</span> (caughtException <span class="keyword">instanceof</span> TransactionTooLargeException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (TransactionTooLargeException)caughtException;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，如果服务所在的进程已经被启动了，那就直接调用 <code>sendServiceArgsLocked</code> 方法，通过服务所属进程在系统进程中的 <code>Binder</code> 对象 <code>ApplicationThreadProxy</code>，通过 <code>Binder</code> 间通信，调用应用进程的 <code>ApplicationThread</code> 的 <code>scheduleServiceArgs</code> 对象，拉起指定服务的 <code>onStartCommand</code> 方法；</p>
<h4 id="2-7-3-1-ApplicationThreadP-scheduleServiceArgs"><a href="#2-7-3-1-ApplicationThreadP-scheduleServiceArgs" class="headerlink" title="2.7.3.1 ApplicationThreadP.scheduleServiceArgs"></a>2.7.3.1 ApplicationThreadP.scheduleServiceArgs</h4><p>拉起 onStartCommand 方法，参数说明：</p>
<ul>
<li><code>IBinder token</code>：服务的 <code>ServiceRecord</code> 对象，实现了 <code>IBinder</code> 接口！</li>
<li><code>boolean taskRemoved</code>：启动项的 <code>taskRemoved</code>；</li>
<li><code>int startId</code>：启动项的 <code>id</code>，用来表示本次启动的 <code>id</code> 值！</li>
<li><code>int flags</code>：</li>
<li><code>Intent args</code>：启动项用的 <code>intent</code>，用来启动 <code>Service</code>！</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApplicationThreadProxy</span> <span class="keyword">implements</span> <span class="title">IApplicationThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleServiceArgs</span><span class="params">(IBinder token, <span class="keyword">boolean</span> taskRemoved, <span class="keyword">int</span> startId,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> flags, Intent args)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Parcel data = Parcel.obtain();</span><br><span class="line">        data.writeInterfaceToken(IApplicationThread.descriptor);</span><br><span class="line">        data.writeStrongBinder(token);</span><br><span class="line">        data.writeInt(taskRemoved ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        data.writeInt(startId);</span><br><span class="line">        data.writeInt(flags);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">            data.writeInt(<span class="number">1</span>);</span><br><span class="line">            args.writeToParcel(data, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            data.writeInt(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// binder 通信，进入到应用进程</span></span><br><span class="line">        mRemote.transact(SCHEDULE_SERVICE_ARGS_TRANSACTION, data, <span class="keyword">null</span>,</span><br><span class="line">                IBinder.FLAG_ONEWAY);</span><br><span class="line"></span><br><span class="line">        data.recycle();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>binder 通信，进入应用进程！</p>
<h1 id="3-被启动者进程"><a href="#3-被启动者进程" class="headerlink" title="3 被启动者进程"></a>3 被启动者进程</h1><p>在之前的进程启动分析中，当进程被拉起后，应用进程会创建进程的 <code>ActivityThread</code> 对象，用于托管进程的主线程，组件信息，<code>ApplicationThread</code> 对象等等的信息！</p>
<p>首先会进入 <code>ApplicationThreadNative.onTransact</code> 方法！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** &#123;<span class="doctag">@hide</span>&#125; */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationThreadNative</span> <span class="keyword">extends</span> <span class="title">Binder</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">IApplicationThread</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">// 拉起 onCreate 方法！</span></span><br><span class="line">            <span class="keyword">case</span> SCHEDULE_CREATE_SERVICE_TRANSACTION: &#123;</span><br><span class="line">                data.enforceInterface(IApplicationThread.descriptor);</span><br><span class="line"></span><br><span class="line">                IBinder token = data.readStrongBinder();</span><br><span class="line">                ServiceInfo info = ServiceInfo.CREATOR.createFromParcel(data);</span><br><span class="line">                CompatibilityInfo compatInfo = CompatibilityInfo.CREATOR.createFromParcel(data);</span><br><span class="line">                <span class="keyword">int</span> processState = data.readInt();</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 继续来看！</span></span><br><span class="line">                scheduleCreateService(token, info, compatInfo, processState);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">// 拉起 onStartCommand 方法！</span></span><br><span class="line">            <span class="keyword">case</span> SCHEDULE_SERVICE_ARGS_TRANSACTION:</span><br><span class="line">            &#123;</span><br><span class="line">                data.enforceInterface(IApplicationThread.descriptor);</span><br><span class="line"></span><br><span class="line">                IBinder token = data.readStrongBinder();</span><br><span class="line">                <span class="keyword">boolean</span> taskRemoved = data.readInt() != <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> startId = data.readInt();</span><br><span class="line">                <span class="keyword">int</span> fl = data.readInt();</span><br><span class="line">                Intent args;</span><br><span class="line">                <span class="keyword">if</span> (data.readInt() != <span class="number">0</span>) &#123;</span><br><span class="line">                    args = Intent.CREATOR.createFromParcel(data);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    args = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 继续来看！</span></span><br><span class="line">                scheduleServiceArgs(token, taskRemoved, startId, fl, args);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来，进入 binder 通信服务端 ApplicationThread！</p>
<h2 id="3-1-ApplicationThread-scheduleCreateService"><a href="#3-1-ApplicationThread-scheduleCreateService" class="headerlink" title="3.1 ApplicationThread.scheduleCreateService"></a>3.1 ApplicationThread.scheduleCreateService</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationThread</span> <span class="keyword">extends</span> <span class="title">ApplicationThreadNative</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleCreateService</span><span class="params">(IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">                ServiceInfo info, CompatibilityInfo compatInfo, <span class="keyword">int</span> processState)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            updateProcessState(processState, <span class="keyword">false</span>);</span><br><span class="line">            CreateServiceData s = <span class="keyword">new</span> CreateServiceData();</span><br><span class="line">            s.token = token;</span><br><span class="line">            s.info = info;</span><br><span class="line">            s.compatInfo = compatInfo;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 发送 H.CREATE_SERVICE 到主线程的 Handler!</span></span><br><span class="line">            sendMessage(H.CREATE_SERVICE, s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，最后会调用 sendMessage 方法，将消息  H.CREATE_SERVICE 发送给进程的主线程！</p>
<h2 id="3-2-ApplicationThread-scheduleServiceArgs"><a href="#3-2-ApplicationThread-scheduleServiceArgs" class="headerlink" title="3.2 ApplicationThread.scheduleServiceArgs"></a>3.2 ApplicationThread.scheduleServiceArgs</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationThread</span> <span class="keyword">extends</span> <span class="title">ApplicationThreadNative</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleServiceArgs</span><span class="params">(IBinder token, <span class="keyword">boolean</span> taskRemoved, <span class="keyword">int</span> startId,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> flags ,Intent args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            ServiceArgsData s = <span class="keyword">new</span> ServiceArgsData();</span><br><span class="line">            s.token = token;</span><br><span class="line">            s.taskRemoved = taskRemoved;</span><br><span class="line">            s.startId = startId;</span><br><span class="line">            s.flags = flags;</span><br><span class="line">            s.args = args;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发送 H.SERVICE_ARGS 到主线程的 Handler!</span></span><br><span class="line">            sendMessage(H.SERVICE_ARGS, s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，最后会调用 sendMessage 方法，将消息  H.SERVICE_ARGS 发送给进程的主线程！</p>
<h2 id="3-3-ApplicationThread-H"><a href="#3-3-ApplicationThread-H" class="headerlink" title="3.3 ApplicationThread.H"></a>3.3 ApplicationThread.H</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">H</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">case</span> CREATE_SERVICE:</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER,</span><br><span class="line">                                        (<span class="string">"serviceCreate: "</span> + String.valueOf(msg.obj)));</span><br><span class="line">            handleCreateService((CreateServiceData)msg.obj);</span><br><span class="line">              </span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">              </span><br><span class="line">        <span class="keyword">case</span> SERVICE_ARGS:</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, </span><br><span class="line">                                        (<span class="string">"serviceStart: "</span> + String.valueOf(msg.obj)));</span><br><span class="line">            handleServiceArgs((ServiceArgsData)msg.obj);</span><br><span class="line">            </span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">            <span class="keyword">break</span>;              </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里省略了其他消息的处理！</p>
<p>最后分别调用：handleCreateService 和 handleServiceArgs 拉起指定的方法！</p>
<h3 id="3-3-1-ApplicationThread-handleCreateService"><a href="#3-3-1-ApplicationThread-handleCreateService" class="headerlink" title="3.3.1 ApplicationThread.handleCreateService"></a>3.3.1 ApplicationThread.handleCreateService</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleCreateService</span><span class="params">(CreateServiceData data)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果此时准备要 GC，那就跳过本次 GC！</span></span><br><span class="line">    unscheduleGcIdler();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获得应用程序的加载信息，先会从缓存中获取，找不到才创建！</span></span><br><span class="line">    LoadedApk packageInfo = getPackageInfoNoCheck(</span><br><span class="line">            data.info.applicationInfo, data.compatInfo);</span><br><span class="line"></span><br><span class="line">    Service service = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 通过反射创建要启动的服务的实例！</span></span><br><span class="line">        java.lang.ClassLoader cl = packageInfo.getClassLoader();</span><br><span class="line">        service = (Service) cl.loadClass(data.info.name).newInstance();</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mInstrumentation.onException(service, e)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Unable to instantiate service "</span> + data.info.name</span><br><span class="line">                + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (localLOGV) Slog.v(TAG, <span class="string">"Creating service "</span> + data.info.name);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建该 Serivce Context 对象！</span></span><br><span class="line">        ContextImpl context = ContextImpl.createAppContext(<span class="keyword">this</span>, packageInfo);</span><br><span class="line">        context.setOuterContext(service);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回该进程的 Application 对象！</span></span><br><span class="line">        Application app = packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将服务实例和 context，Application 进行绑定！</span></span><br><span class="line">        service.attach(context, <span class="keyword">this</span>, data.info.name, data.token, app,</span><br><span class="line">                ActivityManagerNative.getDefault());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用了服务的 onCreate 方法！</span></span><br><span class="line">        service.onCreate();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将创建的服务实例保存到 AT 的托管集合中！</span></span><br><span class="line">        mServices.put(data.token, service);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 通知 AMS，操作完成；</span></span><br><span class="line">            ActivityManagerNative.getDefault().serviceDoneExecuting(</span><br><span class="line">                    data.token, SERVICE_DONE_EXECUTING_ANON, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!mInstrumentation.onException(service, e)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Unable to create service "</span> + data.info.name</span><br><span class="line">                + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着，进入了 Service 的 onCreate 方法中：</p>
<h4 id="3-3-1-1-service-onCreate"><a href="#3-3-1-1-service-onCreate" class="headerlink" title="3.3.1.1 service.onCreate"></a>3.3.1.1 service.onCreate</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Service</span> <span class="keyword">extends</span> <span class="title">ContextWrapper</span> <span class="keyword">implements</span> <span class="title">ComponentCallbacks2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            Context context,</span></span></span><br><span class="line"><span class="function"><span class="params">            ActivityThread thread, String className, IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">            Application application, Object activityManager)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        attachBaseContext(context);</span><br><span class="line">        mThread = thread;           <span class="comment">// <span class="doctag">NOTE:</span>  unused - remove?</span></span><br><span class="line">        mClassName = className;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这个 mToken 在系统进程对应着的是服务的 ServiceRecord 对象</span></span><br><span class="line">        mToken = token;</span><br><span class="line">        mApplication = application;</span><br><span class="line">        mActivityManager = (IActivityManager)activityManager;</span><br><span class="line">        mStartCompatibility = getApplicationInfo().targetSdkVersion</span><br><span class="line">                &lt; Build.VERSION_CODES.ECLAIR;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 由于用户实现具体的调用内容！</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这个 mToken， 它在系统进程对应着的是服务的 ServiceRecord 对象，之前在系统进程通过 ApplicationThreadP 传递对象的时候，会将 ServiceRecord 通过 binder 通信传递过来！</p>
<h3 id="3-3-2-ApplicationThread-handleServiceArgs"><a href="#3-3-2-ApplicationThread-handleServiceArgs" class="headerlink" title="3.3.2 ApplicationThread.handleServiceArgs"></a>3.3.2 ApplicationThread.handleServiceArgs</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleServiceArgs</span><span class="params">(ServiceArgsData data)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得之前创建的服务对象！</span></span><br><span class="line">    Service s = mServices.get(data.token);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (data.args != <span class="keyword">null</span>) &#123;</span><br><span class="line">                data.args.setExtrasClassLoader(s.getClassLoader());</span><br><span class="line">                data.args.prepareToEnterProcess();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> res;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (!data.taskRemoved) &#123; <span class="comment">// 如果 data.taskRemoved 为 false，就拉起 onStartCommand 方法！</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 拉起服务的 onStartCommand 方法！</span></span><br><span class="line">                res = s.onStartCommand(data.args, data.flags, data.startId);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 否则，拉起 onTaskRemoved 方法！</span></span><br><span class="line">                s.onTaskRemoved(data.args);</span><br><span class="line">                res = Service.START_TASK_REMOVED_COMPLETE;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            QueuedWork.waitToFinish();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 通知 AMS，操作完成，并传递 onStartCommand 的返回结果；</span></span><br><span class="line">                ActivityManagerNative.getDefault().serviceDoneExecuting(</span><br><span class="line">                        data.token, SERVICE_DONE_EXECUTING_START, data.startId, res);</span><br><span class="line">                        </span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ensureJitEnabled();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!mInstrumentation.onException(s, e)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                        <span class="string">"Unable to start service "</span> + s</span><br><span class="line">                        + <span class="string">" with "</span> + data.args + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-2-1-service-onStartCommand"><a href="#3-3-2-1-service-onStartCommand" class="headerlink" title="3.3.2.1 service.onStartCommand"></a>3.3.2.1 service.onStartCommand</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@StartResult</span> <span class="function"><span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, @StartArgFlags <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">    onStart(intent, startId);</span><br><span class="line">    <span class="keyword">return</span> mStartCompatibility ? START_STICKY_COMPATIBILITY : START_STICKY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后进入了 Service 的 onStartCommand 方法！</p>
<h2 id="3-4-ActivityManagerP-serviceDoneExecuting"><a href="#3-4-ActivityManagerP-serviceDoneExecuting" class="headerlink" title="3.4 ActivityManagerP.serviceDoneExecuting"></a>3.4 ActivityManagerP.serviceDoneExecuting</h2><p>当服务的指定方法被拉起后，会通知 AMS，拉起操作执行成功，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通知 AMS，拉起 onCreate 操作完成；</span></span><br><span class="line">ActivityManagerNative.getDefault().serviceDoneExecuting(</span><br><span class="line">            data.token, SERVICE_DONE_EXECUTING_ANON, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            </span><br><span class="line"><span class="comment">// 通知 AMS，拉起 onStart 操作完成；</span></span><br><span class="line">ActivityManagerNative.getDefault().serviceDoneExecuting(</span><br><span class="line">            data.token, SERVICE_DONE_EXECUTING_START, data.startId, res);</span><br></pre></td></tr></table></figure></p>
<p>这里进入 ActivityManagerP：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serviceDoneExecuting</span><span class="params">(IBinder token, <span class="keyword">int</span> type, <span class="keyword">int</span> startId,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> res)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Parcel data = Parcel.obtain();</span><br><span class="line">    Parcel reply = Parcel.obtain();</span><br><span class="line">    data.writeInterfaceToken(IActivityManager.descriptor);</span><br><span class="line">    data.writeStrongBinder(token);</span><br><span class="line">    data.writeInt(type);</span><br><span class="line">    data.writeInt(startId);</span><br><span class="line">    data.writeInt(res);</span><br><span class="line">    mRemote.transact(SERVICE_DONE_EXECUTING_TRANSACTION, data, reply, IBinder.FLAG_ONEWAY);</span><br><span class="line">    reply.readException();</span><br><span class="line">    data.recycle();</span><br><span class="line">    reply.recycle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里再次进入系统进程，我们去看看发生了什么！！</p>
<h1 id="4-系统进程"><a href="#4-系统进程" class="headerlink" title="4 系统进程"></a>4 系统进程</h1><p>接下来，进入系统进程，处理反馈结果，首先要进入 ActivityManagerN.onTransact 方法！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> SERVICE_DONE_EXECUTING_TRANSACTION: &#123;</span><br><span class="line">    data.enforceInterface(IActivityManager.descriptor);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    IBinder token = data.readStrongBinder();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> type = data.readInt();</span><br><span class="line">    <span class="keyword">int</span> startId = data.readInt();</span><br><span class="line">    <span class="keyword">int</span> res = data.readInt();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 进入 AMS!</span></span><br><span class="line">    serviceDoneExecuting(token, type, startId, res);</span><br><span class="line">    reply.writeNoException();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="4-1-ActivityManagerS-serviceDoneExecuting"><a href="#4-1-ActivityManagerS-serviceDoneExecuting" class="headerlink" title="4.1 ActivityManagerS.serviceDoneExecuting"></a>4.1 ActivityManagerS.serviceDoneExecuting</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serviceDoneExecuting</span><span class="params">(IBinder token, <span class="keyword">int</span> type, <span class="keyword">int</span> startId, <span class="keyword">int</span> res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 如果 token 不是 ServiceRecord 的实例，就会抛出异常！</span></span><br><span class="line">        <span class="keyword">if</span> (!(token <span class="keyword">instanceof</span> ServiceRecord)) &#123;</span><br><span class="line">            Slog.e(TAG, <span class="string">"serviceDoneExecuting: Invalid service token="</span> + token);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid service token"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 进入 ActiveServices！</span></span><br><span class="line">        mServices.serviceDoneExecutingLocked((ServiceRecord)token, type, startId, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续看！</p>
<h2 id="4-2-ActiveServices-serviceDoneExecutingLocked"><a href="#4-2-ActiveServices-serviceDoneExecutingLocked" class="headerlink" title="4.2 ActiveServices.serviceDoneExecutingLocked"></a>4.2 ActiveServices.serviceDoneExecutingLocked</h2><ul>
<li>对于拉起 onCreate  方法，type 的值为 SERVICE_DONE_EXECUTING_ANON；</li>
<li>对于拉起 onStartCommand 方法，type 的值为 SERVICE_DONE_EXECUTING_START；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serviceDoneExecutingLocked</span><span class="params">(ServiceRecord r, <span class="keyword">int</span> type, <span class="keyword">int</span> startId, <span class="keyword">int</span> res)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断这个服务是否正在被销毁！</span></span><br><span class="line">    <span class="keyword">boolean</span> inDestroying = mDestroyingServices.contains(r);</span><br><span class="line">    <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 这里处理拉起 onStartCommand 方法后的，onStart 方法的返回值！</span></span><br><span class="line">        <span class="keyword">if</span> (type == ActivityThread.SERVICE_DONE_EXECUTING_START) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将 r.callStart 置为 true！</span></span><br><span class="line">            r.callStart = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (res) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> Service.START_STICKY_COMPATIBILITY:</span><br><span class="line">                <span class="keyword">case</span> Service.START_STICKY: &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 从服务的 deliveredStarts 集合中删除本次启动对应的启动项！</span></span><br><span class="line">                    r.findDeliveredStart(startId, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 表示服务被杀死后不会被停止，会被重启！</span></span><br><span class="line">                    r.stopIfKilled = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> Service.START_NOT_STICKY: &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 从服务的 deliveredStarts 集合中删除本次启动对应的启动项！</span></span><br><span class="line">                    r.findDeliveredStart(startId, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 判断服务最后一次启动的 id 是否为本次 id！</span></span><br><span class="line">                    <span class="keyword">if</span> (r.getLastStartId() == startId) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 表示服务被杀死后会被停止，不会被重启！</span></span><br><span class="line">                        r.stopIfKilled = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> Service.START_REDELIVER_INTENT: &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 第二个参数为 false，并没有删除 startId 对应的启动项目，这里只是返回了！</span></span><br><span class="line">                    <span class="comment">// 这个启动项 Intent 被保留下来了！</span></span><br><span class="line">                    ServiceRecord.StartItem si = r.findDeliveredStart(startId, <span class="keyword">false</span>);</span><br><span class="line">                    <span class="keyword">if</span> (si != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        si.deliveryCount = <span class="number">0</span>;</span><br><span class="line">                        si.doneExecutingCount++;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// Don't stop if killed.</span></span><br><span class="line">                        r.stopIfKilled = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> Service.START_TASK_REMOVED_COMPLETE: &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Special processing for onTaskRemoved().  Don't</span></span><br><span class="line">                    <span class="comment">// impact normal onStartCommand() processing.</span></span><br><span class="line">                    r.findDeliveredStart(startId, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                            <span class="string">"Unknown service start result: "</span> + res);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (res == Service.START_STICKY_COMPATIBILITY) &#123;</span><br><span class="line">                r.callStart = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == ActivityThread.SERVICE_DONE_EXECUTING_STOP) &#123;</span><br><span class="line">            <span class="comment">// 这里是处理 destroy 服务的情况，这里先不看！</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 对于拉起 onCreate 方法的返回 type，直接进入这里！！</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">        serviceDoneExecutingLocked(r, inDestroying, inDestroying);</span><br><span class="line"></span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"Done executing unknown service from pid "</span></span><br><span class="line">                + Binder.getCallingPid());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>findDeliveredStart 方法用于从 ServiceRecord 的 deliveredStarts 集合中返回指定 id 的启动项，如果 remove 为 true，也要移除指定 id 的启动项！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StartItem <span class="title">findDeliveredStart</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">boolean</span> remove)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> N = deliveredStarts.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">        StartItem si = deliveredStarts.get(i);</span><br><span class="line">        <span class="keyword">if</span> (si.id == id) &#123;</span><br><span class="line">            <span class="keyword">if</span> (remove) deliveredStarts.remove(i);</span><br><span class="line">            <span class="keyword">return</span> si;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们来看看 <code>Service</code> 的 <code>onStartCommand</code> 方法的返回值的处理总结：</p>
<ul>
<li><strong>START_STICKY</strong>：</li>
<li><strong>START_STICKY_COMPATIBILITY</strong>：<ul>
<li>删除本次启动的 <code>startId</code> 对应的启动项；</li>
<li>设置服务的 <code>stopIfKilled</code> 为 <code>false</code>；</li>
</ul>
</li>
<li><strong>START_NOT_STICKY</strong>： <ul>
<li>删除本次启动的服务的 <code>startId</code> 对应的启动项；</li>
<li>如果最后一次启动的启动项的 <code>id</code> (lastStartId) 等于本次启动的启动项的 <code>id</code>；<ul>
<li>设置服务的 <code>stopIfKilled</code> 为 <code>true</code>；</li>
</ul>
</li>
</ul>
</li>
<li><strong>START_REDELIVER_INTENT</strong>： <ul>
<li>不删除本次启动的 <code>startId</code> 对应的启动项；</li>
<li>如果本次启动的启动项不为 null；<ul>
<li>设置启动项的 <code>deliveryCount</code> 为 <code>0</code>；</li>
<li>设置启动项的 <code>doneExecutingCount</code> 加 <code>1</code>；</li>
<li>设置服务的 <code>stopIfKilled</code> 为 <code>true</code>；</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>那么，如果服务被启动后，因为一些原因，所在的进程被杀掉了，那么系统会根据服务以上的属性对服务进行重启！</p>
<p>这里的 <code>r.stopIfKilled</code> 属性在 <code>AS.killServicesLocked</code> 的方法中会处理，用于判断服务在被 <code>kill</code> 掉后，是否被重启起！对于 <code>Service</code> 的重启，我会在另外一篇博文中分析，尽情期待！</p>
<h2 id="4-3-ActiveServices-serviceDoneExecutingLocked"><a href="#4-3-ActiveServices-serviceDoneExecutingLocked" class="headerlink" title="4.3 ActiveServices.serviceDoneExecutingLocked"></a>4.3 ActiveServices.serviceDoneExecutingLocked</h2><p>我们继续看，参数传递： </p>
<ul>
<li><code>boolean inDestroying</code>：服务正在被销毁！</li>
<li><code>boolean finishing</code>：服务正在完成！</li>
</ul>
<p>因为这里是刚刚启动服务，所以传入均为 false；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">serviceDoneExecutingLocked</span><span class="params">(ServiceRecord r, <span class="keyword">boolean</span> inDestroying,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> finishing)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">"&lt;&lt;&lt; DONE EXECUTING "</span> + r</span><br><span class="line">            + <span class="string">": nesting="</span> + r.executeNesting</span><br><span class="line">            + <span class="string">", inDestroying="</span> + inDestroying + <span class="string">", app="</span> + r.app);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (DEBUG_SERVICE_EXECUTING) Slog.v(TAG_SERVICE_EXECUTING,</span><br><span class="line">            <span class="string">"&lt;&lt;&lt; DONE EXECUTING "</span> + r.shortName);</span><br><span class="line"></span><br><span class="line">    r.executeNesting--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.executeNesting &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r.app != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE,</span><br><span class="line">                    <span class="string">"Nesting at 0 of "</span> + r.shortName);</span><br><span class="line"></span><br><span class="line">            r.app.execServicesFg = <span class="keyword">false</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 从 r.app.executingServices 移除该服务！</span></span><br><span class="line">            r.app.executingServices.remove(r);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果该进程中所有的服务都执行成功了，进入该分支！</span></span><br><span class="line">            <span class="keyword">if</span> (r.app.executingServices.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_SERVICE || DEBUG_SERVICE_EXECUTING) </span><br><span class="line">                     Slog.v(TAG_SERVICE_EXECUTING,</span><br><span class="line">                        <span class="string">"No more executingServices of "</span> + r.shortName);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 移除服务启动超时的消息！</span></span><br><span class="line">                mAm.mHandler.removeMessages(ActivityManagerService.SERVICE_TIMEOUT_MSG, r.app);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.executeFg) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Need to re-evaluate whether the app still needs to be in the foreground.</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=r.app.executingServices.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (r.app.executingServices.valueAt(i).executeFg) &#123;</span><br><span class="line">                        r.app.execServicesFg = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (inDestroying) &#123; <span class="comment">// 不进入！</span></span><br><span class="line">                <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE,</span><br><span class="line">                        <span class="string">"doneExecuting remove destroying "</span> + r);</span><br><span class="line">                mDestroyingServices.remove(r);</span><br><span class="line"></span><br><span class="line">                r.bindings.clear();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 更新 oomAdj！</span></span><br><span class="line">            mAm.updateOomAdjLocked(r.app);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        r.executeFg = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (r.tracker != <span class="keyword">null</span>) &#123;</span><br><span class="line">            r.tracker.setExecuting(<span class="keyword">false</span>, mAm.mProcessStats.getMemFactorLocked(),</span><br><span class="line">                    SystemClock.uptimeMillis());</span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                r.tracker.clearCurrentOwner(r, <span class="keyword">false</span>);</span><br><span class="line">                r.tracker = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (finishing) &#123; <span class="comment">// 不进入！</span></span><br><span class="line">            <span class="keyword">if</span> (r.app != <span class="keyword">null</span> &amp;&amp; !r.app.persistent) &#123;</span><br><span class="line">                r.app.services.remove(r);</span><br><span class="line">                <span class="keyword">if</span> (r.whitelistManager) &#123;</span><br><span class="line">                    updateWhitelistManagerLocked(r.app);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            r.app = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里会让 AMS 的 MainHandler 不再处理超时的消息！</p>
<h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h1><p>到这里，startService 的启动流程就分析完了，我们来回顾一下！！</p>
<h2 id="6-1-数据结构总结"><a href="#6-1-数据结构总结" class="headerlink" title="6.1 数据结构总结"></a>6.1 数据结构总结</h2><p>我们先来看看，在 start 流程中，会涉及到的一些重要的数据结构，以及他们之间的关系！</p>
<h3 id="6-1-1-ProcessRecord"><a href="#6-1-1-ProcessRecord" class="headerlink" title="6.1.1 ProcessRecord"></a>6.1.1 <strong>ProcessRecord</strong></h3><p>启动者和被启动者所在进程的信息对象；<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> curProcState <span class="comment">// 表示当前进程的状态，可以通过其来判断是否是前台进程调度，还是后台进调度</span></span><br><span class="line"><span class="keyword">int</span> setSchedGroup <span class="comment">// 进程的最新状态</span></span><br><span class="line"></span><br><span class="line">ArraySet&lt;ServiceRecord&gt; services <span class="comment">// 运行在这个进程中的所有服务</span></span><br><span class="line">ArraySet&lt;ServiceRecord&gt; executingServices <span class="comment">// 当前正在执行某段代码逻辑的服务列表，比如正在拉起 onCreate 等</span></span><br></pre></td></tr></table></figure></p>
<p>属性解释：</p>
<h3 id="6-1-2-ActivieServices"><a href="#6-1-2-ActivieServices" class="headerlink" title="6.1.2 ActivieServices"></a>6.1.2 <strong>ActivieServices</strong></h3><p>用来保存和管理系统中所有活跃的 Service！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   SparseArray&lt;ServiceMap&gt; mServiceMap <span class="comment">// 所有设备用户下的 Service 集合，key 为 userId，value 是 ServiceMap 类型的实例；</span></span><br><span class="line">   </span><br><span class="line">   ArrayList&lt;ServiceRecord&gt; mRestartingServices  <span class="comment">// 因为 CRASH 需要重启的  ServiceRecord 集合！</span></span><br><span class="line">   ArrayList&lt;ServiceRecord&gt; mDestroyingServices <span class="comment">// 进程被销毁的 ServiceRecord 集合！</span></span><br><span class="line">ArrayList&lt;ServiceRecord&gt; mPendingServices <span class="comment">// 所有正在启动的 ServiceRecord 集合</span></span><br></pre></td></tr></table></figure></p>
<p>属性解释：</p>
<h3 id="6-1-3-ServiceMap"><a href="#6-1-3-ServiceMap" class="headerlink" title="6.1.3 ServiceMap"></a>6.1.3 <strong>ServiceMap</strong></h3><p>是 Handler 的子类，用来保存制定 userId 目录下的所有 ServiceRecord！ </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mUserId： <span class="comment">// 指定的 uid</span></span><br><span class="line"></span><br><span class="line">ArrayMap&lt;ComponentName, ServiceRecord&gt; mServicesByName：<span class="comment">// 通过组件名为 key，存储对应的 ServiceRecord</span></span><br><span class="line">ArrayMap&lt;Intent.FilterComparison, ServiceRecord&gt; mServicesByIntent；<span class="comment">// 通过 intent 为 key，存储对应的 ServiceRecord</span></span><br><span class="line"></span><br><span class="line">ArrayList&lt;ServiceRecord&gt; mDelayedStartList: <span class="comment">// 延迟启动的 ServiceRecord 列表</span></span><br><span class="line">ArrayList&lt;ServiceRecord&gt; mStartingBackground：<span class="comment">// 正在后台启动的 ServiceRecord 列表</span></span><br></pre></td></tr></table></figure>
<p>属性解释：</p>
<h3 id="6-1-4-ServiceRecord"><a href="#6-1-4-ServiceRecord" class="headerlink" title="6.1.4 ServiceRecord"></a>6.1.4 <strong>ServiceRecord</strong></h3><p>要启动的 Service 的数据对象！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">      ServiceInfo serviceInfo <span class="comment">// 该服务的解析信息，来自 PMS</span></span><br><span class="line">      ApplicationInfo appInfo <span class="comment">// 该服务所属应用的信息，来自 PMS</span></span><br><span class="line">      <span class="keyword">int</span> userId <span class="comment">// 该服务所属的设备用户</span></span><br><span class="line">      Intent.FilterComparison intent <span class="comment">// 用来匹配该服务的 intent 封装类，等价于 intent</span></span><br><span class="line">      String permission <span class="comment">// 访问该服务需要的权限</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">long</span> createTime <span class="comment">// 该服务创建的时间</span></span><br><span class="line">      <span class="keyword">boolean</span> createdFromFg <span class="comment">// 表示服务是通过前台进程调度创建的还是后台进程</span></span><br><span class="line">      <span class="keyword">long</span> lastActivity <span class="comment">// 服务的活跃时间；</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">boolean</span> startRequested <span class="comment">// 服务是否被请求启动，开始启动时会置为 true；</span></span><br><span class="line">      <span class="keyword">boolean</span> delayedStop <span class="comment">// 服务是否被延迟停止，开始启动时会置为 false；</span></span><br><span class="line"><span class="keyword">boolean</span> delayed <span class="comment">// 服务是否延迟启动，默认为 false；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> restartDelay <span class="comment">// 服务重启延迟时间！</span></span><br><span class="line"><span class="keyword">int</span> restartCount <span class="comment">// 服务重启次数！</span></span><br><span class="line">      <span class="keyword">long</span> restartTime <span class="comment">// 服务重启时间！</span></span><br><span class="line"></span><br><span class="line">ArrayList&lt;StartItem&gt; pendingStarts <span class="comment">// 待处理的启动项列表；</span></span><br><span class="line">ArrayList&lt;StartItem&gt; deliveredStarts <span class="comment">// 已经被处理的启动项列表；</span></span><br><span class="line"></span><br><span class="line">Runnable restarter <span class="comment">// 这是一个 ServiceRestarter 对象，用于处理重启任务！</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> callStart</span><br><span class="line">ProcessRecord app <span class="comment">// 服务所在的进程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> executeFg <span class="comment">// 表示该服务是否是前台执行</span></span><br><span class="line">      <span class="keyword">int</span> executeNesting <span class="comment">// </span></span><br><span class="line">      <span class="keyword">long</span> executingStart <span class="comment">// 表示服务开始执行的时间</span></span><br></pre></td></tr></table></figure>
<p>属性解释：</p>
<ul>
<li><strong>r.pendingStarts</strong>：AS 会把启动相关的信息封装成一个 StartItem，保存到 pendingStarts 中！</li>
<li><strong>r.delayed：</strong>于后台启动的方式，如果 ServiceMap.mStartingBackground 的大小超过 mMaxStartingBackground 的话，会被置为 true，同时，将 ServiceRecord 添加到  ServiceMap.mDelayedStartList 中！</li>
</ul>
<h3 id="6-1-5-StartItem"><a href="#6-1-5-StartItem" class="headerlink" title="6.1.5  StartItem"></a>6.1.5  <strong>StartItem</strong></h3><p>这是一个启动项，封装一次 <code>startService</code> 的数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ServiceRecord sr; <span class="comment">// 要启动的服务</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> taskRemoved; <span class="comment">//  </span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> id; <span class="comment">// 启动项 id ，最小从 1 开始</span></span><br><span class="line"><span class="keyword">final</span> Intent intent; <span class="comment">// 启动用的 Intent</span></span><br><span class="line"><span class="keyword">final</span> ActivityManagerService.NeededUriGrants neededGrants;</span><br><span class="line"><span class="keyword">long</span> deliveredTime;</span><br><span class="line"><span class="keyword">int</span> deliveryCount;</span><br><span class="line"><span class="keyword">int</span> doneExecutingCount;</span><br><span class="line">UriPermissionOwner uriPermissions;</span><br></pre></td></tr></table></figure>
<p>属性解释：</p>
<h3 id="6-1-6-ServiceRestarter"><a href="#6-1-6-ServiceRestarter" class="headerlink" title="6.1.6 ServiceRestarter"></a>6.1.6 <strong>ServiceRestarter</strong></h3><p>这是 <code>Runnable</code> 对象，用于处理服务的重启！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServiceRecord mService <span class="comment">// 对应的服务！</span></span><br></pre></td></tr></table></figure>
<p>属性解释：</p>
<h3 id="6-1-7-CreateServiceData"><a href="#6-1-7-CreateServiceData" class="headerlink" title="6.1.7 CreateServiceData"></a>6.1.7 <strong>CreateServiceData</strong></h3><p><code>ActivityThread</code> 的内部类，用于封装拉起 <code>onCreate</code> 方法的数据：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IBinder token; <span class="comment">// ServiceRecord 对象</span></span><br><span class="line">ServiceInfo info;</span><br><span class="line">CompatibilityInfo compatInfo;</span><br><span class="line">Intent intent;</span><br></pre></td></tr></table></figure></p>
<p>属性解释：</p>
<h3 id="6-1-8-ServiceArgsData"><a href="#6-1-8-ServiceArgsData" class="headerlink" title="6.1.8 ServiceArgsData"></a>6.1.8 <strong>ServiceArgsData</strong></h3><p><code>ActivityThread</code> 的内部类，用于封装拉起 <code>onStartCommand</code> 方法的数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IBinder token; <span class="comment">// ServiceRecord 对象</span></span><br><span class="line"><span class="keyword">boolean</span> taskRemoved;</span><br><span class="line"><span class="keyword">int</span> startId; <span class="comment">// 本次启动的 id</span></span><br><span class="line"><span class="keyword">int</span> flags; <span class="comment">// 如果</span></span><br><span class="line">Intent args; <span class="comment">// 启动的 Intent</span></span><br></pre></td></tr></table></figure>
<p>属性解释：</p>
<h2 id="6-2-生命周期总结"><a href="#6-2-生命周期总结" class="headerlink" title="6.2 生命周期总结"></a>6.2 生命周期总结</h2><p>startService 方法周期很简单：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Serice.onCreate()(once) -&gt; Service.onStartCommand()(more)</span><br></pre></td></tr></table></figure></p>
<h2 id="6-3-流程总结"><a href="#6-3-流程总结" class="headerlink" title="6.3 流程总结"></a>6.3 流程总结</h2><p>下面是整个过程的 UML 序列图：</p>
<p>（我先填个坑，毕竟画图太累）</p>
<p>我们来看一下，这里面的一些细节：</p>
<ul>
<li>如果多次调用 <code>startService</code>，只有第一次会拉起服务的 <code>onCreate</code> 方法，因为 <code>r.app</code> 和 <code>r.app.thread</code> 为 <code>null</code>，<code>r.app</code> 是在创建 <code>Serivce（onCreate）</code>时被赋值的，多次调用 <code>StartService</code>，会直接进入 <code>sendServiceArgsLocked</code> 方法，拉起服务的 <code>onStartCommand</code> 方法；</li>
<li><code>onCreate</code> 方法的 <code>startId</code> 为 <code>0</code>，<code>onStartCommand</code> 方法的 <code>startId</code> 从 <code>1</code> 开始，一次递增！</li>
<li>如果服务启动后，因为内存不足等情况，被杀掉了，那么系统会重启该服务，如果在重启之前，用户通过 <code>startService</code> 再次启动了服务，那么就会取消之前的重启任务！（<code>r.restartDelay</code> 是在设置服务重启任务时设置的，我们后面再看）</li>
<li><code>onStartCommand</code> 方法的返回值有多个，这些返回值会影响 <code>Serivce</code> 的重启，请看 <code>Service reStart</code> 流程处理的分析，这里就不再多说了！</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2016/02/19/ActivityManager第 1 篇 - ActivityManagerService 的启动/">ActivityManager第 1 篇 - ActivityManagerService 的启动</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2016-02-19</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/AndroidFramework源码分析/">AndroidFramework源码分析</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/AndroidFramework源码分析/ActivityManager活动管理/">ActivityManager活动管理</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/ActivityManager活动管理/">ActivityManager活动管理</a></span><div class="content"><p>[toc]</p>
<p>基于 <code>Android 7.1.1</code> 源码分析 <code>AMS</code> 的机制，本文为作者原创，转载请说明出处，谢谢！ </p>
<h1 id="0-综述"><a href="#0-综述" class="headerlink" title="0 综述"></a>0 综述</h1><p><code>Android</code> 系统开机时，在 <code>SystemService</code> 进程被 <code>Zygote</code> 启动后，<code>SystemSevice</code> 进程需要启动一些系统的重要服务：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, <span class="string">"StartServices"</span>);</span><br><span class="line">startBootstrapServices();</span><br><span class="line">startCoreServices();</span><br><span class="line">startOtherServices();</span><br></pre></td></tr></table></figure></p>
<p><code>AMS</code> 的启动涉及到了以上的每个阶段，以为 <code>AMS</code> 需要和其他的系统服务进行交互，下面我们来逐一分析:</p>
<h1 id="1-第一阶段-startBootstrapServices"><a href="#1-第一阶段-startBootstrapServices" class="headerlink" title="1 第一阶段 - startBootstrapServices"></a>1 第一阶段 - startBootstrapServices</h1><p>我们来看看低级阶段，和 <code>AMS</code> 相关的代码；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startBootstrapServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 启动 Installer 系统服务</span></span><br><span class="line">    Installer installer = mSystemServiceManager.startService(Installer.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】第一阶段：启动 AMS</span></span><br><span class="line">    mActivityManagerService = mSystemServiceManager.startService(</span><br><span class="line">            ActivityManagerService.Lifecycle.class).getService();</span><br><span class="line">    mActivityManagerService.setSystemServiceManager(mSystemServiceManager);</span><br><span class="line">    mActivityManagerService.setInstaller(installer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】第二阶段，启动 PowerManagerService，AMS 初始化电池管理属性</span></span><br><span class="line">    mPowerManagerService = mSystemServiceManager.startService(PowerManagerService.class);</span><br><span class="line">    mActivityManagerService.initPowerManagement();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动 LED 和背光灯、显示、包管理这些重要的系统服务！</span></span><br><span class="line">    mSystemServiceManager.startService(LightsService.class);</span><br><span class="line">    mDisplayManagerService = mSystemServiceManager.startService(DisplayManagerService.class);</span><br><span class="line"></span><br><span class="line">    mSystemServiceManager.startBootPhase(SystemService.PHASE_WAIT_FOR_DEFAULT_DISPLAY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得系统属性 vold.decrypt 的值，表示是否只加载核心服务；</span></span><br><span class="line">    String cryptState = SystemProperties.get(<span class="string">"vold.decrypt"</span>);</span><br><span class="line">    <span class="keyword">if</span> (ENCRYPTING_STATE.equals(cryptState)) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"Detected encryption in progress - only parsing core apps"</span>);</span><br><span class="line">        mOnlyCore = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ENCRYPTED_STATE.equals(cryptState)) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"Device encrypted - only parsing core apps"</span>);</span><br><span class="line">        mOnlyCore = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建 PMS 服务对象，</span></span><br><span class="line">    mPackageManagerService = PackageManagerService.main(mSystemContext, installer,</span><br><span class="line">            mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore);</span><br><span class="line">    mFirstBoot = mPackageManagerService.isFirstBoot();</span><br><span class="line">    <span class="comment">// 和 A/B 升级相关！</span></span><br><span class="line">    <span class="keyword">if</span> (!mOnlyCore) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> disableOtaDexopt = SystemProperties.getBoolean(<span class="string">"config.disable_otadexopt"</span>,</span><br><span class="line">                <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (!disableOtaDexopt) &#123;</span><br><span class="line">            traceBeginAndSlog(<span class="string">"StartOtaDexOptService"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                OtaDexoptService.main(mSystemContext, mPackageManagerService);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                reportWtf(<span class="string">"starting OtaDexOptService"</span>, e);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动用户管理服务！</span></span><br><span class="line">    mSystemServiceManager.startService(UserManagerService.LifeCycle.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化属性缓存，用于缓存包资源</span></span><br><span class="line">    AttributeCache.init(mSystemContext);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【4】设置系统进程相关的参数！</span></span><br><span class="line">    mActivityManagerService.setSystemProcess();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动 Sensor 相关的服务。这是一个 Native 方法，与硬件相关度较大，这里不关注。</span></span><br><span class="line">    startSensorService();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>启动 <code>AMS</code> 之前，需要先连接 <code>installd</code> 进程， 通过 <code>Installer</code> 这个服务，就能完成一些重要目录的创建，譬如 <code>/data/user</code>，同时应用程序的安装，也需要这个服务。</li>
<li>启动 <code>ActivityManagerService</code> 服务；</li>
<li>启动 <code>PowerManagerService</code> 服务，<code>AMS</code> 需要使用 <code>PowerManagerService</code> 的服务：譬如，在启动 <code>Activity</code> 时，要避免系统进入休眠状态，就需要获取 <code>WakeLock</code>；</li>
<li>启动 <code>LightsService</code>、 <code>DisplayManagerService</code>、 <code>PackageManagerService</code> 系统服务；</li>
<li>启动 <code>OtaDexoptService</code> 服务，这里是和 A/B 升级相关的；</li>
<li>调用 <code>AMS.setSystemProcess()</code> 设置当前进程为系统进程，设置系统进程相关的参数；<ul>
<li>因为 <code>AMS</code> 的职责之一就是维护系统中所有进程的状态，不管是应用进程还是系统进程，都是 <code>AMS</code> 的管辖范围。</li>
</ul>
</li>
</ul>
<p>接下来，我们来看看和 <code>AMS</code> 相关的流程！</p>
<h2 id="1-1-ActivityManagerService"><a href="#1-1-ActivityManagerService" class="headerlink" title="1.1 ActivityManagerService"></a>1.1 ActivityManagerService</h2><p>接下来，我们仔细的看看 <code>AMS</code> 的构造器！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ActivityManagerService</span><span class="params">(Context systemContext)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得系统进程的上下文环境；</span></span><br><span class="line">    mContext = systemContext;</span><br><span class="line">    mFactoryTest = FactoryTest.getMode(); <span class="comment">// 是否是工厂模式！</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获得 SystemServer 进程的 ActivityThread 对象，每个进程都有一个！</span></span><br><span class="line">    mSystemThread = ActivityThread.currentActivityThread();</span><br><span class="line"></span><br><span class="line">    Slog.i(TAG, <span class="string">"Memory class: "</span> + ActivityManager.staticGetMemoryClass());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建处理消息的 HandlerThread 和 Handler 对象！</span></span><br><span class="line">    mHandlerThread = <span class="keyword">new</span> ServiceThread(TAG,</span><br><span class="line">            android.os.Process.THREAD_PRIORITY_FOREGROUND, <span class="keyword">false</span> <span class="comment">/*allowIo*/</span>);</span><br><span class="line">    mHandlerThread.start();</span><br><span class="line">    mHandler = <span class="keyword">new</span> MainHandler(mHandlerThread.getLooper());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建处理 ANR 相关的 Handler！</span></span><br><span class="line">    mUiHandler = <span class="keyword">new</span> UiHandler();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里的 sKillHandler 绑定了一个 handlerThread 线程对象，用于处理杀进程的消息！</span></span><br><span class="line">    <span class="keyword">if</span> (sKillHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        sKillThread = <span class="keyword">new</span> ServiceThread(TAG + <span class="string">":kill"</span>,</span><br><span class="line">                android.os.Process.THREAD_PRIORITY_BACKGROUND, <span class="keyword">true</span> <span class="comment">/* allowIo */</span>);</span><br><span class="line">        sKillThread.start();</span><br><span class="line">        sKillHandler = <span class="keyword">new</span> KillHandler(sKillThread.getLooper());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 集合管理前台广播和后台广播的集合，有前 / 后台之分，为了区分不同的广播消息超时时间。</span></span><br><span class="line">    mFgBroadcastQueue = <span class="keyword">new</span> BroadcastQueue(<span class="keyword">this</span>, mHandler,</span><br><span class="line">            <span class="string">"foreground"</span>, BROADCAST_FG_TIMEOUT, <span class="keyword">false</span>);</span><br><span class="line">    mBgBroadcastQueue = <span class="keyword">new</span> BroadcastQueue(<span class="keyword">this</span>, mHandler,</span><br><span class="line">            <span class="string">"background"</span>, BROADCAST_BG_TIMEOUT, <span class="keyword">true</span>);</span><br><span class="line">    mBroadcastQueues[<span class="number">0</span>] = mFgBroadcastQueue;</span><br><span class="line">    mBroadcastQueues[<span class="number">1</span>] = mBgBroadcastQueue;</span><br><span class="line">  </span><br><span class="line">    mServices = <span class="keyword">new</span> ActiveServices(<span class="keyword">this</span>); <span class="comment">// 创建管理 Service 组件的 ActiveServices 对象！</span></span><br><span class="line">    mProviderMap = <span class="keyword">new</span> ProviderMap(<span class="keyword">this</span>); <span class="comment">// 创建管理 Provider 组件的 ProviderMap 对象！</span></span><br><span class="line"></span><br><span class="line">    mAppErrors = <span class="keyword">new</span> AppErrors(mContext, <span class="keyword">this</span>); <span class="comment">// 创建管理 ANR 和 crash 的 AppError 对象！</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 /data/system 目录，诸如包管理packages.xml, packages.list等文件都存放于此目录</span></span><br><span class="line">    File dataDir = Environment.getDataDirectory();</span><br><span class="line">    File systemDir = <span class="keyword">new</span> File(dataDir, <span class="string">"system"</span>);</span><br><span class="line">    systemDir.mkdirs();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建电量统计服务 BatteryStatsService 对象，并将 mHandler 传入，用于通信！</span></span><br><span class="line">    mBatteryStatsService = <span class="keyword">new</span> BatteryStatsService(systemDir, mHandler);</span><br><span class="line">    mBatteryStatsService.getActiveStatistics().readLocked();</span><br><span class="line">    mBatteryStatsService.scheduleWriteToDisk();</span><br><span class="line">    mOnBattery = DEBUG_POWER ? <span class="keyword">true</span></span><br><span class="line">            : mBatteryStatsService.getActiveStatistics().getIsOnBattery();</span><br><span class="line">    mBatteryStatsService.getActiveStatistics().setCallback(<span class="keyword">this</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 创建进程状态监控服务 ProcessStatsService 对象，/data/system/procstats 文件会存储</span></span><br><span class="line">    <span class="comment">// 进程的状态信息！</span></span><br><span class="line">    mProcessStats = <span class="keyword">new</span> ProcessStatsService(<span class="keyword">this</span>, <span class="keyword">new</span> File(systemDir, <span class="string">"procstats"</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建应用操作监控服务 AppOpsService 对象，/data/system/appops.xml文件存储app的</span></span><br><span class="line">    <span class="comment">// 权限设置和操作信息！</span></span><br><span class="line">    mAppOpsService = <span class="keyword">new</span> AppOpsService(<span class="keyword">new</span> File(systemDir, <span class="string">"appops.xml"</span>), mHandler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听是否允许应用在后台运行的操作</span></span><br><span class="line">    mAppOpsService.startWatchingMode(AppOpsManager.OP_RUN_IN_BACKGROUND, <span class="keyword">null</span>,</span><br><span class="line">            <span class="keyword">new</span> IAppOpsCallback.Stub() &#123;</span><br><span class="line">                <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">opChanged</span><span class="params">(<span class="keyword">int</span> op, <span class="keyword">int</span> uid, String packageName)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (op == AppOpsManager.OP_RUN_IN_BACKGROUND &amp;&amp; packageName != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (mAppOpsService.checkOperation(op, uid, packageName)</span><br><span class="line">                                != AppOpsManager.MODE_ALLOWED) &#123;</span><br><span class="line">                            runInBackgroundDisabled(uid);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建 urigrants.xml 文件对象！</span></span><br><span class="line">    mGrantFile = <span class="keyword">new</span> AtomicFile(<span class="keyword">new</span> File(systemDir, <span class="string">"urigrants.xml"</span>));</span><br><span class="line">    <span class="comment">// 创建 UserController 对象！</span></span><br><span class="line">    mUserController = <span class="keyword">new</span> UserController(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取 OpenGL 版本号</span></span><br><span class="line">    GL_ES_VERSION = SystemProperties.getInt(<span class="string">"ro.opengles.version"</span>,</span><br><span class="line">        ConfigurationInfo.GL_ES_VERSION_UNDEFINED);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (SystemProperties.getInt(<span class="string">"sys.use_fifo_ui"</span>, <span class="number">0</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        mUseFifoUiScheduling = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mTrackingAssociations = <span class="string">"1"</span>.equals(SystemProperties.get(<span class="string">"debug.track-associations"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置区域、语言、字体、屏幕方向等，启动 Activity 时，需要用到这个配置！</span></span><br><span class="line">    mConfiguration.setToDefaults();</span><br><span class="line">    mConfiguration.setLocales(LocaleList.getDefault());</span><br><span class="line">    mConfigurationSeq = mConfiguration.seq = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化 processCpuTracker 对象，用来收集 ANR 情况下的 cpu 使用情况，电池状态等等！</span></span><br><span class="line">    mProcessCpuTracker.init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AndroidManifest.xml 中 compatible-screens 相关的解析工具</span></span><br><span class="line">    mCompatModePackages = <span class="keyword">new</span> CompatModePackages(<span class="keyword">this</span>, systemDir, mHandler);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建 instent 防火墙！</span></span><br><span class="line">    mIntentFirewall = <span class="keyword">new</span> IntentFirewall(<span class="keyword">new</span> IntentFirewallInterface(), mHandler);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建管理组件 Activity 的 ActivityStackSupervisor 和 ActivityStarter 对象！</span></span><br><span class="line">    mStackSupervisor = <span class="keyword">new</span> ActivityStackSupervisor(<span class="keyword">this</span>);</span><br><span class="line">    mActivityStarter = <span class="keyword">new</span> ActivityStarter(<span class="keyword">this</span>, mStackSupervisor);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建最近任务对象！</span></span><br><span class="line">    mRecentTasks = <span class="keyword">new</span> RecentTasks(<span class="keyword">this</span>, mStackSupervisor);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建一个子线程，不断循环，更新 cpu 的状态信息！</span></span><br><span class="line">    mProcessCpuThread = <span class="keyword">new</span> Thread(<span class="string">"CpuTracker"</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">                            <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">                            <span class="keyword">long</span> nextCpuDelay = (mLastCpuTime.get()+MONITOR_CPU_MAX_TIME)-now;</span><br><span class="line">                            <span class="keyword">long</span> nextWriteDelay = (mLastWriteTime+BATTERY_STATS_TIME)-now;</span><br><span class="line">                            <span class="comment">//Slog.i(TAG, "Cpu delay=" + nextCpuDelay</span></span><br><span class="line">                            <span class="comment">//        + ", write delay=" + nextWriteDelay);</span></span><br><span class="line">                            <span class="keyword">if</span> (nextWriteDelay &lt; nextCpuDelay) &#123;</span><br><span class="line">                                nextCpuDelay = nextWriteDelay;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (nextCpuDelay &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                                mProcessCpuMutexFree.set(<span class="keyword">true</span>);</span><br><span class="line">                                <span class="keyword">this</span>.wait(nextCpuDelay);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 更新 cpu 的状态以及电池状态信息！</span></span><br><span class="line">                    updateCpuStatsNow();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    Slog.e(TAG, <span class="string">"Unexpected exception collecting process stats"</span>, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将自身加入到 Watchdog 的监控中！</span></span><br><span class="line">    Watchdog.getInstance().addMonitor(<span class="keyword">this</span>);</span><br><span class="line">    Watchdog.getInstance().addThread(mHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们总结一下，在 AMS 的构造器中，主要做了一下几个事情：</p>
<ul>
<li><p>创建了系统目录：<code>/data/system</code></p>
</li>
<li><p>创建了几个系统服务对象：</p>
<ul>
<li><code>BatteryStatsService</code>：用于监控电池状态；</li>
<li><code>ProcessStatsService</code>：用于监控进程状态；</li>
<li><code>AppOpsService</code>：用于监控 <code>app</code> 的操作行为；</li>
<li><code>UserController</code>：</li>
</ul>
</li>
<li><p>创建了四大组件的管理对象；</p>
<ul>
<li><code>Broadcast</code>：<code>mFgBroadcastQueue</code> 和 <code>mBgBroadcastQueue</code>，分别管理前台后台广播；</li>
<li><code>Service</code>：<code>ActiveServices</code>；</li>
<li><code>Provider</code>：<code>ProviderMap</code>；</li>
<li><code>Activity</code>：<code>mStackSupervisor</code>，<code>mActivityStarter</code>；</li>
</ul>
</li>
<li><p>创建了处理 <code>ANR</code> 和 <code>Crash</code> 的对象：<code>mAppErrors</code>；</p>
</li>
<li>创建最近任务对象：<code>RecentTasks</code>；</li>
</ul>
<p>初次之外，还有：</p>
<ul>
<li>初始化 <code>processCpuTracker</code> 对象！</li>
<li>创建了几个 <code>Handler</code>，用于消息处理：<ul>
<li><code>MainHandler</code>：绑定了子线程 <code>ServiceThread</code> 对象 <code>mHandlerThread</code>，<code>AMS</code> 会把它传递个给其他服务，用于交互；</li>
<li><code>UiHandler</code>：绑定了系统进程的主线程，用于处理 <code>ANR</code> 和 <code>Crash</code> 相关的信息！</li>
<li><code>sKillThread</code>：绑定了子线程 <code>ServiceThread</code> 对象 <code>sKillThread</code>，用于处理杀进程的操作；</li>
</ul>
</li>
<li>创建几个子线程<ul>
<li>一个线程 <code>mProcessCpuThread</code>，不断的更新 <code>cpu</code> 和电池的状态信息；</li>
<li>两个 <code>ServiceThread</code> 子线程；</li>
</ul>
</li>
</ul>
<h3 id="1-1-1-new-ActivityStackSupervisor"><a href="#1-1-1-new-ActivityStackSupervisor" class="headerlink" title="1.1.1 new ActivityStackSupervisor"></a>1.1.1 new ActivityStackSupervisor</h3><p><code>ActivityStackSupervisor</code> 是系统中所有的 <code>ActivityStack</code> 的管理对象！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ActivityStackSupervisor</span><span class="params">(ActivityManagerService service)</span> </span>&#123;</span><br><span class="line">    mService = service;</span><br><span class="line">    <span class="comment">// 创建了一个 ActivityStackSupervisorHandler 的 Handler 对象！</span></span><br><span class="line">    mHandler = <span class="keyword">new</span> ActivityStackSupervisorHandler(mService.mHandler.getLooper());</span><br><span class="line">    mActivityMetricsLogger = <span class="keyword">new</span> ActivityMetricsLogger(<span class="keyword">this</span>, mService.mContext);</span><br><span class="line">    mResizeDockedStackTimeout = <span class="keyword">new</span> ResizeDockedStackTimeout(service, <span class="keyword">this</span>, mHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="1-1-2-new-ActivityStarter"><a href="#1-1-2-new-ActivityStarter" class="headerlink" title="1.1.2 new ActivityStarter"></a>1.1.2 new ActivityStarter</h3><p><code>ActivityStarter</code> 对象负责启动 <code>activity</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ActivityStarter(ActivityManagerService service, ActivityStackSupervisor supervisor) &#123;</span><br><span class="line">    mService = service;</span><br><span class="line">    mSupervisor = supervisor;</span><br><span class="line">    mInterceptor = <span class="keyword">new</span> ActivityStartInterceptor(mService, mSupervisor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="1-1-3-new-RecentTasks"><a href="#1-1-3-new-RecentTasks" class="headerlink" title="1.1.3 new RecentTasks"></a>1.1.3 new RecentTasks</h3><p>创建最近任务管理对象！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">RecentTasks(ActivityManagerService service, ActivityStackSupervisor mStackSupervisor) &#123;</span><br><span class="line">    <span class="comment">// 对应 /data/system 目录</span></span><br><span class="line">    File systemDir = Environment.getDataSystemDirectory();</span><br><span class="line">    mService = service;</span><br><span class="line">    <span class="comment">// 创建 TaskPersister 对象，用于管理那些重启后可恢复的任务！</span></span><br><span class="line">    mTaskPersister = <span class="keyword">new</span> TaskPersister(systemDir, mStackSupervisor, service, <span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 将最近任务对象传递给 StackSupervisor！</span></span><br><span class="line">    mStackSupervisor.setRecentTasks(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>TaskPersister</code> 对象用于管理那些重启后可恢复的任务，下面我们去看看：</p>
<h4 id="1-1-3-1-new-TaskPersister"><a href="#1-1-3-1-new-TaskPersister" class="headerlink" title="1.1.3.1 new TaskPersister"></a>1.1.3.1 new TaskPersister</h4><p>用于管理系统中所有的 <code>persisable</code> 类型的 <code>task</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">TaskPersister(File systemDir, ActivityStackSupervisor stackSupervisor,</span><br><span class="line">        ActivityManagerService service, RecentTasks recentTasks) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除目录：/data/system/recent_images 和其子目录！</span></span><br><span class="line">    <span class="keyword">final</span> File legacyImagesDir = <span class="keyword">new</span> File(systemDir, IMAGES_DIRNAME);</span><br><span class="line">    <span class="keyword">if</span> (legacyImagesDir.exists()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!FileUtils.deleteContents(legacyImagesDir) || !legacyImagesDir.delete()) &#123;</span><br><span class="line">            Slog.i(TAG, <span class="string">"Failure deleting legacy images directory: "</span> + legacyImagesDir);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除目录：/data/system/recent_tasks 和其子目录！</span></span><br><span class="line">    <span class="keyword">final</span> File legacyTasksDir = <span class="keyword">new</span> File(systemDir, TASKS_DIRNAME);</span><br><span class="line">    <span class="keyword">if</span> (legacyTasksDir.exists()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!FileUtils.deleteContents(legacyTasksDir) || !legacyTasksDir.delete()) &#123;</span><br><span class="line">            Slog.i(TAG, <span class="string">"Failure deleting legacy tasks directory: "</span> + legacyTasksDir);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建目录 ：/data/system_de，保存了 persisable 任务的 id；</span></span><br><span class="line">    mTaskIdsDir = <span class="keyword">new</span> File(Environment.getDataDirectory(), <span class="string">"system_de"</span>);</span><br><span class="line">    mStackSupervisor = stackSupervisor;</span><br><span class="line">    mService = service;</span><br><span class="line">    mRecentTasks = recentTasks;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个线程对象，用于写数据！</span></span><br><span class="line">    mLazyTaskWriterThread = <span class="keyword">new</span> LazyTaskWriterThread(<span class="string">"LazyTaskWriterThread"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里我来简单的说一下：</p>
<ul>
<li>在 <code>/data/system_de</code> 目录下，会有一个以设备用户 <code>id</code> 命名的文件夹，内部会有一个名为 <code>persisted_taskIds.txt</code> 的文件，内部保存了所有的 <code>persisable</code> 类型的 <code>task</code> 的 <code>id</code>；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lishuaiqi:/data/system_de # ls -al</span><br><span class="line">drwxrwx---  <span class="number">3</span> system system <span class="number">4096</span> <span class="number">2017</span>-<span class="number">08</span>-<span class="number">10</span> <span class="number">08</span>:<span class="number">58</span> <span class="number">0</span></span><br><span class="line">lishuaiqi:/data/system_de/0 # ls -al</span><br><span class="line">-rw-------  <span class="number">1</span> system system   <span class="number">28</span> <span class="number">2017</span>-<span class="number">08</span>-<span class="number">14</span> <span class="number">01</span>:<span class="number">30</span> persisted_taskIds.txt</span><br><span class="line">lishuaiqi:/data/system_de/0 # cat persisted_taskIds.txt</span><br><span class="line"><span class="number">278</span></span><br><span class="line"><span class="number">279</span></span><br><span class="line"><span class="number">320</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在 <code>/data/system_de</code> 目录下，会有一个以设备用户 <code>id</code> 命名的文件夹，内部会有两个文件夹：<code>recent_images</code> 和 <code>recent_tasks</code>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lishuaiqi:/data/system_ce/0 # ls -al</span><br><span class="line">drwx------ <span class="number">2</span> system system  <span class="number">4096</span> <span class="number">2017</span>-<span class="number">08</span>-<span class="number">14</span> <span class="number">01</span>:<span class="number">30</span> recent_images</span><br><span class="line">drwx------ <span class="number">2</span> system system  <span class="number">4096</span> <span class="number">2017</span>-<span class="number">08</span>-<span class="number">14</span> <span class="number">01</span>:<span class="number">31</span> recent_tasks</span><br></pre></td></tr></table></figure>
<p>其中，<code>recent_images</code> 用来保存 <code>task</code> 的截图信息，文件名的格式为：<code>[task_id]_task_thumbnail.png</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lishuaiqi:/data/system_ce/0/recent_images # ls -al</span><br><span class="line">-rw------- <span class="number">1</span> system system  <span class="number">68019</span> <span class="number">2017</span>-<span class="number">08</span>-<span class="number">14</span> <span class="number">01</span>:<span class="number">30</span> <span class="number">326</span>_task_thumbnail.png</span><br><span class="line">-rw------- <span class="number">1</span> system system  <span class="number">18394</span> <span class="number">2017</span>-<span class="number">08</span>-<span class="number">14</span> <span class="number">01</span>:<span class="number">30</span> <span class="number">327</span>_task_thumbnail.png</span><br></pre></td></tr></table></figure></p>
<p>其中，<code>recent_tasks</code> 用来保存 <code>task</code> 的信息，文件名的格式为：<code>[task_id]_task.xml</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lishuaiqi:/data/system_ce/0/recent_tasks # ls -al</span><br><span class="line">-rw------- <span class="number">1</span> system system <span class="number">1107</span> <span class="number">2017</span>-<span class="number">08</span>-<span class="number">14</span> <span class="number">16</span>:<span class="number">58</span> <span class="number">279</span>_task.xml</span><br><span class="line">-rw------- <span class="number">1</span> system system <span class="number">1116</span> <span class="number">2017</span>-<span class="number">08</span>-<span class="number">19</span> <span class="number">19</span>:<span class="number">06</span> <span class="number">320</span>_task.xml</span><br></pre></td></tr></table></figure></p>
<p>下面我们来看看 <code>[task_id]_task.xml</code> 文件中有那些奇葩的属性，这里以腾讯微信为例子：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;task task_id=<span class="string">"278"</span> </span><br><span class="line">	  real_activity=<span class="string">"com.tencent.mm/.ui.LauncherUI"</span> </span><br><span class="line">	  real_activity_suspended=<span class="string">"false"</span> </span><br><span class="line">	  affinity=<span class="string">"com.tencent.mm"</span> </span><br><span class="line">	  root_has_reset=<span class="string">"true"</span> </span><br><span class="line">	  auto_remove_recents=<span class="string">"false"</span> </span><br><span class="line">	  asked_compat_mode=<span class="string">"false"</span> </span><br><span class="line">	  user_id=<span class="string">"0"</span> </span><br><span class="line">	  user_setup_complete=<span class="string">"true"</span> </span><br><span class="line">	  effective_uid=<span class="string">"10109"</span> </span><br><span class="line">	  task_type=<span class="string">"0"</span> </span><br><span class="line">	  first_active_time=<span class="string">"1502678072409"</span> </span><br><span class="line">	  last_active_time=<span class="string">"1502678115558"</span> </span><br><span class="line">	  last_time_moved=<span class="string">"1502678078477"</span> </span><br><span class="line">	  never_relinquish_identity=<span class="string">"true"</span> </span><br><span class="line">	  task_description_color=<span class="string">"ff212121"</span> </span><br><span class="line">	  task_description_colorBackground=<span class="string">"fffafafa"</span> </span><br><span class="line">	  task_thumbnailinfo_task_width=<span class="string">"1080"</span> </span><br><span class="line">	  task_thumbnailinfo_task_height=<span class="string">"1920"</span> </span><br><span class="line">	  task_thumbnailinfo_screen_orientation=<span class="string">"1"</span> </span><br><span class="line">	  task_affiliation_color=<span class="string">"-14606047"</span> </span><br><span class="line">	  task_affiliation=<span class="string">"278"</span> </span><br><span class="line">	  prev_affiliation=<span class="string">"-1"</span> </span><br><span class="line">	  next_affiliation=<span class="string">"-1"</span> </span><br><span class="line">	  calling_uid=<span class="string">"10109"</span> </span><br><span class="line">	  calling_package=<span class="string">"com.tencent.mm"</span> </span><br><span class="line">	  resize_mode=<span class="string">"4"</span> </span><br><span class="line">	  privileged=<span class="string">"false"</span> </span><br><span class="line">	  min_width=<span class="string">"-1"</span> </span><br><span class="line">	  min_height=<span class="string">"-1"</span>&gt;</span><br><span class="line"></span><br><span class="line">	&lt;intent action=<span class="string">"android.intent.action.MAIN"</span> </span><br><span class="line">	        component=<span class="string">"com.tencent.mm/.ui.LauncherUI"</span> </span><br><span class="line">			flags=<span class="string">"10200000"</span>&gt;</span><br><span class="line">		&lt;categories category=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span><br><span class="line">	&lt;/intent&gt;</span><br><span class="line">&lt;/task&gt;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，所有的 <code>persisable</code> 类型的 <code>task</code>，系统会将这些属性保存到对应的文件中，开机后可以恢复！</p>
<h2 id="1-2-onStart"><a href="#1-2-onStart" class="headerlink" title="1.2 onStart"></a>1.2 onStart</h2><p>调用构造器，创建完 <code>AMS</code> 的对象之后，要做的就是启动 <code>AMS</code> 哦，在上一篇中，我们有看到，启动先调用 <code>LifeCircle</code> 的 <code>onStart</code> ，然后会调用了 <code>AMS</code> 的 <code>start</code> 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 移除所有的进程组！</span></span><br><span class="line">    Process.removeAllProcessGroups();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动 ProcessCpuThread，监控 cpu 和电池的状态！</span></span><br><span class="line">    mProcessCpuThread.start();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将 BatteryStatsService 服务和 AppOpsService 注册到 ServiceManager 中，用于进程间通讯！</span></span><br><span class="line">    mBatteryStatsService.publish(mContext);</span><br><span class="line">    mAppOpsService.publish(mContext);</span><br><span class="line">    Slog.d(<span class="string">"AppOps"</span>, <span class="string">"AppOpsService published"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将 AMS 添加进入 LocalServices 集合中，用于同一进程内的本地通信！</span></span><br><span class="line">    LocalServices.addService(ActivityManagerInternal.class, <span class="keyword">new</span> LocalService());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法很简单，就不多说了：</p>
<ul>
<li>移除所有的进程组；并启动 <code>ProcessCpuThread</code>，监控 <code>cpu</code> 和电池的状态！</li>
<li>将 <code>BatteryStatsService</code> 服务和 <code>AppOpsService</code> 注册到 <code>ServiceManager</code> 中，用于 <code>Binder</code> 通讯！  </li>
</ul>
<h2 id="1-3-initPowerManagement"><a href="#1-3-initPowerManagement" class="headerlink" title="1.3 initPowerManagement"></a>1.3 initPowerManagement</h2><p>接下来，初始化 电池管理：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initPowerManagement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化电池管理！</span></span><br><span class="line">    mStackSupervisor.initPowerManagement();</span><br><span class="line">    mBatteryStatsService.initPowerManagement();</span><br><span class="line"></span><br><span class="line">    mLocalPowerManager = LocalServices.getService(PowerManagerInternal.class);</span><br><span class="line">    </span><br><span class="line">    PowerManager pm = (PowerManager)mContext.getSystemService(Context.POWER_SERVICE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获得 WakeLock！</span></span><br><span class="line">    mVoiceWakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, <span class="string">"*voice*"</span>);</span><br><span class="line">    mVoiceWakeLock.setReferenceCounted(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里主要是进一步的初始化电池管理！</p>
<h2 id="1-4-setSystemProcess"><a href="#1-4-setSystemProcess" class="headerlink" title="1.4 setSystemProcess"></a>1.4 setSystemProcess</h2><p>接下来，是设置 SytemServer 系统进程的相关信息，我们来看看代码，这里要仔细的来看了！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSystemProcess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【1】注册一些系统相关的服务</span></span><br><span class="line">        ServiceManager.addService(Context.ACTIVITY_SERVICE, <span class="keyword">this</span>, <span class="keyword">true</span>);</span><br><span class="line">        ServiceManager.addService(ProcessStats.SERVICE_NAME, mProcessStats);</span><br><span class="line">        ServiceManager.addService(<span class="string">"meminfo"</span>, <span class="keyword">new</span> MemBinder(<span class="keyword">this</span>));</span><br><span class="line">        ServiceManager.addService(<span class="string">"gfxinfo"</span>, <span class="keyword">new</span> GraphicsBinder(<span class="keyword">this</span>));</span><br><span class="line">        ServiceManager.addService(<span class="string">"dbinfo"</span>, <span class="keyword">new</span> DbBinder(<span class="keyword">this</span>));</span><br><span class="line">        <span class="keyword">if</span> (MONITOR_CPU_USAGE) &#123;</span><br><span class="line">            ServiceManager.addService(<span class="string">"cpuinfo"</span>, <span class="keyword">new</span> CpuBinder(<span class="keyword">this</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        ServiceManager.addService(<span class="string">"permission"</span>, <span class="keyword">new</span> PermissionController(<span class="keyword">this</span>));</span><br><span class="line">        ServiceManager.addService(<span class="string">"processinfo"</span>, <span class="keyword">new</span> ProcessInfoService(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从 PackageManagerService 中获取 framework-res.apk (包名为 android) 的 ApplicationInfo 信息!</span></span><br><span class="line">        ApplicationInfo info = mContext.getPackageManager().getApplicationInfo(<span class="string">"android"</span>, STOCK_PM_FLAGS | MATCH_SYSTEM_ONLY);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【2】保存 framework-res.apk 的信息到系统进程的主线程中！</span></span><br><span class="line">        mSystemThread.installSystemApplicationInfo(info, getClass().getClassLoader());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 初始化系统进程的 ProcessRecord</span></span><br><span class="line">            ProcessRecord app = newProcessRecordLocked(info, info.processName, <span class="keyword">false</span>, <span class="number">0</span>);</span><br><span class="line">            app.persistent = <span class="keyword">true</span>; <span class="comment">// 设置为常驻进程</span></span><br><span class="line">            app.pid = MY_PID; <span class="comment">// 设置 pid</span></span><br><span class="line">            app.maxAdj = ProcessList.SYSTEM_ADJ; <span class="comment">// 设置系统进程的 adj 为 -900，很难被杀死哦！</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 使系统进程处于活跃状态</span></span><br><span class="line">            app.makeActive(mSystemThread.getApplicationThread(), mProcessStats);</span><br><span class="line">            <span class="keyword">synchronized</span> (mPidsSelfLocked) &#123;</span><br><span class="line">                <span class="comment">// 将 systemServer 进程对象加入到 mPidsSelfLocked 中，以便管理！</span></span><br><span class="line">                mPidsSelfLocked.put(app.pid, app);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 更新最近使用进程列表</span></span><br><span class="line">            updateLruProcessLocked(app, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">// 用于更新进程的oom_adj值</span></span><br><span class="line">            updateOomAdjLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unable to find android system package"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中用到了 <code>mPidsSelfLocked</code> 变量，我们看下这个变量的定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> SparseArray&lt;ProcessRecord&gt; mPidsSelfLocked = <span class="keyword">new</span> SparseArray&lt;ProcessRecord&gt;();</span><br></pre></td></tr></table></figure></p>
<p><code>mPidsSelfLocked</code> 保存有 <code>pid</code> 组织起来的正在运行的进程，保存的是 <code>pid</code>，及 <code>pid</code> 对应的 <code>ProcessRecord</code>。</p>
<p>这里我们来总结一下，这方法主要做了什么：</p>
<ul>
<li>注册一些系统相关的服务，我们可以通过 <code>adb shell dumpsys</code> 命令查看！</li>
<li>获取 <code>framework-res.apk</code> 安装包信息，保存到系统进程的 <code>ActivityThread</code> 对象中！</li>
<li>创建 <code>SystemServer</code> 系统进程的进程结构体，初始化属性，将其加入  <code>mPidsSelfLocked</code> ，用于管理！</li>
<li>更新进程的优先级和 <code>oomAdj</code>，这两个方法，我们后面单开一贴！！！</li>
</ul>
<p>下面我们仔细的看看一些细节，有利于我们对 <code>AMS</code> 的结构有一个更深层次的理解！</p>
<h3 id="1-4-1-ServiceManager-addService"><a href="#1-4-1-ServiceManager-addService" class="headerlink" title="1.4.1 ServiceManager.addService"></a>1.4.1 ServiceManager.addService</h3><p>第一步，注册一些重要的服务，包括 ActivityManagerService 自身！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册一些系统相关的服务</span></span><br><span class="line">ServiceManager.addService(Context.ACTIVITY_SERVICE, <span class="keyword">this</span>, <span class="keyword">true</span>);</span><br><span class="line">ServiceManager.addService(ProcessStats.SERVICE_NAME, mProcessStats);</span><br><span class="line">ServiceManager.addService(<span class="string">"meminfo"</span>, <span class="keyword">new</span> MemBinder(<span class="keyword">this</span>));</span><br><span class="line">ServiceManager.addService(<span class="string">"gfxinfo"</span>, <span class="keyword">new</span> GraphicsBinder(<span class="keyword">this</span>));</span><br><span class="line">ServiceManager.addService(<span class="string">"dbinfo"</span>, <span class="keyword">new</span> DbBinder(<span class="keyword">this</span>));</span><br><span class="line"><span class="keyword">if</span> (MONITOR_CPU_USAGE) &#123;</span><br><span class="line">    ServiceManager.addService(<span class="string">"cpuinfo"</span>, <span class="keyword">new</span> CpuBinder(<span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br><span class="line">ServiceManager.addService(<span class="string">"permission"</span>, <span class="keyword">new</span> PermissionController(<span class="keyword">this</span>));</span><br><span class="line">ServiceManager.addService(<span class="string">"processinfo"</span>, <span class="keyword">new</span> ProcessInfoService(<span class="keyword">this</span>));</span><br></pre></td></tr></table></figure></p>
<p>这里注册了哪些服务呢？这里用到了几个静态变量：</p>
<blockquote>
<p>Context.ACTIVITY_SERVICE = “activity”;<br>ProcessStats.SERVICE_NAME = “procstats”;</p>
</blockquote>
<p>这里注册了那些服务呢，我们来看看：</p>
<table>
<thead>
<tr>
<th>服务名</th>
<th>类名</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>procstats</code></td>
<td><code>ProcessStatsService</code></td>
<td>监控进程信息的服务</td>
</tr>
<tr>
<td><code>cpuinfo</code></td>
<td><code>CpuBinder</code></td>
<td>监控CPU信息的服务</td>
</tr>
<tr>
<td><code>meminfo</code></td>
<td><code>MemBinder</code></td>
<td>dump系统中每个进程的内存使用状况的服务</td>
</tr>
<tr>
<td><code>gfxinfo</code></td>
<td><code>GraphicsBinder</code></td>
<td>dump系统中每个进程使用图形加速卡状态的服务</td>
</tr>
<tr>
<td><code>dbinfo</code></td>
<td><code>DbBinder</code></td>
<td>dump 系统中每个进程的db状况的服务</td>
</tr>
<tr>
<td><code>permission</code></td>
<td><code>PermissionController</code></td>
<td>是检查Binder调用权限的服务</td>
</tr>
<tr>
<td><code>processinfo</code></td>
<td><code>ProcessInfoService</code></td>
<td>进程信息</td>
</tr>
</tbody>
</table>
<p>这些服务我们先不细看，后面遇到了，再具体分析！</p>
<h3 id="1-4-2-处理-framework-res-apk"><a href="#1-4-2-处理-framework-res-apk" class="headerlink" title="1.4.2 处理 framework-res.apk"></a>1.4.2 处理 framework-res.apk</h3><p>接着，处理 <code>framework-res.apk</code> 安装包，在 <code>PMS</code> 的启动过程中，<code>PackageManagerService</code> 会扫描 <code>framework-res.apk</code> 的信息，并将信息封装成 <code>ApplicaitonInfo</code> 并保存在一个集合中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mSystemThread.installSystemApplicationInfo(info, getClass().getClassLoader());</span><br></pre></td></tr></table></figure></p>
<p><code>mSystemThread</code> 对象是 <code>ActvityThread</code> 实例，每一个进程都有一个 <code>ActivityThread</code>  对象，内部保存着进程的主线程对象，这里保存着 <code>SystemServer</code>进程的主线程对象！</p>
<p>我们继续看方法调用：</p>
<h4 id="1-4-2-1-ActivityThread-installSystemApplicaitonInfo"><a href="#1-4-2-1-ActivityThread-installSystemApplicaitonInfo" class="headerlink" title="1.4.2.1 ActivityThread.installSystemApplicaitonInfo"></a>1.4.2.1 ActivityThread.installSystemApplicaitonInfo</h4><p>我们进入 <code>ActivityThread</code> 的 <code>installSystemApplicationInfo</code> 的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">installSystemApplicationInfo</span><span class="params">(ApplicationInfo info, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【1】调用 ContextImpl 对象的 installSystemApplicationInfo 方法！</span></span><br><span class="line">        getSystemContext().installSystemApplicationInfo(info, classLoader);</span><br><span class="line">        mProfiler = <span class="keyword">new</span> Profiler();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>getSystemContext</code> 方法获得的是系统进程的 <code>Context</code> 对象，<code>Context</code> 的具体实现是 <code>ContextImpl</code> 类！</p>
<h4 id="1-4-2-2-ContextImpl-installSystemApplicaitonInfo"><a href="#1-4-2-2-ContextImpl-installSystemApplicaitonInfo" class="headerlink" title="1.4.2.2 ContextImpl.installSystemApplicaitonInfo"></a>1.4.2.2 ContextImpl.installSystemApplicaitonInfo</h4><p>进入 <code>ContextImpl</code> 对象中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">installSystemApplicationInfo</span><span class="params">(ApplicationInfo info, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】调用 LoadedApk.installSystemApplicationInfo 方法；</span></span><br><span class="line">    mPackageInfo.installSystemApplicationInfo(info, classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中 <code>mPackageInfo</code> 是 <code>LoadedApk</code> 对象，这里的 <code>LoadedApk</code> 是属于 <code>SystemServer</code> 进程的：</p>
<h4 id="1-4-2-3-LoadedAPK-installSystemApplicaitonInfo"><a href="#1-4-2-3-LoadedAPK-installSystemApplicaitonInfo" class="headerlink" title="1.4.2.3 LoadedAPK.installSystemApplicaitonInfo"></a>1.4.2.3 LoadedAPK.installSystemApplicaitonInfo</h4><p>最后，将 <code>framework-res.apk</code> 的安装信息，保存到 <code>SystemServer</code> 进程的主线程的 <code>LoadedAPK</code> 对象中！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">installSystemApplicationInfo</span><span class="params">(ApplicationInfo info, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> info.packageName.equals(<span class="string">"android"</span>);</span><br><span class="line">    mApplicationInfo = info;</span><br><span class="line">    mClassLoader = classLoader;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>每一个进程都会有一个 <code>LoadedApk</code> 对象，最后 <code>ApplicationInfo</code> 和 <code>ClassLoader</code> 设置到了 <code>LoadedApk</code> 对象中！</p>
<h3 id="1-4-3-newProcessRecordLocked"><a href="#1-4-3-newProcessRecordLocked" class="headerlink" title="1.4.3 newProcessRecordLocked"></a>1.4.3 newProcessRecordLocked</h3><p>接下来，创建系统进程对应的 <code>ProcessRecord</code> 对象，传入参数：</p>
<ul>
<li><code>info</code>：<code>&quot;framework-res.apk&quot;</code> 的 <code>ApplicationInfo</code> 对象！</li>
<li><code>customProcess</code>：<code>info.processName</code>，所在进程名！</li>
<li><code>isolated</code>：传入 <code>false</code>，表示不是隔离进程！</li>
<li><code>isolatedUid</code>：传入 <code>0</code>，表示隔离进程的 <code>uid</code>；</li>
</ul>
<p><code>isolated</code> 和 <code>isolatedUid</code> 用来表示这进程是不是一个隔离进程！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ProcessRecord <span class="title">newProcessRecordLocked</span><span class="params">(ApplicationInfo info, String customProcess,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> isolated, <span class="keyword">int</span> isolatedUid)</span> </span>&#123;</span><br><span class="line">    String proc = customProcess != <span class="keyword">null</span> ? customProcess : info.processName;</span><br><span class="line">    BatteryStatsImpl stats = mBatteryStatsService.getActiveStatistics();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> userId = UserHandle.getUserId(info.uid); <span class="comment">// 获得所属的设备用户！</span></span><br><span class="line">    <span class="keyword">int</span> uid = info.uid;</span><br><span class="line">    <span class="keyword">if</span> (isolated) &#123; <span class="comment">// isolated 为 false, 不进入这个分支!</span></span><br><span class="line">        <span class="keyword">if</span> (isolatedUid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> stepsLeft = Process.LAST_ISOLATED_UID - Process.FIRST_ISOLATED_UID + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mNextIsolatedProcessUid &lt; Process.FIRST_ISOLATED_UID</span><br><span class="line">                        || mNextIsolatedProcessUid &gt; Process.LAST_ISOLATED_UID) &#123;</span><br><span class="line">                    mNextIsolatedProcessUid = Process.FIRST_ISOLATED_UID;</span><br><span class="line">                &#125;</span><br><span class="line">                uid = UserHandle.getUid(userId, mNextIsolatedProcessUid);</span><br><span class="line">                mNextIsolatedProcessUid++;</span><br><span class="line">                <span class="keyword">if</span> (mIsolatedProcesses.indexOfKey(uid) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// No process for this uid, use it.</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                stepsLeft--;</span><br><span class="line">                <span class="keyword">if</span> (stepsLeft &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Special case for startIsolatedProcess (internal only), where</span></span><br><span class="line">            <span class="comment">// the uid of the isolated process is specified by the caller.</span></span><br><span class="line">            uid = isolatedUid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】创建 ProcessRecord，用于存储系统进程的信息</span></span><br><span class="line">    <span class="keyword">final</span> ProcessRecord r = <span class="keyword">new</span> ProcessRecord(stats, info, proc, uid);</span><br><span class="line">    <span class="keyword">if</span> (!mBooted &amp;&amp; !mBooting</span><br><span class="line">            &amp;&amp; userId == UserHandle.USER_SYSTEM</span><br><span class="line">            &amp;&amp; (info.flags &amp; PERSISTENT_MASK) == PERSISTENT_MASK) &#123;</span><br><span class="line">        r.persistent = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】保存系统进程 ProcessRecord 对象到 AMS 的结构体中！</span></span><br><span class="line">    addProcessNameLocked(r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接着，调用 <code>addProcessNameLocked</code> 方法：</p>
<h4 id="1-4-3-1-addProcessNameLocked"><a href="#1-4-3-1-addProcessNameLocked" class="headerlink" title="1.4.3.1 addProcessNameLocked"></a>1.4.3.1 addProcessNameLocked</h4><p>保存系统进程 <code>ProcessRecord</code> 对象到 <code>AMS</code> 的结构体中！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addProcessNameLocked</span><span class="params">(ProcessRecord proc)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】如果已经有了相同的 ProcessRecord 对象，移除旧的！</span></span><br><span class="line">    ProcessRecord old = removeProcessNameLocked(proc.processName, proc.uid);</span><br><span class="line">    <span class="keyword">if</span> (old == proc &amp;&amp; proc.persistent) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"Re-adding persistent process "</span> + proc);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (old != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Slog.wtf(TAG, <span class="string">"Already have existing proc "</span> + old + <span class="string">" when adding "</span> + proc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】创建 UidRecord 用来保存活跃的 uid，如果已经存在，就不创建！</span></span><br><span class="line">    UidRecord uidRec = mActiveUids.get(proc.uid); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (uidRec == <span class="keyword">null</span>) &#123;</span><br><span class="line">        uidRec = <span class="keyword">new</span> UidRecord(proc.uid);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This is the first appearance of the uid, report it now!</span></span><br><span class="line">        <span class="keyword">if</span> (DEBUG_UID_OBSERVERS) Slog.i(TAG_UID_OBSERVERS,</span><br><span class="line">                <span class="string">"Creating new process uid: "</span> + uidRec);</span><br><span class="line">                </span><br><span class="line">        <span class="comment">// 添加到 mActiveUids 对象！</span></span><br><span class="line">        mActiveUids.put(proc.uid, uidRec);</span><br><span class="line">        noteUidProcessState(uidRec.uid, uidRec.curProcState);</span><br><span class="line">        enqueueUidChangeLocked(uidRec, -<span class="number">1</span>, UidRecord.CHANGE_ACTIVE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    proc.uidRecord = uidRec;</span><br><span class="line">    uidRec.numProcs++; <span class="comment">// 所属该 uid 的进程计数加 1 （uid 代表一个应用程序）</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【3】非隔离进程保存到 mProcessNames 集合中，隔离进程保存到 mIsolatedProcesses 中！</span></span><br><span class="line">    mProcessNames.put(proc.processName, proc.uid, proc); </span><br><span class="line">    <span class="keyword">if</span> (proc.isolated) &#123;</span><br><span class="line">        mIsolatedProcesses.put(proc.uid, proc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="1-4-4-ProcessRecord-makeActive"><a href="#1-4-4-ProcessRecord-makeActive" class="headerlink" title="1.4.4 ProcessRecord.makeActive"></a>1.4.4 ProcessRecord.makeActive</h3><p>参数传递：</p>
<ul>
<li><code>thread</code>：<code>mSystemThread.getApplicationThread()</code>，系统进程的 <code>ApplicationThread</code> 对象！</li>
<li><code>tracker</code>：<code>mProcessStats</code>，是 <code>ProcessStatsService</code> 服务对象，用来监听进程的状态！</li>
</ul>
<p><br></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeActive</span><span class="params">(IApplicationThread _thread, ProcessStatsService tracker)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第一次进来，为null！</span></span><br><span class="line">    <span class="keyword">if</span> (thread == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【1】将旧的 ProcessState 对象设置为非活跃状态！</span></span><br><span class="line">        <span class="keyword">final</span> ProcessState origBase = baseProcessTracker; </span><br><span class="line">        <span class="keyword">if</span> (origBase != <span class="keyword">null</span>) &#123;</span><br><span class="line">            origBase.setState(ProcessStats.STATE_NOTHING,</span><br><span class="line">                    tracker.getMemFactorLocked(), SystemClock.uptimeMillis(), pkgList);</span><br><span class="line">            origBase.makeInactive();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 为系统进程创建新的 ProcessState 监听对象，并设置其为活跃状态！</span></span><br><span class="line">        <span class="comment">// info 为改应用程序所属的应用程序！</span></span><br><span class="line">        baseProcessTracker = tracker.getProcessStateLocked(info.packageName, uid,</span><br><span class="line">                info.versionCode, processName);</span><br><span class="line">        baseProcessTracker.makeActive();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;pkgList.size(); i++) &#123;</span><br><span class="line">            ProcessStats.ProcessStateHolder holder = pkgList.valueAt(i);</span><br><span class="line">            <span class="keyword">if</span> (holder.state != <span class="keyword">null</span> &amp;&amp; holder.state != origBase) &#123;</span><br><span class="line">                holder.state.makeInactive();</span><br><span class="line">            &#125;</span><br><span class="line">            holder.state = tracker.getProcessStateLocked(pkgList.keyAt(i), uid,</span><br><span class="line">                    info.versionCode, processName);</span><br><span class="line">            <span class="keyword">if</span> (holder.state != baseProcessTracker) &#123;</span><br><span class="line">                holder.state.makeActive();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【2】将系统进程的 ActivityThread 保存到 ProcessRecord.thread，完成引用关系！</span></span><br><span class="line">    thread = _thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上是在 <code>SystemServer</code> 启动系统服务的第一阶段做的一些主要的工作，接下来，我们来看第二阶段！</p>
<h1 id="2-第二阶段-startCoreServices"><a href="#2-第二阶段-startCoreServices" class="headerlink" title="2 第二阶段 - startCoreServices"></a>2 第二阶段 - startCoreServices</h1><p>接下来，看看第二阶段的代码段：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startCoreServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 启动电池服务,必须是在 lightService 后启动 ；</span></span><br><span class="line">    mSystemServiceManager.startService(BatteryService.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】启动应用统计服务，用于监控应用的使用频率等信息，并使得 AMS 持有其引用！</span></span><br><span class="line">    mSystemServiceManager.startService(UsageStatsService.class);</span><br><span class="line">    mActivityManagerService.setUsageStatsManager(</span><br><span class="line">            LocalServices.getService(UsageStatsManagerInternal.class));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动 WebView 更新服务，这里不关注！</span></span><br><span class="line">    mWebViewUpdateService = mSystemServiceManager.startService(WebViewUpdateService.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里我们看看 <code>setUsageStatsManager</code></p>
<h2 id="2-1-setUsageStatsManager"><a href="#2-1-setUsageStatsManager" class="headerlink" title="2.1 setUsageStatsManager"></a>2.1 setUsageStatsManager</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsageStatsManager</span><span class="params">(UsageStatsManagerInternal usageStatsManager)</span> </span>&#123;</span><br><span class="line">    mUsageStatsService = usageStatsManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法主要的作用是：</p>
<ul>
<li>设置应用统计服务的应用，用于监控应用的使用频率等信息！</li>
</ul>
<h1 id="3-第三阶段-startOtherServices"><a href="#3-第三阶段-startOtherServices" class="headerlink" title="3 第三阶段 - startOtherServices"></a>3 第三阶段 - startOtherServices</h1><p>这里就要进入开机的最后阶段了，<code>startOtherServices</code> 方法非常的长，这里只列举和 <code>ams</code> 相关的代码！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startOtherServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        ... ... ... ...</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【1】安装系统进程的 provider！</span></span><br><span class="line">        traceBeginAndSlog(<span class="string">"InstallSystemProviders"</span>);</span><br><span class="line">        mActivityManagerService.installSystemProviders();</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);</span><br><span class="line"></span><br><span class="line">        ... ... ... ...</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化 watch dog 实例！</span></span><br><span class="line">        traceBeginAndSlog(<span class="string">"InitWatchdog"</span>);</span><br><span class="line">        <span class="keyword">final</span> Watchdog watchdog = Watchdog.getInstance();</span><br><span class="line">        watchdog.init(context, mActivityManagerService);</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 启动 InputManagerService 和 WindowManagerService 服务！</span></span><br><span class="line">        traceBeginAndSlog(<span class="string">"StartInputManagerService"</span>);</span><br><span class="line">        inputManager = <span class="keyword">new</span> InputManagerService(context);</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);</span><br><span class="line"></span><br><span class="line">        traceBeginAndSlog(<span class="string">"StartWindowManagerService"</span>);</span><br><span class="line">        wm = WindowManagerService.main(context, inputManager,</span><br><span class="line">                mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL,</span><br><span class="line">                !mFirstBoot, mOnlyCore);</span><br><span class="line">        ServiceManager.addService(Context.WINDOW_SERVICE, wm);</span><br><span class="line">        ServiceManager.addService(Context.INPUT_SERVICE, inputManager);</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);</span><br><span class="line">        </span><br><span class="line">        ... ... ... ...</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【2】将 WMS 的引用实例保存到 ams 中！</span></span><br><span class="line">        mActivityManagerService.setWindowManager(wm);</span><br><span class="line"></span><br><span class="line">        inputManager.setWindowManagerCallbacks(wm.getInputMonitor());</span><br><span class="line">        inputManager.start();</span><br><span class="line"></span><br><span class="line">        ... ... ... ...</span><br><span class="line">   </span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        Slog.e(<span class="string">"System"</span>, <span class="string">"******************************************"</span>);</span><br><span class="line">        Slog.e(<span class="string">"System"</span>, <span class="string">"************ Failure starting core service"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ... ... ... ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        wm.displayReady();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        reportWtf(<span class="string">"making display ready"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ... ... ... ...  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        wm.systemReady();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        reportWtf(<span class="string">"making Window Manager Service ready"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (safeMode) &#123;</span><br><span class="line">        mActivityManagerService.showSafeModeOverlay();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新显示相关的配置！</span></span><br><span class="line">    Configuration config = wm.computeNewConfiguration();</span><br><span class="line">    DisplayMetrics metrics = <span class="keyword">new</span> DisplayMetrics();</span><br><span class="line">    WindowManager w = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE);</span><br><span class="line">    w.getDefaultDisplay().getMetrics(metrics);</span><br><span class="line">    context.getResources().updateConfiguration(config, metrics);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置系统主题，因为可能依赖显示配置！</span></span><br><span class="line">    <span class="keyword">final</span> Theme systemTheme = context.getTheme();</span><br><span class="line">    <span class="keyword">if</span> (systemTheme.getChangingConfigurations() != <span class="number">0</span>) &#123;</span><br><span class="line">        systemTheme.rebase();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ... ... ... ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【3】进入 AMS 的 systemReady 方法，Runnable 任务中只要是启动一些其他的服务，这里我就省略了！</span></span><br><span class="line">    mActivityManagerService.systemReady(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Slog.i(TAG, <span class="string">"Making services ready"</span>);</span><br><span class="line">            ... ... ... ...</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 开始监听 native crash！</span></span><br><span class="line">                mActivityManagerService.startObservingNativeCrashes();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                reportWtf(<span class="string">"observing native crashes"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);</span><br><span class="line"></span><br><span class="line">            ... ... ... ...</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 启动 watch dog！</span></span><br><span class="line">            Watchdog.getInstance().start();</span><br><span class="line"></span><br><span class="line">            ... ... ... ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="3-1-AMS-installSystemProviders"><a href="#3-1-AMS-installSystemProviders" class="headerlink" title="3.1 AMS.installSystemProviders"></a>3.1 AMS.installSystemProviders</h2><p>安装系统数据库：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">installSystemProviders</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;ProviderInfo&gt; providers;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//【1】获取系统进程的 ProcessRecord, 之前 setSystemProcess() 时，创建了系统进程对应的 ProcessRecord</span></span><br><span class="line">        ProcessRecord app = mProcessNames.get(<span class="string">"system"</span>, Process.SYSTEM_UID);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【2】生成 ProviderInfo 的列表！</span></span><br><span class="line">        providers = generateApplicationProvidersLocked(app);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (providers != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=providers.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">                ProviderInfo pi = (ProviderInfo)providers.get(i);</span><br><span class="line">                <span class="keyword">if</span> ((pi.applicationInfo.flags&amp;ApplicationInfo.FLAG_SYSTEM) == <span class="number">0</span>) &#123;</span><br><span class="line">                    Slog.w(TAG, <span class="string">"Not installing system proc provider "</span> + pi.name</span><br><span class="line">                            + <span class="string">": not system .apk"</span>);</span><br><span class="line">                            </span><br><span class="line">                    <span class="comment">//【2.1】移除一些非系统的 provider！</span></span><br><span class="line">                    providers.remove(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (providers != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【3】调用系统进程的 ActivityThread 的 installSystemProviders 方法，安装系统进程的数据库！</span></span><br><span class="line">        mSystemThread.installSystemProviders(providers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mCoreSettingsObserver = <span class="keyword">new</span> CoreSettingsObserver(<span class="keyword">this</span>);</span><br><span class="line">    mFontScaleSettingObserver = <span class="keyword">new</span> FontScaleSettingObserver();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//mUsageStatsService.monitorPackages();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里指定了进程名为 <code>system</code>，进程 <code>uid</code> 为 <code>Process.SYSTEM_UID</code>，一般来说，会有以下 <code>Provider</code> 会出现在返回结果中：</p>
<ul>
<li><code>framework-res.apk</code> 中的 <code>Provider</code>, 定义在：<code>frameworks/base/core/res/AndroidManifest.xml</code></li>
<li><code>SettingsProvider.apk</code> 中的 <code>Provider</code>, 定义在：<code>frameworks/base/packages/SettingsProvider/AndroidManifest.xml</code></li>
</ul>
<p>对于手机厂商，可以对系统 <code>apk</code> 进行定制，比如让系统 <code>apk</code> 共享系统 <code>uid</code>，这样的话，就不止以上两种 <code>provider</code> 了！</p>
<h3 id="3-1-1-AMS-generateApplicationProvidersLocked"><a href="#3-1-1-AMS-generateApplicationProvidersLocked" class="headerlink" title="3.1.1 AMS.generateApplicationProvidersLocked"></a>3.1.1 AMS.generateApplicationProvidersLocked</h3><p>参数传递：</p>
<ul>
<li><code>ProcessRecord app</code>：系统进程的 <code>ProcessRecord</code> 对象！</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;ProviderInfo&gt; <span class="title">generateApplicationProvidersLocked</span><span class="params">(ProcessRecord app)</span> </span>&#123;</span><br><span class="line">    List&lt;ProviderInfo&gt; providers = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//【1】通过 PackageManagerService 获得系统进程的 provider！</span></span><br><span class="line">        providers = AppGlobals.getPackageManager()</span><br><span class="line">                .queryContentProviders(app.processName, app.uid,</span><br><span class="line">                        STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS</span><br><span class="line">                                | MATCH_DEBUG_TRIAGED_MISSING)</span><br><span class="line">                .getList();</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (DEBUG_MU) Slog.v(TAG_MU,</span><br><span class="line">            <span class="string">"generateApplicationProvidersLocked, app.info.uid = "</span> + app.uid);</span><br><span class="line">            </span><br><span class="line">    <span class="comment">//【2】将 Provider 和 ProcessRecord 绑定！        </span></span><br><span class="line">    <span class="keyword">int</span> userId = app.userId;</span><br><span class="line">    <span class="keyword">if</span> (providers != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> N = providers.size();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【2.1】确保 ProcessRecord 中的 Provider 映射表的容量！</span></span><br><span class="line">        app.pubProviders.ensureCapacity(N + app.pubProviders.size());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 遍历 ProviderInfo 列表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">            ProviderInfo cpi = (ProviderInfo) providers.get(i);</span><br><span class="line">            <span class="comment">// 判断是否是单例模式！</span></span><br><span class="line">            <span class="keyword">boolean</span> singleton = isSingleton(cpi.processName, cpi.applicationInfo,</span><br><span class="line">                    cpi.name, cpi.flags);</span><br><span class="line">                    </span><br><span class="line">            <span class="comment">// 如果是单例模式的 provider，且其 uid 不是 system，跳过该 provider！</span></span><br><span class="line">            <span class="keyword">if</span> (singleton &amp;&amp; UserHandle.getUserId(app.uid) != UserHandle.USER_SYSTEM) &#123;</span><br><span class="line">                providers.remove(i);</span><br><span class="line">                N--;</span><br><span class="line">                i--;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">  </span><br><span class="line">            <span class="comment">//【2.2】如果 mProviderMap 中不存在 ContentProviderRecord 对象，则新建一个！</span></span><br><span class="line">            ComponentName comp = <span class="keyword">new</span> ComponentName(cpi.packageName, cpi.name);</span><br><span class="line">            ContentProviderRecord cpr = mProviderMap.getProviderByClass(comp, userId);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (cpr == <span class="keyword">null</span>) &#123;</span><br><span class="line">                cpr = <span class="keyword">new</span> ContentProviderRecord(<span class="keyword">this</span>, cpi, app.info, comp, singleton);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//【2.3】添加到 AMS.mProciderMap 管理集合中；</span></span><br><span class="line">                mProviderMap.putProviderByClass(comp, cpr);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (DEBUG_MU) Slog.v(TAG_MU,</span><br><span class="line">                    <span class="string">"generateApplicationProvidersLocked, cpi.uid = "</span> + cpr.uid);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//【2.4】将当前的 provider 保存到系统进程的 ProcessRecord 的 pubProviders 中；</span></span><br><span class="line">            app.pubProviders.put(cpi.name, cpr);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!cpi.multiprocess || !<span class="string">"android"</span>.equals(cpi.packageName)) &#123;</span><br><span class="line">                app.addPackage(cpi.applicationInfo.packageName, cpi.applicationInfo.versionCode,</span><br><span class="line">                        mProcessStats);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            notifyPackageUse(cpi.applicationInfo.packageName,</span><br><span class="line">                             PackageManager.NOTIFY_PACKAGE_USE_CONTENT_PROVIDER);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> providers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们通过一张类图，简单的了解一下 <code>AMS</code> 是如何管理 <code>ContentProvider</code> 的：</p>
<p><img src="http://static.zybuluo.com/Coolqi/d5jopu5clkmnagqeu47jldl5/AMS%E7%AE%A1%E7%90%86provider.png" alt="AMS管理provider.png-66.2kB"></p>
<ul>
<li><p><code>AMS</code> 为每一个 <code>ContentProvider</code> 创建了一个 <code>ContentProviderRecord</code> 对象，<code>ContentProviderRecord</code> 中保存着 <code>provider</code> 的配置信息 <code>providerInfo</code>；<code>provider</code> 所属进程的 <code>uid</code>；<code>provider</code> 所属应用的 <code>ApplicaitonInfo</code> 对象！</p>
</li>
<li><p><code>AMS</code> 的 <code>mProviderMap</code> 对象管理着系统中所有的 <code>ContentProviderRecord</code> 对象，其内部保存着 <code>Authority</code> 或者 <code>CompnentName</code> 到指定 <code>ContentProviderRecord</code> 的映射！</p>
</li>
<li><p><code>AMS</code> 内部还维护着和 <code>ProcessRecord</code> 相关的集合，用于管理进程，有前台进程集合，内存常驻进程集合，最近使用的进程等等，当 <code>AMS</code> 将一个 <code>ContentProviderRecord</code> 与 <code>ProcessRecord</code> 关联时，会将它保存到 <code>ProcessRecord</code> 内部的一个 <code>pubProviders</code> 集合中！</p>
</li>
</ul>
<h3 id="3-1-2-ActivityThread-installSystemProviders"><a href="#3-1-2-ActivityThread-installSystemProviders" class="headerlink" title="3.1.2 ActivityThread.installSystemProviders"></a>3.1.2 ActivityThread.installSystemProviders</h3><p>接着调用 <code>systemserver</code> 进程的 <code>ActivityThread</code> 的 <code>installSystemProvider</code> 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">installSystemProviders</span><span class="params">(List&lt;ProviderInfo&gt; providers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (providers != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【1】mInitialApplication 是 SystemServer 的进程的 Application 对象！</span></span><br><span class="line">        installContentProviders(mInitialApplication, providers);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的 <code>mInitialApplication</code> 是系统进程的 <code>Application</code> 对象，接着调用了 <code>installContentProviders</code> 方法！</p>
<h3 id="3-1-3-ActivityThread-installContentProviders"><a href="#3-1-3-ActivityThread-installContentProviders" class="headerlink" title="3.1.3 ActivityThread.installContentProviders"></a>3.1.3 ActivityThread.installContentProviders</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">installContentProviders</span><span class="params">(Context context, List&lt;ProviderInfo&gt; providers)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ArrayList&lt;IActivityManager.ContentProviderHolder&gt; results =</span><br><span class="line">        <span class="keyword">new</span> ArrayList&lt;IActivityManager.ContentProviderHolder&gt;();</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//【1】遍历系统进程的所有 provider，为每一个 provider 创建对应的 ContentProviderHolder 对象！</span></span><br><span class="line">    <span class="keyword">for</span> (ProviderInfo cpi : providers) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_PROVIDER) &#123;</span><br><span class="line">            StringBuilder buf = <span class="keyword">new</span> StringBuilder(<span class="number">128</span>);</span><br><span class="line">            buf.append(<span class="string">"Pub "</span>);</span><br><span class="line">            buf.append(cpi.authority);</span><br><span class="line">            buf.append(<span class="string">": "</span>);</span><br><span class="line">            buf.append(cpi.name);</span><br><span class="line">            Log.i(TAG, buf.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【1.1】将每一个 ProviderInfo 封装为一个 ContentProviderHolder 对象！</span></span><br><span class="line">        IActivityManager.ContentProviderHolder cph = installProvider(context, <span class="keyword">null</span>, cpi,</span><br><span class="line">                <span class="keyword">false</span> <span class="comment">/*noisy*/</span>, <span class="keyword">true</span> <span class="comment">/*noReleaseNeeded*/</span>, <span class="keyword">true</span> <span class="comment">/*stable*/</span>);</span><br><span class="line">        <span class="keyword">if</span> (cph != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cph.noReleaseNeeded = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加到集合中！</span></span><br><span class="line">            results.add(cph);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【2】调用 AMS 的 publish 方法， 注册 ContentProvider</span></span><br><span class="line">        ActivityManagerNative.getDefault().publishContentProviders(</span><br><span class="line">            getApplicationThread(), results);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有 <code>ContentProvider</code> 的创建都需要经过 <code>installContentProvider()</code> 函数，这个地方调用了 <code>ActivityThread.installProvider</code> 方法，继续安装 <code>provider</code>!</p>
<h4 id="3-1-3-1-ActivityThread-installProvider"><a href="#3-1-3-1-ActivityThread-installProvider" class="headerlink" title="3.1.3.1 ActivityThread.installProvider"></a>3.1.3.1 ActivityThread.installProvider</h4><p>让我们来继续看看这部分的代码 <code>installProvider</code>，参数传递：</p>
<ul>
<li><code>Context context</code>：传入 <code>context</code> 对象，这里的 <code>context</code> 是 <code>mInitialApplication</code> 对象，是系统进程的上下文运行环境；</li>
<li><code>IActivityManager.ContentProviderHolder holder</code>：传入 <strong><code>null</code></strong>；</li>
<li><code>ProviderInfo info</code>：传入 <code>ProviderInfo</code> 对象，封装着 <code>provider</code> 的信息；</li>
<li><code>boolean noisy</code>：传入 <strong><code>false</code></strong>；</li>
<li><code>boolean noReleaseNeeded</code>：传入 <strong><code>true</code></strong>；</li>
<li><code>boolean stable</code>：传入 <strong><code>true</code></strong>；</li>
</ul>
<p>接着来看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> IActivityManager.<span class="function">ContentProviderHolder <span class="title">installProvider</span><span class="params">(Context context,</span></span></span><br><span class="line"><span class="function"><span class="params">        IActivityManager.ContentProviderHolder holder, ProviderInfo info,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> noisy, <span class="keyword">boolean</span> noReleaseNeeded, <span class="keyword">boolean</span> stable)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ContentProvider localProvider = <span class="keyword">null</span>;</span><br><span class="line">    IContentProvider provider;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (holder == <span class="keyword">null</span> || holder.provider == <span class="keyword">null</span>) &#123; <span class="comment">// 进入这个分支!</span></span><br><span class="line">        <span class="keyword">if</span> (DEBUG_PROVIDER || noisy) &#123;</span><br><span class="line">            Slog.d(TAG, <span class="string">"Loading provider "</span> + info.authority + <span class="string">": "</span></span><br><span class="line">                    + info.name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Context c = <span class="keyword">null</span>;</span><br><span class="line">        ApplicationInfo ai = info.applicationInfo;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【1】通过包名，找到和 provider 匹配的 context！</span></span><br><span class="line">        <span class="comment">// 如果当前已有的运行环境 Context 不匹配的话，就会创建一个新的 Context！</span></span><br><span class="line">        <span class="keyword">if</span> (context.getPackageName().equals(ai.packageName)) &#123;</span><br><span class="line">            c = context;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mInitialApplication != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                mInitialApplication.getPackageName().equals(ai.packageName)) &#123;</span><br><span class="line">            c = mInitialApplication;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                c = context.createPackageContext(ai.packageName,</span><br><span class="line">                        Context.CONTEXT_INCLUDE_CODE);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// Ignore</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Unable to get context for package "</span> +</span><br><span class="line">                  ai.packageName +</span><br><span class="line">                  <span class="string">" while loading content provider "</span> +</span><br><span class="line">                  info.name);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【2】根据包名，通过反射创建新的 ContentProvider 对象！</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> java.lang.ClassLoader cl = c.getClassLoader();</span><br><span class="line">            localProvider = (ContentProvider)cl.</span><br><span class="line">                loadClass(info.name).newInstance();</span><br><span class="line">            provider = localProvider.getIContentProvider();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (provider == <span class="keyword">null</span>) &#123;</span><br><span class="line">                Slog.e(TAG, <span class="string">"Failed to instantiate class "</span> +</span><br><span class="line">                      info.name + <span class="string">" from sourceDir "</span> +</span><br><span class="line">                      info.applicationInfo.sourceDir);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (DEBUG_PROVIDER) Slog.v(</span><br><span class="line">                TAG, <span class="string">"Instantiating local provider "</span> + info.name);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//【2.1】将创建的 provider 和 providerInfo 数据进行绑定；</span></span><br><span class="line">            <span class="comment">// 这个方法对 provider 会做初始化，</span></span><br><span class="line">            localProvider.attachInfo(c, info);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (java.lang.Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mInstrumentation.onException(<span class="keyword">null</span>, e)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                        <span class="string">"Unable to get provider "</span> + info.name</span><br><span class="line">                        + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        provider = holder.provider;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_PROVIDER) Slog.v(TAG, <span class="string">"Installing external provider "</span> + info.authority + <span class="string">": "</span></span><br><span class="line">                + info.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【3】设置对应的 ContentProviderHolder 对象！</span></span><br><span class="line">    IActivityManager.ContentProviderHolder retHolder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mProviderMap) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_PROVIDER) Slog.v(TAG, <span class="string">"Checking to add "</span> + provider</span><br><span class="line">                + <span class="string">" / "</span> + info.name);</span><br><span class="line"></span><br><span class="line">        IBinder jBinder = provider.asBinder();</span><br><span class="line">        <span class="keyword">if</span> (localProvider != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ComponentName cname = <span class="keyword">new</span> ComponentName(info.packageName, info.name);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 尝试获得对应的 ProviderClientRecord 对象！</span></span><br><span class="line">            ProviderClientRecord pr = mLocalProvidersByName.get(cname);</span><br><span class="line">            <span class="keyword">if</span> (pr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_PROVIDER) &#123;</span><br><span class="line">                    Slog.v(TAG, <span class="string">"installProvider: lost the race, "</span></span><br><span class="line">                            + <span class="string">"using existing local provider"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                provider = pr.mProvider;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 创建一个新的 ContentProviderHolder 对象!</span></span><br><span class="line">                holder = <span class="keyword">new</span> IActivityManager.ContentProviderHolder(info);</span><br><span class="line">                holder.provider = provider;</span><br><span class="line">                holder.noReleaseNeeded = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 创建一个新的 ProviderClientRecord 对象，并将映射关系保存起来！</span></span><br><span class="line">                pr = installProviderAuthoritiesLocked(provider, localProvider, holder);</span><br><span class="line">                mLocalProviders.put(jBinder, pr);</span><br><span class="line">                mLocalProvidersByName.put(cname, pr);</span><br><span class="line">            &#125;</span><br><span class="line">            retHolder = pr.mHolder;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ProviderRefCount prc = mProviderRefCountMap.get(jBinder);</span><br><span class="line">            <span class="keyword">if</span> (prc != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_PROVIDER) &#123;</span><br><span class="line">                    Slog.v(TAG, <span class="string">"installProvider: lost the race, updating ref count"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!noReleaseNeeded) &#123;</span><br><span class="line">                    incProviderRefLocked(prc, stable);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        ActivityManagerNative.getDefault().removeContentProvider(</span><br><span class="line">                                holder.connection, stable);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                        <span class="comment">// do nothing content provider object is dead any way</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ProviderClientRecord client = installProviderAuthoritiesLocked(</span><br><span class="line">                        provider, localProvider, holder);</span><br><span class="line">                <span class="keyword">if</span> (noReleaseNeeded) &#123;</span><br><span class="line">                    prc = <span class="keyword">new</span> ProviderRefCount(holder, client, <span class="number">1000</span>, <span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    prc = stable</span><br><span class="line">                            ? <span class="keyword">new</span> ProviderRefCount(holder, client, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">                            : <span class="keyword">new</span> ProviderRefCount(holder, client, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                mProviderRefCountMap.put(jBinder, prc);</span><br><span class="line">            &#125;</span><br><span class="line">            retHolder = prc.holder;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> retHolder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>首先，找到 <code>ProviderInfo</code> 对应的运行环境 <code>Context</code>：</p>
<ul>
<li>对于 <code>framework-res.apk</code> 中定义的 <code>com.android.server.am.DumpHeapProvider</code> 而言，重新设置的 <code>Context</code> 就是 <code>mInitialApplication</code>，所以就直接使用；</li>
<li>对于 <code>SettingProvider.apk</code> 中定义的 <code>SettingsProvider</code> 而言，它的包名为 <code>com.android.providers.settings</code>，不等于 <code>mInitialApplication</code> 的包名 <code>android</code>，所以，会通过 <code>Context.createPackageContext()</code> 函数创建一个新的 <code>Context</code> 实例！</li>
</ul>
</li>
<li><p>接着，反射创建 <code>ContentProvider</code> 对象，然后，根据反射对象 <code>ContentProvider</code>，创建对应的 <code>ContentProviderHolder</code> 对象！</p>
</li>
</ul>
<h4 id="3-1-3-2-AactivityManagerN-publishContentProviders"><a href="#3-1-3-2-AactivityManagerN-publishContentProviders" class="headerlink" title="3.1.3.2 AactivityManagerN.publishContentProviders"></a>3.1.3.2 AactivityManagerN.publishContentProviders</h4><p>最终会调用 <code>ActivityManagerService</code> 中的 <code>publishContentProviders</code> 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">publishContentProviders</span><span class="params">(IApplicationThread caller,</span></span></span><br><span class="line"><span class="function"><span class="params">        List&lt;ContentProviderHolder&gt; providers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (providers == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    enforceNotIsolatedCaller(<span class="string">"publishContentProviders"</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【1】获得调用者所在进程的 ProcessRecord 对象！</span></span><br><span class="line">        <span class="keyword">final</span> ProcessRecord r = getRecordForAppLocked(caller);</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_MU) Slog.v(TAG_MU, <span class="string">"ProcessRecord uid = "</span> + r.uid);</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(</span><br><span class="line">                    <span class="string">"Unable to find app for caller "</span> + caller</span><br><span class="line">                  + <span class="string">" (pid="</span> + Binder.getCallingPid()</span><br><span class="line">                  + <span class="string">") when publishing content providers"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【2】遍历传入的 ContentProviderHolder 集合！</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N = providers.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line"></span><br><span class="line">            ContentProviderHolder src = providers.get(i);</span><br><span class="line">            <span class="keyword">if</span> (src == <span class="keyword">null</span> || src.info == <span class="keyword">null</span> || src.provider == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从 ProcessRecord 中获得其对应的 ContentProviderRecord 对象！</span></span><br><span class="line">            ContentProviderRecord dst = r.pubProviders.get(src.info.name);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (DEBUG_MU) Slog.v(TAG_MU, <span class="string">"ContentProviderRecord uid = "</span> + dst.uid);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (dst != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                ComponentName comp = <span class="keyword">new</span> ComponentName(dst.info.packageName, dst.info.name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 将其保存到 AMS 的 mProviderMap 中！</span></span><br><span class="line">                mProviderMap.putProviderByClass(comp, dst);</span><br><span class="line">                String names[] = dst.info.authority.split(<span class="string">";"</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; names.length; j++) &#123;</span><br><span class="line">                    mProviderMap.putProviderByName(names[j], dst);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> launchingCount = mLaunchingProviders.size();</span><br><span class="line">                <span class="keyword">int</span> j;</span><br><span class="line">                <span class="keyword">boolean</span> wasInLaunchingProviders = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; launchingCount; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mLaunchingProviders.get(j) == dst) &#123;</span><br><span class="line">                        <span class="comment">// 从正在启动的 provider 列表中删除！</span></span><br><span class="line">                        mLaunchingProviders.remove(j);</span><br><span class="line">                        wasInLaunchingProviders = <span class="keyword">true</span>;</span><br><span class="line">                        j--;</span><br><span class="line">                        launchingCount--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (wasInLaunchingProviders) &#123;</span><br><span class="line">                    mHandler.removeMessages(CONTENT_PROVIDER_PUBLISH_TIMEOUT_MSG, r);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span> (dst) &#123;</span><br><span class="line">                    dst.provider = src.provider;</span><br><span class="line">                    dst.proc = r;</span><br><span class="line">                    dst.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 更新 ommAdj 值，用于 LMK！</span></span><br><span class="line">                updateOomAdjLocked(r);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 更新 provider 的使用状态！</span></span><br><span class="line">                maybeUpdateProviderUsageStatsLocked(r, src.info.packageName,</span><br><span class="line">                        src.info.authority);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>关于 <code>ContentProvider</code> 的实现原理，我后续会有对应的博文分析，这里就不多说了！</p>
<h3 id="3-1-3-阶段总结"><a href="#3-1-3-阶段总结" class="headerlink" title="3.1.3 阶段总结"></a>3.1.3 阶段总结</h3><p>我们总结一下：</p>
<ul>
<li><p>首先，获得系统进程的 <code>providerInfo</code> 列表！</p>
<ul>
<li>通过 PMS，获得系统进程的 <code>providerInfo</code> 列表；</li>
<li>确保系统进程 <code>ProcessRecord</code> 有足够的空间存储 <code>ContentProvider</code>；</li>
<li>然后，对找到的 <code>ProviderInfo</code> 列表进行遍历, 如有需要, 则新建一个 <code>ContentProviderRecord</code> 对象, 将其添加到 <code>AMS.mProviderMap</code> 中以方便管理；同时, 也需要将其添加到 <code>PrcoessRecord.mPubProviders</code> 中。</li>
<li>最后返回 <code>providerInfo</code> 列表；</li>
</ul>
</li>
<li><p>将 <code>provider</code> 注册到系统进程！</p>
</li>
</ul>
<h2 id="3-2-ActivityManagerS-setWindowManager"><a href="#3-2-ActivityManagerS-setWindowManager" class="headerlink" title="3.2 ActivityManagerS.setWindowManager"></a>3.2 ActivityManagerS.setWindowManager</h2><p>接着是就是设置 <code>wms</code> 的引用对象！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setWindowManager</span><span class="params">(WindowManagerService wm)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mService) &#123;</span><br><span class="line">        <span class="comment">//【1】设置 wms 引用实例</span></span><br><span class="line">        mWindowManager = wm;</span><br><span class="line">        <span class="comment">//【2】获得 dms 的引用实力，并将 ams 注册进入 dms！</span></span><br><span class="line">        mDisplayManager =</span><br><span class="line">                (DisplayManager)mService.mContext.getSystemService(Context.DISPLAY_SERVICE);</span><br><span class="line">        mDisplayManager.registerDisplayListener(<span class="keyword">this</span>, <span class="keyword">null</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【3】通过 dms 获得是当前安卓设备所有有效的逻辑显示器列表！</span></span><br><span class="line">        Display[] displays = mDisplayManager.getDisplays();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> displayNdx = displays.length - <span class="number">1</span>; displayNdx &gt;= <span class="number">0</span>; --displayNdx) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> displayId = displays[displayNdx].getDisplayId();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 为每一个显示器创建一个 ActivityDisplay 对象，存储该显示器的信息；</span></span><br><span class="line">            ActivityDisplay activityDisplay = <span class="keyword">new</span> ActivityDisplay(displayId);</span><br><span class="line">            <span class="keyword">if</span> (activityDisplay.mDisplay == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Default Display does not exist"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//【3.1】将其保存到 ams 的 mActivityDisplays 集合中，后续会用到！</span></span><br><span class="line">            mActivityDisplays.put(displayId, activityDisplay);</span><br><span class="line">            calculateDefaultMinimalSizeOfResizeableTasks(activityDisplay);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【4】初始化 mHomeStack，mFocusedStack 和 mLastFocusedStack 这三个 stack！</span></span><br><span class="line">        mHomeStack = mFocusedStack = mLastFocusedStack =</span><br><span class="line">                getStack(HOME_STACK_ID, CREATE_IF_NEEDED, ON_TOP);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【5】通过本地服务过得 ims 的调用接口；</span></span><br><span class="line">        mInputManagerInternal = LocalServices.getService(InputManagerInternal.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法逻辑很简单！这里重点看一下，在系统启动的时候，会初始化 <code>mFocusedStack</code> 和 <code>mLastFocusedStack</code> 为 <code>HOME_STACK_ID</code> 类型的 <code>stack</code>，这个是显而易见的，因为开机后，就会进入桌面，此时焦点 <code>stack</code> 一定是 <code>home stack</code>!</p>
<h3 id="3-2-1-ActivityStackSupervisor-getStack"><a href="#3-2-1-ActivityStackSupervisor-getStack" class="headerlink" title="3.2.1 ActivityStackSupervisor.getStack"></a>3.2.1 ActivityStackSupervisor.getStack</h3><p>该方法的作用是返回一个可用的 <code>stack</code>，<code>createStaticStackIfNeeded</code> 表示有必要的话是否创建一个静态 <code>stack</code>！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ActivityStack <span class="title">getStack</span><span class="params">(<span class="keyword">int</span> stackId, <span class="keyword">boolean</span> createStaticStackIfNeeded, <span class="keyword">boolean</span> createOnTop)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】获得 stackId 对应的 ActivityContainer 如果其不为 null，返回其内部的 Stack！</span></span><br><span class="line">    ActivityContainer activityContainer = mActivityContainers.get(stackId);</span><br><span class="line">    <span class="keyword">if</span> (activityContainer != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> activityContainer.mStack;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【2】如果不能通过 ActivityContainer 来获得想要的 statck 话，就先判断是否需要创建一个 stack</span></span><br><span class="line">    <span class="comment">// 不需要创建一个新的 stack 或者 stack id 不是静态的，那就不能创建，返回一个空的 stack！</span></span><br><span class="line">    <span class="keyword">if</span> (!createStaticStackIfNeeded || !StackId.isStaticStack(stackId)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【3】创建一个 stack，这里的 Display.DEFAULT_DISPLAY 对应的是默认的显示器 ！</span></span><br><span class="line">    <span class="keyword">return</span> createStackOnDisplay(stackId, Display.DEFAULT_DISPLAY, createOnTop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们知道，在刚开机的时候，是没有任何的 <code>ActivityContainer</code> 的，所以这里会进入 <code>createStackOnDisplay</code> 方法中继续创建！</p>
<h3 id="3-2-2-ActivityStackSupervisor-createStackOnDisplay"><a href="#3-2-2-ActivityStackSupervisor-createStackOnDisplay" class="headerlink" title="3.2.2 ActivityStackSupervisor.createStackOnDisplay"></a>3.2.2 ActivityStackSupervisor.createStackOnDisplay</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ActivityStack <span class="title">createStackOnDisplay</span><span class="params">(<span class="keyword">int</span> stackId, <span class="keyword">int</span> displayId, <span class="keyword">boolean</span> onTop)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】获得 displayId 对应的逻辑显示器的 ActivityDisplay 对象！</span></span><br><span class="line">    ActivityDisplay activityDisplay = mActivityDisplays.get(displayId);</span><br><span class="line">    <span class="keyword">if</span> (activityDisplay == <span class="keyword">null</span>) &#123; <span class="comment">// 这里显然不会进入！</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【2】根据 stackId 创建了一个 ActivityContainer 对象爱！</span></span><br><span class="line">    ActivityContainer activityContainer = <span class="keyword">new</span> ActivityContainer(stackId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【3】将其加入到 mActivityContainers 中！</span></span><br><span class="line">    mActivityContainers.put(stackId, activityContainer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【4】将 activityContainer 绑定到对应的显示器对象 activityDisplay 中！</span></span><br><span class="line">    activityContainer.attachToDisplayLocked(activityDisplay, onTop);</span><br><span class="line">    <span class="keyword">return</span> activityContainer.mStack;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里其实很简单，针对于指定的显示器 <code>ActivityDisplay</code>，创建对应的 <code>ActivityContainer</code>，然后 <code>ActivityContainer</code> 内部再去创建 <code>ActivityStack</code>!</p>
<h4 id="3-2-2-1-new-ActivityContainer"><a href="#3-2-2-1-new-ActivityContainer" class="headerlink" title="3.2.2.1 new ActivityContainer"></a>3.2.2.1 new ActivityContainer</h4><p>我们来去看看 <code>ActivityContainer</code> 的创建：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ActivityContainer</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">app</span>.<span class="title">IActivityContainer</span>.<span class="title">Stub</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> FORCE_NEW_TASK_FLAGS = FLAG_ACTIVITY_NEW_TASK |</span><br><span class="line">            FLAG_ACTIVITY_MULTIPLE_TASK | Intent.FLAG_ACTIVITY_NO_ANIMATION;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> mStackId; <span class="comment">// stack 的 id！</span></span><br><span class="line">    IActivityContainerCallback mCallback = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">final</span> ActivityStack mStack; <span class="comment">// 对应的 ActivityStack 对象！</span></span><br><span class="line">    ActivityRecord mParentActivity = <span class="keyword">null</span>; <span class="comment">// 父亲 activity！</span></span><br><span class="line">    String mIdString; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> mVisible = <span class="keyword">true</span>; <span class="comment">// 是否是可见的，默认为 true！</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其所绑定到的 ActivityDisplay 对象，不为 null 说明绑定到了一个逻辑显示器，</span></span><br><span class="line">    <span class="comment">// 这样该 stack 中的 activity 就可以被显示出来！</span></span><br><span class="line">    ActivityDisplay mActivityDisplay;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> CONTAINER_STATE_HAS_SURFACE = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> CONTAINER_STATE_NO_SURFACE = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> CONTAINER_STATE_FINISHING = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// container 的状态，取值有 3 种！</span></span><br><span class="line">    <span class="keyword">int</span> mContainerState = CONTAINER_STATE_HAS_SURFACE;</span><br><span class="line"></span><br><span class="line">    ActivityContainer(<span class="keyword">int</span> stackId) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mService) &#123;</span><br><span class="line">            mStackId = stackId;</span><br><span class="line">            <span class="comment">//【1】创建一个 ActivityStack</span></span><br><span class="line">            mStack = <span class="keyword">new</span> ActivityStack(<span class="keyword">this</span>, mRecentTasks);</span><br><span class="line"></span><br><span class="line">            mIdString = <span class="string">"ActivtyContainer&#123;"</span> + mStackId + <span class="string">"&#125;"</span>;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_STACK) Slog.d(TAG_STACK, <span class="string">"Creating "</span> + <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ... ... ...   </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们再去看看 <code>ActivityStack</code> 的创建：</p>
<h5 id="3-2-2-2-1-new-ActivityStack"><a href="#3-2-2-2-1-new-ActivityStack" class="headerlink" title="3.2.2.2.1 new ActivityStack"></a>3.2.2.2.1 new ActivityStack</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ActivityStack(ActivityStackSupervisor.ActivityContainer activityContainer,</span><br><span class="line">        RecentTasks recentTasks) &#123;</span><br><span class="line">    <span class="comment">//【1】设置 ActivityContainer 引用关系；</span></span><br><span class="line">    mActivityContainer = activityContainer;</span><br><span class="line">    <span class="comment">// ActivityContainer 是 ActivityStackSupervisor 内部类，这里是通过 getOuter 获得外部类的实例；</span></span><br><span class="line">    mStackSupervisor = activityContainer.getOuter();</span><br><span class="line">    mService = mStackSupervisor.mService; <span class="comment">// ams 的引用实例；</span></span><br><span class="line">    <span class="comment">//【2】创建 ActivityStackHandler 用于处理 activity 的周期变化；</span></span><br><span class="line">    mHandler = <span class="keyword">new</span> ActivityStackHandler(mService.mHandler.getLooper());</span><br><span class="line">    mWindowManager = mService.mWindowManager; <span class="comment">// wms 实例，不多说了；</span></span><br><span class="line">    mStackId = activityContainer.mStackId; <span class="comment">// stack id；</span></span><br><span class="line">    mCurrentUser = mService.mUserController.getCurrentUserIdLocked(); <span class="comment">// 当前的设备用户对象；</span></span><br><span class="line">    mRecentTasks = recentTasks; <span class="comment">// 最近任务；</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 stack id 为 FREEFORM_WORKSPACE_STACK_ID，才会创建对应实例，安卓手机默认是为 null</span></span><br><span class="line">    mTaskPositioner = mStackId == FREEFORM_WORKSPACE_STACK_ID</span><br><span class="line">            ? <span class="keyword">new</span> LaunchingTaskPositioner() : <span class="keyword">null</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就不多说了！</p>
<h4 id="3-2-2-2-ActivityContainer-attachToDisplayLocked"><a href="#3-2-2-2-ActivityContainer-attachToDisplayLocked" class="headerlink" title="3.2.2.2 ActivityContainer.attachToDisplayLocked"></a>3.2.2.2 ActivityContainer.attachToDisplayLocked</h4><p>接下来就是很关键的一部，就是将 <code>ActivityContainer</code> 绑定到指定的 <code>ActivityDisplay</code> 对象上！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">attachToDisplayLocked</span><span class="params">(ActivityDisplay activityDisplay, <span class="keyword">boolean</span> onTop)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_STACK) Slog.d(TAG_STACK, <span class="string">"attachToDisplayLocked: "</span> + <span class="keyword">this</span></span><br><span class="line">            + <span class="string">" to display="</span> + activityDisplay + <span class="string">" onTop="</span> + onTop);</span><br><span class="line">    <span class="comment">//【1】设置 mActivityDisplay 引用关系！</span></span><br><span class="line">    mActivityDisplay = activityDisplay;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    mStack.attachDisplay(activityDisplay, onTop);</span><br><span class="line">    activityDisplay.attachActivities(mStack, onTop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-2-2-2-1-ActivityStack-attachDisplay"><a href="#3-2-2-2-1-ActivityStack-attachDisplay" class="headerlink" title="3.2.2.2.1 ActivityStack.attachDisplay"></a>3.2.2.2.1 ActivityStack.attachDisplay</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">attachDisplay</span><span class="params">(ActivityStackSupervisor.ActivityDisplay activityDisplay, <span class="keyword">boolean</span> onTop)</span> </span>&#123;</span><br><span class="line">    mDisplayId = activityDisplay.mDisplayId;</span><br><span class="line">    mStacks = activityDisplay.mStacks;</span><br><span class="line">    mBounds = mWindowManager.attachStack(mStackId, activityDisplay.mDisplayId, onTop);</span><br><span class="line">    mFullscreen = mBounds == <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (mTaskPositioner != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mTaskPositioner.setDisplay(activityDisplay.mDisplay);</span><br><span class="line">        mTaskPositioner.configure(mBounds);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mStackId == DOCKED_STACK_ID) &#123;</span><br><span class="line">        <span class="comment">// If we created a docked stack we want to resize it so it resizes all other stacks</span></span><br><span class="line">        <span class="comment">// in the system.</span></span><br><span class="line">        mStackSupervisor.resizeDockedStackLocked(</span><br><span class="line">                mBounds, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, PRESERVE_WINDOWS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-2-2-2-2-ActivityDisplay-attachActivities"><a href="#3-2-2-2-2-ActivityDisplay-attachActivities" class="headerlink" title="3.2.2.2.2 ActivityDisplay.attachActivities"></a>3.2.2.2.2 ActivityDisplay.attachActivities</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">attachActivities</span><span class="params">(ActivityStack stack, <span class="keyword">boolean</span> onTop)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_STACK) Slog.v(TAG_STACK,</span><br><span class="line">            <span class="string">"attachActivities: attaching "</span> + stack + <span class="string">" to displayId="</span> + mDisplayId</span><br><span class="line">            + <span class="string">" onTop="</span> + onTop);</span><br><span class="line">    <span class="keyword">if</span> (onTop) &#123;</span><br><span class="line">        mStacks.add(stack);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mStacks.add(<span class="number">0</span>, stack);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实，整个过程就是创建容器，建立引用关系的过程，通过分析，我们知道，安卓系统的所有的 <code>stack</code> 的创建都是这样的！！</p>
<h2 id="3-3-ActivityManagerS-systemReady"><a href="#3-3-ActivityManagerS-systemReady" class="headerlink" title="3.3 ActivityManagerS.systemReady"></a>3.3 ActivityManagerS.systemReady</h2><p><code>SystemServer</code> 在启动完所有服务之后，将调用 <code>AMS</code> 的 <code>systemReady()</code> 方法。这个方法是 <code>Android</code> 进入用户交互阶段前最后进行的准备工作。这里就即将进入开机的最后阶段了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">systemReady</span><span class="params">(<span class="keyword">final</span> Runnable goingCallback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【3.3.1】最开始是不会进入这个分支的，即 mSystemReady 为 false，但是由于 systemReady 会被调用多次</span></span><br><span class="line">        <span class="comment">// 后续 mSystemReady 会被置为 true，这样执行 goingCallback 后就会退出了！</span></span><br><span class="line">        <span class="keyword">if</span> (mSystemReady) &#123; </span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (goingCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">                goingCallback.run();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mLocalDeviceIdleController</span><br><span class="line">                = LocalServices.getService(DeviceIdleController.LocalService.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通知 UserController、RecentTask 和 AppOpsService 服务，系统已经准备好了！</span></span><br><span class="line">        mUserController.onSystemReady();</span><br><span class="line">        mRecentTasks.onSystemReadyLocked();</span><br><span class="line">        mAppOpsService.systemReady();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【2】mSystemReady 置为 true，表示系统进程已经准备完毕了！</span></span><br><span class="line">        mSystemReady = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【3.3.2】遍历 mPidsSelfLocked，找到已经启动但是没有带有 FLAG_PERSISTENT 标记的非 persistent 应用进程；</span></span><br><span class="line">    <span class="comment">// 然后杀掉它们，目的是在启动 Home 前准备一个干净的环境！</span></span><br><span class="line">    ArrayList&lt;ProcessRecord&gt; procsToKill = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span>(mPidsSelfLocked) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=mPidsSelfLocked.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            ProcessRecord proc = mPidsSelfLocked.valueAt(i);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!isAllowedWhileBooting(proc.info))&#123;</span><br><span class="line">                <span class="keyword">if</span> (procsToKill == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    procsToKill = <span class="keyword">new</span> ArrayList&lt;ProcessRecord&gt;();</span><br><span class="line">                &#125;</span><br><span class="line">                procsToKill.add(proc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (procsToKill != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=procsToKill.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">                ProcessRecord proc = procsToKill.get(i);</span><br><span class="line">                Slog.i(TAG, <span class="string">"Removing system update proc: "</span> + proc);</span><br><span class="line">                removeProcessLocked(proc, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="string">"system update done"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【3.1】表示系统进程已经准备完毕，可以启动其他进程了！</span></span><br><span class="line">        mProcessesReady = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Slog.i(TAG, <span class="string">"System now ready"</span>);</span><br><span class="line">    EventLog.writeEvent(EventLogTags.BOOT_PROGRESS_AMS_READY,</span><br><span class="line">        SystemClock.uptimeMillis());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mFactoryTest == FactoryTest.FACTORY_TEST_LOW_LEVEL) &#123;</span><br><span class="line">           ... ... ... ...<span class="comment">// 测试模式，非正常情况，先不看！</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【3.3.3】读取设置信息！</span></span><br><span class="line">    retrieveSettings();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> currentUserId;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得当前设备用户 id！</span></span><br><span class="line">        currentUserId = mUserController.getCurrentUserIdLocked();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【3.3.4】从 /data/system/urigrants.xml 文件中读取 Uri 相关的权限信息！</span></span><br><span class="line">        readGrantedUriPermissionsLocked();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【5】执行传入的 callback 回调，主要是启动其他服务等等！</span></span><br><span class="line">    <span class="keyword">if</span> (goingCallback != <span class="keyword">null</span>) goingCallback.run();</span><br><span class="line"></span><br><span class="line">    mBatteryStatsService.noteEvent(BatteryStats.HistoryItem.EVENT_USER_RUNNING_START,</span><br><span class="line">            Integer.toString(currentUserId), currentUserId);</span><br><span class="line">    mBatteryStatsService.noteEvent(BatteryStats.HistoryItem.EVENT_USER_FOREGROUND_START,</span><br><span class="line">            Integer.toString(currentUserId), currentUserId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动当前的设备用户！</span></span><br><span class="line">    mSystemServiceManager.startUser(currentUserId);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【3.3.5】启动那些 peristent 应用进程!</span></span><br><span class="line">        startPersistentApps(PackageManager.MATCH_DIRECT_BOOT_AWARE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Start up initial activity.</span></span><br><span class="line">        mBooting = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (UserManager.isSplitSystemUser()) &#123;</span><br><span class="line">            ComponentName cName = <span class="keyword">new</span> ComponentName(mContext, SystemUserHomeActivity.class);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                AppGlobals.getPackageManager().setComponentEnabledSetting(cName,</span><br><span class="line">                        PackageManager.COMPONENT_ENABLED_STATE_ENABLED, <span class="number">0</span>,</span><br><span class="line">                        UserHandle.USER_SYSTEM);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e.rethrowAsRuntimeException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【3.3.6】启动桌面 activity！</span></span><br><span class="line">        startHomeActivityLocked(currentUserId, <span class="string">"systemReady"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (AppGlobals.getPackageManager().hasSystemUidErrors()) &#123;</span><br><span class="line">                Slog.e(TAG, <span class="string">"UIDs on the system are inconsistent, you need to wipe your"</span></span><br><span class="line">                        + <span class="string">" data partition or your device will be unstable."</span>);</span><br><span class="line">                mUiHandler.obtainMessage(SHOW_UID_ERROR_UI_MSG).sendToTarget();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!Build.isBuildConsistent()) &#123;</span><br><span class="line">            Slog.e(TAG, <span class="string">"Build fingerprint is not consistent, warning user"</span>);</span><br><span class="line">            mUiHandler.obtainMessage(SHOW_FINGERPRINT_ERROR_UI_MSG).sendToTarget();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 发送 ACTION_USER_STARTED 广播！</span></span><br><span class="line">            Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_USER_STARTED);</span><br><span class="line">            intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY</span><br><span class="line">                    | Intent.FLAG_RECEIVER_FOREGROUND);</span><br><span class="line">            intent.putExtra(Intent.EXTRA_USER_HANDLE, currentUserId);</span><br><span class="line">            broadcastIntentLocked(<span class="keyword">null</span>, <span class="keyword">null</span>, intent,</span><br><span class="line">                    <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, AppOpsManager.OP_NONE,</span><br><span class="line">                    <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, MY_PID, Process.SYSTEM_UID,</span><br><span class="line">                    currentUserId);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 发送 ACTION_USER_STARTING 广播！</span></span><br><span class="line">            intent = <span class="keyword">new</span> Intent(Intent.ACTION_USER_STARTING);</span><br><span class="line">            intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);</span><br><span class="line">            intent.putExtra(Intent.EXTRA_USER_HANDLE, currentUserId);</span><br><span class="line"></span><br><span class="line">            broadcastIntentLocked(<span class="keyword">null</span>, <span class="keyword">null</span>, intent,</span><br><span class="line">                    <span class="keyword">null</span>, <span class="keyword">new</span> IIntentReceiver.Stub() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performReceive</span><span class="params">(Intent intent, <span class="keyword">int</span> resultCode, String data,</span></span></span><br><span class="line"><span class="function"><span class="params">                                Bundle extras, <span class="keyword">boolean</span> ordered, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> sendingUser)</span></span></span><br><span class="line"><span class="function">                                <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;, <span class="number">0</span>, <span class="keyword">null</span>, <span class="keyword">null</span>,</span><br><span class="line">                    <span class="keyword">new</span> String[] &#123;INTERACT_ACROSS_USERS&#125;, AppOpsManager.OP_NONE,</span><br><span class="line">                    <span class="keyword">null</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, MY_PID, Process.SYSTEM_UID, UserHandle.USER_ALL);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            Slog.wtf(TAG, <span class="string">"Failed sending first user broadcasts"</span>, t);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Binder.restoreCallingIdentity(ident);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【8】此时的桌面已经是 top activity，设置桌面 activity 为 resumed 状态！</span></span><br><span class="line">        mStackSupervisor.resumeFocusedStackTopActivityLocked();</span><br><span class="line">        <span class="comment">// 发送设备用户已经切换的广播；</span></span><br><span class="line">        mUserController.sendUserSwitchBroadcastsLocked(-<span class="number">1</span>, currentUserId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的代码逻辑比较复杂，里面有一些关键的点，我们来看看：</p>
<h3 id="3-3-1-通知其他服务-SystemReady"><a href="#3-3-1-通知其他服务-SystemReady" class="headerlink" title="3.3.1 通知其他服务 - SystemReady"></a>3.3.1 通知其他服务 - SystemReady</h3><p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mUserController.onSystemReady();</span><br><span class="line">mRecentTasks.onSystemReadyLocked();</span><br><span class="line">mAppOpsService.systemReady();</span><br><span class="line">mSystemReady = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure></p>
<p>我们一个一个来看：</p>
<h4 id="3-3-1-1-UserController-onSystemReady"><a href="#3-3-1-1-UserController-onSystemReady" class="headerlink" title="3.3.1.1 UserController.onSystemReady"></a>3.3.1.1 UserController.onSystemReady</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onSystemReady</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    updateCurrentProfileIdsLocked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用了 <code>updateCurrentProfileIdsLocked</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateCurrentProfileIdsLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> List&lt;UserInfo&gt; profiles = getUserManager().getProfiles(mCurrentUserId,</span><br><span class="line">            <span class="keyword">false</span> <span class="comment">/* enabledOnly */</span>);</span><br><span class="line">    <span class="keyword">int</span>[] currentProfileIds = <span class="keyword">new</span> <span class="keyword">int</span>[profiles.size()]; <span class="comment">// profiles will not be null</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; currentProfileIds.length; i++) &#123;</span><br><span class="line">        currentProfileIds[i] = profiles.get(i).id;</span><br><span class="line">    &#125;</span><br><span class="line">    mCurrentProfileIds = currentProfileIds;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mUserProfileGroupIdsSelfLocked) &#123;</span><br><span class="line">        mUserProfileGroupIdsSelfLocked.clear();</span><br><span class="line">        <span class="keyword">final</span> List&lt;UserInfo&gt; users = getUserManager().getUsers(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存所有设备用户的信息，用于以后权限校验使用！</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; users.size(); i++) &#123;</span><br><span class="line">            UserInfo user = users.get(i);</span><br><span class="line">            <span class="keyword">if</span> (user.profileGroupId != UserInfo.NO_PROFILE_GROUP_ID) &#123;</span><br><span class="line">                <span class="comment">// 保存在这里！</span></span><br><span class="line">                mUserProfileGroupIdsSelfLocked.put(user.id, user.profileGroupId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法的作用是：<code>Android</code> 的许多系统调用都需要检查用户的 <code>ID</code>，所以这里调用 <code>updateCurrnetProfileIdsLocked()</code> 方法来通过 <code>UserManagerService</code> 读取系统保持的 <code>Profile</code> 信息，装载系统中已经存在的用户信息。</p>
<h4 id="3-3-1-2-RecentTasks-onSystemReady"><a href="#3-3-1-2-RecentTasks-onSystemReady" class="headerlink" title="3.3.1.2 RecentTasks.onSystemReady"></a>3.3.1.2 RecentTasks.onSystemReady</h4><p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onSystemReadyLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    clear();</span><br><span class="line">    mTaskPersister.startPersisting();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从 <code>Android5.0</code> 开始支持带有 <code>persistent</code> 标记的 <code>task</code>，这些 <code>task</code> 在关机时，信息保存在 <code>/data/system_ce/recent_tasks</code> 目录下的 <code>xxx_task.xml</code>（<code>xxx</code> 表示 <code>task id</code>）中，系统重启时，通过这些文件中保存的信息重建 <code>task</code>，和 <code>JobSchedulerService</code> 很类似哦！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startPersisting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mLazyTaskWriterThread.isAlive()) &#123;</span><br><span class="line">        mLazyTaskWriterThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法中启动了一个 <code>mLazyTaskWriterThread</code> 的线程，恢复那些 <code>pesistable</code> 类型的 <code>task</code>，这里不多说了！</p>
<h4 id="3-3-1-3-AppOpsService-onSystemReady"><a href="#3-3-1-3-AppOpsService-onSystemReady" class="headerlink" title="3.3.1.3 AppOpsService.onSystemReady"></a>3.3.1.3 AppOpsService.onSystemReady</h4><p>这里调用了 <code>AppOpsService</code> 的 <code>systemReady</code>，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">systemReady</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> changed = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//【1】更新系统中所有的 uid 的状态！</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = mUidStates.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            UidState uidState = mUidStates.valueAt(i);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//【1.1】uid 对应的 package 为 null，移除该 uid！</span></span><br><span class="line">            String[] packageNames = getPackagesForUid(uidState.uid);</span><br><span class="line">            <span class="keyword">if</span> (ArrayUtils.isEmpty(packageNames)) &#123;</span><br><span class="line">                uidState.clear();</span><br><span class="line">                mUidStates.removeAt(i);</span><br><span class="line">                changed = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ArrayMap&lt;String, Ops&gt; pkgs = uidState.pkgOps;</span><br><span class="line">            <span class="keyword">if</span> (pkgs == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            <span class="comment">//【1.1】如果 uid 的某个 ops 发生变化，移除它！</span></span><br><span class="line">            Iterator&lt;Ops&gt; it = pkgs.values().iterator();</span><br><span class="line">            <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">                Ops ops = it.next();</span><br><span class="line">                <span class="keyword">int</span> curUid = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    curUid = AppGlobals.getPackageManager().getPackageUid(ops.packageName,</span><br><span class="line">                            PackageManager.MATCH_UNINSTALLED_PACKAGES,</span><br><span class="line">                            UserHandle.getUserId(ops.uidState.uid));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemoteException ignored) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (curUid != ops.uidState.uid) &#123;</span><br><span class="line">                    Slog.i(TAG, <span class="string">"Pruning old package "</span> + ops.packageName</span><br><span class="line">                            + <span class="string">"/"</span> + ops.uidState + <span class="string">": new uid="</span> + curUid);</span><br><span class="line">                    it.remove();</span><br><span class="line">                    changed = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (uidState.isDefault()) &#123;</span><br><span class="line">                mUidStates.removeAt(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【1.3】如果 uid 的状态发生变化，将其持久化到本地文件中！</span></span><br><span class="line">        <span class="keyword">if</span> (changed) &#123;</span><br><span class="line">            scheduleFastWriteLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【2】获得挂载服务，设置外置存储挂载策略！</span></span><br><span class="line">    MountServiceInternal mountServiceInternal = LocalServices.getService(</span><br><span class="line">            MountServiceInternal.class);</span><br><span class="line">    mountServiceInternal.addExternalStoragePolicy(</span><br><span class="line">            <span class="keyword">new</span> MountServiceInternal.ExternalStorageMountPolicy() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMountMode</span><span class="params">(<span class="keyword">int</span> uid, String packageName)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (Process.isIsolated(uid)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> Zygote.MOUNT_EXTERNAL_NONE;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (noteOperation(AppOpsManager.OP_READ_EXTERNAL_STORAGE, uid,</span><br><span class="line">                            packageName) != AppOpsManager.MODE_ALLOWED) &#123;</span><br><span class="line">                        <span class="keyword">return</span> Zygote.MOUNT_EXTERNAL_NONE;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (noteOperation(AppOpsManager.OP_WRITE_EXTERNAL_STORAGE, uid,</span><br><span class="line">                            packageName) != AppOpsManager.MODE_ALLOWED) &#123;</span><br><span class="line">                        <span class="keyword">return</span> Zygote.MOUNT_EXTERNAL_READ;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> Zygote.MOUNT_EXTERNAL_WRITE;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasExternalStorage</span><span class="params">(<span class="keyword">int</span> uid, String packageName)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> mountMode = getMountMode(uid, packageName);</span><br><span class="line">                    <span class="keyword">return</span> mountMode == Zygote.MOUNT_EXTERNAL_READ</span><br><span class="line">                            || mountMode == Zygote.MOUNT_EXTERNAL_WRITE;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个 <code>AppOpsService</code> 是谷歌原生的应用程序权限管理服务，在 <code>Android M ( Android 6.0 )</code> 加入的 <code>Application Permission Manager</code> 的功能就是基于 <code>AppOps</code> 实现的！</p>
<p><code>AppOps</code> 全称是 <code>Application Operations</code>，类似我们平时常说的应用程序的操作（权限）管理。目前 <code>Google</code> 在每次版本更新时都会隐藏掉 <code>AppOps</code> 的入口。</p>
<p>注意：<code>AppOps</code> 虽然涵盖了 <code>App</code> 的权限管理，但是 <code>Google</code> 原生的设计并不仅仅是对“权限”的管理，而是对 <code>App</code> 的“动作”的管理。我们平时讲的权限管理多是针对具体的权限（<code>App</code> 开发者在 <code>Manifest</code> 里申请的权限），而 <code>AppOps</code> 所管理的是所有可能涉及用户隐私和安全的操作，包括 <code>access notification</code>, <code>keep weak lock</code>, <code>activate vpn</code>, <code>display toast</code> 等等，有些操作是不需要 <code>Manifest</code> 里申请权限的。</p>
<p>不多说了，这不多关注！</p>
<h3 id="3-3-2-杀掉特定进程"><a href="#3-3-2-杀掉特定进程" class="headerlink" title="3.3.2 杀掉特定进程"></a>3.3.2 杀掉特定进程</h3><p>刚刚有讲到，<code>AMS</code> 会杀掉已经启动并且没有带有 <code>FLAG_PERSISTENT</code> 标记的进程，那如何判断是否具有这个标记呢：</p>
<h4 id="3-3-2-1-isAllowedWhileBooting"><a href="#3-3-2-1-isAllowedWhileBooting" class="headerlink" title="3.3.2.1 isAllowedWhileBooting"></a>3.3.2.1 isAllowedWhileBooting</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isAllowedWhileBooting</span><span class="params">(ApplicationInfo ai)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (ai.flags&amp;ApplicationInfo.FLAG_PERSISTENT) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果某个进程没有 <code>FLAG_PERSISTENT</code> ，这个方法会返回 <code>false</code>！</p>
<h3 id="3-3-3-读取设置信息-retrieveSettings"><a href="#3-3-3-读取设置信息-retrieveSettings" class="headerlink" title="3.3.3 读取设置信息 - retrieveSettings"></a>3.3.3 读取设置信息 - retrieveSettings</h3><p>该方法的目的是从前面已经配置好的系统 <code>provider</code> 中互动一些设置属性！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">retrieveSettings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ContentResolver resolver = mContext.getContentResolver();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】获得一些系统属性！</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> freeformWindowManagement =</span><br><span class="line">            mContext.getPackageManager().hasSystemFeature(FEATURE_FREEFORM_WINDOW_MANAGEMENT)</span><br><span class="line">                    || Settings.Global.getInt(</span><br><span class="line">                            resolver, DEVELOPMENT_ENABLE_FREEFORM_WINDOWS_SUPPORT, <span class="number">0</span>) != <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 是否支持画中画模式！</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> supportsPictureInPicture =</span><br><span class="line">            mContext.getPackageManager().hasSystemFeature(FEATURE_PICTURE_IN_PICTURE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否支持分屏模式！</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> supportsMultiWindow = ActivityManager.supportsMultiWindow();</span><br><span class="line">    <span class="keyword">final</span> String debugApp = Settings.Global.getString(resolver, DEBUG_APP);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> waitForDebugger = Settings.Global.getInt(resolver, WAIT_FOR_DEBUGGER, <span class="number">0</span>) != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> alwaysFinishActivities =</span><br><span class="line">            Settings.Global.getInt(resolver, ALWAYS_FINISH_ACTIVITIES, <span class="number">0</span>) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> lenientBackgroundCheck =</span><br><span class="line">            Settings.Global.getInt(resolver, LENIENT_BACKGROUND_CHECK, <span class="number">0</span>) != <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 是否强制 RTL 显示！</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> forceRtl = Settings.Global.getInt(resolver, DEVELOPMENT_FORCE_RTL, <span class="number">0</span>) != <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 是否强制 activity 显示尺寸可变化！</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> forceResizable = Settings.Global.getInt(</span><br><span class="line">            resolver, DEVELOPMENT_FORCE_RESIZABLE_ACTIVITIES, <span class="number">0</span>) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> supportsLeanbackOnly =</span><br><span class="line">            mContext.getPackageManager().hasSystemFeature(FEATURE_LEANBACK_ONLY);</span><br><span class="line"></span><br><span class="line">    SystemProperties.set(DEVELOPMENT_FORCE_RTL, forceRtl ? <span class="string">"1"</span>:<span class="string">"0"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Configuration configuration = <span class="keyword">new</span> Configuration();</span><br><span class="line">    Settings.System.getConfiguration(resolver, configuration);</span><br><span class="line">    <span class="keyword">if</span> (forceRtl) &#123;</span><br><span class="line">        <span class="comment">// This will take care of setting the correct layout direction flags</span></span><br><span class="line">        configuration.setLayoutDirection(configuration.locale);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】根据获得的系统属性，初始化系统属性变量！</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        mDebugApp = mOrigDebugApp = debugApp;</span><br><span class="line">        mWaitForDebugger = mOrigWaitForDebugger = waitForDebugger;</span><br><span class="line">        mAlwaysFinishActivities = alwaysFinishActivities;</span><br><span class="line">        mLenientBackgroundCheck = lenientBackgroundCheck;</span><br><span class="line">        mSupportsLeanbackOnly = supportsLeanbackOnly;</span><br><span class="line">        mForceResizableActivities = forceResizable;</span><br><span class="line">        mWindowManager.setForceResizableTasks(mForceResizableActivities);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (supportsMultiWindow || forceResizable) &#123;</span><br><span class="line">            mSupportsMultiWindow = <span class="keyword">true</span>;</span><br><span class="line">            mSupportsFreeformWindowManagement = freeformWindowManagement || forceResizable;</span><br><span class="line">            mSupportsPictureInPicture = supportsPictureInPicture || forceResizable;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mSupportsMultiWindow = <span class="keyword">false</span>;</span><br><span class="line">            mSupportsFreeformWindowManagement = <span class="keyword">false</span>;</span><br><span class="line">            mSupportsPictureInPicture = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This happens before any activities are started, so we can</span></span><br><span class="line">        <span class="comment">// change mConfiguration in-place.</span></span><br><span class="line">        updateConfigurationLocked(configuration, <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_CONFIGURATION) Slog.v(TAG_CONFIGURATION,</span><br><span class="line">                <span class="string">"Initial config: "</span> + mConfiguration);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Load resources only after the current configuration has been set.</span></span><br><span class="line">        <span class="keyword">final</span> Resources res = mContext.getResources();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 是否有最近任务！</span></span><br><span class="line">        mHasRecents = res.getBoolean(com.android.internal.R.bool.config_hasRecents);</span><br><span class="line">        mThumbnailWidth = res.getDimensionPixelSize(</span><br><span class="line">                com.android.internal.R.dimen.thumbnail_width);</span><br><span class="line">        mThumbnailHeight = res.getDimensionPixelSize(</span><br><span class="line">                com.android.internal.R.dimen.thumbnail_height);</span><br><span class="line">        mDefaultPinnedStackBounds = Rect.unflattenFromString(res.getString(</span><br><span class="line">                com.android.internal.R.string.config_defaultPictureInPictureBounds));</span><br><span class="line">                </span><br><span class="line">        mAppErrors.loadAppsNotReportingCrashesFromConfigLocked(res.getString(</span><br><span class="line">                com.android.internal.R.string.config_appsNotReportingCrashes));</span><br><span class="line">        <span class="keyword">if</span> ((mConfiguration.uiMode &amp; UI_MODE_TYPE_TELEVISION) == UI_MODE_TYPE_TELEVISION) &#123;</span><br><span class="line">            mFullscreenThumbnailScale = (<span class="keyword">float</span>) res</span><br><span class="line">                .getInteger(com.android.internal.R.integer.thumbnail_width_tv) /</span><br><span class="line">                (<span class="keyword">float</span>) mConfiguration.screenWidthDp;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mFullscreenThumbnailScale = res.getFraction(</span><br><span class="line">                com.android.internal.R.fraction.thumbnail_fullscreen_scale, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里不多说了！</p>
<h3 id="3-3-4-读取-Uri-权限信息"><a href="#3-3-4-读取-Uri-权限信息" class="headerlink" title="3.3.4 读取 Uri 权限信息"></a>3.3.4 读取 Uri 权限信息</h3><h4 id="3-3-4-1-读取-Uri-权限信息"><a href="#3-3-4-1-读取-Uri-权限信息" class="headerlink" title="3.3.4.1 读取 Uri 权限信息"></a>3.3.4.1 读取 Uri 权限信息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readGrantedUriPermissionsLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_URI_PERMISSION) Slog.v(TAG_URI_PERMISSION, <span class="string">"readGrantedUriPermissions()"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//【1】读取 /data/system/urigrants.xml 文件！</span></span><br><span class="line">        fis = mGrantFile.openRead();</span><br><span class="line">        <span class="keyword">final</span> XmlPullParser in = Xml.newPullParser();</span><br><span class="line">        in.setInput(fis, StandardCharsets.UTF_8.name());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> type;</span><br><span class="line">        <span class="keyword">while</span> ((type = in.next()) != END_DOCUMENT) &#123;</span><br><span class="line">            <span class="keyword">final</span> String tag = in.getName();</span><br><span class="line">            <span class="keyword">if</span> (type == START_TAG) &#123;</span><br><span class="line">                <span class="keyword">if</span> (TAG_URI_GRANT.equals(tag)) &#123; <span class="comment">// uri-grants 标签</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> sourceUserId;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> targetUserId;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> userHandle = readIntAttribute(in,</span><br><span class="line">                            ATTR_USER_HANDLE, UserHandle.USER_NULL); <span class="comment">// userHandle 属性</span></span><br><span class="line">                    <span class="keyword">if</span> (userHandle != UserHandle.USER_NULL) &#123;</span><br><span class="line">                        <span class="comment">// For backwards compatibility.</span></span><br><span class="line">                        sourceUserId = userHandle;</span><br><span class="line">                        targetUserId = userHandle;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        sourceUserId = readIntAttribute(in, ATTR_SOURCE_USER_ID); <span class="comment">// sourceUserId 属性</span></span><br><span class="line">                        targetUserId = readIntAttribute(in, ATTR_TARGET_USER_ID); <span class="comment">// targetUserId 属性</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">final</span> String sourcePkg = in.getAttributeValue(<span class="keyword">null</span>, ATTR_SOURCE_PKG); <span class="comment">// sourcePkg 属性</span></span><br><span class="line">                    <span class="keyword">final</span> String targetPkg = in.getAttributeValue(<span class="keyword">null</span>, ATTR_TARGET_PKG); <span class="comment">// targetPkg 属性</span></span><br><span class="line">                    <span class="keyword">final</span> Uri uri = Uri.parse(in.getAttributeValue(<span class="keyword">null</span>, ATTR_URI)); <span class="comment">// uri 属性</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">boolean</span> prefix = readBooleanAttribute(in, ATTR_PREFIX); <span class="comment">// prefix 属性</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> modeFlags = readIntAttribute(in, ATTR_MODE_FLAGS); <span class="comment">// modeFlags 属性</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">long</span> createdTime = readLongAttribute(in, ATTR_CREATED_TIME, now); <span class="comment">// createdTime 属性</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Sanity check that provider still belongs to source package</span></span><br><span class="line">                    <span class="comment">// Both direct boot aware and unaware packages are fine as we</span></span><br><span class="line">                    <span class="comment">// will do filtering at query time to avoid multiple parsing.</span></span><br><span class="line">                    <span class="comment">// 根据 uri 获得其所属的 ContentProvider 对象！</span></span><br><span class="line">                    <span class="keyword">final</span> ProviderInfo pi = getProviderInfoLocked(</span><br><span class="line">                            uri.getAuthority(), sourceUserId, MATCH_DIRECT_BOOT_AWARE</span><br><span class="line">                                    | MATCH_DIRECT_BOOT_UNAWARE);</span><br><span class="line">                    <span class="keyword">if</span> (pi != <span class="keyword">null</span> &amp;&amp; sourcePkg.equals(pi.packageName)) &#123;</span><br><span class="line">                        <span class="keyword">int</span> targetUid = -<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">// 获得持有该 uri 权限的目标ingyon</span></span><br><span class="line">                            targetUid = AppGlobals.getPackageManager().getPackageUid(</span><br><span class="line">                                    targetPkg, MATCH_UNINSTALLED_PACKAGES, targetUserId);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 创建 UriPermission，封装该应用的 uri 权限！</span></span><br><span class="line">                        <span class="keyword">if</span> (targetUid != -<span class="number">1</span>) &#123;</span><br><span class="line">                            <span class="keyword">final</span> UriPermission perm = findOrCreateUriPermissionLocked(</span><br><span class="line">                                    sourcePkg, targetPkg, targetUid,</span><br><span class="line">                                    <span class="keyword">new</span> GrantUri(sourceUserId, uri, prefix));</span><br><span class="line">                            perm.initPersistedModes(modeFlags, createdTime);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        Slog.w(TAG, <span class="string">"Persisted grant for "</span> + uri + <span class="string">" had source "</span> + sourcePkg</span><br><span class="line">                                + <span class="string">" but instead found "</span> + pi);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        <span class="comment">// Missing grants is okay</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        Slog.wtf(TAG, <span class="string">"Failed reading Uri grants"</span>, e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (XmlPullParserException e) &#123;</span><br><span class="line">        Slog.wtf(TAG, <span class="string">"Failed reading Uri grants"</span>, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        IoUtils.closeQuietly(fis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-4-2-ActivityManagerS-findOrCreateUriPermissionLocked"><a href="#3-3-4-2-ActivityManagerS-findOrCreateUriPermissionLocked" class="headerlink" title="3.3.4.2 ActivityManagerS.findOrCreateUriPermissionLocked"></a>3.3.4.2 ActivityManagerS.findOrCreateUriPermissionLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> UriPermission <span class="title">findOrCreateUriPermissionLocked</span><span class="params">(String sourcePkg,</span></span></span><br><span class="line"><span class="function"><span class="params">        String targetPkg, <span class="keyword">int</span> targetUid, GrantUri grantUri)</span> </span>&#123;</span><br><span class="line">    ArrayMap&lt;GrantUri, UriPermission&gt; targetUris = mGrantedUriPermissions.get(targetUid);</span><br><span class="line">    <span class="keyword">if</span> (targetUris == <span class="keyword">null</span>) &#123;</span><br><span class="line">        targetUris = Maps.newArrayMap();</span><br><span class="line">        mGrantedUriPermissions.put(targetUid, targetUris);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    UriPermission perm = targetUris.get(grantUri);</span><br><span class="line">    <span class="keyword">if</span> (perm == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建一个 UriPermission 对象！</span></span><br><span class="line">        perm = <span class="keyword">new</span> UriPermission(sourcePkg, targetPkg, targetUid, grantUri);</span><br><span class="line">        targetUris.put(grantUri, perm);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> perm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mGrantedUriPermissions 用来保存系统中所有已经授予的 uri 权限！</p>
<p>下面去看看 UriPermission 对象！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">UriPermission(String sourcePkg, String targetPkg, <span class="keyword">int</span> targetUid, GrantUri uri) &#123;</span><br><span class="line">    <span class="keyword">this</span>.targetUserId = UserHandle.getUserId(targetUid);</span><br><span class="line">    <span class="keyword">this</span>.sourcePkg = sourcePkg;</span><br><span class="line">    <span class="keyword">this</span>.targetPkg = targetPkg;</span><br><span class="line">    <span class="keyword">this</span>.targetUid = targetUid;</span><br><span class="line">    <span class="keyword">this</span>.uri = uri;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着调用了 initPersistedModes 初始化 persisted 相关属性，包括 persistableModeFlags，persistedModeFlags 和 persistedCreateTime！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initPersistedModes</span><span class="params">(<span class="keyword">int</span> modeFlags, <span class="keyword">long</span> createdTime)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化 persistableModeFlags 和 persistedModeFlags </span></span><br><span class="line">    <span class="comment">// 只包含 FLAG_GRANT_READ_URI_PERMISSION 和 FLAG_GRANT_WRITE_URI_PERMISSION！</span></span><br><span class="line">    modeFlags &amp;= (Intent.FLAG_GRANT_READ_URI_PERMISSION</span><br><span class="line">            | Intent.FLAG_GRANT_WRITE_URI_PERMISSION);</span><br><span class="line"></span><br><span class="line">    persistableModeFlags = modeFlags;</span><br><span class="line">    persistedModeFlags = modeFlags;</span><br><span class="line">    persistedCreateTime = createdTime;</span><br><span class="line"></span><br><span class="line">    updateModeFlags(); <span class="comment">// 更新 modeFlags!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateModeFlags</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> oldModeFlags = modeFlags;</span><br><span class="line">    modeFlags = ownedModeFlags | globalModeFlags | persistableModeFlags | persistedModeFlags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE) &amp;&amp; (modeFlags != oldModeFlags)) &#123;</span><br><span class="line">        Slog.d(TAG,</span><br><span class="line">                <span class="string">"Permission for "</span> + targetPkg + <span class="string">" to "</span> + uri + <span class="string">" is changing from 0x"</span></span><br><span class="line">                        + Integer.toHexString(oldModeFlags) + <span class="string">" to 0x"</span></span><br><span class="line">                        + Integer.toHexString(modeFlags),</span><br><span class="line">                <span class="keyword">new</span> Throwable());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>关于 UriPermission 我们这里只涉及这么多！</p>
<h3 id="3-3-5-启动-persistent-进程-startPersistentApps"><a href="#3-3-5-启动-persistent-进程-startPersistentApps" class="headerlink" title="3.3.5 启动 persistent 进程 - startPersistentApps"></a>3.3.5 启动 persistent 进程 - startPersistentApps</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startPersistentApps</span><span class="params">(<span class="keyword">int</span> matchFlags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mFactoryTest == FactoryTest.FACTORY_TEST_LOW_LEVEL) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//【1】获得 persistent 类型的 app 的信息！</span></span><br><span class="line">            <span class="keyword">final</span> List&lt;ApplicationInfo&gt; apps = AppGlobals.getPackageManager()</span><br><span class="line">                    .getPersistentApplications(STOCK_PM_FLAGS | matchFlags).getList();</span><br><span class="line">            <span class="keyword">for</span> (ApplicationInfo app : apps) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="string">"android"</span>.equals(app.packageName)) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//【2】启动对应进程！</span></span><br><span class="line">                    addAppLocked(app, <span class="keyword">false</span>, <span class="keyword">null</span> <span class="comment">/* ABI override */</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动进程调用了 <code>addAppLocked</code>，我们继续看！</p>
<h4 id="3-3-5-1-ActivityManagerS-addAppLocked"><a href="#3-3-5-1-ActivityManagerS-addAppLocked" class="headerlink" title="3.3.5.1 ActivityManagerS.addAppLocked"></a>3.3.5.1 ActivityManagerS.addAppLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ProcessRecord <span class="title">addAppLocked</span><span class="params">(ApplicationInfo info, <span class="keyword">boolean</span> isolated,</span></span></span><br><span class="line"><span class="function"><span class="params">        String abiOverride)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】创建 persistent 进程对应的 ProcessRecord 对象！</span></span><br><span class="line">    ProcessRecord app;</span><br><span class="line">    <span class="keyword">if</span> (!isolated) &#123;</span><br><span class="line">        app = getProcessRecordLocked(info.processName, info.uid, <span class="keyword">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        app = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (app == <span class="keyword">null</span>) &#123;</span><br><span class="line">        app = newProcessRecordLocked(info, <span class="keyword">null</span>, isolated, <span class="number">0</span>);</span><br><span class="line">        updateLruProcessLocked(app, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        updateOomAdjLocked();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】要被启动的 package 不能处于 true 状态！</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        AppGlobals.getPackageManager().setPackageStoppedState(</span><br><span class="line">                info.packageName, <span class="keyword">false</span>, UserHandle.getUserId(app.uid));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"Failed trying to unstop package "</span></span><br><span class="line">                + info.packageName + <span class="string">": "</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【3】设置进程的 persistent 和 maxAdj 属性！</span></span><br><span class="line">    <span class="keyword">if</span> ((info.flags &amp; PERSISTENT_MASK) == PERSISTENT_MASK) &#123;</span><br><span class="line">        app.persistent = <span class="keyword">true</span>;</span><br><span class="line">        app.maxAdj = ProcessList.PERSISTENT_PROC_ADJ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【4】保存到 mPersistentStartingProcesses 类型的集合中进行管理，并启动进程！</span></span><br><span class="line">    <span class="keyword">if</span> (app.thread == <span class="keyword">null</span> &amp;&amp; mPersistentStartingProcesses.indexOf(app) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        mPersistentStartingProcesses.add(app);</span><br><span class="line">        startProcessLocked(app, <span class="string">"added application"</span>, app.processName, abiOverride,</span><br><span class="line">                <span class="keyword">null</span> <span class="comment">/* entryPoint */</span>, <span class="keyword">null</span> <span class="comment">/* entryPointArgs */</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于进程的启动，请看我的另一系列的博文，这里就不多说了！</p>
<h3 id="3-3-6-启动桌面进程"><a href="#3-3-6-启动桌面进程" class="headerlink" title="3.3.6 启动桌面进程"></a>3.3.6 启动桌面进程</h3><p>接着是启动桌面所在的进程：</p>
<h4 id="3-3-6-1-startHomeActivityLocked"><a href="#3-3-6-1-startHomeActivityLocked" class="headerlink" title="3.3.6.1 startHomeActivityLocked"></a>3.3.6.1 startHomeActivityLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">startHomeActivityLocked</span><span class="params">(<span class="keyword">int</span> userId, String reason)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mFactoryTest == FactoryTest.FACTORY_TEST_LOW_LEVEL</span><br><span class="line">            &amp;&amp; mTopAction == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【1】创建启动桌面的 Intent！</span></span><br><span class="line">    Intent intent = getHomeIntent();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】获得桌面应用对应的 ActivityInfo 实例！</span></span><br><span class="line">    ActivityInfo aInfo = resolveActivityInfo(intent, STOCK_PM_FLAGS, userId);</span><br><span class="line">    <span class="keyword">if</span> (aInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        intent.setComponent(<span class="keyword">new</span> ComponentName(aInfo.applicationInfo.packageName, aInfo.name));</span><br><span class="line">        aInfo = <span class="keyword">new</span> ActivityInfo(aInfo);</span><br><span class="line">        aInfo.applicationInfo = getAppInfoForUser(aInfo.applicationInfo, userId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【2.1】获得桌面的进程 ProcessRecord，因为 ams 的初始化在开机，所以 app 一定为 null！</span></span><br><span class="line">        ProcessRecord app = getProcessRecordLocked(aInfo.processName,</span><br><span class="line">                aInfo.applicationInfo.uid, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (app == <span class="keyword">null</span> || app.instrumentationClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">            intent.setFlags(intent.getFlags() | Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【2.2】启动桌面！</span></span><br><span class="line">            mActivityStarter.startHomeActivityLocked(intent, aInfo, reason);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Slog.wtf(TAG, <span class="string">"No home screen found for "</span> + intent, <span class="keyword">new</span> Throwable());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-3-6-1-1-ActivityManagerS-getHomeIntent"><a href="#3-3-6-1-1-ActivityManagerS-getHomeIntent" class="headerlink" title="3.3.6.1.1 ActivityManagerS.getHomeIntent"></a>3.3.6.1.1 ActivityManagerS.getHomeIntent</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Intent <span class="title">getHomeIntent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】这里的 mTopAction 等于 Intent.ACTION_MAIN;</span></span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent(mTopAction, mTopData != <span class="keyword">null</span> ? Uri.parse(mTopData) : <span class="keyword">null</span>);</span><br><span class="line">    intent.setComponent(mTopComponent);</span><br><span class="line">    intent.addFlags(Intent.FLAG_DEBUG_TRIAGED_MISSING);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mFactoryTest != FactoryTest.FACTORY_TEST_LOW_LEVEL) &#123;</span><br><span class="line">        intent.addCategory(Intent.CATEGORY_HOME);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> intent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>startHomeActivityLocked</code> 方法最后会来自桌面 <code>activity</code> 的 <code>onCreate</code> 方法，然后，<code>resumeFocusedStackTopActivityLocked</code> 又会拉起桌面 <code>activity</code> 的 <code>onResume</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mStackSupervisor.resumeFocusedStackTopActivityLocked();</span><br></pre></td></tr></table></figure>
<p>对于 <code>activity</code> 的启动，这里我就不多讲了，请看我的其他博文！</p>
<p>到这里，桌面就完全显示在用户面前的，然而，还没有结束，我们进入到 <code>ActivityThread</code> 中去：</p>
<h4 id="3-3-6-2-ActivityThread-handleResumeActivity"><a href="#3-3-6-2-ActivityThread-handleResumeActivity" class="headerlink" title="3.3.6.2 ActivityThread.handleResumeActivity"></a>3.3.6.2 ActivityThread.handleResumeActivity</h4><p><code>handleResumeActivity</code> 负责拉起桌面 <code>activity</code> 的 <code>onResume</code> 方法，我们过滤掉一些不重要的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">handleResumeActivity</span><span class="params">(IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> clearHide, <span class="keyword">boolean</span> isForward, <span class="keyword">boolean</span> reallyResume, <span class="keyword">int</span> seq, String reason)</span> </span>&#123;</span><br><span class="line">    ... ... ... ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拉起桌面 activity 的 onResume 方法！</span></span><br><span class="line">    r = performResumeActivity(token, clearHide, reason);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> Activity a = r.activity;</span><br><span class="line"></span><br><span class="line">        ... ... ... ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!r.onlyLocalRequest) &#123;</span><br><span class="line">            r.nextIdle = mNewActivities;</span><br><span class="line">            mNewActivities = r;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建了一个 Idler 对象，加入到了主线程的 Looper 队列中！</span></span><br><span class="line">            Looper.myQueue().addIdleHandler(<span class="keyword">new</span> Idler());</span><br><span class="line">        &#125;</span><br><span class="line">        r.onlyLocalRequest = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (reallyResume) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ActivityManagerNative.getDefault().activityResumed(token);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">                <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ... ... ... ...</span><br><span class="line">        <span class="comment">// 异常状态，不处理！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当桌面进程的主线程进入空闲状态时，<code>Idler.queueIdle</code> 方法会被执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Idler</span> <span class="keyword">implements</span> <span class="title">MessageQueue</span>.<span class="title">IdleHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">queueIdle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ActivityClientRecord a = mNewActivities;</span><br><span class="line">        <span class="keyword">boolean</span> stopProfiling = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (mBoundApplication != <span class="keyword">null</span> &amp;&amp; mProfiler.profileFd != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; mProfiler.autoStopProfiler) &#123;</span><br><span class="line">            stopProfiling = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mNewActivities = <span class="keyword">null</span>;</span><br><span class="line">            IActivityManager am = ActivityManagerNative.getDefault();</span><br><span class="line">            ActivityClientRecord prev;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (localLOGV) Slog.v(</span><br><span class="line">                    TAG, <span class="string">"Reporting idle of "</span> + a +</span><br><span class="line">                    <span class="string">" finished="</span> +</span><br><span class="line">                    (a.activity != <span class="keyword">null</span> &amp;&amp; a.activity.mFinished));</span><br><span class="line">                <span class="keyword">if</span> (a.activity != <span class="keyword">null</span> &amp;&amp; !a.activity.mFinished) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//【1】调用 ams 的 activityIdle 方法！</span></span><br><span class="line">                        am.activityIdle(a.token, a.createdConfig, stopProfiling);</span><br><span class="line">                        a.createdConfig = <span class="keyword">null</span>;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                prev = a;</span><br><span class="line">                a = a.nextIdle;</span><br><span class="line">                prev.nextIdle = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">while</span> (a != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stopProfiling) &#123;</span><br><span class="line">            mProfiler.stopProfiling();</span><br><span class="line">        &#125;</span><br><span class="line">        ensureJitEnabled();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面，进入 <code>ActivityManagerService</code> 中去：</p>
<h4 id="3-3-6-3-ActivityManagerS-activityIdle"><a href="#3-3-6-3-ActivityManagerS-activityIdle" class="headerlink" title="3.3.6.3 ActivityManagerS.activityIdle"></a>3.3.6.3 ActivityManagerS.activityIdle</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">activityIdle</span><span class="params">(IBinder token, Configuration config, <span class="keyword">boolean</span> stopProfiling)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        ActivityStack stack = ActivityRecord.getStackLocked(token);</span><br><span class="line">        <span class="keyword">if</span> (stack != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//【1】继续调用！</span></span><br><span class="line">            ActivityRecord r =</span><br><span class="line">                    mStackSupervisor.activityIdleInternalLocked(token, <span class="keyword">false</span>, config);</span><br><span class="line">            <span class="keyword">if</span> (stopProfiling) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((mProfileProc == r.app) &amp;&amp; (mProfileFd != <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        mProfileFd.close();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                    clearProfilerLocked();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Binder.restoreCallingIdentity(origId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-6-4-ActivityManagerS-activityIdleInternalLocked"><a href="#3-3-6-4-ActivityManagerS-activityIdleInternalLocked" class="headerlink" title="3.3.6.4 ActivityManagerS.activityIdleInternalLocked"></a>3.3.6.4 ActivityManagerS.activityIdleInternalLocked</h4><p>这里我们只关注和 <code>AMS</code>启动有关的代码！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ActivityRecord <span class="title">activityIdleInternalLocked</span><span class="params">(<span class="keyword">final</span> IBinder token, <span class="keyword">boolean</span> fromTimeout,</span></span></span><br><span class="line"><span class="function"><span class="params">        Configuration config)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_ALL) Slog.v(TAG, <span class="string">"Activity idle: "</span> + token);</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;ActivityRecord&gt; finishes = <span class="keyword">null</span>;</span><br><span class="line">    ArrayList&lt;UserState&gt; startingUsers = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> NS = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> NF = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> booting = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> activityRemoved = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    ActivityRecord r = ActivityRecord.forTokenLocked(token);</span><br><span class="line">    <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_IDLE) Slog.d(TAG_IDLE, <span class="string">"activityIdleInternalLocked: Callers="</span></span><br><span class="line">                + Debug.getCallers(<span class="number">4</span>));</span><br><span class="line">        mHandler.removeMessages(IDLE_TIMEOUT_MSG, r);</span><br><span class="line">        r.finishLaunchTickingLocked();</span><br><span class="line">        <span class="keyword">if</span> (fromTimeout) &#123;</span><br><span class="line">            reportActivityLaunchedLocked(fromTimeout, r, -<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (config != <span class="keyword">null</span>) &#123;</span><br><span class="line">            r.configuration = config;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        r.idle = <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 显然，桌面 activity 所在的 stack 就是焦点栈！</span></span><br><span class="line">        <span class="keyword">if</span> (isFocusedStack(r.task.stack) || fromTimeout) &#123;</span><br><span class="line">            <span class="comment">//【1】继续调用！</span></span><br><span class="line">            booting = checkFinishBootingLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ... ... ... ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-6-5-ActivityStackS-checkFinishBootingLocked"><a href="#3-3-6-5-ActivityStackS-checkFinishBootingLocked" class="headerlink" title="3.3.6.5 ActivityStackS.checkFinishBootingLocked"></a>3.3.6.5 ActivityStackS.checkFinishBootingLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkFinishBootingLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 此时 mService.mBooting 为 true；</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> booting = mService.mBooting;</span><br><span class="line">    <span class="keyword">boolean</span> enableScreen = <span class="keyword">false</span>;</span><br><span class="line">    mService.mBooting = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!mService.mBooted) &#123;</span><br><span class="line">        mService.mBooted = <span class="keyword">true</span>;</span><br><span class="line">        enableScreen = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (booting || enableScreen) &#123;</span><br><span class="line">        <span class="comment">//【1】进入这里！</span></span><br><span class="line">        mService.postFinishBooting(booting, enableScreen);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> booting;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>postFinishBooting</code> 会通过 <code>MainHandler</code> 发送 <code>FINISH_BOOTING_MSG</code> 消息给子线程，子线程会调用 <code>AMS.finishBooting</code> 的方法！</p>
<h4 id="3-3-6-6-ActivityManagerS-finishBooting"><a href="#3-3-6-6-ActivityManagerS-finishBooting" class="headerlink" title="3.3.6.6 ActivityManagerS.finishBooting"></a>3.3.6.6 ActivityManagerS.finishBooting</h4><p>该方法就是最关键的地方了，我们的开机广播就是在这个地方发送的！！！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">finishBooting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">//【1】如果开机动画没有显示完，则退出，等开机动画显示完后才会调用！</span></span><br><span class="line">        <span class="keyword">if</span> (!mBootAnimationComplete) &#123;</span><br><span class="line">            mCallFinishBooting = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mCallFinishBooting = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查系统 ABI，ABI 和系统 cpu 指令集有关！</span></span><br><span class="line">    ArraySet&lt;String&gt; completedIsas = <span class="keyword">new</span> ArraySet&lt;String&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String abi : Build.SUPPORTED_ABIS) &#123;</span><br><span class="line">        Process.establishZygoteConnectionForAbi(abi);</span><br><span class="line">        <span class="keyword">final</span> String instructionSet = VMRuntime.getInstructionSet(abi);</span><br><span class="line">        <span class="keyword">if</span> (!completedIsas.contains(instructionSet)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mInstaller.markBootComplete(VMRuntime.getInstructionSet(abi));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InstallerException e) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Unable to mark boot complete for abi: "</span> + abi + <span class="string">" ("</span> +</span><br><span class="line">                        e.getMessage() +<span class="string">")"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            completedIsas.add(instructionSet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册接收者，监听重启 package 的广播，当系统发送了该广播后，该广播会传递所有需要重启的 package</span></span><br><span class="line">    <span class="comment">// 这里监听到该广播后，会重启所有的 package 的进程！</span></span><br><span class="line">    IntentFilter pkgFilter = <span class="keyword">new</span> IntentFilter();</span><br><span class="line">    pkgFilter.addAction(Intent.ACTION_QUERY_PACKAGE_RESTART);</span><br><span class="line">    pkgFilter.addDataScheme(<span class="string">"package"</span>);</span><br><span class="line">    mContext.registerReceiver(<span class="keyword">new</span> BroadcastReceiver() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">            String[] pkgs = intent.getStringArrayExtra(Intent.EXTRA_PACKAGES);</span><br><span class="line">            <span class="keyword">if</span> (pkgs != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (String pkg : pkgs) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (ActivityManagerService.<span class="keyword">this</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (forceStopPackageLocked(pkg, -<span class="number">1</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>,</span><br><span class="line">                                <span class="number">0</span>, <span class="string">"query restart"</span>)) &#123;</span><br><span class="line">                            setResultCode(Activity.RESULT_OK);</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, pkgFilter);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册接收者，监听 ACTION_DELETE_DUMPHEAP 广播！</span></span><br><span class="line">    IntentFilter dumpheapFilter = <span class="keyword">new</span> IntentFilter();</span><br><span class="line">    dumpheapFilter.addAction(DumpHeapActivity.ACTION_DELETE_DUMPHEAP);</span><br><span class="line">    mContext.registerReceiver(<span class="keyword">new</span> BroadcastReceiver() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (intent.getBooleanExtra(DumpHeapActivity.EXTRA_DELAY_DELETE, <span class="keyword">false</span>)) &#123;</span><br><span class="line">                mHandler.sendEmptyMessageDelayed(POST_DUMP_HEAP_NOTIFICATION_MSG, <span class="number">5</span>*<span class="number">60</span>*<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mHandler.sendEmptyMessage(POST_DUMP_HEAP_NOTIFICATION_MSG);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, dumpheapFilter);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知系统服务已经进入最后阶段：PHASE_BOOT_COMPLETED</span></span><br><span class="line">    mSystemServiceManager.startBootPhase(SystemService.PHASE_BOOT_COMPLETED);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 启动那些之前无法启动的进程，比如系统进程未准备好，且不是常驻进程等等！</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> NP = mProcessesOnHold.size();</span><br><span class="line">        <span class="keyword">if</span> (NP &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ArrayList&lt;ProcessRecord&gt; procs =</span><br><span class="line">                <span class="keyword">new</span> ArrayList&lt;ProcessRecord&gt;(mProcessesOnHold);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> ip=<span class="number">0</span>; ip&lt;NP; ip++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_PROCESSES) Slog.v(TAG_PROCESSES, <span class="string">"Starting process on hold: "</span></span><br><span class="line">                        + procs.get(ip));</span><br><span class="line">                <span class="comment">// 启动之前无法启动而被系统暂时监管的应用进程！</span></span><br><span class="line">                startProcessLocked(procs.get(ip), <span class="string">"on-hold"</span>, <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mFactoryTest != FactoryTest.FACTORY_TEST_LOW_LEVEL) &#123;</span><br><span class="line">            Message nmsg = mHandler.obtainMessage(CHECK_EXCESSIVE_WAKE_LOCKS_MSG);</span><br><span class="line">            mHandler.sendMessageDelayed(nmsg, POWER_CHECK_DELAY);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置系统属性！</span></span><br><span class="line">            SystemProperties.set(<span class="string">"sys.boot_completed"</span>, <span class="string">"1"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!<span class="string">"trigger_restart_min_framework"</span>.equals(SystemProperties.get(<span class="string">"vold.decrypt"</span>))</span><br><span class="line">                || <span class="string">""</span>.equals(SystemProperties.get(<span class="string">"vold.encrypt_progress"</span>))) &#123;</span><br><span class="line">                SystemProperties.set(<span class="string">"dev.bootcomplete"</span>, <span class="string">"1"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//【2】解锁设备用户，发送开机相关的广播！</span></span><br><span class="line">            mUserController.sendBootCompletedLocked(</span><br><span class="line">                    <span class="keyword">new</span> IIntentReceiver.Stub() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performReceive</span><span class="params">(Intent intent, <span class="keyword">int</span> resultCode,</span></span></span><br><span class="line"><span class="function"><span class="params">                                String data, Bundle extras, <span class="keyword">boolean</span> ordered,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> sendingUser)</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">synchronized</span> (ActivityManagerService.<span class="keyword">this</span>) &#123;</span><br><span class="line">                                requestPssAllProcsLocked(SystemClock.uptimeMillis(),</span><br><span class="line">                                        <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            scheduleStartProfilesLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>总体来看，逻辑不复杂，最后的一步很关键：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mUserController.sendBootCompletedLocked(...);</span><br></pre></td></tr></table></figure></p>
<p>该方法会发送一系列的开机广播，并且会解除所有启动完成的设备用户的锁定状态！</p>
<p>广播的发送顺序是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ACTION_LOCKED_BOOT_COMPLETED -&gt; ACTION_PRE_BOOT_COMPLETED -&gt; ACTION_BOOT_COMPLETED</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>ACTION_LOCKED_BOOT_COMPLETED</strong></li>
</ul>
<p>因为此时设备用户仍然处于锁定状态，该方法会首先发送 <code>ACTION_LOCKED_BOOT_COMPLETED</code> 广播，<br>这个广播的触发时机是：设备用户已经完成了启动，当时仍然处于锁定状态！</p>
<p>发生了该广播后，系统进程就会开始接触设备用户的锁定！！</p>
<ul>
<li><strong>ACTION_PRE_BOOT_COMPLETED</strong></li>
</ul>
<p>当设备用户解除锁定后，就会发送这个广播，这个广播的发送时机是，系统升级后，设备的 <code>FINGERPRINT</code> 发生了变化！如果没有发生变化的话，会直接发送 <code>ACTION_BOOT_COMPLETED</code> 广播！</p>
<p>下面是核心代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">finishUserUnlocked</span><span class="params">(<span class="keyword">final</span> UserState uss)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> userId = uss.mHandle.getIdentifier();</span><br><span class="line">    <span class="keyword">synchronized</span> (mService) &#123;</span><br><span class="line">        ... ... ... ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (uss.setState(STATE_RUNNING_UNLOCKING, STATE_RUNNING_UNLOCKED)) &#123;</span><br><span class="line">            ... ... ... ... ...</span><br><span class="line">      </span><br><span class="line">            <span class="keyword">final</span> UserInfo info = getUserInfo(userId);</span><br><span class="line">             </span><br><span class="line">            <span class="keyword">if</span> (!Objects.equals(info.lastLoggedInFingerprint, Build.FINGERPRINT)) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">boolean</span> quiet;</span><br><span class="line">                <span class="keyword">if</span> (info.isManagedProfile()) &#123;</span><br><span class="line">                    quiet = !uss.tokenProvided</span><br><span class="line">                            || !mLockPatternUtils.isSeparateProfileChallengeEnabled(userId);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    quiet = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// PreBootBroadcaster 的 sendNext 方法中会发送 ACTION_PRE_BOOT_COMPLETED！</span></span><br><span class="line">                <span class="keyword">new</span> PreBootBroadcaster(mService, userId, <span class="keyword">null</span>, quiet) &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFinished</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="comment">// 该方法会发送 ACTION_BOOT_COMPLETED 广播！</span></span><br><span class="line">                        finishUserUnlockedCompleted(uss);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;.sendNext();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 该方法会发送 ACTION_BOOT_COMPLETED 广播！</span></span><br><span class="line">                finishUserUnlockedCompleted(uss);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>ACTION_BOOT_COMPLETED</strong></li>
</ul>
<p><code>ACTION_PRE_BOOT_COMPLETED</code> 广播是最后发送的，也就是我们说的开机广播，发送的代码在 <code>finishUserUnlockedCompleted</code> 方法中！</p>
<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>到这里，<code>AMS</code> 的启动过程就分析完了!</p>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2019 By Coolqi.Li</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.6"></script><script src="/js/fancybox.js?version=1.5.6"></script><script src="/js/sidebar.js?version=1.5.6"></script><script src="/js/copy.js?version=1.5.6"></script><script src="/js/fireworks.js?version=1.5.6"></script><script src="/js/transition.js?version=1.5.6"></script><script src="/js/scroll.js?version=1.5.6"></script><script src="/js/head.js?version=1.5.6"></script><script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"live2d-widget-model-hijiki"},"display":{"position":"right","width":110,"height":220},"mobile":{"show":false},"log":false});</script></body></html>