<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="“你好，我是李帅奇，Android 系统工程师，MineCraft 忠实玩家，设计和绘画爱好者，缺妹纸晚期患者，熬夜星人。”"><meta name="keywords" content=""><meta name="author" content="Coolqi.Li,undefined"><meta name="copyright" content="Coolqi.Li"><title>Every day is always sleepy. | Coolqi`s Blog</title><link rel="shortcut icon" href="/my-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.5.6"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.5.6"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Coolqi.Li</div><div class="author-info__description text-center">“你好，我是李帅奇，Android 系统工程师，MineCraft 忠实玩家，设计和绘画爱好者，缺妹纸晚期患者，熬夜星人。”</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">64</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">14</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">15</span></a></div></div></div><nav class="no-bg" id="nav"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Coolqi`s Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a></span></div><div id="site-info"><div id="site-title">Coolqi`s Blog</div><div id="site-sub-title">Every day is always sleepy.</div></div></nav><div id="sidebar"><div class="author-info"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Coolqi.Li</div><div class="author-info__description text-center">“你好，我是李帅奇，Android 系统工程师，MineCraft 忠实玩家，设计和绘画爱好者，缺妹纸晚期患者，熬夜星人。”</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">64</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">14</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">15</span></a></div></div></div><div id="content-outer"><div class="layout" id="content-inner"><div class="recent-post-item article-container"><a class="article-title" href="/2017/04/03/UsageStats 第 2 篇 - UsageStatsService 消息处理/">UsageStats 第 2 篇 - UsageStatsService 消息处理</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-04-03</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/AndroidFramework源码分析/">AndroidFramework源码分析</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/AndroidFramework源码分析/UsageStats使用状态管理/">UsageStats使用状态管理</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/UsageStats使用状态管理/">UsageStats使用状态管理</a></span><div class="content"><p>[toc]</p>
<p>基于 Android7.1.1 源码分析 UsageStatsService 的架构和原理</p>
<p>UsageStatsService 定义的事件类型目前一共有 8 种类型，全部定义在 UsageEvents.java 中，如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An event type denoting that a component moved to the foreground.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVE_TO_FOREGROUND = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An event type denoting that a component moved to the background.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVE_TO_BACKGROUND = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An event type denoting that a component was in the foreground when the stats</span></span><br><span class="line"><span class="comment"> * rolled-over. This is effectively treated as a &#123;<span class="doctag">@link</span> #MOVE_TO_BACKGROUND&#125;.</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@hide</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> END_OF_DAY = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An event type denoting that a component was in the foreground the previous day.</span></span><br><span class="line"><span class="comment"> * This is effectively treated as a &#123;<span class="doctag">@link</span> #MOVE_TO_FOREGROUND&#125;.</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@hide</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONTINUE_PREVIOUS_DAY = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An event type denoting that the device configuration has changed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONFIGURATION_CHANGE = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An event type denoting that a package was interacted with in some way by the system.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SYSTEM_INTERACTION = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An event type denoting that a package was interacted with in some way by the user.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> USER_INTERACTION = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An event type denoting that an action equivalent to a ShortcutInfo is taken by the user.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> android.content.pm.ShortcutManager#reportShortcutUsed(String)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHORTCUT_INVOCATION = <span class="number">8</span>;</span><br></pre></td></tr></table></figure>
<h1 id="0-综述"><a href="#0-综述" class="headerlink" title="0 综述"></a>0 综述</h1><p>UsageStatsService 的消息处理是在 H 中， 下面我们去看看具体的消息处理！</p>
<h1 id="1-消息：MSG-REPORT-EVENT-OK"><a href="#1-消息：MSG-REPORT-EVENT-OK" class="headerlink" title="1 消息：MSG_REPORT_EVENT - OK"></a>1 消息：MSG_REPORT_EVENT - OK</h1><h2 id="1-0-消息触发时机"><a href="#1-0-消息触发时机" class="headerlink" title="1.0 消息触发时机"></a>1.0 消息触发时机</h2><p>当 AcitivtyManagerService 调用 LocalService 的以下方法的时候，会发送 MSG_REPORT_EVENT 消息！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalService</span> <span class="keyword">extends</span> <span class="title">UsageStatsManagerInternal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reportEvent</span><span class="params">(ComponentName component, <span class="keyword">int</span> userId, <span class="keyword">int</span> eventType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (component == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Event reported without a component name"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        UsageEvents.Event event = <span class="keyword">new</span> UsageEvents.Event();</span><br><span class="line">        event.mPackage = component.getPackageName();</span><br><span class="line">        event.mClass = component.getClassName();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This will later be converted to system time.</span></span><br><span class="line">        event.mTimeStamp = SystemClock.elapsedRealtime();</span><br><span class="line"></span><br><span class="line">        event.mEventType = eventType;</span><br><span class="line">        mHandler.obtainMessage(MSG_REPORT_EVENT, userId, <span class="number">0</span>, event).sendToTarget();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>还有其他的 report 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reportEvent</span><span class="params">(String packageName, <span class="keyword">int</span> userId, <span class="keyword">int</span> eventType)</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reportConfigurationChange</span><span class="params">(Configuration config, <span class="keyword">int</span> userId)</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reportShortcutUsage</span><span class="params">(String packageName, String shortcutId, <span class="keyword">int</span> userId)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这些方法会接收到传入的 event，然后发送 MSG_REPORT_EVENT 消息！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> MSG_REPORT_EVENT:</span><br><span class="line">    reportEvent((UsageEvents.Event) msg.obj, msg.arg1);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>该消息会携带  2 个重要数据：UsageEvents 和 userId！</p>
<h2 id="1-1-UsageStatsService-reportEvent"><a href="#1-1-UsageStatsService-reportEvent" class="headerlink" title="1.1 UsageStatsService.reportEvent"></a>1.1 UsageStatsService.reportEvent</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reportEvent</span><span class="params">(UsageEvents.Event event, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="comment">//【*1.1.1】获得当前的实际时间点；</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> timeNow = checkAndGetTimeLocked();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> elapsedRealtime = SystemClock.elapsedRealtime();</span><br><span class="line">        <span class="comment">//【*1.1.2】将 UsageEvents 的时间戳转为系统时间；</span></span><br><span class="line">        convertToSystemTimeLocked(event);</span><br><span class="line">        <span class="comment">//【*1.1.3】获得 userId 的使用信息；</span></span><br><span class="line">        <span class="keyword">final</span> UserUsageStatsService service =</span><br><span class="line">                getUserDataAndInitializeIfNeededLocked(userId, timeNow);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【*1.1.4】判断 event 所属应用当前是否处于 idle 状态！</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> previouslyIdle = mAppIdleHistory.isIdleLocked(</span><br><span class="line">                event.mPackage, userId, elapsedRealtime);</span><br><span class="line">                </span><br><span class="line">        <span class="comment">//【1】调用了 UserUsageStatsService 的 reportEvent 方法记录该 event！</span></span><br><span class="line">        service.reportEvent(event);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【2】如果本次的 event type 是如下类型，进入下面的 IF 分支！</span></span><br><span class="line">        <span class="keyword">if</span> ((event.mEventType == Event.MOVE_TO_FOREGROUND</span><br><span class="line">                || event.mEventType == Event.MOVE_TO_BACKGROUND</span><br><span class="line">                || event.mEventType == Event.SYSTEM_INTERACTION</span><br><span class="line">                || event.mEventType == Event.USER_INTERACTION)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【×1.1.6】更新下 app idle 信息！</span></span><br><span class="line">            mAppIdleHistory.reportUsageLocked(event.mPackage, userId, elapsedRealtime);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【2.1】如果之前是 idle 状态，此时退出 idle 状态！</span></span><br><span class="line">            <span class="keyword">if</span> (previouslyIdle) &#123;</span><br><span class="line">                mHandler.sendMessage(mHandler.obtainMessage(MSG_INFORM_LISTENERS, userId,</span><br><span class="line">                        <span class="comment">/* idle = */</span> <span class="number">0</span>, event.mPackage));</span><br><span class="line">                notifyBatteryStats(event.mPackage, userId, <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 UserUsageStatsService.reportEvent 方法，这里不再多说！</p>
<h3 id="1-1-1-UsageStatsService-checkAndGetTimeLocked"><a href="#1-1-1-UsageStatsService-checkAndGetTimeLocked" class="headerlink" title="1.1.1 UsageStatsService.checkAndGetTimeLocked"></a>1.1.1 UsageStatsService.checkAndGetTimeLocked</h3><p>checkAndGetTimeLocked 方法用于计算当前的实际时间！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">checkAndGetTimeLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】获得当前的系统时间，可以被系统设置修改；</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> actualSystemTime = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">//【2】获得自开机后，经过的时间，包括深度睡眠的时间；</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> actualRealtime = SystemClock.elapsedRealtime();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> expectedSystemTime = (actualRealtime - mRealTimeSnapshot) + mSystemTimeSnapshot;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> diffSystemTime = actualSystemTime - expectedSystemTime;</span><br><span class="line">    <span class="comment">//【3】判断时间是否有发生变化，</span></span><br><span class="line">    <span class="keyword">if</span> (Math.abs(diffSystemTime) &gt; TIME_CHANGE_THRESHOLD_MILLIS) &#123;</span><br><span class="line">        <span class="comment">// The time has changed.</span></span><br><span class="line">        Slog.i(TAG, <span class="string">"Time changed in UsageStats by "</span> + (diffSystemTime / <span class="number">1000</span>) + <span class="string">" seconds"</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> userCount = mUserState.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; userCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> UserUsageStatsService service = mUserState.valueAt(i);</span><br><span class="line">            <span class="comment">//【3.1】更新本地数据！</span></span><br><span class="line">            service.onTimeChanged(expectedSystemTime, actualSystemTime);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【3.2】记录本次的时间点到 mRealTimeSnapshot，mSystemTimeSnapshot！</span></span><br><span class="line">        mRealTimeSnapshot = actualRealtime;</span><br><span class="line">        mSystemTimeSnapshot = actualSystemTime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【4】返回当前的实际时间！</span></span><br><span class="line">    <span class="keyword">return</span> actualSystemTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 checkAndGetTimeLocked 返回的时间是  actualSystemTime 的值，也就是 System.currentTimeMillis()，这个时间值可以被系统设置修改，然后值就会发生跳变，比如联网对时，手动调时！</p>
<p>而 actualRealtime 的值为 System.elapsedRealtime 自开机后，经过的时间，包括深度睡眠的时间，这部分时间值是不会被修改；</p>
<p>如果判断时间是否有发生调时，对时情况呢？</p>
<ul>
<li>mSystemTimeSnapshot 中保存的是上一次 check 时的系统时间；</li>
<li>mRealTimeSnapshot 中保存的是上一次 check 时的自开机后，经过的时间；</li>
<li>先计算出期望的时间：<ul>
<li>本次距离开机的时间 actualRealtime - 上次距离开机的时间 mRealTimeSnapshot，这个时间差值是正常情况下的时间差值；</li>
<li>然后再加上上一次 check 时的系统时间 mSystemTimeSnapshot，如果没有发生调时的话，这个应该是理想的时间点 expectedSystemTime；</li>
<li>如果发生了调时，对时的情况，actualSystemTime 一定是会发生变化的！</li>
<li>计算 actualSystemTime 和 expectedSystemTime 的差值，如果大于 TIME_CHANGE_THRESHOLD_MILLIS，说明铁定发生了调时，对时；</li>
</ul>
</li>
</ul>
<p>如果发生上述情况，那就调用 UserUsageStatsService.onTimeChanged 更新本地持久化文件的日期！</p>
<p>对于 UsageStatsService 是如何存储应用数据，如何更新本地持久化文件的，这里我先不关注，我们只需要知道，该方法返回的时间值是实际的时间（正常，手动调时，联网对时）</p>
<p>对于 service.onTimeChanged 方法，这里不再分析！</p>
<h3 id="1-1-2-AppIdleHistory-convertToSystemTimeLocked"><a href="#1-1-2-AppIdleHistory-convertToSystemTimeLocked" class="headerlink" title="1.1.2 AppIdleHistory.convertToSystemTimeLocked"></a>1.1.2 AppIdleHistory.convertToSystemTimeLocked</h3><p>UsageEvents.Event 的 mTimeStamp 是在设置的时候，是通过 SystemClock.elapsedRealtime() 计算的；<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">convertToSystemTimeLocked</span><span class="params">(UsageEvents.Event event)</span> </span>&#123;</span><br><span class="line">    event.mTimeStamp = Math.max(<span class="number">0</span>, event.mTimeStamp - mRealTimeSnapshot) + mSystemTimeSnapshot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>convertToSystemTimeLocked 的作用是：</p>
<ul>
<li>将相对于开机的时间转为系统时间：SystemClock.elapsedRealtime() -&gt; SystemClock.currentTimeMillis()!</li>
</ul>
<h3 id="1-1-3-UsageStatsS-getUserDataAndInitializeIfNeededLocked"><a href="#1-1-3-UsageStatsS-getUserDataAndInitializeIfNeededLocked" class="headerlink" title="1.1.3 UsageStatsS.getUserDataAndInitializeIfNeededLocked"></a>1.1.3 UsageStatsS.getUserDataAndInitializeIfNeededLocked</h3><p>尝试获得指定 userId 对应的 UserUsageStatsService 对象，封装了该 userId 的使用情况！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> UserUsageStatsService <span class="title">getUserDataAndInitializeIfNeededLocked</span><span class="params">(<span class="keyword">int</span> userId,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span> currentTimeMillis)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】尝试获得 userId 对应的使用情况</span></span><br><span class="line">    UserUsageStatsService service = mUserState.get(userId);</span><br><span class="line">    <span class="comment">//【1.1.3.1】如果为 null，那就默认会初始化一个！</span></span><br><span class="line">    <span class="keyword">if</span> (service == <span class="keyword">null</span>) &#123;</span><br><span class="line">        service = <span class="keyword">new</span> UserUsageStatsService(getContext(), userId,</span><br><span class="line">                <span class="keyword">new</span> File(mUsageStatsDir, Integer.toString(userId)), <span class="keyword">this</span>);</span><br><span class="line">        service.init(currentTimeMillis);</span><br><span class="line">        mUserState.put(userId, service);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【3】返回对应的 UserUsageStatsService 对象</span></span><br><span class="line">    <span class="keyword">return</span> service;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里要涉及到另外一个数据结构 UserUsageStatsService，UserUsageStatsService 用于保存每个 userId 的使用情况！</p>
<p>UsageStatsService 内部会通过 mUserState 来记录 userId 的使用情况：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SparseArray&lt;UserUsageStatsService&gt; mUserState = <span class="keyword">new</span> SparseArray&lt;&gt;();</span><br></pre></td></tr></table></figure></p>
<h4 id="1-1-3-1-new-UserUsageStatsService"><a href="#1-1-3-1-new-UserUsageStatsService" class="headerlink" title="1.1.3.1 new UserUsageStatsService"></a>1.1.3.1 new UserUsageStatsService</h4><p>创建一个 UserUsageStatsService 对象！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">UserUsageStatsService(Context context, <span class="keyword">int</span> userId, File usageStatsDir,</span><br><span class="line">        StatsUpdatedListener listener) &#123;</span><br><span class="line">    mContext = context;</span><br><span class="line">    mDailyExpiryDate = <span class="keyword">new</span> UnixCalendar(<span class="number">0</span>);</span><br><span class="line">    mDatabase = <span class="keyword">new</span> UsageStatsDatabase(usageStatsDir);</span><br><span class="line">    mCurrentStats = <span class="keyword">new</span> IntervalStats[UsageStatsManager.INTERVAL_COUNT];</span><br><span class="line">    mListener = listener;</span><br><span class="line">    mLogPrefix = <span class="string">"User["</span> + Integer.toString(userId) + <span class="string">"] "</span>;</span><br><span class="line">    mUserId = userId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="1-1-4-AppIdleHistory-isIdleLocked"><a href="#1-1-4-AppIdleHistory-isIdleLocked" class="headerlink" title="1.1.4 AppIdleHistory.isIdleLocked"></a>1.1.4 AppIdleHistory.isIdleLocked</h3><p>判断在 elapsedRealtime 指定的时间点下，该 package 是否是 idle 状态！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isIdleLocked</span><span class="params">(String packageName, <span class="keyword">int</span> userId, <span class="keyword">long</span> elapsedRealtime)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1.4.1】获得该 userId 下的历史信息！</span></span><br><span class="line">    ArrayMap&lt;String, PackageHistory&gt; userHistory = getUserHistoryLocked(userId);</span><br><span class="line">    <span class="comment">//【1.4.2】获得该 pacakge 的历史信息 PackageHistory！</span></span><br><span class="line">    PackageHistory packageHistory =</span><br><span class="line">            getPackageHistoryLocked(userHistory, packageName, elapsedRealtime);</span><br><span class="line">    <span class="comment">//【3】如果 packageHistory，那就返回 false，默认为不处于 idle 状态！</span></span><br><span class="line">    <span class="keyword">if</span> (packageHistory == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//【1.1.4.1】判断该 package 是否属于 idle 状态！</span></span><br><span class="line">        <span class="keyword">return</span> hasPassedThresholdsLocked(packageHistory, elapsedRealtime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-1-4-1-AppIdleHistory-hasPassedThresholdsLocked"><a href="#1-1-4-1-AppIdleHistory-hasPassedThresholdsLocked" class="headerlink" title="1.1.4.1 AppIdleHistory.hasPassedThresholdsLocked"></a>1.1.4.1 AppIdleHistory.hasPassedThresholdsLocked</h4><p>接下来看看系统是如何判断一个应用是否进入 idle 状态！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasPassedThresholdsLocked</span><span class="params">(PackageHistory packageHistory, <span class="keyword">long</span> elapsedRealtime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (packageHistory.lastUsedScreenTime</span><br><span class="line">                &lt;= getScreenOnTimeLocked(elapsedRealtime) - mScreenOnTimeThreshold)</span><br><span class="line">            &amp;&amp; (packageHistory.lastUsedElapsedTime</span><br><span class="line">                    &lt;= getElapsedTimeLocked(elapsedRealtime) - mElapsedTimeThreshold);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>需要满足 2 个条件：</p>
<ul>
<li>自开机时算起，当前时间距离应用上次被使用的时间（自开机时算起），超过了 24 小时！</li>
<li>只算亮屏时间，当前时间距离应用上次被使用的时间（只算亮屏时间），超过了 12 小时！</li>
</ul>
<h3 id="1-1-6-AppIdleHistory-reportUsageLocked"><a href="#1-1-6-AppIdleHistory-reportUsageLocked" class="headerlink" title="1.1.6 AppIdleHistory.reportUsageLocked"></a>1.1.6 AppIdleHistory.reportUsageLocked</h3><p>根据 report event 的时间点，更新 app idle 相关的时间信息！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reportUsageLocked</span><span class="params">(String packageName, <span class="keyword">int</span> userId, <span class="keyword">long</span> elapsedRealtime)</span> </span>&#123;</span><br><span class="line">    ArrayMap&lt;String, PackageHistory&gt; userHistory = getUserHistoryLocked(userId);</span><br><span class="line">    PackageHistory packageHistory = getPackageHistoryLocked(userHistory, packageName,</span><br><span class="line">            elapsedRealtime);</span><br><span class="line"></span><br><span class="line">    shiftHistoryToNow(userHistory, elapsedRealtime);</span><br><span class="line">    <span class="comment">//【1】自开机后，该应用最后一次使用的时间；     </span></span><br><span class="line">    packageHistory.lastUsedElapsedTime = mElapsedDuration  + (elapsedRealtime - mElapsedSnapshot);</span><br><span class="line">    <span class="comment">//【2】在只计算亮屏时间的条件下，该应用最后一次使用的时间；</span></span><br><span class="line">    packageHistory.lastUsedScreenTime = getScreenOnTimeLocked(elapsedRealtime);</span><br><span class="line"></span><br><span class="line">    packageHistory.recent[HISTORY_SIZE - <span class="number">1</span>] = FLAG_LAST_STATE | FLAG_PARTIAL_ACTIVE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到，当每次 report event 后，会更新 PackageHistory 的如下两个变量：</p>
<ul>
<li><strong>lastUsedElapsedTime</strong>：自开机后，应用最后一次被使用的时间；</li>
<li><strong>lastUsedScreenTime</strong>：只计算亮屏时间的情况下，应用最后一次被使用的时间；</li>
</ul>
<h1 id="2-消息：MSG-FLUSH-TO-DISK-OK"><a href="#2-消息：MSG-FLUSH-TO-DISK-OK" class="headerlink" title="2 消息：MSG_FLUSH_TO_DISK - OK"></a>2 消息：MSG_FLUSH_TO_DISK - OK</h1><h2 id="2-0-消息触发时机"><a href="#2-0-消息触发时机" class="headerlink" title="2.0 消息触发时机"></a>2.0 消息触发时机</h2><p>在如下的情况下会触发 UsageStatsService.onStatsUpdated ：</p>
<ul>
<li><strong>UserUsageStatsService.init</strong> 方法在加载完数据后，会将 LastEvent 为 MOVE_TO_FOREGROUND 或者 CONTINUE_PREVIOUS_DAY 的 UsageStats 的  LastEvent 改为 END_OF_DAY，此时会触发 notifyStatsChanged 方法！</li>
</ul>
<p><br></p>
<ul>
<li><strong>UserUsageStatsService.reportEvent</strong> 方法处理完上报的事件后，会触发 notifyStatsChanged 方法！</li>
</ul>
<p><br></p>
<ul>
<li><strong>UserUsageStatsService.rolloverStats</strong> 方法一天时间过去会后，数据进行回滚后，会触发 notifyStatsChanged 方法！</li>
</ul>
<p><br></p>
<p>当 UserUsageStatsService 的 notifyStatsChanged 触发后，会触发 UsageStatsService.onStatsUpdated 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyStatsChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mStatsChanged) &#123;</span><br><span class="line">        mStatsChanged = <span class="keyword">true</span>;</span><br><span class="line">        mListener.onStatsUpdated();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在 UsageStatsService.onStatsUpdated 方法中会发送 MSG_FLUSH_TO_DISK 消息！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onStatsUpdated() &#123;</span><br><span class="line">    //【1】延迟 20mins 发送 MSG_FLUSH_TO_DISK 消息！</span><br><span class="line">    mHandler.sendEmptyMessageDelayed(MSG_FLUSH_TO_DISK, FLUSH_INTERVAL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里延迟了 FLUSH_INTERVAL 时间间隔发送 MSG_FLUSH_TO_DISK 消息！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> COMPRESS_TIME = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> TEN_SECONDS = <span class="number">10</span> * <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> TWENTY_MINUTES = <span class="number">20</span> * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> FLUSH_INTERVAL = COMPRESS_TIME ? TEN_SECONDS : TWENTY_MINUTES;</span><br></pre></td></tr></table></figure></p>
<p>由于 COMPRESS_TIME 为 false，所以是 20mins！</p>
<p>最后进入 H：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> MSG_FLUSH_TO_DISK:</span><br><span class="line">    <span class="comment">//【2.1】进入 flushToDisk 方法！</span></span><br><span class="line">    flushToDisk();</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></p>
<p>MSG_FLUSH_TO_DISK 消息用于将 App idle 的数据写入本地持久化文件！</p>
<h2 id="2-1-UsageStatsService-flushToDisk"><a href="#2-1-UsageStatsService-flushToDisk" class="headerlink" title="2.1 UsageStatsService.flushToDisk"></a>2.1 UsageStatsService.flushToDisk</h2><p>调用了 flushToDisk 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flushToDisk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="comment">//【2.2】调用了 flushToDiskLocked 方法！</span></span><br><span class="line">        flushToDiskLocked ();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>继续来看：</p>
<h2 id="2-2-UsageStatsService-flushToDiskLocked"><a href="#2-2-UsageStatsService-flushToDiskLocked" class="headerlink" title="2.2 UsageStatsService.flushToDiskLocked"></a>2.2 UsageStatsService.flushToDiskLocked</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flushToDiskLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> userCount = mUserState.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; userCount; i++) &#123;</span><br><span class="line">        UserUsageStatsService service = mUserState.valueAt(i);</span><br><span class="line">        <span class="comment">//【1】这里会调用 UserUsageStatsService.persistActiveStats 方法，将该 userId 下的最新 UsageStats 信息</span></span><br><span class="line">        <span class="comment">// 持久化到本地文件！</span></span><br><span class="line">        service.persistActiveStats();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【×2.3.1】将 app idle 的时间信息保存到本地文件！</span></span><br><span class="line">        mAppIdleHistory.writeAppIdleTimesLocked(mUserState.keyAt(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Persist elapsed and screen on time. If this fails for whatever reason, the apps will be</span></span><br><span class="line">    <span class="comment">// considered not-idle, which is the safest outcome in such an event.</span></span><br><span class="line">    <span class="comment">//【×2.3.2】将 app idle 的时间间隔保存到本地文件！</span></span><br><span class="line">    mAppIdleHistory.writeAppIdleDurationsLocked();</span><br><span class="line">    mHandler.removeMessages(MSG_FLUSH_TO_DISK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 UserUsageStatsService.persistActiveStats，这里我们不再分析，可以看 UserUsageStatsService 分析！</p>
<h3 id="2-2-1-AppIdleHistory-writeAppIdleTimesLocked"><a href="#2-2-1-AppIdleHistory-writeAppIdleTimesLocked" class="headerlink" title="2.2.1 AppIdleHistory.writeAppIdleTimesLocked"></a>2.2.1 AppIdleHistory.writeAppIdleTimesLocked</h3><p>将系统中的 app idle 信息保存到本地文件中！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeAppIdleTimesLocked</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//【1】目标文件 /data/system/users/&lt;userId&gt;/app_idle_stats.xml 文件</span></span><br><span class="line">    AtomicFile appIdleFile = <span class="keyword">new</span> AtomicFile(getUserFile(userId));</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fos = appIdleFile.startWrite();</span><br><span class="line">        <span class="keyword">final</span> BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(fos);</span><br><span class="line"></span><br><span class="line">        FastXmlSerializer xml = <span class="keyword">new</span> FastXmlSerializer();</span><br><span class="line">        xml.setOutput(bos, StandardCharsets.UTF_8.name());</span><br><span class="line">        xml.startDocument(<span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">        xml.setFeature(<span class="string">"http://xmlpull.org/v1/doc/features.html#indent-output"</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        xml.startTag(<span class="keyword">null</span>, TAG_PACKAGES); <span class="comment">//  packages 标签</span></span><br><span class="line"></span><br><span class="line">        ArrayMap&lt;String,PackageHistory&gt; userHistory = getUserHistoryLocked(userId);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N = userHistory.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="comment">//【1】遍历处理每一个 PackageHistory 对象！</span></span><br><span class="line">            String packageName = userHistory.keyAt(i);</span><br><span class="line">            PackageHistory history = userHistory.valueAt(i);</span><br><span class="line">            xml.startTag(<span class="keyword">null</span>, TAG_PACKAGE); <span class="comment">//  package 标签</span></span><br><span class="line">            xml.attribute(<span class="keyword">null</span>, ATTR_NAME, packageName); <span class="comment">//  name 标签</span></span><br><span class="line">            xml.attribute(<span class="keyword">null</span>, ATTR_ELAPSED_IDLE,</span><br><span class="line">                    Long.toString(history.lastUsedElapsedTime)); <span class="comment">// elapsedIdleTime 标签</span></span><br><span class="line">            xml.attribute(<span class="keyword">null</span>, ATTR_SCREEN_IDLE,</span><br><span class="line">                    Long.toString(history.lastUsedScreenTime)); <span class="comment">// screenIdleTime 标签</span></span><br><span class="line"></span><br><span class="line">            xml.endTag(<span class="keyword">null</span>, TAG_PACKAGE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        xml.endTag(<span class="keyword">null</span>, TAG_PACKAGES);</span><br><span class="line">        xml.endDocument();</span><br><span class="line">        appIdleFile.finishWrite(fos);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        appIdleFile.failWrite(fos);</span><br><span class="line">        Slog.e(TAG, <span class="string">"Error writing app idle file for user "</span> + userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们来看看，保存后的文件内容：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;packages&gt;</span><br><span class="line">    &lt;<span class="keyword">package</span> name=<span class="string">"com.github.shadowsocks"</span> elapsedIdleTime=<span class="string">"6836535861"</span> screenIdleTime=<span class="string">"2173999944"</span> /&gt;</span><br><span class="line">&lt;/packages&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-2-2-AppIdleHistory-writeAppIdleDurationsLocked"><a href="#2-2-2-AppIdleHistory-writeAppIdleDurationsLocked" class="headerlink" title="2.2.2 AppIdleHistory.writeAppIdleDurationsLocked"></a>2.2.2 AppIdleHistory.writeAppIdleDurationsLocked</h3><p>将系统中的屏幕亮灭时间信息保存到本地文件中！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeAppIdleDurationsLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> elapsedRealtime = SystemClock.elapsedRealtime();</span><br><span class="line">    <span class="comment">// Only bump up and snapshot the elapsed time. Don't change screen on duration.</span></span><br><span class="line">    mElapsedDuration += elapsedRealtime - mElapsedSnapshot;</span><br><span class="line">    mElapsedSnapshot = elapsedRealtime;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【2.2.2.1】调用 writeScreenOnTimeLocked 方法！</span></span><br><span class="line">    writeScreenOnTimeLocked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-2-1-AppIdleHistory-writeScreenOnTimeLocked"><a href="#2-2-2-1-AppIdleHistory-writeScreenOnTimeLocked" class="headerlink" title="2.2.2.1 AppIdleHistory.writeScreenOnTimeLocked"></a>2.2.2.1 AppIdleHistory.writeScreenOnTimeLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeScreenOnTimeLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】目标文件： /data/system/screen_on_time</span></span><br><span class="line">    AtomicFile screenOnTimeFile = <span class="keyword">new</span> AtomicFile(getScreenOnTimeFile());</span><br><span class="line">    FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fos = screenOnTimeFile.startWrite();</span><br><span class="line">        <span class="comment">//【2】将 mScreenOnDuration 和 mElapsedDuration 写入到 screen_on_time 文件中！</span></span><br><span class="line">        fos.write((Long.toString(mScreenOnDuration) + <span class="string">"\n"</span></span><br><span class="line">                + Long.toString(mElapsedDuration) + <span class="string">"\n"</span>).getBytes());</span><br><span class="line">        screenOnTimeFile.finishWrite(fos);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">        screenOnTimeFile.failWrite(fos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看看 /data/system/screen_on_time 文件内容！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2201351882</span></span><br><span class="line"><span class="number">6898458370</span></span><br></pre></td></tr></table></figure></p>
<h1 id="3-消息：MSG-REMOVE-USER-OK"><a href="#3-消息：MSG-REMOVE-USER-OK" class="headerlink" title="3 消息：MSG_REMOVE_USER - OK"></a>3 消息：MSG_REMOVE_USER - OK</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> MSG_REMOVE_USER:</span><br><span class="line">    <span class="comment">//【3.1】调用 onUserRemoved 方法！</span></span><br><span class="line">    onUserRemoved(msg.arg1);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<h2 id="3-0-消息触发机制"><a href="#3-0-消息触发机制" class="headerlink" title="3.0 消息触发机制"></a>3.0 消息触发机制</h2><p>UsageStatsService 内部有一个广播接收者 UserActionsReceiver，用于监听 User 相关的广播！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">UserActionsReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> userId = intent.getIntExtra(Intent.EXTRA_USER_HANDLE, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">final</span> String action = intent.getAction();</span><br><span class="line">        <span class="comment">//【1】监听到 User 被移除的广播！</span></span><br><span class="line">        <span class="keyword">if</span> (Intent.ACTION_USER_REMOVED.equals(action)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (userId &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                mHandler.obtainMessage(MSG_REMOVE_USER, userId, <span class="number">0</span>).sendToTarget();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Intent.ACTION_USER_STARTED.equals(action)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (userId &gt;=<span class="number">0</span>) &#123;</span><br><span class="line">                postCheckIdleStates(userId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当其接收到用户被移除的广播，接受到被启动的 UserId，会发送 MSG_REMOVE_USER 消息!</p>
<h2 id="3-1-UsageStatsService-onUserRemoved"><a href="#3-1-UsageStatsService-onUserRemoved" class="headerlink" title="3.1 UsageStatsService.onUserRemoved"></a>3.1 UsageStatsService.onUserRemoved</h2><p>这里调用了 onUserRemoved 方法，我们去看看该方法的逻辑：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onUserRemoved</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        Slog.i(TAG, <span class="string">"Removing user "</span> + userId + <span class="string">" and all data."</span>);</span><br><span class="line">        <span class="comment">//【1】从 mUserState 中移除该 userId 对应的 UserUsageStatsService 实例；</span></span><br><span class="line">        mUserState.remove(userId);</span><br><span class="line">        <span class="comment">//【3.1.1】从 AppIdleHistory 中移除该 userId 下的 app idle 信息；</span></span><br><span class="line">        mAppIdleHistory.onUserRemoved(userId);</span><br><span class="line">        <span class="comment">//【3】清楚被移除的 userId 对应的 UsageStats 信息！</span></span><br><span class="line">        cleanUpRemovedUsersLocked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-1-1-AppIdleHistory-onUserRemoved"><a href="#3-1-1-AppIdleHistory-onUserRemoved" class="headerlink" title="3.1.1 AppIdleHistory.onUserRemoved"></a>3.1.1 AppIdleHistory.onUserRemoved</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onUserRemoved</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    mIdleHistory.remove(userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>流程很简单，不多说了！</p>
<h1 id="4-消息：MSG-INFORM-LISTENERS-OK"><a href="#4-消息：MSG-INFORM-LISTENERS-OK" class="headerlink" title="4 消息：MSG_INFORM_LISTENERS - OK"></a>4 消息：MSG_INFORM_LISTENERS - OK</h1><h2 id="4-0-消息触发时机"><a href="#4-0-消息触发时机" class="headerlink" title="4.0 消息触发时机"></a>4.0 消息触发时机</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> MSG_INFORM_LISTENERS:</span><br><span class="line">    informListeners((String) msg.obj, msg.arg1, msg.arg2 == <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<h2 id="4-1-UsageStatsService-informListeners"><a href="#4-1-UsageStatsService-informListeners" class="headerlink" title="4.1 UsageStatsService.informListeners"></a>4.1 UsageStatsService.informListeners</h2><p>informListeners 用于通知那件监听 app idle 的应用，app idle 状态的变化！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">informListeners</span><span class="params">(String packageName, <span class="keyword">int</span> userId, <span class="keyword">boolean</span> isIdle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (AppIdleStateChangeListener listener : mPackageAccessListeners) &#123;</span><br><span class="line">        listener.onAppIdleStateChanged(packageName, userId, isIdle);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>逻辑很见简单，不多说了！</p>
<h1 id="5-消息：MSG-FORCE-IDLE-STATE"><a href="#5-消息：MSG-FORCE-IDLE-STATE" class="headerlink" title="5 消息：MSG_FORCE_IDLE_STATE"></a>5 消息：MSG_FORCE_IDLE_STATE</h1><h2 id="5-0-消息触发时机"><a href="#5-0-消息触发时机" class="headerlink" title="5.0 消息触发时机"></a>5.0 消息触发时机</h2><p>当 BinderService 的 setAppInactive 方法触发后！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BinderService</span> <span class="keyword">extends</span> <span class="title">IUsageStatsManager</span>.<span class="title">Stub</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAppInactive</span><span class="params">(String packageName, <span class="keyword">boolean</span> idle, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> callingUid = Binder.getCallingUid();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                userId = ActivityManagerNative.getDefault().handleIncomingUser(</span><br><span class="line">                        Binder.getCallingPid(), callingUid, userId, <span class="keyword">false</span>, <span class="keyword">true</span>,</span><br><span class="line">                        <span class="string">"setAppIdle"</span>, <span class="keyword">null</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException re) &#123;</span><br><span class="line">                <span class="keyword">throw</span> re.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line">            getContext().enforceCallingPermission(Manifest.permission.CHANGE_APP_IDLE_STATE,</span><br><span class="line">                    <span class="string">"No permission to change app idle state"</span>);</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> token = Binder.clearCallingIdentity();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> appId = getAppId(packageName);</span><br><span class="line">                <span class="keyword">if</span> (appId &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">                <span class="comment">//【1】调用了 UsageStatsService.setAppIdle 方法！</span></span><br><span class="line">                UsageStatsService.<span class="keyword">this</span>.setAppIdle(packageName, idle, userId);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                Binder.restoreCallingIdentity(token);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>UsageStatsService.setAppIdle 会发送 MSG_FORCE_IDLE_STATE 消息给 H:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setAppIdle</span><span class="params">(String packageName, <span class="keyword">boolean</span> idle, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (packageName == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    mHandler.obtainMessage(MSG_FORCE_IDLE_STATE, userId, idle ? <span class="number">1</span> : <span class="number">0</span>, packageName)</span><br><span class="line">            .sendToTarget();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们来看看 H 对于消息 MSG_FORCE_IDLE_STATE 的处理：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> MSG_FORCE_IDLE_STATE:</span><br><span class="line">    <span class="comment">//【5.1】调用 forceIdleState 将 app 设置为 idle 状态！</span></span><br><span class="line">    forceIdleState((String) msg.obj, msg.arg1, msg.arg2 == <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="5-1-UsageStatsService-forceIdleState"><a href="#5-1-UsageStatsService-forceIdleState" class="headerlink" title="5.1 UsageStatsService.forceIdleState"></a>5.1 UsageStatsService.forceIdleState</h2><p>设置 app 进入 idle 状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forceIdleState</span><span class="params">(String packageName, <span class="keyword">int</span> userId, <span class="keyword">boolean</span> idle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> appId = getAppId(packageName);</span><br><span class="line">    <span class="keyword">if</span> (appId &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> elapsedRealtime = SystemClock.elapsedRealtime();</span><br><span class="line">        <span class="comment">//【×6.1.1】判断 app 之前是否处于 idle 状态！</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> previouslyIdle = isAppIdleFiltered(packageName, appId,</span><br><span class="line">                userId, elapsedRealtime);</span><br><span class="line">                </span><br><span class="line">        <span class="comment">//【×5.1.1】设置 app 的 idle 的状态！</span></span><br><span class="line">        mAppIdleHistory.setIdleLocked(packageName, userId, idle, elapsedRealtime);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【×6.1.1】判断 app 之前现在是否处于 idle 状态！</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> stillIdle = isAppIdleFiltered(packageName, appId,</span><br><span class="line">                userId, elapsedRealtime);</span><br><span class="line">                </span><br><span class="line">        <span class="comment">//【1】当前后 app idle 状态发生了变化，那就通知监听 app idle 的监听者！</span></span><br><span class="line">        <span class="keyword">if</span> (previouslyIdle != stillIdle) &#123;</span><br><span class="line">            mHandler.sendMessage(mHandler.obtainMessage(MSG_INFORM_LISTENERS, userId,</span><br><span class="line">                    <span class="comment">/* idle = */</span> stillIdle ? <span class="number">1</span> : <span class="number">0</span>, packageName));</span><br><span class="line">                    </span><br><span class="line">            <span class="comment">//【5.1.2】如果此时不处于 idle 状态，通知 PowerManagerService，此时退出了 idle 状态！</span></span><br><span class="line">            <span class="keyword">if</span> (!stillIdle) &#123;</span><br><span class="line">                notifyBatteryStats(packageName, userId, idle);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-1-1-AppIdleHistory-setIdleLocked"><a href="#5-1-1-AppIdleHistory-setIdleLocked" class="headerlink" title="5.1.1 AppIdleHistory.setIdleLocked"></a>5.1.1 AppIdleHistory.setIdleLocked</h3><p>设置 package 的 idle 状态！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIdleLocked</span><span class="params">(String packageName, <span class="keyword">int</span> userId, <span class="keyword">boolean</span> idle, <span class="keyword">long</span> elapsedRealtime)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】同样先获得该 userId 下该 packageName 的 PackageHistory 对象！</span></span><br><span class="line">    ArrayMap&lt;String, PackageHistory&gt; userHistory = getUserHistoryLocked(userId);</span><br><span class="line">    PackageHistory packageHistory = getPackageHistoryLocked(userHistory, packageName,</span><br><span class="line">            elapsedRealtime);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【5.1.1.1】设置 package 上一次被使用的时间</span></span><br><span class="line">    packageHistory.lastUsedElapsedTime = getElapsedTimeLocked(elapsedRealtime)</span><br><span class="line">            - mElapsedTimeThreshold;</span><br><span class="line">    packageHistory.lastUsedScreenTime = getScreenOnTimeLocked(elapsedRealtime)</span><br><span class="line">            - (idle ? mScreenOnTimeThreshold : <span class="number">0</span>) - <span class="number">1000</span> <span class="comment">/* just a second more */</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于 getUserHistoryLocked 和 getPackageHistoryLocked 我们不再重新分析！</p>
<h4 id="5-1-1-1-AppIdleHistory-getElapsedTimeLocked"><a href="#5-1-1-1-AppIdleHistory-getElapsedTimeLocked" class="headerlink" title="5.1.1.1 AppIdleHistory.getElapsedTimeLocked"></a>5.1.1.1 AppIdleHistory.getElapsedTimeLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">getElapsedTimeLocked</span><span class="params">(<span class="keyword">long</span> elapsedRealtime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (elapsedRealtime - mElapsedSnapshot + mElapsedDuration);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-1-1-2-AppIdleHistory-getScreenOnTimeLocked"><a href="#5-1-1-2-AppIdleHistory-getScreenOnTimeLocked" class="headerlink" title="5.1.1.2 AppIdleHistory.getScreenOnTimeLocked"></a>5.1.1.2 AppIdleHistory.getScreenOnTimeLocked</h4><p>获得亮屏的总时长！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getScreenOnTimeLocked</span><span class="params">(<span class="keyword">long</span> elapsedRealtime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> screenOnTime = mScreenOnDuration;</span><br><span class="line">    <span class="keyword">if</span> (mScreenOn) &#123;</span><br><span class="line">        screenOnTime += elapsedRealtime - mScreenOnSnapshot;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> screenOnTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果此时亮屏 mScreenOn 为 true，那么会在 mScreenOnDuration 基础上，再加上当前时间减去上次亮屏的时间点 mScreenOnSnapshot！</p>
<h3 id="5-1-2-UsageStatsService-notifyBatteryState"><a href="#5-1-2-UsageStatsService-notifyBatteryState" class="headerlink" title="5.1.2 UsageStatsService.notifyBatteryState"></a>5.1.2 UsageStatsService.notifyBatteryState</h3><p>通知 PowerManagerService，app 退出了 idle 状态！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private void notifyBatteryStats(String packageName, int userId, boolean idle) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        final int uid = mPackageManager.getPackageUidAsUser(packageName,</span><br><span class="line">                PackageManager.MATCH_UNINSTALLED_PACKAGES, userId);</span><br><span class="line">        if (idle) &#123;</span><br><span class="line">            mBatteryStats.noteEvent(BatteryStats.HistoryItem.EVENT_PACKAGE_INACTIVE,</span><br><span class="line">                    packageName, uid);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            mBatteryStats.noteEvent(BatteryStats.HistoryItem.EVENT_PACKAGE_ACTIVE,</span><br><span class="line">                    packageName, uid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (NameNotFoundException | RemoteException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="6-消息：MSG-CHECK-IDLE-STATES"><a href="#6-消息：MSG-CHECK-IDLE-STATES" class="headerlink" title="6 消息：MSG_CHECK_IDLE_STATES"></a>6 消息：MSG_CHECK_IDLE_STATES</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> MSG_CHECK_IDLE_STATES:</span><br><span class="line">    <span class="keyword">if</span> (checkIdleStates(msg.arg1)) &#123;</span><br><span class="line">        mHandler.sendMessageDelayed(mHandler.obtainMessage(</span><br><span class="line">                MSG_CHECK_IDLE_STATES, msg.arg1, <span class="number">0</span>),</span><br><span class="line">                mCheckIdleIntervalMillis);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<h2 id="6-0-消息触发机制"><a href="#6-0-消息触发机制" class="headerlink" title="6.0 消息触发机制"></a>6.0 消息触发机制</h2><p>UsageStatsService 内部有一个广播接收者 UserActionsReceiver，用于监听 User 相关的广播！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">UserActionsReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> userId = intent.getIntExtra(Intent.EXTRA_USER_HANDLE, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">final</span> String action = intent.getAction();</span><br><span class="line">        <span class="keyword">if</span> (Intent.ACTION_USER_REMOVED.equals(action)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (userId &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                mHandler.obtainMessage(MSG_REMOVE_USER, userId, <span class="number">0</span>).sendToTarget();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Intent.ACTION_USER_STARTED.equals(action)) &#123;</span><br><span class="line">            <span class="comment">//【1】监听到 User 被启动的广播！</span></span><br><span class="line">            <span class="keyword">if</span> (userId &gt;=<span class="number">0</span>) &#123;</span><br><span class="line">                postCheckIdleStates(userId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当其接收到用户被启动的广播，接受到被启动的 UserId：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postCheckIdleStates</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    mHandler.sendMessage(mHandler.obtainMessage(MSG_CHECK_IDLE_STATES, userId, <span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>MSG_CHECK_IDLE_STATES 用于检查指定 userid 下的 app idle 状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> MSG_CHECK_IDLE_STATES:</span><br><span class="line">    <span class="comment">//【*6.1】调用 checkIdleStates 方法，检查 app idle 信息！</span></span><br><span class="line">    <span class="keyword">if</span> (checkIdleStates(msg.arg1)) &#123;</span><br><span class="line">        mHandler.sendMessageDelayed(mHandler.obtainMessage(</span><br><span class="line">                MSG_CHECK_IDLE_STATES, msg.arg1, <span class="number">0</span>),</span><br><span class="line">                mCheckIdleIntervalMillis);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>checkIdleStates 返回 true 表示检查操作完成，那么就会设置下一次的 check idle 的消息的发送时间，延迟  mCheckIdleIntervalMillis 8 hours 后再次发送 MSG_CHECK_IDLE_STATES 消息！</p>
<p>关于 mCheckIdleIntervalMillis 的取值，可以看下 SettingsObserver 相关代码！</p>
<h2 id="6-1-UsageStatsService-checkIdleStates"><a href="#6-1-UsageStatsService-checkIdleStates" class="headerlink" title="6.1 UsageStatsService.checkIdleStates"></a>6.1 UsageStatsService.checkIdleStates</h2><p>checkIdleStates 方法用于检查当前时间系统中 app idle 的状态，同时更新 AppIdleHistory 中的数据！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">checkIdleStates</span><span class="params">(<span class="keyword">int</span> checkUserId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】如果 mAppIdleEnabled 为 false，说明系统没有打开 device idle 状态！</span></span><br><span class="line">    <span class="keyword">if</span> (!mAppIdleEnabled) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【2】获得系统中正在运行中的 UserId！</span></span><br><span class="line">    <span class="comment">// 如果要检查的 userId 不是 UserHandle.USER_ALL(所有用户)，并且也不是系统中正在运行的 userId</span></span><br><span class="line">    <span class="comment">// 那就返回 false；</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span>[] runningUserIds;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        runningUserIds = ActivityManagerNative.getDefault().getRunningUserIds();</span><br><span class="line">        <span class="keyword">if</span> (checkUserId != UserHandle.USER_ALL</span><br><span class="line">                &amp;&amp; !ArrayUtils.contains(runningUserIds, checkUserId)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException re) &#123;</span><br><span class="line">        <span class="keyword">throw</span> re.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> elapsedRealtime = SystemClock.elapsedRealtime();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【3】遍历收集到的所有正在运行中的 userId，如果指定的是所有用户 USER_ALL，那就检查所有的 userId</span></span><br><span class="line">    <span class="comment">// 否则，跳过那些不是 checkUserId 的 uid！</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; runningUserIds.length; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> userId = runningUserIds[i];</span><br><span class="line">        <span class="keyword">if</span> (checkUserId != UserHandle.USER_ALL &amp;&amp; checkUserId != userId) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">            Slog.d(TAG, <span class="string">"Checking idle state for user "</span> + userId);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【3.1】获得 userId 下的所有的 package 信息！</span></span><br><span class="line">        List&lt;PackageInfo&gt; packages = mPackageManager.getInstalledPackagesAsUser(</span><br><span class="line">                PackageManager.MATCH_DISABLED_COMPONENTS,</span><br><span class="line">                userId);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> packageCount = packages.size();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【3.2】遍历处理</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; packageCount; p++) &#123;</span><br><span class="line">            <span class="keyword">final</span> PackageInfo pi = packages.get(p);</span><br><span class="line">            <span class="keyword">final</span> String packageName = pi.packageName;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//【*6.1.1】判断当前时间下，该 package 是否处于 idle 状态！</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> isIdle = isAppIdleFiltered(packageName,</span><br><span class="line">                    UserHandle.getAppId(pi.applicationInfo.uid),</span><br><span class="line">                    userId, elapsedRealtime);</span><br><span class="line">                    </span><br><span class="line">            <span class="comment">//【*4】发送 MSG_INFORM_LISTENERS 消息给，通知 app idle 监听者！</span></span><br><span class="line">            mHandler.sendMessage(mHandler.obtainMessage(MSG_INFORM_LISTENERS,</span><br><span class="line">                    userId, isIdle ? <span class="number">1</span> : <span class="number">0</span>, packageName));</span><br><span class="line">                    </span><br><span class="line">            <span class="keyword">if</span> (isIdle) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">                    <span class="comment">//【*6.1.2】如果 package 应该处于 idle 状态的话，那就通过 AppIdleHistory 记录下来！</span></span><br><span class="line">                    mAppIdleHistory.setIdle(packageName, userId, elapsedRealtime);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">        Slog.d(TAG, <span class="string">"checkIdleStates took "</span></span><br><span class="line">                + (SystemClock.elapsedRealtime() - elapsedRealtime));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-1-1-UsageStatsService-isAppIdleFiltered"><a href="#6-1-1-UsageStatsService-isAppIdleFiltered" class="headerlink" title="6.1.1 UsageStatsService.isAppIdleFiltered"></a>6.1.1 UsageStatsService.isAppIdleFiltered</h3><p>isAppIdleFiltered 方法用于过滤一些特殊的条件！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isAppIdleFiltered</span><span class="params">(String packageName, <span class="keyword">int</span> appId, <span class="keyword">int</span> userId,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span> elapsedRealtime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (packageName == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//【1】如果不允许应用进入 idle 状态，显然，没有应用会处于 idle 状态！</span></span><br><span class="line">    <span class="keyword">if</span> (!mAppIdleEnabled) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【2】如果 appId 小于 FIRST_APPLICATION_UID，说明是系统应用，系统应用不能进入 idle 状态！</span></span><br><span class="line">    <span class="keyword">if</span> (appId &lt; Process.FIRST_APPLICATION_UID) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【3】如果包名是 "android"，不能处于 idle 状态！</span></span><br><span class="line">    <span class="keyword">if</span> (packageName.equals(<span class="string">"android"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mSystemServicesReady) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//【4】如果 package 在 doze 模式的白名单中，那就不能进入 app idle (app standby) 状态</span></span><br><span class="line">            <span class="keyword">if</span> (mDeviceIdleController.isPowerSaveWhitelistExceptIdleApp(packageName)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException re) &#123;</span><br><span class="line">            <span class="keyword">throw</span> re.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【5】接着处理一些特殊情况，满足条件，也不能处于 idle 状态！</span></span><br><span class="line">        <span class="keyword">if</span> (isActiveDeviceAdmin(packageName, userId)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isActiveNetworkScorer(packageName)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mAppWidgetManager != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; mAppWidgetManager.isBoundWidgetPackage(packageName, userId)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isDeviceProvisioningPackage(packageName)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【*6.1.1.1】进入 isAppIdleUnfiltered 方法！</span></span><br><span class="line">    <span class="keyword">if</span> (!isAppIdleUnfiltered(packageName, userId, elapsedRealtime)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【7】如果是运营商特权应用，不能进入 idle 状态！</span></span><br><span class="line">    <span class="keyword">if</span> (isCarrierApp(packageName)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接着来看 isAppIdleUnfiltered 方法！</p>
<h4 id="6-1-1-1-UsageStatsService-isAppIdleUnfiltered"><a href="#6-1-1-1-UsageStatsService-isAppIdleUnfiltered" class="headerlink" title="6.1.1.1 UsageStatsService.isAppIdleUnfiltered"></a>6.1.1.1 UsageStatsService.isAppIdleUnfiltered</h4><p>isAppIdleUnfiltered 方法是不过滤条件，直接读取数据，判断 app 是否处于 idle 状态！一般是先调用 isAppIdleFiltered 过滤特殊情况，然后再调用该方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isAppIdleUnfiltered</span><span class="params">(String packageName, <span class="keyword">int</span> userId, <span class="keyword">long</span> elapsedRealtime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="comment">//【×1.4】调用 isIdleLocked 判断是否是 idle 状态！</span></span><br><span class="line">        <span class="keyword">return</span> mAppIdleHistory.isIdleLocked(packageName, userId, elapsedRealtime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们看到，是直接调用 AppIdleHistory.isIdleLocked 方法读取数据！</p>
<p>对于 AppIdleHistory.isIdleLocked 方法，这里不再分析！</p>
<h3 id="6-1-2-AppIdleHistory-setIdle"><a href="#6-1-2-AppIdleHistory-setIdle" class="headerlink" title="6.1.2 AppIdleHistory.setIdle"></a>6.1.2 AppIdleHistory.setIdle</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIdle</span><span class="params">(String packageName, <span class="keyword">int</span> userId, <span class="keyword">long</span> elapsedRealtime)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】从 mIdleHistory 读取该 userId 下的 app idle 数据，如果 userId 对应的数据为 null；</span></span><br><span class="line">    <span class="comment">// 会做一次初始化，从本地文件读取数据！</span></span><br><span class="line">    ArrayMap&lt;String, PackageHistory&gt; userHistory = getUserHistoryLocked(userId);</span><br><span class="line">    <span class="comment">//【*6.1.2.1】获得 packageName 对应的 packageHistory！</span></span><br><span class="line">    PackageHistory packageHistory = getPackageHistoryLocked(userHistory, packageName,</span><br><span class="line">            elapsedRealtime);</span><br><span class="line">            </span><br><span class="line">    <span class="comment">//【*6.1.2.2】根据周期调整数据！！</span></span><br><span class="line">    shiftHistoryToNow(userHistory, elapsedRealtime);</span><br><span class="line"></span><br><span class="line">    packageHistory.recent[HISTORY_SIZE - <span class="number">1</span>] &amp;= ~FLAG_LAST_STATE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-1-2-1-AppIdleHistory-getPackageHistoryLocked"><a href="#6-1-2-1-AppIdleHistory-getPackageHistoryLocked" class="headerlink" title="6.1.2.1 AppIdleHistory.getPackageHistoryLocked"></a>6.1.2.1 AppIdleHistory.getPackageHistoryLocked</h4><p>从指定的 userId 的 userHistory 获得该 package 的 PackageHistory 对象，如果没有就重新创建一个！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> PackageHistory <span class="title">getPackageHistoryLocked</span><span class="params">(ArrayMap&lt;String, PackageHistory&gt; userHistory,</span></span></span><br><span class="line"><span class="function"><span class="params">        String packageName, <span class="keyword">long</span> elapsedRealtime)</span> </span>&#123;</span><br><span class="line">    PackageHistory packageHistory = userHistory.get(packageName);</span><br><span class="line">    <span class="comment">//【1】如果没有该 package 的历史信息，那就初始化一个！</span></span><br><span class="line">    <span class="keyword">if</span> (packageHistory == <span class="keyword">null</span>) &#123;</span><br><span class="line">        packageHistory = <span class="keyword">new</span> PackageHistory();</span><br><span class="line">        <span class="comment">//【*6.1.2.1.1】初始化 lastUsedElapsedTime</span></span><br><span class="line">        packageHistory.lastUsedElapsedTime = getElapsedTimeLocked(elapsedRealtime);</span><br><span class="line">        <span class="comment">//【*6.1.2.1.2】初始化 lastUsedScreenTime</span></span><br><span class="line">        packageHistory.lastUsedScreenTime = getScreenOnTimeLocked(elapsedRealtime);</span><br><span class="line"></span><br><span class="line">        userHistory.put(packageName, packageHistory);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> packageHistory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="6-1-2-1-1-AppIdleHistory-getElapsedTimeLocked"><a href="#6-1-2-1-1-AppIdleHistory-getElapsedTimeLocked" class="headerlink" title="6.1.2.1.1 AppIdleHistory.getElapsedTimeLocked"></a>6.1.2.1.1 AppIdleHistory.getElapsedTimeLocked</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">getElapsedTimeLocked</span><span class="params">(<span class="keyword">long</span> elapsedRealtime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (elapsedRealtime - mElapsedSnapshot + mElapsedDuration);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="6-1-2-1-2-AppIdleHistory-getScreenOnTimeLocked"><a href="#6-1-2-1-2-AppIdleHistory-getScreenOnTimeLocked" class="headerlink" title="6.1.2.1.2 AppIdleHistory.getScreenOnTimeLocked"></a>6.1.2.1.2 AppIdleHistory.getScreenOnTimeLocked</h5><p>获得亮屏的总时长！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getScreenOnTimeLocked</span><span class="params">(<span class="keyword">long</span> elapsedRealtime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> screenOnTime = mScreenOnDuration;</span><br><span class="line">    <span class="keyword">if</span> (mScreenOn) &#123;</span><br><span class="line">        screenOnTime += elapsedRealtime - mScreenOnSnapshot;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> screenOnTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果此时亮屏 mScreenOn 为 true，那么会在 mScreenOnDuration 基础上，再加上当前时间减去上次亮屏的时间点 mScreenOnSnapshot！</p>
<h4 id="6-1-2-2-AppIdleHistory-shiftHistoryToNow"><a href="#6-1-2-2-AppIdleHistory-shiftHistoryToNow" class="headerlink" title="6.1.2.2 AppIdleHistory.shiftHistoryToNow"></a>6.1.2.2 AppIdleHistory.shiftHistoryToNow</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shiftHistoryToNow</span><span class="params">(ArrayMap&lt;String, PackageHistory&gt; userHistory,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span> elapsedRealtime)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】计算本次周期！</span></span><br><span class="line">    <span class="keyword">long</span> thisPeriod = elapsedRealtime / PERIOD_DURATION;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Has the period switched over? Slide all users' package histories</span></span><br><span class="line">    <span class="keyword">if</span> (mLastPeriod != <span class="number">0</span> &amp;&amp; mLastPeriod &lt; thisPeriod</span><br><span class="line">            &amp;&amp; (thisPeriod - mLastPeriod) &lt; HISTORY_SIZE - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> diff = (<span class="keyword">int</span>) (thisPeriod - mLastPeriod);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> NUSERS = mIdleHistory.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; NUSERS; u++) &#123;</span><br><span class="line">            userHistory = mIdleHistory.valueAt(u);</span><br><span class="line">            <span class="keyword">for</span> (PackageHistory idleState : userHistory.values()) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Shift left</span></span><br><span class="line">                System.arraycopy(idleState.recent, diff, idleState.recent, <span class="number">0</span>,</span><br><span class="line">                        HISTORY_SIZE - diff);</span><br><span class="line">                <span class="comment">// Replicate last state across the diff</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; diff; i++) &#123;</span><br><span class="line">                    idleState.recent[HISTORY_SIZE - i - <span class="number">1</span>] =</span><br><span class="line">                        (<span class="keyword">byte</span>) (idleState.recent[HISTORY_SIZE - diff - <span class="number">1</span>] &amp; FLAG_LAST_STATE);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【2】</span></span><br><span class="line">    mLastPeriod = thisPeriod;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mLastPeriod 用来记录能够更新的周期！</p>
<h1 id="7-消息：MSG-ONE-TIME-CHECK-IDLE-STATES-OK"><a href="#7-消息：MSG-ONE-TIME-CHECK-IDLE-STATES-OK" class="headerlink" title="7 消息：MSG_ONE_TIME_CHECK_IDLE_STATES - OK"></a>7 消息：MSG_ONE_TIME_CHECK_IDLE_STATES - OK</h1><h2 id="7-1-消息触发时机"><a href="#7-1-消息触发时机" class="headerlink" title="7.1 消息触发时机"></a>7.1 消息触发时机</h2><ul>
<li><strong>UsageStatsService.onBootPhase</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBootPhase</span><span class="params">(<span class="keyword">int</span> phase)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (phase == PHASE_SYSTEM_SERVICES_READY) &#123;</span><br><span class="line">        ... ... ... ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mPendingOneTimeCheckIdleStates) &#123;</span><br><span class="line">            postOneTimeCheckIdleStates();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mSystemServicesReady = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (phase == PHASE_BOOT_COMPLETED) &#123;</span><br><span class="line">        setChargingState(getContext().getSystemService(BatteryManager.class).isCharging());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 UsageStatsService 开机初始化的时候，会进行一次 app idle check！</p>
<ul>
<li><strong>SettingsObserver.onChange</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChange</span><span class="params">(<span class="keyword">boolean</span> selfChange)</span> </span>&#123;</span><br><span class="line">    updateSettings();</span><br><span class="line">    postOneTimeCheckIdleStates();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当数据库时间属性变化后！</p>
<ul>
<li><strong>UsageStatsService.onStatsReloaded</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStatsReloaded</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    postOneTimeCheckIdleStates();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这几种情况下，都是开机初始化，或者数据库配置更新，使用状态重新加载的情况，这些情况会导致 app idle 发生变化，所以需要重新 check idle！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> MSG_ONE_TIME_CHECK_IDLE_STATES:</span><br><span class="line">    mHandler.removeMessages(MSG_ONE_TIME_CHECK_IDLE_STATES);</span><br><span class="line">    <span class="comment">//【1】处理所有用户下的 app idle 检查操作！</span></span><br><span class="line">    checkIdleStates(UserHandle.USER_ALL);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<h2 id="7-2-UsageStatsService-postOneTimeCheckIdleStates"><a href="#7-2-UsageStatsService-postOneTimeCheckIdleStates" class="headerlink" title="7.2 UsageStatsService.postOneTimeCheckIdleStates"></a>7.2 UsageStatsService.postOneTimeCheckIdleStates</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOneTimeCheckIdleStates</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDeviceIdleController == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Not booted yet; wait for it!</span></span><br><span class="line">        mPendingOneTimeCheckIdleStates = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mHandler.sendEmptyMessage(MSG_ONE_TIME_CHECK_IDLE_STATES);</span><br><span class="line">        mPendingOneTimeCheckIdleStates = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>MSG_ONE_TIME_CHECK_IDLE_STATES 也用于检查 device idle 状态！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> MSG_ONE_TIME_CHECK_IDLE_STATES:</span><br><span class="line">    mHandler.removeMessages(MSG_ONE_TIME_CHECK_IDLE_STATES);</span><br><span class="line">    checkIdleStates(UserHandle.USER_ALL);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>和 MSG_CHECK_IDLE_STATES 的区别是：</p>
<ul>
<li>MSG_ONE_TIME_CHECK_IDLE_STATES 只会检测一次，而 MSG_CHECK_IDLE_STATES 会持续检查！</li>
<li>MSG_ONE_TIME_CHECK_IDLE_STATES 会检查所有 user 下的 app idle 状态，而 MSG_CHECK_IDLE_STATES 是检查指定的 userId 下的 app idle 状态；</li>
</ul>
<h1 id="8-消息：MSG-CHECK-PAROLE-TIMEOUT"><a href="#8-消息：MSG-CHECK-PAROLE-TIMEOUT" class="headerlink" title="8 消息：MSG_CHECK_PAROLE_TIMEOUT"></a>8 消息：MSG_CHECK_PAROLE_TIMEOUT</h1><p>该消息用于进入下一次假释状态！</p>
<h2 id="8-1-消息触发时机"><a href="#8-1-消息触发时机" class="headerlink" title="8.1 消息触发时机"></a>8.1 消息触发时机</h2><p>我们在 DeviceStateReceiver 接收者中，当接收到 PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED 广播后，即 doze 模式发生了变化，我们会调用 onDeviceIdleModeChanged 方法！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onDeviceIdleModeChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> deviceIdle = mPowerManager.isDeviceIdleMode();</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) Slog.i(TAG, <span class="string">"DeviceIdleMode changed to "</span> + deviceIdle);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="comment">//【1】计算距离上次退出假释状态过去的时间！</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> timeSinceLastParole = checkAndGetTimeLocked() - mLastAppIdleParoledTime;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!deviceIdle </span><br><span class="line">                &amp;&amp; timeSinceLastParole &gt;= mAppIdleParoleIntervalMillis) &#123;</span><br><span class="line">            <span class="comment">//【1.1】如果当前不处于 device idle 状态，并且当前距离上次退出假释状态超过了 24 小时</span></span><br><span class="line">            <span class="comment">// 那么我们会进入假释状态！</span></span><br><span class="line">            <span class="keyword">if</span> (DEBUG) Slog.i(TAG, <span class="string">"Bringing idle apps out of inactive state due to deviceIdleMode=false"</span>);</span><br><span class="line">            setAppIdleParoled(<span class="keyword">true</span>);</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (deviceIdle) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG) Slog.i(TAG, <span class="string">"Device idle, back to prison"</span>);</span><br><span class="line">            <span class="comment">//【1.2】如果当前处于 device idle 状态，那么无法进入假释状态！</span></span><br><span class="line">            setAppIdleParoled(<span class="keyword">false</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>UsageStatsService.setAppIdleParoled</strong></li>
</ul>
<p>setAppIdleParoled 方法用于将 app 在 idle 的状态下唤醒进入假释状态，参数 boolean paroled 表示当前是否进入假释状态！</p>
<p>mAppIdleTempParoled 用于保存假释状态，boolean paroled 表示是否进入假释状态！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setAppIdleParoled</span><span class="params">(<span class="keyword">boolean</span> paroled)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mAppIdleTempParoled != paroled) &#123;</span><br><span class="line">            <span class="comment">//【1】缓存本次假释状态！</span></span><br><span class="line">            mAppIdleTempParoled = paroled;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">"Changing paroled to "</span> + mAppIdleTempParoled);</span><br><span class="line">            <span class="keyword">if</span> (paroled) &#123;</span><br><span class="line">                <span class="comment">//【1.1】如果本次是进入假释，设置退出假释的超时消息！</span></span><br><span class="line">                postParoleEndTimeout();</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//【1.2】如果本次是退出假释，设置下一次进入假释的消息，即 24Hours 后！</span></span><br><span class="line">                <span class="comment">// 保存上次退出假释的时间！</span></span><br><span class="line">                mLastAppIdleParoledTime = checkAndGetTimeLocked();</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//【*8.1.1】设置进入下一次假释的消息！</span></span><br><span class="line">                postNextParoleTimeout();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//【common】处理假释状态的变化！</span></span><br><span class="line">            postParoleStateChanged();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后，调用了 postNextParoleTimeout 方法！</p>
<h3 id="8-1-1-UsageStatsService-postNextParoleTimeout"><a href="#8-1-1-UsageStatsService-postNextParoleTimeout" class="headerlink" title="8.1.1 UsageStatsService.postNextParoleTimeout"></a>8.1.1 UsageStatsService.postNextParoleTimeout</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postNextParoleTimeout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">"Posting MSG_CHECK_PAROLE_TIMEOUT"</span>);</span><br><span class="line">    mHandler.removeMessages(MSG_CHECK_PAROLE_TIMEOUT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】在上次退出假释的时间基础上，加上 mAppIdleParoleIntervalMillis（24Hours）</span></span><br><span class="line">    <span class="comment">// 然后减去当前时间，得到延迟时间 timeLeft！</span></span><br><span class="line">    <span class="keyword">long</span> timeLeft = (mLastAppIdleParoledTime + mAppIdleParoleIntervalMillis)</span><br><span class="line">            - checkAndGetTimeLocked();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (timeLeft &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        timeLeft = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【2】延迟 timeLeft 发送 MSG_CHECK_PAROLE_TIMEOUT 消息！</span></span><br><span class="line">    mHandler.sendEmptyMessageDelayed(MSG_CHECK_PAROLE_TIMEOUT, timeLeft);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我么你可以看到，延迟发送 MSG_CHECK_PAROLE_TIMEOUT 的时间是剩余的等待时间！！</p>
<p>我们来看看 H 对 MSG_CHECK_PAROLE_TIMEOUT 消息的处理：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> MSG_CHECK_PAROLE_TIMEOUT:</span><br><span class="line">    <span class="comment">//【8.2】调用了 checkParoleTimeout 方法！</span></span><br><span class="line">    checkParoleTimeout();</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="8-2-UsageStatsService-checkParoleTimeout"><a href="#8-2-UsageStatsService-checkParoleTimeout" class="headerlink" title="8.2 UsageStatsService.checkParoleTimeout"></a>8.2 UsageStatsService.checkParoleTimeout</h2><p>当该消息触发后，进入 checkParoleTimeout 方法！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkParoleTimeout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="comment">//【1】mAppIdleTempParoled 为 false，说明当前没有进入假释状态！</span></span><br><span class="line">        <span class="keyword">if</span> (!mAppIdleTempParoled) &#123;</span><br><span class="line">            <span class="comment">//【1.1】计算距离上次退出假释模式，经过的时间！</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> timeSinceLastParole = checkAndGetTimeLocked() - mLastAppIdleParoledTime;</span><br><span class="line">            <span class="keyword">if</span> (timeSinceLastParole &gt; mAppIdleParoleIntervalMillis) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">"Crossed default parole interval"</span>);</span><br><span class="line">                <span class="comment">//【1.1.1】距离上次退出假释模式经过的时间如果超过了 24 hours</span></span><br><span class="line">                <span class="comment">// 进入假释模式！</span></span><br><span class="line">                setAppIdleParoled(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">"Not long enough to go to parole"</span>);</span><br><span class="line">                <span class="comment">//【*8.1.1】当前不能进入假释模式，继续延迟！</span></span><br><span class="line">                postNextParoleTimeout();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当距离上次退出假释模式经过的时间如果超过了 24 hours 后，会调用 setAppIdleParoled 方法进入假释模式！</p>
<p>整个流程很简单，不多说了！</p>
<h1 id="9-消息：MSG-PAROLE-END-TIMEOUT"><a href="#9-消息：MSG-PAROLE-END-TIMEOUT" class="headerlink" title="9 消息：MSG_PAROLE_END_TIMEOUT"></a>9 消息：MSG_PAROLE_END_TIMEOUT</h1><p>该消息用于退出当前的假释状态！</p>
<h2 id="9-1-消息触发时机"><a href="#9-1-消息触发时机" class="headerlink" title="9.1 消息触发时机"></a>9.1 消息触发时机</h2><p>当 app 进入了假释状态时，会触发 setAppIdleParoled 方法，此时 boolean paroled 为 true！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setAppIdleParoled</span><span class="params">(<span class="keyword">boolean</span> paroled)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mAppIdleTempParoled != paroled) &#123;</span><br><span class="line">            <span class="comment">//【1】更新 mAppIdleTempParoled</span></span><br><span class="line">            mAppIdleTempParoled = paroled;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">"Changing paroled to "</span> + mAppIdleTempParoled);</span><br><span class="line">            <span class="keyword">if</span> (paroled) &#123;</span><br><span class="line">                <span class="comment">//【1.1】调用 postParoleEndTimeout 设置退出假释状态的</span></span><br><span class="line">                postParoleEndTimeout();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mLastAppIdleParoledTime = checkAndGetTimeLocked();</span><br><span class="line">                postNextParoleTimeout();</span><br><span class="line">            &#125;</span><br><span class="line">            postParoleStateChanged();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>UsageStatsService.postParoleEndTimeout</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postParoleEndTimeout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">"Posting MSG_PAROLE_END_TIMEOUT"</span>);</span><br><span class="line">    <span class="comment">//【1】延迟 10mins，发送 MSG_PAROLE_END_TIMEOUT 消息，退出假释模式！</span></span><br><span class="line">    mHandler.removeMessages(MSG_PAROLE_END_TIMEOUT);</span><br><span class="line">    mHandler.sendEmptyMessageDelayed(MSG_PAROLE_END_TIMEOUT, mAppIdleParoleDurationMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>mAppIdleParoleDurationMillis 值为 10mins！</p>
<p>我们来看看 H 是如处理该消息的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> MSG_PAROLE_END_TIMEOUT:</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">"Ending parole"</span>);</span><br><span class="line">    <span class="comment">//【1】调用了 setAppIdleParoled 退出假释模式，同时设置下一次进入假释的消息！</span></span><br><span class="line">    setAppIdleParoled(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></p>
<h1 id="10-消息：MSG-REPORT-CONTENT-PROVIDER-USAGE-OK"><a href="#10-消息：MSG-REPORT-CONTENT-PROVIDER-USAGE-OK" class="headerlink" title="10 消息：MSG_REPORT_CONTENT_PROVIDER_USAGE - OK"></a>10 消息：MSG_REPORT_CONTENT_PROVIDER_USAGE - OK</h1><h2 id="10-0-消息触发时机"><a href="#10-0-消息触发时机" class="headerlink" title="10.0 消息触发时机"></a>10.0 消息触发时机</h2><p>当 ActivityManagerService 触发了 LocalService 下面的方法时：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalService</span> <span class="keyword">extends</span> <span class="title">UsageStatsManagerInternal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reportContentProviderUsage</span><span class="params">(String name, String packageName, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">            SomeArgs args = SomeArgs.obtain();</span><br><span class="line">            args.arg1 = name;</span><br><span class="line">            args.arg2 = packageName;</span><br><span class="line">            args.arg3 = userId;</span><br><span class="line">            <span class="comment">//【1】发送 MSG_REPORT_CONTENT_PROVIDER_USAGE 消息</span></span><br><span class="line">            mHandler.obtainMessage(MSG_REPORT_CONTENT_PROVIDER_USAGE, args)</span><br><span class="line">                    .sendToTarget();</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会发送 MSG_REPORT_CONTENT_PROVIDER_USAGE 消息！上报 ContentProvider 的使用情况！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> MSG_REPORT_CONTENT_PROVIDER_USAGE:</span><br><span class="line">    SomeArgs args = (SomeArgs) msg.obj;</span><br><span class="line">    <span class="comment">//【10.1】调用了 reportContentProviderUsage 方法！</span></span><br><span class="line">    reportContentProviderUsage((String) args.arg1, <span class="comment">// authority name</span></span><br><span class="line">            (String) args.arg2, <span class="comment">// package name</span></span><br><span class="line">            (<span class="keyword">int</span>) args.arg3); <span class="comment">// userId</span></span><br><span class="line">    args.recycle();</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<h2 id="10-1-UsageStatsService-reportContentProviderUsage"><a href="#10-1-UsageStatsService-reportContentProviderUsage" class="headerlink" title="10.1 UsageStatsService.reportContentProviderUsage"></a>10.1 UsageStatsService.reportContentProviderUsage</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reportContentProviderUsage</span><span class="params">(String authority, String providerPkgName, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】获得同步适配器！</span></span><br><span class="line">    String[] packages = ContentResolver.getSyncAdapterPackagesForAuthorityAsUser(</span><br><span class="line">            authority, userId);</span><br><span class="line">    <span class="keyword">for</span> (String packageName: packages) &#123;</span><br><span class="line">        <span class="comment">//【2】如果同步适配器是系统 package，同时 provider 并没有在相同的 package 中</span></span><br><span class="line">        <span class="comment">// 那么，我们需要强制将同步适配器所在的 package 设置为 active 状态！</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            PackageInfo pi = mPackageManager.getPackageInfoAsUser(</span><br><span class="line">                    packageName, PackageManager.MATCH_SYSTEM_ONLY, userId);</span><br><span class="line">            <span class="keyword">if</span> (pi == <span class="keyword">null</span> || pi.applicationInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!packageName.equals(providerPkgName)) &#123;</span><br><span class="line">                <span class="comment">//【*5.1】调用了 forceIdleState 方法！</span></span><br><span class="line">                forceIdleState(packageName, userId, <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NameNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// Shouldn't happen</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 forceIdleState 方法，请看 5.1 节！</p>
<h1 id="11-消息：MSG-PAROLE-STATE-CHANGED"><a href="#11-消息：MSG-PAROLE-STATE-CHANGED" class="headerlink" title="11 消息：MSG_PAROLE_STATE_CHANGED"></a>11 消息：MSG_PAROLE_STATE_CHANGED</h1><p>当应用的假释状态发生变化后，会发送该消息！</p>
<h2 id="11-1-消息触发时机"><a href="#11-1-消息触发时机" class="headerlink" title="11.1 消息触发时机"></a>11.1 消息触发时机</h2><ul>
<li><strong>UsageStatsService.setChargingState</strong></li>
</ul>
<p>当充电状态发生变化时，会触发 postParoleStateChanged 方法！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setChargingState</span><span class="params">(<span class="keyword">boolean</span> charging)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCharging != charging) &#123;</span><br><span class="line">            mCharging = charging;</span><br><span class="line">            <span class="comment">//【*11.1.1-common】当充电状态发生变化后，处理假释状态的变化！</span></span><br><span class="line">            postParoleStateChanged();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们在 UsageStatsService.onBootPhase 方法中会初始化下开机时的充电状态，这时候会调用 setChargingState 方法！</p>
<p>同时，我们在 DeviceStateReceiver 接收者中，当接收到 Intent.ACTION_BATTERY_CHANGED 广播后，我们会调用 setChargingState 方法！</p>
<ul>
<li><strong>UsageStatsService.setAppIdleParoled</strong></li>
</ul>
<p>我们在 DeviceStateReceiver 接收者中，当接收到 PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED 广播后，即 doze 模式发生了变化，我们会调用 onDeviceIdleModeChanged 方法！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onDeviceIdleModeChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> deviceIdle = mPowerManager.isDeviceIdleMode();</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) Slog.i(TAG, <span class="string">"DeviceIdleMode changed to "</span> + deviceIdle);</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> timeSinceLastParole = checkAndGetTimeLocked() - mLastAppIdleParoledTime;</span><br><span class="line">        <span class="keyword">if</span> (!deviceIdle</span><br><span class="line">                &amp;&amp; timeSinceLastParole &gt;= mAppIdleParoleIntervalMillis) &#123;</span><br><span class="line">            <span class="comment">//【1】如果当前不处于 device idle 状态，并且当前距离上次假释状态超过了 24 小时</span></span><br><span class="line">            <span class="comment">// 那么我们会进入假释状态！</span></span><br><span class="line">            <span class="keyword">if</span> (DEBUG) Slog.i(TAG, <span class="string">"Bringing idle apps out of inactive state due to deviceIdleMode=false"</span>);</span><br><span class="line">            setAppIdleParoled(<span class="keyword">true</span>);</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (deviceIdle) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG) Slog.i(TAG, <span class="string">"Device idle, back to prison"</span>);</span><br><span class="line">            <span class="comment">//【2】如果当前处于 device idle 状态，那么无法进入假释状态！</span></span><br><span class="line">            setAppIdleParoled(<span class="keyword">false</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>setAppIdleParoled 方法用于将 app 在 idle 的状态下唤醒进入假释状态，参数 boolean paroled 表示当前是否进入假释状态！</p>
<p>mAppIdleTempParoled 用于保存假释状态！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setAppIdleParoled</span><span class="params">(<span class="keyword">boolean</span> paroled)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mAppIdleTempParoled != paroled) &#123;</span><br><span class="line">            <span class="comment">//【1】缓存本次假释状态！</span></span><br><span class="line">            mAppIdleTempParoled = paroled;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">"Changing paroled to "</span> + mAppIdleTempParoled);</span><br><span class="line">            <span class="keyword">if</span> (paroled) &#123;</span><br><span class="line">                <span class="comment">//【1.1】如果本次是进入假释，设置退出假释的超时消息！</span></span><br><span class="line">                postParoleEndTimeout();</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//【1.2】如果本次是退出假释，设置下一次进入假释的消息！</span></span><br><span class="line">                <span class="comment">// 保存上次假释的最后时间！</span></span><br><span class="line">                mLastAppIdleParoledTime = checkAndGetTimeLocked();</span><br><span class="line">                postNextParoleTimeout();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//【*11.1.1-common】处理假释状态的变化！</span></span><br><span class="line">            postParoleStateChanged();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后，调用了 postParoleStateChanged 方法！</p>
<h3 id="11-1-1-UsageStatsService-postParoleStateChanged"><a href="#11-1-1-UsageStatsService-postParoleStateChanged" class="headerlink" title="11.1.1 UsageStatsService.postParoleStateChanged"></a>11.1.1 UsageStatsService.postParoleStateChanged</h3><p>postParoleStateChanged 会发送 MSG_PAROLE_STATE_CHANGED 消息给 H：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postParoleStateChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">"Posting MSG_PAROLE_STATE_CHANGED"</span>);</span><br><span class="line">    mHandler.removeMessages(MSG_PAROLE_STATE_CHANGED);</span><br><span class="line">    mHandler.sendEmptyMessage(MSG_PAROLE_STATE_CHANGED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们去看看 H 是如何处理 MSG_PAROLE_STATE_CHANGED 消息的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> MSG_PAROLE_STATE_CHANGED:</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">"Parole state: "</span> + mAppIdleTempParoled</span><br><span class="line">            + <span class="string">", Charging state:"</span> + mCharging);</span><br><span class="line">    <span class="comment">//【*11.2】处理 app 假释状态改变的消息！</span></span><br><span class="line">    informParoleStateChanged();</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="11-2-UsageStatsService-informParoleStateChanged"><a href="#11-2-UsageStatsService-informParoleStateChanged" class="headerlink" title="11.2 UsageStatsService.informParoleStateChanged"></a>11.2 UsageStatsService.informParoleStateChanged</h2><p>当假释状态改变后，会通知所有的监听者！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">informParoleStateChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> paroled = isParoledOrCharging();</span><br><span class="line">    <span class="keyword">for</span> (AppIdleStateChangeListener listener : mPackageAccessListeners) &#123;</span><br><span class="line">        listener.onParoleStateChanged(paroled);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2017/03/13/Handler篇 5 - Message 源码分析/">Handler篇 5 - Message 源码分析</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-03-13</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/AndroidFramework源码分析/">AndroidFramework源码分析</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/AndroidFramework源码分析/Handler线程消息机制/">Handler线程消息机制</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Handler线程消息机制/">Handler线程消息机制</a></span><div class="content"><p>基于 Android 7.1.1 源码，分析 Message 的架构和原理。</p>
<h1 id="1-成员变量"><a href="#1-成员变量" class="headerlink" title="1 成员变量"></a>1 成员变量</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> what;</span><br></pre></td></tr></table></figure>
<p>用于标识 Message！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> arg1;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> arg2;</span><br></pre></td></tr></table></figure>
<p>用于传递简单的整型数据，如果想传递复杂的数据使用 Bundle</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Object obj;</span><br></pre></td></tr></table></figure>
<p>用于发送任意对象，如果要用 Message 进行跨进程通信，obj 必须实现序列化接口！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Messenger replyTo;</span><br></pre></td></tr></table></figure>
<p>用于跨进程双向通信，接受到该 message 的进程，可以通过 Message.replyTo 向发送方进程发送 message，从而实现双向通信！</p>
<p>这个在分析 Messenger 的时候会看到！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> sendingUid = -<span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>发送方的 uid，只有在通过 Messenger 跨进程通信的时候才有效，否则为 -1；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> flags;</span><br></pre></td></tr></table></figure>
<p>Message 的标志位，可以取如下的值；</p>
<ul>
<li><p><strong>static final int FLAG_IN_USE = 1 &lt;&lt; 0</strong>：用于标识当前的 Message 处于使用状态，当 Message 处于消息队列中、处于消息池中或者 Handler 正在处理该 Message 的时候，它就处于使用状态；</p>
</li>
<li><p><strong>static final int FLAG_ASYNCHRONOUS = 1 &lt;&lt; 1</strong>：用于标识当前的 Message 是异步的；</p>
</li>
<li><p><strong>static final int FLAGS_TO_CLEAR_ON_COPY_FROM = FLAG_IN_USE</strong>：当调用 copyFrom 方法的时候，会去掉 FLAG_IN_USE 标志位！</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> when;</span><br></pre></td></tr></table></figure>
<p>Message 的分发时间；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Bundle data;</span><br></pre></td></tr></table></figure>
<p>用于传输比较复杂的数据；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Handler target;</span><br></pre></td></tr></table></figure>
<p>表示消息的目标处理 Handler！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Runnable callback;</span><br></pre></td></tr></table></figure>
<p>表示要处理的任务 Runnable，通过 handler post Runnable 的时候，Runnable 会被封装成一个 Message，如果要用 Message 进行跨进程通信，callback 必须为 null，因为其不能序列化！！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sometimes we store linked lists of these things</span></span><br><span class="line">Message next;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object sPoolSync = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure>
<p>用于同步的锁对象！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Message sPool;</span><br></pre></td></tr></table></figure>
<p>静态变量，我们知道 Handler 发送过的 message 会被缓存到消息池中，方便复用，其实消息池也是一个列表，sPool 是这个链表的头元素！！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> sPoolSize = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>静态变量，用于记录消息池中 Message 的数量，也就是链表的长度，其最大不能超过 MAX_POOL_SIZE 规定的大小！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_POOL_SIZE = <span class="number">50</span>;</span><br></pre></td></tr></table></figure>
<p>消息池中 Message 的最大数量！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> gCheckRecycle = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>
<h1 id="2-create-Message"><a href="#2-create-Message" class="headerlink" title="2 create Message"></a>2 create Message</h1><p>想要发送 Message，首先要创建 Message，创建分为 2 种：</p>
<ul>
<li>直接创建；</li>
<li>复用已有消息；</li>
</ul>
<p>下面我们来分别看看；</p>
<h2 id="2-1-new-Message"><a href="#2-1-new-Message" class="headerlink" title="2.1 new Message"></a>2.1 new Message</h2><p>直接创建，能够保证我们每次创建的都是一个新的消息对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Message</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造器很简单，没有多么复杂，我们可以创建一个 Message 对象，然后设置它的属性：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Message msg = <span class="keyword">new</span> Message();</span><br><span class="line">Bundle b = <span class="keyword">new</span> Bundle();</span><br><span class="line">b.putString(<span class="string">"name"</span>, <span class="string">"coolqi"</span>);</span><br><span class="line">b.putString(<span class="string">"face"</span>, <span class="string">"cool"</span>);</span><br><span class="line">msg.setData(b);</span><br><span class="line">mHandler.sendMessage(msg);</span><br></pre></td></tr></table></figure></p>
<p>这里就不多说了！</p>
<h2 id="2-2-Message-obtain"><a href="#2-2-Message-obtain" class="headerlink" title="2.2 Message.obtain"></a>2.2 Message.obtain</h2><p>复用已有消息，我们知道 handler 会将发送过的消息，保存到一个消息池中，便于复用！</p>
<p>Message 提供了多个 obtain 用于复用一个 Message！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">(Message orig)</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">(Handler h)</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">(Handler h, Runnable callback)</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">(Handler h, <span class="keyword">int</span> what)</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">(Handler h, <span class="keyword">int</span> what, Object obj)</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">(Handler h, <span class="keyword">int</span> what, <span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2)</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">(Handler h, <span class="keyword">int</span> what, <span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2, Object obj)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>上面的多个 obtain 都会先尝试从消息池中获取一个缓存的消息，如果找不到，再创建一个新的消息，然后<strong>用传入的参数更新这个消息对应的属性值</strong>，并返回！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sPool != <span class="keyword">null</span>) &#123; <span class="comment">// 每次都复用消息池的头消息！</span></span><br><span class="line">            Message m = sPool;</span><br><span class="line">            sPool = m.next;</span><br><span class="line">            m.next = <span class="keyword">null</span>;</span><br><span class="line">            m.flags = <span class="number">0</span>; <span class="comment">// 清空 flag，不再为使用状态</span></span><br><span class="line">            sPoolSize--;</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Message(); <span class="comment">// 如果没有就创建一个新的消息！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码很简单，不多了！</p>
<h1 id="3-recycle-Message"><a href="#3-recycle-Message" class="headerlink" title="3 recycle Message"></a>3 recycle Message</h1><p>回收一个 Message 分为 2 种情况，一种是安全的回收，一种是不安全的回收！</p>
<h2 id="3-1-safe-recycle"><a href="#3-1-safe-recycle" class="headerlink" title="3.1 safe recycle"></a>3.1 safe recycle</h2><p>安全的回收：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isInUse()) &#123; <span class="comment">// 判断是否在使用中!</span></span><br><span class="line">        <span class="keyword">if</span> (gCheckRecycle) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"This message cannot be recycled because it "</span></span><br><span class="line">                    + <span class="string">"is still in use."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    recycleUnchecked(); <span class="comment">// 不再使用了，回收！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>安全回收在回收 Message 之前会先检查 Message 是否处于使用状态，处于使用状态下是不能回收的！！</p>
<p>recycle() 在判断安全后，会调用 recycleUnchecked() 进行回收！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*package*/</span> <span class="function"><span class="keyword">boolean</span> <span class="title">isInUse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((flags &amp; FLAG_IN_USE) == FLAG_IN_USE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的方法用于判断 Message 是否在使用中！</p>
<p>gCheckRecycle 属性在 SDK 21 以及以后默认为 true，他用来决定在回收时如果正在使用，是否抛出异常！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">updateCheckRecycle</span><span class="params">(<span class="keyword">int</span> targetSdkVersion)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (targetSdkVersion &lt; Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">        gCheckRecycle = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面是具体的判断方法！</p>
<h2 id="3-2-unsafe-recycle"><a href="#3-2-unsafe-recycle" class="headerlink" title="3.2 unsafe recycle"></a>3.2 unsafe recycle</h2><p>不安全的回收：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recycleUnchecked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    flags = FLAG_IN_USE;</span><br><span class="line">    what = <span class="number">0</span>;</span><br><span class="line">    arg1 = <span class="number">0</span>;</span><br><span class="line">    arg2 = <span class="number">0</span>;</span><br><span class="line">    obj = <span class="keyword">null</span>;</span><br><span class="line">    replyTo = <span class="keyword">null</span>;</span><br><span class="line">    sendingUid = -<span class="number">1</span>;</span><br><span class="line">    when = <span class="number">0</span>;</span><br><span class="line">    target = <span class="keyword">null</span>;</span><br><span class="line">    callback = <span class="keyword">null</span>;</span><br><span class="line">    data = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123; <span class="comment">// 如果消息池未满，将回收后的消息加入到消息池中！</span></span><br><span class="line">            next = sPool;</span><br><span class="line">            sPool = <span class="keyword">this</span>;</span><br><span class="line">            sPoolSize++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 recycleUnchecked() 会重置掉 Message 的属性！</p>
<h1 id="4-跨进程传输"><a href="#4-跨进程传输" class="headerlink" title="4 跨进程传输"></a>4 跨进程传输</h1><p>由于 Message 实现了 Parcelable 接口，所以可以序列化，跨进程传输数据，我们知道信使 Messenger 就是通过 Message 来实现跨进程通信的！</p>
<h2 id="4-1-writeToParcel"><a href="#4-1-writeToParcel" class="headerlink" title="4.1 writeToParcel"></a>4.1 writeToParcel</h2><p>序列化方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel dest, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (callback != <span class="keyword">null</span>) &#123; <span class="comment">// 如果消息的 callback 不为，不能序列化！</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">            <span class="string">"Can't marshal callbacks across processes."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    dest.writeInt(what);</span><br><span class="line">    dest.writeInt(arg1);</span><br><span class="line">    dest.writeInt(arg2);</span><br><span class="line">    <span class="keyword">if</span> (obj != <span class="keyword">null</span>) &#123; <span class="comment">// 如果要传递任意对象，必须实现 Parcelable 接口！</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Parcelable p = (Parcelable)obj;</span><br><span class="line">            dest.writeInt(<span class="number">1</span>);</span><br><span class="line">            dest.writeParcelable(p, flags);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassCastException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Can't marshal non-Parcelable objects across processes."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dest.writeInt(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    dest.writeLong(when);</span><br><span class="line">    dest.writeBundle(data);</span><br><span class="line">    Messenger.writeMessengerOrNullToParcel(replyTo, dest); <span class="comment">// 针对于 Messenger 的特殊处理！</span></span><br><span class="line">    dest.writeInt(sendingUid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 Message 设置了 Runnable callback，那么不能序列化！</p>
<h2 id="4-2-readFromParcel"><a href="#4-2-readFromParcel" class="headerlink" title="4.2 readFromParcel"></a>4.2 readFromParcel</h2><p>反序列化方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readFromParcel</span><span class="params">(Parcel source)</span> </span>&#123;</span><br><span class="line">    what = source.readInt();</span><br><span class="line">    arg1 = source.readInt();</span><br><span class="line">    arg2 = source.readInt();</span><br><span class="line">    <span class="keyword">if</span> (source.readInt() != <span class="number">0</span>) &#123;</span><br><span class="line">        obj = source.readParcelable(getClass().getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">    when = source.readLong();</span><br><span class="line">    data = source.readBundle();</span><br><span class="line">    replyTo = Messenger.readMessengerOrNullFromParcel(source); <span class="comment">// 针对于 Messenger 的特殊处理！</span></span><br><span class="line">    sendingUid = source.readInt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 Messenger 的内容，我们会单独开一篇文章来分析！</p>
<h1 id="5-其他方法"><a href="#5-其他方法" class="headerlink" title="5 其他方法"></a>5 其他方法</h1><p>Message 提供了一些其他的方法：</p>
<ul>
<li>copyFrom 用于将一个 Message 的属性 copy 到另一个 Message 中：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">copyFrom</span><span class="params">(Message o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.flags = o.flags &amp; ~FLAGS_TO_CLEAR_ON_COPY_FROM; <span class="comment">// 去掉 FLAG_IN_USE 标志位！</span></span><br><span class="line">    <span class="keyword">this</span>.what = o.what;</span><br><span class="line">    <span class="keyword">this</span>.arg1 = o.arg1;</span><br><span class="line">    <span class="keyword">this</span>.arg2 = o.arg2;</span><br><span class="line">    <span class="keyword">this</span>.obj = o.obj;</span><br><span class="line">    <span class="keyword">this</span>.replyTo = o.replyTo;</span><br><span class="line">    <span class="keyword">this</span>.sendingUid = o.sendingUid;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (o.data != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.data = (Bundle) o.data.clone();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.data = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>异步相关的方法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAsynchronous</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (flags &amp; FLAG_ASYNCHRONOUS) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAsynchronous</span><span class="params">(<span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (async) &#123;</span><br><span class="line">        flags |= FLAG_ASYNCHRONOUS;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        flags &amp;= ~FLAG_ASYNCHRONOUS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以及一些其他的用于 get 属性，打印属性的方法，这里就不多说了！！</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2017/03/06/Binder跨进程通信 - 信使 Messenger/">Binder跨进程通信 - 信使 Messenger</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-03-06</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/AndroidFramework源码分析/">AndroidFramework源码分析</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/AndroidFramework源码分析/Binder跨进程通信/">Binder跨进程通信</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Binder跨进程通信/">Binder跨进程通信</a></span><div class="content"><p>Android 已经内置了一些模板和工具类来帮助我们更好的实现跨进程通信，除了 aidl 模板，还有一个就是信使 Messenger，下面我们来分析下信使的原理！</p>
<h1 id="1-Messenger-源码分析"><a href="#1-Messenger-源码分析" class="headerlink" title="1 Messenger 源码分析"></a>1 Messenger 源码分析</h1><p>Messenger 本质上是实现了 aidl 模板，aidl 文件名为 IMessenger.aidl，位于 android/frameworks/base/core/java/android/os/IMessenger.aidl 目录下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> android.os;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Message;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line">oneway <span class="class"><span class="keyword">interface</span> <span class="title">IMessenger</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(in Message msg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，该 aidl 会生成一个用于跨进程通信的接口！！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> android.os;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IMessenger</span> <span class="keyword">extends</span> <span class="title">IInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(Message var1)</span> <span class="keyword">throws</span> RemoteException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于创建服务端桩对象！</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Stub</span> <span class="keyword">extends</span> <span class="title">Binder</span> <span class="keyword">implements</span> <span class="title">IMessenger</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Stub</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"stub"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IMessenger <span class="title">asInterface</span><span class="params">(IBinder var0)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"stub"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> IBinder <span class="title">asBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"stub"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> var1, Parcel var2, Parcel var3, <span class="keyword">int</span> var4)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"stub"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一切又是那么熟悉，下面我们重点分析 Messenger 是如何封装的！</p>
<h2 id="1-1-Messenger-create"><a href="#1-1-Messenger-create" class="headerlink" title="1.1 Messenger create"></a>1.1 Messenger create</h2><p>创建 Messenger 的方法有如下 2 种：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Messenger</span><span class="params">(IBinder target)</span> </span>&#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Messenger</span><span class="params">(Handler target)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>参数不同，作用和目的也不同！</p>
<h3 id="1-1-1-create-with-IBinder"><a href="#1-1-1-create-with-IBinder" class="headerlink" title="1.1.1 create with IBinder"></a>1.1.1 create with IBinder</h3><p>下面我们来看第一个构造器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Messenger</span><span class="params">(IBinder target)</span> </span>&#123;</span><br><span class="line">    mTarget = IMessenger.Stub.asInterface(target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个构造器很简单，和使用 aidl 模板很相似：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mTarget = IMessenger.Stub.asInterface(target);</span><br></pre></td></tr></table></figure></p>
<p>其实就是通过 asInterface 将服务端转为一个代理对象，保存到内部的成员变量 mTarget 中！</p>
<p>其实我们类比 aidl 模板，要实现跨进程通信，服务端需要有一个桩对象，客户端需要有其对应的代理对象！</p>
<p>所以，<strong>以 IBinder target 为参数的构造器用于跨进程通信的客户端进程，用以生成客户端代理对象</strong>！</p>
<h3 id="1-1-2-create-with-Handler"><a href="#1-1-2-create-with-Handler" class="headerlink" title="1.1.2 create with Handler"></a>1.1.2 create with Handler</h3><p>下面我们来看看第二个构造器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Messenger</span><span class="params">(Handler target)</span> </span>&#123;</span><br><span class="line">    mTarget = target.getIMessenger();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里调用了 Handler.getIMessenger() 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> IMessenger <span class="title">getIMessenger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mQueue) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mMessenger != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> mMessenger;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【1】这里会创建一个 MessengerImpl 实例！</span></span><br><span class="line">        mMessenger = <span class="keyword">new</span> MessengerImpl();</span><br><span class="line">        <span class="keyword">return</span> mMessenger;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>IMessenger mMessenger 是 Handler 内部的一个变量，getIMessenger() 方法会创建 MessengerImpl 实例！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MessengerImpl</span> <span class="keyword">extends</span> <span class="title">IMessenger</span>.<span class="title">Stub</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        msg.sendingUid = Binder.getCallingUid();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【1】MessengerImpl 为 Handler 的内部类，持有外部类的引用！</span></span><br><span class="line">        <span class="comment">// 调用 Handler.sendMessage 方法！</span></span><br><span class="line">        Handler.<span class="keyword">this</span>.sendMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实，可以看到 MessengerImpl 继承了 IMessenger.Stub 抽象类，并实现了其 send 方法，就是调用 Handler 的 sendMessage 方法！</p>
<p>类比 aidl 模板，<strong>以 Handler target 为参数的构造器用于跨进程通信的服务端进程，用以生成服务端 “桩” 对象</strong>！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IBinder <span class="title">getBinder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mTarget.asBinder();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时，Messenger 也会提供一个 getBinder()，用于获得用于通信的 IBinder 实例！</p>
<h2 id="1-2-Messenger-send"><a href="#1-2-Messenger-send" class="headerlink" title="1.2 Messenger send"></a>1.2 Messenger send</h2><p>Messenger 是通过 Message 来封装通信数据的，因为 Message 实现了 Parcelable 接口，可以序列化，跨进程传输！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Message message)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    mTarget.send(message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>send 方法很简单，只需要调用内部的 IMessenger mTarget 的 send 方法，那么服务端的 MessengerImpl.send 方法会调用，最终触发</p>
<h1 id="2-Messenger-序列化处理"><a href="#2-Messenger-序列化处理" class="headerlink" title="2 Messenger 序列化处理"></a>2 Messenger 序列化处理</h1><p>Messenger 实现了 Parcelable 接口，因此可以序列化，而<strong>使用 Messenger 进行双向通信，正式依赖于序列化的特性</strong>，下面我们来看下：</p>
<p>Messenger 内部定义了 2 个方法，来实现序列化！</p>
<h2 id="2-1-writeMessengerOrNullToParcel"><a href="#2-1-writeMessengerOrNullToParcel" class="headerlink" title="2.1 writeMessengerOrNullToParcel"></a>2.1 writeMessengerOrNullToParcel</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel out, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    out.writeStrongBinder(mTarget.asBinder());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeMessengerOrNullToParcel</span><span class="params">(Messenger messenger,</span></span></span><br><span class="line"><span class="function"><span class="params">        Parcel out)</span> </span>&#123;</span><br><span class="line">    out.writeStrongBinder(messenger != <span class="keyword">null</span> ? messenger.mTarget.asBinder()</span><br><span class="line">            : <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，我们写入到 Parcel out 中的并不是我们的 Messenger 对象，而是 messenger.mTarget.asBinder()！！</p>
<h2 id="2-1-readMessengerOrNullFromParcel"><a href="#2-1-readMessengerOrNullFromParcel" class="headerlink" title="2.1 readMessengerOrNullFromParcel"></a>2.1 readMessengerOrNullFromParcel</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Messenger <span class="title">readMessengerOrNullFromParcel</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">    IBinder b = in.readStrongBinder();</span><br><span class="line">    <span class="keyword">return</span> b != <span class="keyword">null</span> ? <span class="keyword">new</span> Messenger(b) : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，当我们从 Parcel out 中读取时，Messenger 又帮我们做了一些的处理，调用了构造器：Messenger(IBinder target)，通过传递过来的 IBinder 对象，创建客户端 Messenger 对象！</p>
<p>可以看到，Messenger 序列化传递过程中，利用了序列化的特性，自动帮我们是实现了代理和装对象的转换！</p>
<h1 id="3-Messenger-的使用"><a href="#3-Messenger-的使用" class="headerlink" title="3 Messenger 的使用"></a>3 Messenger 的使用</h1><p>下面列出 Messenger 使用的核心代码，这里我会使用一个</p>
<h2 id="3-1-服务端实现"><a href="#3-1-服务端实现" class="headerlink" title="3.1 服务端实现"></a>3.1 服务端实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MServerService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MServerService"</span>;</span><br><span class="line">    <span class="keyword">private</span> Messenger mSMessenger = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> HandlerThread mThread = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> MyHandler mHandler = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        mThread = <span class="keyword">new</span> HandlerThread(<span class="string">"Messenger"</span>, Thread.MIN_PRIORITY);</span><br><span class="line">        mThread.start();</span><br><span class="line">        mHandler = <span class="keyword">new</span> MyHandler(mThread.getLooper());</span><br><span class="line">        <span class="comment">//【关键代码】创建 Messenger 传入指定的 Handler！</span></span><br><span class="line">        mSMessenger = <span class="keyword">new</span> Messenger(mHandler);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mSMessenger == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mSMessenger = <span class="keyword">new</span> Messenger(mHandler);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【关键代码】调用 Messenger.getBinder() 方法！</span></span><br><span class="line">        <span class="keyword">return</span> mSMessenger.getBinder();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyHandler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(looper);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    Log.d(TAG, <span class="string">"BIND SUCCESSFUL"</span>);</span><br><span class="line">                    <span class="comment">//【关键代码】客户端注册，然后回调</span></span><br><span class="line">                    Message msgR = <span class="keyword">new</span> Message();</span><br><span class="line">                    msgR.what = <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        mtoCMessenger = msg.replyTo;</span><br><span class="line">                        mtoCMessenger.send(msgR);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-2-客户端实现"><a href="#3-2-客户端实现" class="headerlink" title="3.2 客户端实现"></a>3.2 客户端实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MClientActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MClientActivity"</span>;</span><br><span class="line">    <span class="keyword">private</span> Messenger mtoSProxy;</span><br><span class="line">    <span class="keyword">private</span> Messenger mCMessenger;</span><br><span class="line">    <span class="keyword">private</span> CHandler mHandler;</span><br><span class="line">    <span class="keyword">private</span> ServiceConnection mConnection = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//【关键代码】bind 成功，同时客户端注册！        </span></span><br><span class="line">            mtoSProxy = <span class="keyword">new</span> Messenger(service);</span><br><span class="line">            sendMessage(mtoSProxy);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line">            mtoSProxy = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_aidl);</span><br><span class="line">        <span class="comment">//【关键代码】创建服务端的 Messenger！</span></span><br><span class="line">        mHandler = <span class="keyword">new</span> CHandler(getMainLooper());</span><br><span class="line">        mCMessenger = <span class="keyword">new</span> Messenger(mHandler);</span><br><span class="line">        bindMServerService();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bindMServerService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">        intent.setClass(<span class="keyword">this</span>, MServerService.class);</span><br><span class="line">        bindService(intent, mConnection, BIND_AUTO_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(Messenger proxy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//【关键代码】bind 成功，注册客户端的 Messenger</span></span><br><span class="line">            Message msg = <span class="keyword">new</span> Message();</span><br><span class="line">            msg.what = <span class="number">1</span>;</span><br><span class="line">            msg.replyTo = mCMessenger;</span><br><span class="line">            proxy.send(msg);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">CHandler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(looper);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    Log.d(TAG, <span class="string">"REGISTER SUCCESSFUL"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>代码很简单，就不多说了！</p>
<h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h1><p>Messenger 本质上是对 AIDL 模板的封装，通过 Messenger 我们可以实现基于消息的跨进程通信！</p>
<p>同样的，由于 Messenger 是基于消息的跨进程通信，通过 Handler 实现，所以无法实现并发的通信操作！！</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2017/02/27/Handler篇 4 - MessageQueue 源码分析/">Handler篇 4 - MessageQueue 源码分析</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-02-27</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/AndroidFramework源码分析/">AndroidFramework源码分析</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/AndroidFramework源码分析/Handler线程消息机制/">Handler线程消息机制</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Handler线程消息机制/">Handler线程消息机制</a></span><div class="content"><p>基于 Android 7.1.1 源码，分析 handler 的架构和原理。</p>
<h1 id="1-成员变量"><a href="#1-成员变量" class="headerlink" title="1 成员变量"></a>1 成员变量</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> mQuitAllowed;</span><br></pre></td></tr></table></figure>
<p>该变量表示 MessageQueue 是否可以退出，主线程的消息队列不可退出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unused"</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> mPtr; <span class="comment">// used by native code</span></span><br></pre></td></tr></table></figure>
<p>java 层有一个 MessageQueue，同样的 native 层也有一个 MessageQueue，java 层 MessageQueue 在初始化是，也会初始化 native 层的 MessageQueue，这个变量用来保存 natvie 层的消息队列的句柄！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Message mMessages;</span><br></pre></td></tr></table></figure>
<p>MessageQueue 消息队列中的所有消息是通过链表联系在一起的，mMessages 是这个链表的头元素！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> IdleHandler[] mPendingIdleHandlers;</span><br></pre></td></tr></table></figure>
<p>用于保存将要被执行的 IdleHandler，当消息队列要执行 IdleHandler 的时候，他会将 mIdleHandlers 中的所有 IdleHandler 拷贝到 mPendingIdleHandlers！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayList&lt;IdleHandler&gt; mIdleHandlers = <span class="keyword">new</span> ArrayList&lt;IdleHandler&gt;();</span><br></pre></td></tr></table></figure>
<p>用于保存该线程的所有 IdleHandler！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> SparseArray&lt;FileDescriptorRecord&gt; mFileDescriptorRecords;</span><br></pre></td></tr></table></figure>
<p>用于记录文件描述符</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> mQuitting;</span><br></pre></td></tr></table></figure>
<p>该变量表示 MessageQueue 是否正在关闭退出！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> mBlocked;</span><br></pre></td></tr></table></figure>
<p>该变量表示 MessageQueue 是否是阻塞的，当 MessageQueue 中没有任何消息的时候，消息队列会阻塞，等待消息的插入！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mNextBarrierToken;</span><br></pre></td></tr></table></figure>
<p>这里要提及一个概念叫：障栅（Barrier）。</p>
<p>障栅是一个特殊的 Message，他的 target 为 null，并且其 Message.arg1 作为句柄，标识每一个独一无二的障栅！</p>
<p>障栅的作用很重要，它能够拦截同步 Message，阻止同步消息被执行，放行异步 Message！后面我们会看到！</p>
<p>mNextBarrierToken 的作用是计算下一个 Barrier 的 token！</p>
<h1 id="2-create-MessageQueue"><a href="#2-create-MessageQueue" class="headerlink" title="2 create MessageQueue"></a>2 create MessageQueue</h1><p>我们来回顾下 Looper 的创建：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed); <span class="comment">// 这里创建了一个消息队列！</span></span><br><span class="line">    mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-1-new-MessageQueue"><a href="#2-1-new-MessageQueue" class="headerlink" title="2.1 new MessageQueue"></a>2.1 new MessageQueue</h2><p>这里会调用 MessageQueue 构造器，创建一个消息队列！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MessageQueue(<span class="keyword">boolean</span> quitAllowed) &#123;</span><br><span class="line">    mQuitAllowed = quitAllowed;</span><br><span class="line">    mPtr = nativeInit(); <span class="comment">// 初始化 native 层的消息队列，并返回其指针！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>mQuitAllowed 成员变量表示该消息队列是否可以关闭</strong>，对于 ui 线程的消息队列，是不能退出的，我们可以回顾下，ui 线程的 Looper 创建：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    prepare(<span class="keyword">false</span>); <span class="comment">// prepare 方法的参数就是 quitAllowed，这里传入的是 false；</span></span><br><span class="line">    <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The main Looper has already been prepared."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sMainLooper = myLooper();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>nativeInit 方法是一个 native 方法，他会初始化处于 native 层的 MessageQueue，他和 java 层的 MessageQueue 一一对应！</p>
<p>在 Android 2.3 之前，只有 java 层才可以向 MessageQueue 中添加消息，在 Android 2.3 之后，MessageQueue 的核心部分移动到了 native 层。这样，java 层和 native 层都可以使用 MessageQueue！</p>
<p>也就是说， Java 层的 MessageQueue 处理 Java 层的消息，natvie 层的 MessageQueue 负责处理 native 层的消息！</p>
<h1 id="3-enqueue-Message"><a href="#3-enqueue-Message" class="headerlink" title="3 enqueue Message"></a>3 enqueue Message</h1><p>我们回到 Handler 中，当我们通过 handler 发送消息的时候，会调用 Handler.enqueueMessage 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    msg.target = <span class="keyword">this</span>; <span class="comment">// 设置消息的目标</span></span><br><span class="line">    <span class="keyword">if</span> (mAsynchronous) &#123; <span class="comment">// 如果 Handler 是异步的，其内部消息都是异步的！</span></span><br><span class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis); <span class="comment">// 将消息加入到队列中！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-1-MessageQueue-enqueueMessage"><a href="#3-1-MessageQueue-enqueueMessage" class="headerlink" title="3.1 MessageQueue.enqueueMessage"></a>3.1 MessageQueue.enqueueMessage</h2><p>最终会调用 enqueueMessage 将消息插入到 MessageQueue 中，下面我们来看看 MessageQueue.enqueueMessage 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(Message msg, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】校验下 Message 的有效性！</span></span><br><span class="line">    <span class="keyword">if</span> (msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Message must have a target."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (msg.isInUse()) &#123; <span class="comment">//【2】如果 message 正在使用，抛出异常！</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(msg + <span class="string">" This message is already in use."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mQuitting) &#123; <span class="comment">// 如果 MessageQueue 正在关闭，抛出异常，我们不能</span></span><br><span class="line">            IllegalStateException e = <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    msg.target + <span class="string">" sending message to a Handler on a dead thread"</span>);</span><br><span class="line">            Log.w(TAG, e.getMessage(), e);</span><br><span class="line">            msg.recycle();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg.markInUse(); <span class="comment">// 设置 FLAG_IN_USE 标志位，表示正在使用中！</span></span><br><span class="line">        msg.when = when;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        <span class="keyword">boolean</span> needWake;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || when == <span class="number">0</span> || when &lt; p.when) &#123;</span><br><span class="line">            <span class="comment">// 新的 message 为消息队列的新头元素！</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">            needWake = mBlocked; <span class="comment">// 此时是否唤醒消息队列，取决于是否阻塞！</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果不是新的头元素，那就将其添加到正确的位置！</span></span><br><span class="line">            Message prev;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                prev = p; <span class="comment">// 确定 pre 和 next message！</span></span><br><span class="line">                p = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == <span class="keyword">null</span> || when &lt; p.when) &#123; <span class="comment">// 按照分发时间从小到大排序！</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (needWake &amp;&amp; p.isAsynchronous()) &#123;</span><br><span class="line">                    needWake = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            msg.next = p; <span class="comment">// 找到合适的位置并插入！</span></span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (needWake) &#123;</span><br><span class="line">            <span class="comment">// 唤醒消息队列！</span></span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里来说下 MessageQueue 的成员变量 mMessages：在 MessageQueue 中，所有的 Message 是以链表的形式组织在一起的，mMessages 是链表的头元素！</p>
<h1 id="4-dispatch-Message"><a href="#4-dispatch-Message" class="headerlink" title="4 dispatch Message"></a>4 dispatch Message</h1><p>在前面 Looper 分析中，我们知道，Looper.loop() 方法会进入一个 for 死循环，不断的调用 MessageQueue.next 方法，返回下一个 Message。</p>
<h2 id="4-1-MessageQueue-next"><a href="#4-1-MessageQueue-next" class="headerlink" title="4.1 MessageQueue.next"></a>4.1 MessageQueue.next</h2><p>下面我们来看看 MessageQueue.next 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Message <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】当 mPtr == 0 的时候，说明消息队列关闭了，那么我们会返回一个 null 的 Message</span></span><br><span class="line">    <span class="comment">// 这样消息循环就会关闭！</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ptr = mPtr;</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pendingIdleHandlerCount = -<span class="number">1</span>; <span class="comment">// Looper 每次调用 MQ.next 方法，都会初始化为 -1；</span></span><br><span class="line">    <span class="keyword">int</span> nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextPollTimeoutMillis != <span class="number">0</span>) &#123;</span><br><span class="line">            Binder.flushPendingCommands();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nativePollOnce(ptr, nextPollTimeoutMillis);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// 从链表头开始，分发 Message！</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">            Message prevMsg = <span class="keyword">null</span>;</span><br><span class="line">            Message msg = mMessages;</span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span> &amp;&amp; msg.target == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果 msg 不为 null，但是 msg.target，那说明这是障珊，根据障珊的特性，拦截同步，放行异步</span></span><br><span class="line">                <span class="comment">// 那就顺序遍历，找到下一个异步 Message！</span></span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    prevMsg = msg;</span><br><span class="line">                    msg = msg.next;</span><br><span class="line">                &#125; <span class="keyword">while</span> (msg != <span class="keyword">null</span> &amp;&amp; !msg.isAsynchronous()); <span class="comment">// 如果消息是同步的，继续查找！</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果 msg 不为 null，说明我们找到了要分发的消息（异步/同步）！</span></span><br><span class="line">            <span class="keyword">if</span> (msg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (now &lt; msg.when) &#123;</span><br><span class="line">                    <span class="comment">// Next message is not ready.  Set a timeout to wake up when it is ready.</span></span><br><span class="line">                    <span class="comment">// 如果消息还没有到分发的时间，设置一个超时时间用于触发他！</span></span><br><span class="line">                    nextPollTimeoutMillis = (<span class="keyword">int</span>) Math.min(msg.when - now, Integer.MAX_VALUE);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 消息的分发时间已经到了，分发消息！</span></span><br><span class="line">                    mBlocked = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (prevMsg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 如果 prevMsg 不为 null，说明我们分发的是异步消息，这里要重新设置链表元素关系！</span></span><br><span class="line">                        prevMsg.next = msg.next;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 如果 prevMsg 为 null，说明我们分发的是同步消息，修改链表头！</span></span><br><span class="line">                        mMessages = msg.next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 设置 msg.next 为 null，并设置 msg 为正在使用状态；</span></span><br><span class="line">                    msg.next = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG) Log.v(TAG, <span class="string">"Returning message: "</span> + msg);</span><br><span class="line">                    msg.markInUse();</span><br><span class="line">                    <span class="keyword">return</span> msg;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nextPollTimeoutMillis = -<span class="number">1</span>; <span class="comment">// 没有要分发的 message！</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果 mQuitting 为 true，说明消息队列正在关闭，那就返回一个 null 的 Message，</span></span><br><span class="line">            <span class="comment">// 这样 Looper 就会结束消息循环！</span></span><br><span class="line">            <span class="keyword">if</span> (mQuitting) &#123;</span><br><span class="line">                dispose();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 能进入这里，说明前面我们没有找到分发的 message 或者消息触发事件未到！</span></span><br><span class="line">            <span class="comment">// 如果本次 next 第一次进入空闲状态，即没有消息去分发，那就执行 IdleHandler！</span></span><br><span class="line">            <span class="comment">// 执行的条件是：消息队列为空，或者消息队列的第一个消息还没有到执行时间！</span></span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt; <span class="number">0</span></span><br><span class="line">                    &amp;&amp; (mMessages == <span class="keyword">null</span> || now &lt; mMessages.when)) &#123;</span><br><span class="line">                pendingIdleHandlerCount = mIdleHandlers.size(); <span class="comment">// 计算 IdleHandler 个数！</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (pendingIdleHandlerCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果连 IdleHandler 也没有，那么说明消息循环没有任何消息需要处理！</span></span><br><span class="line">                <span class="comment">// 那就进入阻塞状态，设置 mBlocked 为 true！</span></span><br><span class="line">                mBlocked = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将 mIdleHandlers 中需要触发的 IdleHandler 拷贝到 mPendingIdleHandlers 中！</span></span><br><span class="line">            <span class="keyword">if</span> (mPendingIdleHandlers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mPendingIdleHandlers = <span class="keyword">new</span> IdleHandler[Math.max(pendingIdleHandlerCount, <span class="number">4</span>)];</span><br><span class="line">            &#125;</span><br><span class="line">            mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 运行收集到的 IdleHandler</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pendingIdleHandlerCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> IdleHandler idler = mPendingIdleHandlers[i];</span><br><span class="line">            mPendingIdleHandlers[i] = <span class="keyword">null</span>; <span class="comment">// 取消引用！</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> keep = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// queueIdle 返回值，表示是否保留该 IdleHandler！</span></span><br><span class="line">                keep = idler.queueIdle();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                Log.wtf(TAG, <span class="string">"IdleHandler threw exception"</span>, t);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!keep) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    mIdleHandlers.remove(idler); <span class="comment">// keep 为 false，不保留，移除！</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 pendingIdleHandlerCount 重置为 0 ，本次 next 将不会再执行 IdleHandler！</span></span><br><span class="line">        pendingIdleHandlerCount = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 我们在执行 IdleHandler 之后，会消耗一些时间，这时候消息队列里的可能有消息已经到达</span></span><br><span class="line">        <span class="comment">// 可执行时间，所以重置该变量回去重新检查消息队列。</span></span><br><span class="line">        nextPollTimeoutMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法逻辑：</p>
<ul>
<li>查询下一个要触发的消息：next 方法会启动一个 for 循环，顺序遍历消息链表：<ul>
<li>如果头消息是障栅，那就顺序查找下一个异步消息！</li>
<li>如果头消息不是障栅，那么那其就是同步消息，也是我们即将分发的消息！</li>
</ul>
</li>
</ul>
<p><br></p>
<ul>
<li><p>如果消息链表中没有任何消息，或者消息的分发时间未到，那么消息循环会进入阻塞状态，其实就是不断的 for 循环；在进入阻塞状态之前，会查询是否有 idleHandler 触发，如果没有会立刻进入阻塞状态，否则，会触发 IdleHandler，然后在再进入阻塞状态！</p>
<ul>
<li>所谓的阻塞，实际上是不断地 for 循环，直到有消息被插入，idleHandler 触发只会在进入阻塞状态的第一次 for 循环执行！</li>
</ul>
</li>
</ul>
<p><br></p>
<ul>
<li>当 MessageQueue 退出关闭的时候，mQuitting 会被置为 true，这样 MessageQueue.next 会返回一个 null 的 Message，回顾 Looper.loop，消息循环就可以退出了！</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*package*/</span> <span class="function"><span class="keyword">void</span> <span class="title">markInUse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    flags |= FLAG_IN_USE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将一个 message 设置为正在使用的状态！</p>
<h1 id="5-quit-MessageQueue"><a href="#5-quit-MessageQueue" class="headerlink" title="5 quit MessageQueue"></a>5 quit MessageQueue</h1><p>回顾 Looper.quit 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mQueue.quit(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当我们不想使用消息队列了，我们可以关闭它，最终调用的 MessageQueue.quit 方法:</p>
<h2 id="5-1-MessageQueue-quit"><a href="#5-1-MessageQueue-quit" class="headerlink" title="5.1 MessageQueue.quit"></a>5.1 MessageQueue.quit</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quit</span><span class="params">(<span class="keyword">boolean</span> safe)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果 mQuitAllowed 为 false，说明消息队列不可以关闭！</span></span><br><span class="line">    <span class="keyword">if</span> (!mQuitAllowed) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Main thread not allowed to quit."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mQuitting) &#123; <span class="comment">// 如果已经在退出了，不允许退出 2 次！</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mQuitting = <span class="keyword">true</span>; <span class="comment">// 设置 mQuitting 为 true！</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据是否安全推出做不同处理！</span></span><br><span class="line">        <span class="keyword">if</span> (safe) &#123;</span><br><span class="line">            removeAllFutureMessagesLocked();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            removeAllMessagesLocked();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We can assume mPtr != 0 because mQuitting was previously false.</span></span><br><span class="line">        nativeWake(mPtr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法逻辑：</p>
<ul>
<li>设置 mQuitting 为 true；</li>
<li>如果是安全关闭，调用 removeAllFutureMessagesLocked 移除当前时间点以后未分发的消息；</li>
<li>如果是非安全关闭，调用 removeAllMessagesLocked 移除所有的消息；</li>
</ul>
<h1 id="6-remove-Message"><a href="#6-remove-Message" class="headerlink" title="6 remove Message"></a>6 remove Message</h1><p>回顾 Handler。Handler 提供了 remove 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">removeMessages</span><span class="params">(<span class="keyword">int</span> what)</span> </span>&#123;</span><br><span class="line">    mQueue.removeMessages(<span class="keyword">this</span>, what, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终调用了 MessageQueue 的 removeMessages 方法！</p>
<p>MessageQueue 有多个 remove 方法，我们一个一个来看：</p>
<h2 id="6-1-MessageQueue-removeMessages"><a href="#6-1-MessageQueue-removeMessages" class="headerlink" title="6.1 MessageQueue.removeMessages"></a>6.1 MessageQueue.removeMessages</h2><ul>
<li>移除 Messages：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeMessages</span><span class="params">(Handler h, <span class="keyword">int</span> what, Object object)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【1】从头消息开始移除，如果头消息匹配到了。更新头消息指向，并移除 what 对应的消息！</span></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.target == h &amp;&amp; p.what == what</span><br><span class="line">               &amp;&amp; (object == <span class="keyword">null</span> || p.obj == object)) &#123;</span><br><span class="line">            Message n = p.next;</span><br><span class="line">            mMessages = n;</span><br><span class="line">            p.recycleUnchecked(); <span class="comment">// 非安全回收！</span></span><br><span class="line">            p = n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【2】进入这里说明头消息现在已经不用被移除了，然后在非头消息的剩余消息中移除能够匹配的消息！</span></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Message n = p.next;</span><br><span class="line">            <span class="keyword">if</span> (n != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (n.target == h &amp;&amp; n.what == what</span><br><span class="line">                    &amp;&amp; (object == <span class="keyword">null</span> || n.obj == object)) &#123;</span><br><span class="line">                    Message nn = n.next;</span><br><span class="line">                    n.recycleUnchecked(); <span class="comment">// 非安全回收！</span></span><br><span class="line">                    p.next = nn;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            p = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>移除 Runnable：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeMessages</span><span class="params">(Handler h, Runnable r, Object object)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="keyword">null</span> || r == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【1】从头消息开始移除，如果头消息匹配到了。更新头消息，并移除 Runnable 对应的消息！</span></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.target == h &amp;&amp; p.callback == r</span><br><span class="line">               &amp;&amp; (object == <span class="keyword">null</span> || p.obj == object)) &#123;</span><br><span class="line">            Message n = p.next;</span><br><span class="line">            mMessages = n;</span><br><span class="line">            p.recycleUnchecked(); <span class="comment">// 非安全回收！</span></span><br><span class="line">            p = n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【2】进入这里说明头消息现在已经不用被移除了，然后在非头消息的剩余消息中移除能够匹配的消息！</span></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Message n = p.next;</span><br><span class="line">            <span class="keyword">if</span> (n != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (n.target == h &amp;&amp; n.callback == r</span><br><span class="line">                    &amp;&amp; (object == <span class="keyword">null</span> || n.obj == object)) &#123;</span><br><span class="line">                    Message nn = n.next;</span><br><span class="line">                    n.recycleUnchecked(); <span class="comment">// 非安全回收！</span></span><br><span class="line">                    p.next = nn;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            p = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不管是移除 Messages 还是移除 Runnable，流程都是一样的：</p>
<ul>
<li>先从头消息开始进行第一阶段的匹配，如果能够匹配，就移除头消息，并更新链表头！</li>
<li>当头消息无法匹配，那么我们就删除剩下的消息中能够匹配的消息！</li>
</ul>
<h2 id="6-2-MessageQueue-removeCallbacksAndMessages"><a href="#6-2-MessageQueue-removeCallbacksAndMessages" class="headerlink" title="6.2 MessageQueue.removeCallbacksAndMessages"></a>6.2 MessageQueue.removeCallbacksAndMessages</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeCallbacksAndMessages</span><span class="params">(Handler h, Object object)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Remove all messages at front.</span></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.target == h</span><br><span class="line">                &amp;&amp; (object == <span class="keyword">null</span> || p.obj == object)) &#123;</span><br><span class="line">            Message n = p.next;</span><br><span class="line">            mMessages = n;</span><br><span class="line">            p.recycleUnchecked(); <span class="comment">// 非安全回收！</span></span><br><span class="line">            p = n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Remove all messages after front.</span></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Message n = p.next;</span><br><span class="line">            <span class="keyword">if</span> (n != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (n.target == h &amp;&amp; (object == <span class="keyword">null</span> || n.obj == object)) &#123;</span><br><span class="line">                    Message nn = n.next;</span><br><span class="line">                    n.recycleUnchecked(); <span class="comment">// 非安全回收！</span></span><br><span class="line">                    p.next = nn;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            p = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-3-MessageQueue-removeAllMessagesLocked"><a href="#6-3-MessageQueue-removeAllMessagesLocked" class="headerlink" title="6.3 MessageQueue.removeAllMessagesLocked"></a>6.3 MessageQueue.removeAllMessagesLocked</h2><p>移除消息队列中所有的 Message！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeAllMessagesLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Message p = mMessages;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Message n = p.next;</span><br><span class="line">        p.recycleUnchecked(); <span class="comment">// 回收消息！</span></span><br><span class="line">        p = n;</span><br><span class="line">    &#125;</span><br><span class="line">    mMessages = <span class="keyword">null</span>; <span class="comment">// 设置 mMessages 为 null；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法很简单，不多说！</p>
<h2 id="6-4-MessageQueue-removeAllFutureMessagesLocked"><a href="#6-4-MessageQueue-removeAllFutureMessagesLocked" class="headerlink" title="6.4 MessageQueue.removeAllFutureMessagesLocked"></a>6.4 MessageQueue.removeAllFutureMessagesLocked</h2><p>移除消息队列中当前时间下所有未分发的 Message！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeAllFutureMessagesLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 计算当前时间！</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">    Message p = mMessages;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p.when &gt; now) &#123;</span><br><span class="line">            <span class="comment">// 如果消息链表中所有消息都没有分发，那就移除所有消息！</span></span><br><span class="line">            removeAllMessagesLocked();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Message n;</span><br><span class="line">            <span class="comment">// 找到第一个还没到分发时间的消息！</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                n = p.next;</span><br><span class="line">                <span class="keyword">if</span> (n == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (n.when &gt; now) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                p = n;</span><br><span class="line">            &#125;</span><br><span class="line">            p.next = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 移除所有未分发的消息！</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                p = n;</span><br><span class="line">                n = p.next;</span><br><span class="line">                p.recycleUnchecked(); <span class="comment">// 非安全回收！</span></span><br><span class="line">            &#125; <span class="keyword">while</span> (n != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法很简单，不多说！！</p>
<h1 id="7-障栅-Barrier"><a href="#7-障栅-Barrier" class="headerlink" title="7 障栅 Barrier"></a>7 障栅 Barrier</h1><p>我们知道障栅本质上是一个特殊的 Message，其 target 为 null，他能够<strong>拦截同步的消息，放行异步消息</strong>！！</p>
<p>我们关心的是如何向消息队列中插入和移除障栅！！</p>
<h2 id="7-1-MessageQueue-postSyncBarrier"><a href="#7-1-MessageQueue-postSyncBarrier" class="headerlink" title="7.1 MessageQueue.postSyncBarrier"></a>7.1 MessageQueue.postSyncBarrier</h2><p>MessageQueue 提供了 postSyncBarrier 来向消息队列中增加障栅 Barrier!</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">postSyncBarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> postSyncBarrier(SystemClock.uptimeMillis());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">postSyncBarrier</span><span class="params">(<span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 为障栅计算 token，mNextBarrierToken自增！</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> token = mNextBarrierToken++;</span><br><span class="line">        <span class="keyword">final</span> Message msg = Message.obtain(); <span class="comment">// 优先复用 message！</span></span><br><span class="line">        msg.markInUse();</span><br><span class="line">        msg.when = when;</span><br><span class="line">        msg.arg1 = token; <span class="comment">// 设置 msg.arg1 为 token！</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将障栅添加到合适的位置，可能是表头，也可能是中间某个节点！</span></span><br><span class="line">        Message prev = <span class="keyword">null</span>;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        <span class="keyword">if</span> (when != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.when &lt;= when) &#123;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123; <span class="comment">// invariant: p == prev.next</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            prev.next = msg;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 将障珊作为新的表头！</span></span><br><span class="line">            msg.next = p;</span><br><span class="line">            mMessages = msg;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数 when 表示障栅的拦截时间点！</p>
<p>可以看到，当我们插入障栅后，其要么是位于消息队列的头，要么是根据拦截时间 when，将障栅插入到消息队列的合适位置！</p>
<p>这样，障栅就可以拦截其后的所有同步消息了！</p>
<h2 id="7-2-MessageQueue-removeSyncBarrier"><a href="#7-2-MessageQueue-removeSyncBarrier" class="headerlink" title="7.2 MessageQueue.removeSyncBarrier"></a>7.2 MessageQueue.removeSyncBarrier</h2><p>MessageQueue 提供了 removeSyncBarrier 来从消息队列中移除障栅 Barrier：</p>
<p>参数 token 用于识别指定的障珊！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeSyncBarrier</span><span class="params">(<span class="keyword">int</span> token)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        Message prev = <span class="keyword">null</span>;</span><br><span class="line">        Message p = mMessages;</span><br><span class="line">        <span class="comment">// 顺序遍历链表，如果 p.target 不为 null，说明它不是障珊；</span></span><br><span class="line">        <span class="comment">// 如果 p.arg1 != token 说明他不是我们要删除的障珊；</span></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; (p.target != <span class="keyword">null</span> || p.arg1 != token)) &#123;</span><br><span class="line">            prev = p;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123; <span class="comment">// 如果队列中没有障珊，会抛出异常！</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The specified message queue synchronization "</span></span><br><span class="line">                    + <span class="string">" barrier token has not been posted or has already been removed."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> needWake;</span><br><span class="line">        <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// pre 不为 null，说明障栅在消息队列的中间某个节点！</span></span><br><span class="line">            prev.next = p.next;</span><br><span class="line">            needWake = <span class="keyword">false</span>; <span class="comment">// 这种情况不需要唤醒！</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// pre 为 null 说明障栅就是消息队列的头，那么设置新的头节点为下一个 message！</span></span><br><span class="line">            mMessages = p.next;</span><br><span class="line">            </span><br><span class="line">            needWake = mMessages == <span class="keyword">null</span> || mMessages.target != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p.recycleUnchecked(); <span class="comment">// 回收障栅，加入消息池！</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果需要唤醒 native 层队列，并且 java 层队列没有关闭，那就唤醒！</span></span><br><span class="line">        <span class="keyword">if</span> (needWake &amp;&amp; !mQuitting) &#123;</span><br><span class="line">            nativeWake(mPtr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>逻辑很简单，就是遍历消息队列，根据传入的 token，匹配合适的障栅！！</p>
<p>我们为什么要 remove 掉障栅？</p>
<p>道理很简单，<strong>由于障栅是一种特殊的 message，其 target 为 null，所以其不能被分发，意味着如果障栅后面没有异步消息，那么整个队列就会一直阻塞下去！！</strong></p>
<h1 id="8-Native-层分析"><a href="#8-Native-层分析" class="headerlink" title="8 Native 层分析"></a>8 Native 层分析</h1><p>上面分析了 java 层的 MessageQueue 逻辑架构，但我们早已经知道 native 也有个 MessageQueue，java 层的消息队列可通过以下方法和 native 层的 MessageQueue 通信：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">nativeInit</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeDestroy</span><span class="params">(<span class="keyword">long</span> ptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativePollOnce</span><span class="params">(<span class="keyword">long</span> ptr, <span class="keyword">int</span> timeoutMillis)</span></span>; <span class="comment">/*non-static for callbacks*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeWake</span><span class="params">(<span class="keyword">long</span> ptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">nativeIsPolling</span><span class="params">(<span class="keyword">long</span> ptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeSetFileDescriptorEvents</span><span class="params">(<span class="keyword">long</span> ptr, <span class="keyword">int</span> fd, <span class="keyword">int</span> events)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>native 层的 MessageQueue 除了可以让 native 层实现消息通信机制，更重要的是，其能够保证 java 层的不会陷入死循环！！</p>
<p>对应的 native 层方法位于 android/frameworks/base/core/jni/android_os_MessageQueue.cpp 文件中！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> JNINativeMethod gMessageQueueMethods[] = &#123;</span><br><span class="line">    <span class="comment">/* name, signature, funcPtr */</span></span><br><span class="line">    &#123; <span class="string">"nativeInit"</span>, <span class="string">"()J"</span>, (<span class="keyword">void</span>*)android_os_MessageQueue_nativeInit &#125;,</span><br><span class="line">    &#123; <span class="string">"nativeDestroy"</span>, <span class="string">"(J)V"</span>, (<span class="keyword">void</span>*)android_os_MessageQueue_nativeDestroy &#125;,</span><br><span class="line">    &#123; <span class="string">"nativePollOnce"</span>, <span class="string">"(JI)V"</span>, (<span class="keyword">void</span>*)android_os_MessageQueue_nativePollOnce &#125;,</span><br><span class="line">    &#123; <span class="string">"nativeWake"</span>, <span class="string">"(J)V"</span>, (<span class="keyword">void</span>*)android_os_MessageQueue_nativeWake &#125;,</span><br><span class="line">    &#123; <span class="string">"nativeIsPolling"</span>, <span class="string">"(J)Z"</span>, (<span class="keyword">void</span>*)android_os_MessageQueue_nativeIsPolling &#125;,</span><br><span class="line">    &#123; <span class="string">"nativeSetFileDescriptorEvents"</span>, <span class="string">"(JII)V"</span>,</span><br><span class="line">            (<span class="keyword">void</span>*)android_os_MessageQueue_nativeSetFileDescriptorEvents &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">register_android_os_MessageQueue</span><span class="params">(JNIEnv* env)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = RegisterMethodsOrDie(env, <span class="string">"android/os/MessageQueue"</span>, gMessageQueueMethods,</span><br><span class="line">                                   NELEM(gMessageQueueMethods));</span><br><span class="line"></span><br><span class="line">    jclass clazz = FindClassOrDie(env, <span class="string">"android/os/MessageQueue"</span>);</span><br><span class="line">    gMessageQueueClassInfo.mPtr = GetFieldIDOrDie(env, clazz, <span class="string">"mPtr"</span>, <span class="string">"J"</span>);</span><br><span class="line">    gMessageQueueClassInfo.dispatchEvents = GetMethodIDOrDie(env, clazz,</span><br><span class="line">            <span class="string">"dispatchEvents"</span>, <span class="string">"(II)I"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>register_android_os_MessageQueue 用来注册静态方法！</p>
<h2 id="8-1-android-os-MessageQueue-nativeInit"><a href="#8-1-android-os-MessageQueue-nativeInit" class="headerlink" title="8.1 android_os_MessageQueue_nativeInit"></a>8.1 android_os_MessageQueue_nativeInit</h2><p>我们来看一下这个 nativeInit 对应的 native 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">android_os_MessageQueue_nativeInit</span><span class="params">(JNIEnv* env, jclass clazz)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】创建 native 消息队列：NativeMessageQueue！</span></span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = <span class="keyword">new</span> NativeMessageQueue();</span><br><span class="line">    <span class="keyword">if</span> (!nativeMessageQueue) &#123;</span><br><span class="line">        jniThrowRuntimeException(env, <span class="string">"Unable to allocate native queue"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nativeMessageQueue-&gt;incStrong(env);</span><br><span class="line">    <span class="keyword">return</span> reinterpret_cast&lt;jlong&gt;(nativeMessageQueue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里创建了 native 层的消息队列：NativeMessageQueue！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NativeMessageQueue::NativeMessageQueue() :</span><br><span class="line">        mPollEnv(NULL), mPollObj(NULL), mExceptionObj(NULL) &#123;</span><br><span class="line">    mLooper = Looper::getForThread();</span><br><span class="line">    <span class="keyword">if</span> (mLooper == NULL) &#123;</span><br><span class="line">        mLooper = <span class="keyword">new</span> Looper(<span class="keyword">false</span>);</span><br><span class="line">        Looper::setForThread(mLooper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-1-android-os-MessageQueue-nativePollOnce"><a href="#8-1-android-os-MessageQueue-nativePollOnce" class="headerlink" title="8.1 android_os_MessageQueue_nativePollOnce"></a>8.1 android_os_MessageQueue_nativePollOnce</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">android_os_MessageQueue_nativePollOnce</span><span class="params">(JNIEnv* env, jobject obj,</span></span></span><br><span class="line"><span class="function"><span class="params">        jlong ptr, jint timeoutMillis)</span> </span>&#123;</span><br><span class="line">    NativeMessageQueue* nativeMessageQueue = reinterpret_cast&lt;NativeMessageQueue*&gt;(ptr);</span><br><span class="line">    nativeMessageQueue-&gt;pollOnce(env, obj, timeoutMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="9-总结"><a href="#9-总结" class="headerlink" title="9 总结"></a>9 总结</h1><p>下面我们来总结下 MessageQueue 的类图！</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2017/01/27/Handler篇 3 - Looper 源码分析/">Handler篇 3 - Looper 源码分析</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-01-27</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/AndroidFramework源码分析/">AndroidFramework源码分析</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/AndroidFramework源码分析/Handler线程消息机制/">Handler线程消息机制</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Handler线程消息机制/">Handler线程消息机制</a></span><div class="content"><p>基于 Android 7.1.1 源码，分析 Looper 的架构和原理。</p>
<h1 id="1-成员变量"><a href="#1-成员变量" class="headerlink" title="1 成员变量"></a>1 成员变量</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Looper&gt;();</span><br></pre></td></tr></table></figure>
<p>线程本地变量，用于保存每个线程创建出来的 Looper 对象！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Looper sMainLooper;</span><br></pre></td></tr></table></figure>
<p>ui 线程的 Looper 对象！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> MessageQueue mQueue;</span><br></pre></td></tr></table></figure>
<p>消息队列，每一个 Looper 有一个消息队列，Looper 会循环遍历该消息队列，分发消息！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Thread mThread;</span><br></pre></td></tr></table></figure>
<p>当前线程，也就是该 Looper 所属的线程！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Printer mLogging;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> mTraceTag;</span><br></pre></td></tr></table></figure>
<p>和调试监控相关的，我们不过多关注！</p>
<h1 id="2-Looper-prepare"><a href="#2-Looper-prepare" class="headerlink" title="2 Looper.prepare"></a>2 Looper.prepare</h1><p>我们知道，如果要给一个指定的线程创建一个 handler，该线程必须要有一个 Looper，创建 looper 的方法就是 prepare：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    prepare(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123; <span class="comment">// 每个线程只能有一个 Looper！</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed)); <span class="comment">// 将创建的 Looper 加入到线程本地变量中！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法会给当前的线程创建一个 Looper 对象！</p>
<p>注意第二个方法是<strong>私有方法</strong>！</p>
<h2 id="2-1-new-Looper"><a href="#2-1-new-Looper" class="headerlink" title="2.1 new Looper"></a>2.1 new Looper</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed); <span class="comment">// 为该 looper 创建一个消息队列！</span></span><br><span class="line">    mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>quitAllowed 表示该队列是否可以推出！</p>
<h2 id="2-2-Looper-prepareMainLooper"><a href="#2-2-Looper-prepareMainLooper" class="headerlink" title="2.2 Looper.prepareMainLooper"></a>2.2 Looper.prepareMainLooper</h2><p>对于 ui 主线程，Looper 有一个方法方法专门用于创建其对应的 Looper：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepareMainLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    prepare(<span class="keyword">false</span>); <span class="comment">// 调用 prepare 方法，创建 Looper</span></span><br><span class="line">    <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sMainLooper != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The main Looper has already been prepared."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sMainLooper = myLooper(); <span class="comment">// 将 ui 线程的 Looper 保存到 sMainLooper 中！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，ui 线程的 MessageQueue 是不能退出的！</p>
<h3 id="2-2-1-Looper-myLooper"><a href="#2-2-1-Looper-myLooper" class="headerlink" title="2.2.1 Looper.myLooper"></a>2.2.1 Looper.myLooper</h3><p>这里调用了 myLooper 方法，用于返回和当前线程相关联的 Looper 对象！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@Nullable</span> <span class="function">Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sThreadLocal.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法很简单，不多说了！</p>
<h1 id="3-Looper-loop"><a href="#3-Looper-loop" class="headerlink" title="3 Looper.loop"></a>3 Looper.loop</h1><p>当 Looper 创建好后，需要调用 loop 方法，使其进入消息循环中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Looper me = myLooper(); <span class="comment">// 获得当前线程的 Looper 对象，并校验其有效性！</span></span><br><span class="line">    <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> MessageQueue queue = me.mQueue; <span class="comment">// 获得对应的消息队列！</span></span><br><span class="line"></span><br><span class="line">    Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//【1】通过 next 方法返回下一个要分发的 message，next 方法可能会阻塞！</span></span><br><span class="line">        Message msg = queue.next();</span><br><span class="line">        <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果 msg 为 null，说明消息队列正在推出，那就 return，结束消息循环！</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Printer logging = me.mLogging;</span><br><span class="line">        <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">            logging.println(<span class="string">"&gt;&gt;&gt;&gt;&gt; Dispatching to "</span> + msg.target + <span class="string">" "</span> +</span><br><span class="line">                    msg.callback + <span class="string">": "</span> + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> traceTag = me.mTraceTag;</span><br><span class="line">        <span class="keyword">if</span> (traceTag != <span class="number">0</span> &amp;&amp; Trace.isTagEnabled(traceTag)) &#123;</span><br><span class="line">            Trace.traceBegin(traceTag, msg.target.getTraceName(msg));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【2】分发这个 message！</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            msg.target.dispatchMessage(msg);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</span><br><span class="line">                Trace.traceEnd(traceTag);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">            logging.println(<span class="string">"&lt;&lt;&lt;&lt;&lt; Finished to "</span> + msg.target + <span class="string">" "</span> + msg.callback);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> newIdent = Binder.clearCallingIdentity();</span><br><span class="line">        <span class="keyword">if</span> (ident != newIdent) &#123;</span><br><span class="line">            Log.wtf(TAG, <span class="string">"Thread identity changed from 0x"</span></span><br><span class="line">                    + Long.toHexString(ident) + <span class="string">" to 0x"</span></span><br><span class="line">                    + Long.toHexString(newIdent) + <span class="string">" while dispatching to "</span></span><br><span class="line">                    + msg.target.getClass().getName() + <span class="string">" "</span></span><br><span class="line">                    + msg.callback + <span class="string">" what="</span> + msg.what);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        msg.recycleUnchecked(); <span class="comment">// 回收 Message。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实方法流程很简单：</p>
<ul>
<li>获得当前线程的 Looper 对象，如果为 null，那就要抛出异常</li>
<li>获得该 Looper 所有的消息队列</li>
<li>通过 MessageQueue.next 方法，获得下一个要分发的 message！</li>
<li>调用 msg.target.dispatchMessage 方法，分发消息！</li>
<li>回收 Message，我们知道 MessageQueue 中的 Message 可以复用的！</li>
</ul>
<p>注意：</p>
<ul>
<li>queue.next() 方法会从消息队列中取出消息对象 Message，如果 MessageQueue 中没有任何 Message 的话，该方法将会阻塞等待新的消息。</li>
<li>当我们想要退出消息循环的时候，调用 quit 方法，那么 queue.next() 会返回一个 null 的 Message，这样就退出了！</li>
</ul>
<h1 id="4-Looper-quit"><a href="#4-Looper-quit" class="headerlink" title="4 Looper.quit"></a>4 Looper.quit</h1><p>Looper 提供了 quit 方法，用于结束消息循环：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mQueue.quit(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quitSafely</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mQueue.quit(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终都调用了 MessageQueue 的 quit 方法，来结束消息循环！</p>
<p>quit 和 quitSafely 的区别是，quit 方法是不安全的，而 quitSafely 会在停止 Looper 的时候把当前时间点之后的已经达到处理时间点的消息处理完后才停止 Looper！</p>
<h1 id="5-其他方法"><a href="#5-其他方法" class="headerlink" title="5 其他方法"></a>5 其他方法</h1><p>Looper 提供了一些其他的方法：</p>
<ul>
<li>获得主线程的 Looper 对象！</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Looper <span class="title">getMainLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (Looper.class) &#123;</span><br><span class="line">        <span class="keyword">return</span> sMainLooper;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>获得 Looper 对象所在的线程！</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@NonNull</span> <span class="function">Thread <span class="title">getThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mThread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>获得 Looper 对象的消息队列！</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@NonNull</span> <span class="function">MessageQueue <span class="title">getQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mQueue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>判断 Looper 对象是否属于当前线程！<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCurrentThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Thread.currentThread() == mThread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>总体来看，Looper 的实现并不复杂，接下来，我们来看看 MessageQueue！</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2017/01/19/Handler篇 2 - Handler 源码分析/">Handler篇 2 - Handler 源码分析</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-01-19</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/AndroidFramework源码分析/">AndroidFramework源码分析</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/AndroidFramework源码分析/Handler线程消息机制/">Handler线程消息机制</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Handler线程消息机制/">Handler线程消息机制</a></span><div class="content"><p>基于 Android 7.1.1 源码，分析 handler 的架构和原理。</p>
<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言</h1><p>本片博客通过以下几个方面总结 Handler 源码的实现架构！</p>
<h1 id="1-create-Handler"><a href="#1-create-Handler" class="headerlink" title="1 create Handler"></a>1 create Handler</h1><p>Handler 提供了如下的构造器方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//【方法1】默认使用当前的线程的 Looper 对象创建 Handler，如果当前线程的没有 Looper，那就会抛出异常！</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//【方法2】默认使用当前的线程的 Looper 对象创建 Handler，如果当前线程的没有 Looper，那就会抛出异常！</span></span><br><span class="line"><span class="comment">// 同时传入一个 Callback 接口，用于处理消息回调！</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback)</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//【方法3】显示指定一个 Looper 对象，不能为 null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Looper looper)</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//【方法4】可以看成方法 2 和方法 3 的合并，其中 callback 可以为 null！</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Looper looper, Callback callback)</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//【方法5】默认使用当前的线程的 Looper 对象创建 Handler，并且显式指定 handler 是否是异步的！</span></span><br><span class="line"><span class="comment">// handler 默认是同步的，除非显示的指定 async 为 true！</span></span><br><span class="line"><span class="comment">// @hide</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(<span class="keyword">boolean</span> async)</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//【方法6】可以看成方法 2 和方法 5 的合并!!</span></span><br><span class="line"><span class="comment">// @hide</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//【方法7】 可以看成方法 2，方法 3 和方法 5 的合并!!</span></span><br><span class="line"><span class="comment">// @hide</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Looper looper, Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>Handler 默认是同步的，如果我们显式的设置 async 为 true，那么其该 handler 会以异步的方式处理 message 和 runnable！</p>
<p>关于异步的实现，我们后续会分析！</p>
<p>其中，最核心的构造方法是方法 6 和方法 7，其他方法都是调用它们完成初始化的：</p>
<h2 id="1-1-Handler-Callback-boolean"><a href="#1-1-Handler-Callback-boolean" class="headerlink" title="1.1 Handler(Callback, boolean)"></a>1.1 Handler(Callback, boolean)</h2><p>默认使用当前线程的 Looper 对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class="line">        <span class="keyword">final</span> Class&lt;? extends Handler&gt; klass = getClass();</span><br><span class="line">        <span class="keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class="line">                (klass.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">"The following Handler class should be static or leaks might occur: "</span> +</span><br><span class="line">                klass.getCanonicalName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mLooper = Looper.myLooper(); <span class="comment">// 使用当前线程的 Looper 对象！</span></span><br><span class="line">    <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123; <span class="comment">// 如果当前线程没有 Looper </span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">            <span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mQueue = mLooper.mQueue;</span><br><span class="line">    mCallback = callback;</span><br><span class="line">    mAsynchronous = async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-2-Handler-Looper，Callback-boolean"><a href="#1-2-Handler-Looper，Callback-boolean" class="headerlink" title="1.2 Handler(Looper，Callback, boolean)"></a>1.2 Handler(Looper，Callback, boolean)</h2><p>显示指定了 Looper 对象！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Looper looper, Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">    mLooper = looper; </span><br><span class="line">    mQueue = looper.mQueue;</span><br><span class="line">    mCallback = callback;</span><br><span class="line">    mAsynchronous = async;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-2-成员变量"><a href="#1-2-成员变量" class="headerlink" title="1.2 成员变量"></a>1.2 成员变量</h2><p>构造器中出现了 Handler 的主要成员变量，下面解释一下，也便于后续分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Looper mLooper;</span><br></pre></td></tr></table></figure>
<p>Looper 对象;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> MessageQueue mQueue;</span><br></pre></td></tr></table></figure>
<p>消息队列，来自 Looper 对象;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Callback mCallback;</span><br></pre></td></tr></table></figure>
<p>Callback 回调，该回调会被封装成 message；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> mAsynchronous;</span><br></pre></td></tr></table></figure>
<p>该 handler 是否是异步的，默认为 false；</p>
<h1 id="2-Handler-obtainMessage"><a href="#2-Handler-obtainMessage" class="headerlink" title="2 Handler.obtainMessage"></a>2 Handler.obtainMessage</h1><p>Handler 提供了多个 obtainMessage 方法，来复用一个 Message 对象！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Message <span class="title">obtainMessage</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Message <span class="title">obtainMessage</span><span class="params">(<span class="keyword">int</span> what)</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Message <span class="title">obtainMessage</span><span class="params">(<span class="keyword">int</span> what, Object obj)</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Message <span class="title">obtainMessage</span><span class="params">(<span class="keyword">int</span> what, <span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2)</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Message <span class="title">obtainMessage</span><span class="params">(<span class="keyword">int</span> what, <span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2, Object obj)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>Handler 允许我们复用 Message 对象，这样可以避免过多的创建 Message 对象！</p>
<p>Message 有一个静态变量 Message sPool 他是一个消息池链表的头元素，obtainMessage 会从该消息池中复用 Message，并用参数初始化复用的 Message！</p>
<p>obtainMessage 方法最终会调用 Message.obtain 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Message <span class="title">obtainMessage</span><span class="params">(<span class="keyword">int</span> what, <span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Message.obtain(<span class="keyword">this</span>, what, arg1, arg2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于 Message.obtain，我们后面会分析，这里我们只需要知道，复用的时候，会从消息池链表的头元素开始，复用消息！</p>
<h1 id="3-Handler-sendMessage"><a href="#3-Handler-sendMessage" class="headerlink" title="3 Handler.sendMessage"></a>3 Handler.sendMessage</h1><p>Handler 提供了多个 sendMessage 方法，来发送一个 Message 对象！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessage</span><span class="params">(Message msg)</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendEmptyMessage</span><span class="params">(<span class="keyword">int</span> what)</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendEmptyMessageDelayed</span><span class="params">(<span class="keyword">int</span> what, <span class="keyword">long</span> delayMillis)</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendEmptyMessageAtTime</span><span class="params">(<span class="keyword">int</span> what, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(Message msg, <span class="keyword">long</span> delayMillis)</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtFrontOfQueue</span><span class="params">(c msg)</span> </span>&#123;...&#125; <span class="comment">// 发生消息到消息队列的头部</span></span><br></pre></td></tr></table></figure>
<p>通过这些方法我们可以实现立即或者延迟发送消息！</p>
<p>如果指定的是延迟时间，那么会通过 SystemClock.uptimeMillis() + delayMillis 方式计算为绝对时间！</p>
<p>sendMessage 最后调用的是 Handler.enqueueMessage，就是将 Message 插入到消息队列中！！</p>
<h2 id="3-1-Handler-enqueueMessage"><a href="#3-1-Handler-enqueueMessage" class="headerlink" title="3.1 Handler.enqueueMessage"></a>3.1 Handler.enqueueMessage</h2><p>我们来看看 enqueueMessage 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    msg.target = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (mAsynchronous) &#123; <span class="comment">// 如果 Handler 是异步的，那么 Message 也是异步的！</span></span><br><span class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过 MessageQueue.enqueueMessage 方法，将消息压入到消息队列中！</p>
<p>如果 uptimeMillis 为 0 ，会将消息插入到消息队列的头部；如果 uptimeMillis 不为 0 ，会按照 uptimeMillis 将消息插入到消息队列的指定位置；</p>
<h1 id="4-Handler-post"><a href="#4-Handler-post" class="headerlink" title="4 Handler.post"></a>4 Handler.post</h1><p>Handler 除了可以发送消息，进行线程间通信，还可以执行指定的任务 Runnable，Handler 提供了多个 post 方法供我们选择：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable r)</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">postAtTime</span><span class="params">(Runnable r, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">postAtTime</span><span class="params">(Runnable r, Object token, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">postDelayed</span><span class="params">(Runnable r, <span class="keyword">long</span> delayMillis)</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">postAtFrontOfQueue</span><span class="params">(Runnable r)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>通过这些方法我们可以实现立即或者延迟执行任务！</p>
<p>Runnable 的执行很有意思：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable r)</span></span>&#123;</span><br><span class="line">   <span class="keyword">return</span> sendMessageDelayed(getPostMessage(r), <span class="number">0</span>); <span class="comment">// 将 Runnable 封装为 Message！！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们去看看 getPostMessage() 方法：</p>
<h2 id="4-1-Handler-getPostMessage"><a href="#4-1-Handler-getPostMessage" class="headerlink" title="4.1 Handler.getPostMessage"></a>4.1 Handler.getPostMessage</h2><p>getPostMessage 用于将 Runnable 封装为 Message！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title">getPostMessage</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">    Message m = Message.obtain();</span><br><span class="line">    m.callback = r;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title">getPostMessage</span><span class="params">(Runnable r, Object token)</span> </span>&#123;</span><br><span class="line">    Message m = Message.obtain();</span><br><span class="line">    m.obj = token;</span><br><span class="line">    m.callback = r; <span class="comment">// 将 Runnable 保存到 Message 的属性中！</span></span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优先复用消息池中的消息！</p>
<h1 id="5-Handler-dispatchMessage"><a href="#5-Handler-dispatchMessage" class="headerlink" title="5 Handler.dispatchMessage"></a>5 Handler.dispatchMessage</h1><p>回顾 Loop.loop() 方法，当 queue.next() 能够返回一个可以分发的 Message 后，会调用下面的逻辑，处理消息！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    msg.target.dispatchMessage(msg);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</span><br><span class="line">        Trace.traceEnd(traceTag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 msg.target 就是目标 Handler：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123; <span class="comment">// 处理 Runnbale</span></span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 处理 Message</span></span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123; <span class="comment">// 如果设置了 Callback，就通过 Callback 处理消息！</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handleMessage(msg); <span class="comment">// 默认使用 handler 的方法处理消息！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 Runable 来说，虽然其被封装为了 Message，但是由于其 what 的特殊性，无法按照一般的 Message 的去处理，</p>
<h2 id="5-1-Handler-handleCallback"><a href="#5-1-Handler-handleCallback" class="headerlink" title="5.1 Handler.handleCallback"></a>5.1 Handler.handleCallback</h2><p>对于 Runable，通过 handleCallback 方法处理，该方法会调用 Runnable.run() 方法来执行任务！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleCallback</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">    message.callback.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不多说了！</p>
<h2 id="5-2-Callback-handleMessage"><a href="#5-2-Callback-handleMessage" class="headerlink" title="5.2 Callback.handleMessage"></a>5.2 Callback.handleMessage</h2><p>对于 Message，如果我们指定了回调接口 Callback，那就通过 Callback 处理 Message：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callback</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>mCallback 为 Handler 的成员变量，需要显式指定！</p>
<p>Callback 是 Handler 的内部接口！</p>
<h2 id="5-3-Handler-handleMessage"><a href="#5-3-Handler-handleMessage" class="headerlink" title="5.3 Handler.handleMessage"></a>5.3 Handler.handleMessage</h2><p>对于 Message，默认使用 Handler 的 handleMessage 来处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们需要复写该方法，实现自己的逻辑！！</p>
<h1 id="6-handler-removeMessages"><a href="#6-handler-removeMessages" class="headerlink" title="6 handler.removeMessages"></a>6 handler.removeMessages</h1><p>同时 Handler 也提供了移除消息的操作；<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">removeMessages</span><span class="params">(<span class="keyword">int</span> what)</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">removeMessages</span><span class="params">(<span class="keyword">int</span> what, Object object)</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">removeCallbacksAndMessages</span><span class="params">(Object token)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure></p>
<p>最终调用的是 MessageQueue 的 remove 方法;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mQueue.removeMessages(<span class="keyword">this</span>, what, object);</span><br><span class="line">mQueue.removeCallbacksAndMessages(<span class="keyword">this</span>, token);</span><br></pre></td></tr></table></figure>
<p>MessageQueue 的 remove 操作的原理很简单，根据输入的参数，进行匹配即可！！</p>
<h1 id="7-跨进程通信"><a href="#7-跨进程通信" class="headerlink" title="7 跨进程通信"></a>7 跨进程通信</h1><p>Handler 也可以用于跨进程通信：Messenger</p>
<p>Handler 有一个变量 IMessenger mMessenger 用于保存通过 Messenger 跨进程通信是服务端的桩对象！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> IMessenger <span class="title">getIMessenger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mQueue) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mMessenger != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> mMessenger;</span><br><span class="line">        &#125;</span><br><span class="line">        mMessenger = <span class="keyword">new</span> MessengerImpl(); <span class="comment">// 创建桩对象</span></span><br><span class="line">        <span class="keyword">return</span> mMessenger;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Messenger 信使本质上实现了 Aidl 模板，下面是服务端桩的实现！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MessengerImpl</span> <span class="keyword">extends</span> <span class="title">IMessenger</span>.<span class="title">Stub</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        msg.sendingUid = Binder.getCallingUid(); <span class="comment">// 因为会跨进程通信，所以会设置 msg.sendingUid 为当前进程的 uid</span></span><br><span class="line">        Handler.<span class="keyword">this</span>.sendMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跨进程的分析会在单独的文章中，这里不再过多的介绍！！</p>
<h1 id="8-其他方法"><a href="#8-其他方法" class="headerlink" title="8 其他方法"></a>8 其他方法</h1><ul>
<li>判断消息队列中是否有指定的消息！</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasMessages</span><span class="params">(<span class="keyword">int</span> what, Object object)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mQueue.hasMessages(<span class="keyword">this</span>, what, object);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasCallbacks</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mQueue.hasMessages(<span class="keyword">this</span>, r, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2017/01/13/Handler篇 1 - Handler 初识/">Handler篇 1 - Handler 初识</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-01-13</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/AndroidFramework源码分析/">AndroidFramework源码分析</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/AndroidFramework源码分析/Handler线程消息机制/">Handler线程消息机制</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Handler线程消息机制/">Handler线程消息机制</a></span><div class="content"><p>基于 Android 7.1.1 源码，分析 handler 的架构和原理。</p>
<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言</h1><p>Android 中有 2 中常见的通信方式，进程间的通信使用 Binder，而线程间的通信则使用 Handler，该系列文章就来总结下和 Handler 相关的知识点！</p>
<h1 id="1-创建-Handler"><a href="#1-创建-Handler" class="headerlink" title="1 创建 Handler"></a>1 创建 Handler</h1><p>我们知道，每一个 Handler 都要和一个 Thread 的 Looper 对象相关联，一个线程可以有多个 Handler，下面来看看  Handler 的创建！</p>
<h2 id="1-1-主线程的-Handler"><a href="#1-1-主线程的-Handler" class="headerlink" title="1.1 主线程的 Handler"></a>1.1 主线程的 Handler</h2><p>通常，我们可以这样创建一个 Handler：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Handler handler = <span class="keyword">new</span> Handler();</span><br></pre></td></tr></table></figure>
<p>这种创建方式，默认会将 Handler 和当前线程的 Looper 对象相关联，这个我们后续分析！</p>
<p>当然也可以显式的传入 Looper 对象！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Handler handler = <span class="keyword">new</span> Handler(Looper.myLooper());</span><br><span class="line">Handler handler = <span class="keyword">new</span> Handler(Looper.getMainLooper());</span><br></pre></td></tr></table></figure>
<p>这里涉及到几个 Looper 的几个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Looper.myLooper() <span class="comment">// 当前线程的 Looper 对象！</span></span><br><span class="line">Looper.getMainLooper() <span class="comment">// 主线程的 Looper 对象！</span></span><br></pre></td></tr></table></figure>
<p>对于 Looper 我们后续分析；</p>
<h2 id="1-2-子线程的-Handler"><a href="#1-2-子线程的-Handler" class="headerlink" title="1.2 子线程的 Handler"></a>1.2 子线程的 Handler</h2><p>在 Ui 线程中直接创建 Handler 是没有问题的，因为 Ui 线程默认会创建 Looper 对象，对于子线程，默认是不会有 Looper 对象，直接创建是会报错的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">E AndroidRuntime: FATAL EXCEPTION: AsyncTask #1</span><br><span class="line">E AndroidRuntime: Process: com.coolqi.papapa:ui, PID: <span class="number">27199</span></span><br><span class="line">E AndroidRuntime: java.lang.RuntimeException: <span class="function">An error occurred <span class="keyword">while</span> executing <span class="title">doInBackground</span><span class="params">()</span></span></span><br><span class="line"><span class="function">E AndroidRuntime:        at android.os.AsyncTask$3.<span class="title">done</span><span class="params">(AsyncTask.java:<span class="number">353</span>)</span></span></span><br><span class="line"><span class="function">E AndroidRuntime:        at java.util.concurrent.FutureTask.<span class="title">finishCompletion</span><span class="params">(FutureTask.java:<span class="number">383</span>)</span></span></span><br><span class="line"><span class="function">E AndroidRuntime:        at java.util.concurrent.FutureTask.<span class="title">setException</span><span class="params">(FutureTask.java:<span class="number">252</span>)</span></span></span><br><span class="line"><span class="function">E AndroidRuntime:        at java.util.concurrent.FutureTask.<span class="title">run</span><span class="params">(FutureTask.java:<span class="number">271</span>)</span></span></span><br><span class="line"><span class="function">E AndroidRuntime:        at android.os.AsyncTask$SerialExecutor$1.<span class="title">run</span><span class="params">(AsyncTask.java:<span class="number">245</span>)</span></span></span><br><span class="line"><span class="function">E AndroidRuntime:        at java.util.concurrent.ThreadPoolExecutor.<span class="title">runWorker</span><span class="params">(ThreadPoolExecutor.java:<span class="number">1162</span>)</span></span></span><br><span class="line"><span class="function">E AndroidRuntime:        at java.util.concurrent.ThreadPoolExecutor$Worker.<span class="title">run</span><span class="params">(ThreadPoolExecutor.java:<span class="number">636</span>)</span></span></span><br><span class="line"><span class="function">E AndroidRuntime:        at java.lang.Thread.<span class="title">run</span><span class="params">(Thread.java:<span class="number">764</span>)</span></span></span><br><span class="line"><span class="function">E AndroidRuntime: Caused by: java.lang.RuntimeException: Can't create handler inside thread that has not called Looper.<span class="title">prepare</span><span class="params">()</span></span></span><br><span class="line"><span class="function">E AndroidRuntime:        at android.os.Handler.&lt;init&gt;<span class="params">(Handler.java:<span class="number">204</span>)</span></span></span><br><span class="line"><span class="function">E AndroidRuntime:        at android.os.Handler.&lt;init&gt;<span class="params">(Handler.java:<span class="number">118</span>)</span></span></span><br><span class="line"><span class="function">E AndroidRuntime:        at com.coolqi.papapa.f.<span class="title">doInBackground</span><span class="params">(EntryActivity.java:<span class="number">2368</span>)</span></span></span><br><span class="line"><span class="function">E AndroidRuntime:        at android.os.AsyncTask$2.<span class="title">call</span><span class="params">(AsyncTask.java:<span class="number">333</span>)</span></span></span><br><span class="line"><span class="function">E AndroidRuntime:        at java.util.concurrent.FutureTask.<span class="title">run</span><span class="params">(FutureTask.java:<span class="number">266</span>)</span></span></span><br><span class="line"><span class="function">E AndroidRuntime:        ... 4 more</span></span><br></pre></td></tr></table></figure>
<p>我们必须在创建之前，显式的调用 Looper.prepare() 方法，为了能使 Handler 正常工作，创建完 Handler 后要 Looper.loop() 启动消息循环！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Looper.prepare();</span><br><span class="line">    <span class="keyword">new</span> Handler(Looper.myLooper());</span><br><span class="line">    Looper.loop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>
<p>那么，我们可以不用调用 Looper.prepare() 吗？</p>
<p>每次都调用，很麻烦，实际上是可以的，系统已经给我们内置了一个 HandlerThread，HandlerThread 和 Ui 线程一样，也会默认创建一个 Looper 对象！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HandlerThread mWorkThread =</span><br><span class="line">            <span class="keyword">new</span> HandlerThread(<span class="string">"handler"</span>, android.os.Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">mWorkThread.start();</span><br><span class="line">Handler mHandler = <span class="keyword">new</span> Handler(mWorkThread.getLooper());</span><br></pre></td></tr></table></figure>
<p>到这里，关于 Handler 的创建，就讲这么多！</p>
<h1 id="2-使用-Handler"><a href="#2-使用-Handler" class="headerlink" title="2 使用 Handler"></a>2 使用 Handler</h1><p>Handler 的主要用途有 2 个：</p>
<ul>
<li>进行线程间通信，能在其他线程中执行指定操作，比如一些异步，或者耗时的操作！</li>
<li>能够指定在某个时间点执行一些任务！</li>
</ul>
<p>使用的方式很简单：</p>
<ul>
<li>send message</li>
<li>post runnable</li>
</ul>
<p>Handler 本质上是作为线程的消息队列的管理者，不管是发送消息，还是执行任务，都其实是将其添加到队列中依次处理！</p>
<h2 id="2-1-send-messsage"><a href="#2-1-send-messsage" class="headerlink" title="2.1 send messsage"></a>2.1 send messsage</h2><p>Handler 和消息相关的方法有很多，这我们只看一些常见的：</p>
<ul>
<li><strong>发送消息</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> MSG_FIRST = <span class="number">1001</span>;</span><br><span class="line">handler.sendEmptyMessage(MSG_FIRST);</span><br></pre></td></tr></table></figure>
<p>这是发送一个空消息！</p>
<ul>
<li><strong>延迟发送消息</strong>：</li>
</ul>
<p>我们也可以延迟发送消息：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> MSG_FIRST = <span class="number">1001</span>;</span><br><span class="line">handler.sendMessageDelayed(MSG_FIRST, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p><strong>指定某个时刻发送消息</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> MSG_FIRST = <span class="number">1001</span>;</span><br><span class="line">handler.sendEmptyMessageAtTime(MSG_FIRST， System.currentTimeMillis() + <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>发送非空消息</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> MSG_FIRST = <span class="number">1001</span>;</span><br><span class="line">message.what = MSG_FIRST;</span><br><span class="line">Message message = <span class="keyword">new</span> Message();</span><br><span class="line">handler.sendMessage(message)</span><br><span class="line"><span class="comment">// handler.sendMessageDelayed(message, 2000)</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>用法和发送空消息很类似，可以立刻发送，也可以延迟发送！</p>
<p>对于非空的消息 Message，我们可以携带一些数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bundle.putFloat(<span class="string">"cat"</span>, <span class="number">0.11f</span>);</span><br><span class="line">message.setData(bundle);</span><br></pre></td></tr></table></figure>
<p>对于 Bundle，这里就不多说了，以上是基本的用法！</p>
<h2 id="2-2-post-runnable"><a href="#2-2-post-runnable" class="headerlink" title="2.2 post runnable"></a>2.2 post runnable</h2><p>post 操作其实本质上是将 Runnable 转化为了 message 和 callback，并不会指定消息的 what 属性，因为他的处理方式不同！</p>
<ul>
<li><strong>执行任务</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">handler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do something！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>延迟执行任务</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">handler.postDelayed(...);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>延迟执行任务</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">handler.postDelayed(Runnable r, <span class="keyword">long</span> delayMillis)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2-3-handle-message-runnable"><a href="#2-3-handle-message-runnable" class="headerlink" title="2.3 handle message/runnable"></a>2.3 handle message/runnable</h2><p>接下来，看看如何处理 Message 和 runnable：</p>
<p>处理 message，需要我们实现 handleMessage，在内部来根据 msg.what 来分别对 msg 进行处理！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>处理 runnable 则不同，runnable 不需要我们像 message 那样处理，系统会自动调用下面的方法来帮我们执行 runnable：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleCallback</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">    message.callback.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-线程间通信的实现"><a href="#3-线程间通信的实现" class="headerlink" title="3 线程间通信的实现"></a>3 线程间通信的实现</h1><p>实现线程间通信的方法很简单，当前线程持有其他线程的 Handler，然后向其发送 message 即可！</p>
<p>关于 Handler 的简单用法，到这里就分析结束了，后面会继续分析其源码的实现！</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2017/01/03/UsageStats 第 1 篇 - UsageStatsService 的启动/">UsageStats 第 1 篇 - UsageStatsService 的启动</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-01-03</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/AndroidFramework源码分析/">AndroidFramework源码分析</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/AndroidFramework源码分析/UsageStats使用状态管理/">UsageStats使用状态管理</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/UsageStats使用状态管理/">UsageStats使用状态管理</a></span><div class="content"><p>[toc]</p>
<p>基于 Android7.1.1 源码分析 UsageStatsService 的架构和原理！</p>
<h1 id="0-综述"><a href="#0-综述" class="headerlink" title="0 综述"></a>0 综述</h1><p>启动 UsageStatsService 服务，是从 SystemServer.startCoreServices 开始！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startCoreServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mSystemServiceManager.startService(BatteryService.class);</span><br><span class="line"></span><br><span class="line">    mSystemServiceManager.startService(UsageStatsService.class);</span><br><span class="line">    mActivityManagerService.setUsageStatsManager(</span><br><span class="line">            LocalServices.getService(UsageStatsManagerInternal.class));</span><br><span class="line"></span><br><span class="line">    mWebViewUpdateService = mSystemServiceManager.startService(WebViewUpdateService.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1-new-UsageStatsService"><a href="#1-new-UsageStatsService" class="headerlink" title="1 new UsageStatsService"></a>1 new UsageStatsService</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UsageStatsService</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>UsageStatsService 的构造器很简单，没有过多的数据！</p>
<h1 id="2-UsageStatsS-onStart"><a href="#2-UsageStatsS-onStart" class="headerlink" title="2 UsageStatsS.onStart"></a>2 UsageStatsS.onStart</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】获得一些重要的服务管理对象！</span></span><br><span class="line">    mAppOps = (AppOpsManager) getContext().getSystemService(Context.APP_OPS_SERVICE);</span><br><span class="line">    mUserManager = (UserManager) getContext().getSystemService(Context.USER_SERVICE);</span><br><span class="line">    mPackageManager = getContext().getPackageManager();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【*2.1】创建 H 消息处理 Handler！</span></span><br><span class="line">    mHandler = <span class="keyword">new</span> H(BackgroundThread.get().getLooper());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】创建数据目录</span></span><br><span class="line">    File systemDataDir = <span class="keyword">new</span> File(Environment.getDataDirectory(), <span class="string">"system"</span>);</span><br><span class="line">    mUsageStatsDir = <span class="keyword">new</span> File(systemDataDir, <span class="string">"usagestats"</span>);</span><br><span class="line">    mUsageStatsDir.mkdirs();</span><br><span class="line">    <span class="keyword">if</span> (!mUsageStatsDir.exists()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Usage stats directory does not exist: "</span></span><br><span class="line">                + mUsageStatsDir.getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【*2.2】动态注册一个广播接收者：UserActionsReceiver</span></span><br><span class="line">    <span class="comment">// 监听 Intent.ACTION_USER_STARTED 和 Intent.ACTION_USER_REMOVED 广播；</span></span><br><span class="line">    IntentFilter filter = <span class="keyword">new</span> IntentFilter(Intent.ACTION_USER_REMOVED);</span><br><span class="line">    filter.addAction(Intent.ACTION_USER_STARTED);</span><br><span class="line">    getContext().registerReceiverAsUser(<span class="keyword">new</span> UserActionsReceiver(), UserHandle.ALL, filter,</span><br><span class="line">            <span class="keyword">null</span>, mHandler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2.3】动态注册一个广播接收者：PackageReceiver</span></span><br><span class="line">    <span class="comment">// 监听 Intent.ACTION_PACKAGE_ADDED，Intent.ACTION_PACKAGE_REMOVED 和 Intent.ACTION_PACKAGE_CHANGED 广播；</span></span><br><span class="line">    IntentFilter packageFilter = <span class="keyword">new</span> IntentFilter();</span><br><span class="line">    packageFilter.addAction(Intent.ACTION_PACKAGE_ADDED);</span><br><span class="line">    packageFilter.addAction(Intent.ACTION_PACKAGE_CHANGED);</span><br><span class="line">    packageFilter.addAction(Intent.ACTION_PACKAGE_REMOVED);</span><br><span class="line">    packageFilter.addDataScheme(<span class="string">"package"</span>);</span><br><span class="line"></span><br><span class="line">    getContext().registerReceiverAsUser(<span class="keyword">new</span> PackageReceiver(), UserHandle.ALL, packageFilter,</span><br><span class="line">            <span class="keyword">null</span>, mHandler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【*2.4】通过系统属性 config_enableAutoPowerModes 值来判断是否支持 app idle，注意 doze 模式也是通过这个值判断的</span></span><br><span class="line">    <span class="comment">// 如果支持，创建一个动态注册的接收者：DeviceStateReceiver，用于接收 ACTION_BATTERY_CHANGED</span></span><br><span class="line">    <span class="comment">// ACTION_DISCHARGING，ACTION_DEVICE_IDLE_MODE_CHANGED（doze 模式的广播），监听设备状态！</span></span><br><span class="line">    mAppIdleEnabled = getContext().getResources().getBoolean(</span><br><span class="line">            com.android.internal.R.bool.config_enableAutoPowerModes);</span><br><span class="line">    <span class="keyword">if</span> (mAppIdleEnabled) &#123;</span><br><span class="line">        IntentFilter deviceStates = <span class="keyword">new</span> IntentFilter(Intent.ACTION_BATTERY_CHANGED);</span><br><span class="line">        deviceStates.addAction(BatteryManager.ACTION_DISCHARGING);</span><br><span class="line">        deviceStates.addAction(PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED);</span><br><span class="line">        getContext().registerReceiver(<span class="keyword">new</span> DeviceStateReceiver(), deviceStates);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="comment">//【*2.5】清楚被移除的用户信息！</span></span><br><span class="line">        cleanUpRemovedUsersLocked();</span><br><span class="line">        <span class="comment">//【*2.6】创建一个 AppIdleHistory 对象，用于加载和保存 app idle 的历史信息！</span></span><br><span class="line">        mAppIdleHistory = <span class="keyword">new</span> AppIdleHistory(SystemClock.elapsedRealtime());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【3】记录此时的系统时间到 mSystemTimeSnapshot，距离开始的时间间隔到 mRealTimeSnapshot</span></span><br><span class="line">    <span class="comment">// 后续时间检查时会用到！</span></span><br><span class="line">    mRealTimeSnapshot = SystemClock.elapsedRealtime();</span><br><span class="line">    mSystemTimeSnapshot = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【*2.7】注册 LocalService 服务对象，方便进程内部通信</span></span><br><span class="line">    <span class="comment">// 同时将自身注册到 ServiceManager 中，用于跨进程通信！</span></span><br><span class="line">    publishLocalService(UsageStatsManagerInternal.class, <span class="keyword">new</span> LocalService());</span><br><span class="line">    publishBinderService(Context.USAGE_STATS_SERVICE, <span class="keyword">new</span> BinderService());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续分析;</p>
<h2 id="2-1-new-H"><a href="#2-1-new-H" class="headerlink" title="2.1 new H"></a>2.1 new H</h2><p>创建了一个 Handler 对，处理 UsageStatsService 中的一些重要的消息，下面我们先开看看有哪些消息！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">H</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">H</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(looper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="keyword">case</span> MSG_REPORT_EVENT: <span class="comment">//【1】处理其他进程传递的 UsageEvents；</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MSG_FLUSH_TO_DISK: <span class="comment">//【2】处理其他进程传递的 UsageEvents 时间；</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MSG_REMOVE_USER: <span class="comment">//【3】移除某个 user；</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MSG_INFORM_LISTENERS: <span class="comment">//【4】</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MSG_FORCE_IDLE_STATE: <span class="comment">//【5】设置应用进入 idle 状态；</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MSG_CHECK_IDLE_STATES:  <span class="comment">//【6】每隔一段时间检查 idle 状态；</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MSG_ONE_TIME_CHECK_IDLE_STATES: <span class="comment">//【7】只检查一次 idle 状态；</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MSG_CHECK_PAROLE_TIMEOUT: <span class="comment">//【8】</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MSG_PAROLE_END_TIMEOUT: <span class="comment">//【9】</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MSG_REPORT_CONTENT_PROVIDER_USAGE: <span class="comment">//【10】记录 content provider 的使用；</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MSG_PAROLE_STATE_CHANGED: <span class="comment">//【11】充电状态变化；</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在启动的过程中也会发送一些 MSG 给 H 进行处理，对于消息的处理，我们放在第四节分析！</p>
<h2 id="2-2-new-UserActionsReceiver-监听用户状态"><a href="#2-2-new-UserActionsReceiver-监听用户状态" class="headerlink" title="2.2 new UserActionsReceiver - 监听用户状态"></a>2.2 new UserActionsReceiver - 监听用户状态</h2><p>UserActionsReceiver 接收者用于监听 User 相关的广播！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">UserActionsReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> userId = intent.getIntExtra(Intent.EXTRA_USER_HANDLE, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">final</span> String action = intent.getAction();</span><br><span class="line">        <span class="keyword">if</span> (Intent.ACTION_USER_REMOVED.equals(action)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (userId &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//【1】如果是用户被移除的广播，发送 MSG_REMOVE_USER 消息给 H！</span></span><br><span class="line">                mHandler.obtainMessage(MSG_REMOVE_USER, userId, <span class="number">0</span>).sendToTarget();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Intent.ACTION_USER_STARTED.equals(action)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (userId &gt;=<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//【*2.2.1】如果是用户被启动的广播，调用 postCheckIdleStates 方法，检查 idle 状态信息！</span></span><br><span class="line">                postCheckIdleStates(userId);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-2-1-UsageStatsService-postCheckIdleStates"><a href="#2-2-1-UsageStatsService-postCheckIdleStates" class="headerlink" title="2.2.1 UsageStatsService.postCheckIdleStates"></a>2.2.1 UsageStatsService.postCheckIdleStates</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postCheckIdleStates</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    mHandler.sendMessage(mHandler.obtainMessage(MSG_CHECK_IDLE_STATES, userId, <span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是用户被启动的广播，调用 postCheckIdleStates 方法，发送 MSG_CHECK_IDLE_STATES 消息给 H，检查 idle 状态信息！</p>
<h2 id="2-3-new-PackageReceiver-监听包状态"><a href="#2-3-new-PackageReceiver-监听包状态" class="headerlink" title="2.3 new PackageReceiver - 监听包状态"></a>2.3 new PackageReceiver - 监听包状态</h2><p>PackageReceiver 接收者用于监听 package 相关的广播！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">PackageReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String action = intent.getAction();</span><br><span class="line">        <span class="keyword">if</span> (Intent.ACTION_PACKAGE_ADDED.equals(action)</span><br><span class="line">                || Intent.ACTION_PACKAGE_CHANGED.equals(action)) &#123;</span><br><span class="line">            <span class="comment">//【*2.3.1】清除运营商特权应用程序列表！</span></span><br><span class="line">            clearCarrierPrivilegedApps();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((Intent.ACTION_PACKAGE_REMOVED.equals(action) ||</span><br><span class="line">                Intent.ACTION_PACKAGE_ADDED.equals(action))</span><br><span class="line">                &amp;&amp; !intent.getBooleanExtra(Intent.EXTRA_REPLACING, <span class="keyword">false</span>)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【*2.3.2】清楚 package 的 idle 状态</span></span><br><span class="line">            clearAppIdleForPackage(intent.getData().getSchemeSpecificPart(),</span><br><span class="line">                    getSendingUserId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果接收到的广播是：Intent.ACTION_PACKAGE_ADDED 或者 Intent.ACTION_PACKAGE_CHANGED，那就调用 clearCarrierPrivilegedApps 方法，清除运营商特权应用程序列表了；</p>
<p>如果接收到的广播是：Intent.ACTION_PACKAGE_REMOVED(移除应用) 或者 Intent.ACTION_PACKAGE_ADDED，且 Intent.EXTRA_REPLACING 为 false  (新安装的应用)，那就会清楚 package 的 idle 状态！</p>
<h3 id="2-3-1-UsageStatsS-clearCarrierPrivilegedApps"><a href="#2-3-1-UsageStatsS-clearCarrierPrivilegedApps" class="headerlink" title="2.3.1 UsageStatsS.clearCarrierPrivilegedApps"></a>2.3.1 UsageStatsS.clearCarrierPrivilegedApps</h3><p>清除运营商特权应用程序列表!<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearCarrierPrivilegedApps</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">        Slog.i(TAG, <span class="string">"Clearing carrier privileged apps list"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        mHaveCarrierPrivilegedApps = <span class="keyword">false</span>;</span><br><span class="line">        mCarrierPrivilegedApps = <span class="keyword">null</span>; <span class="comment">// Need to be refetched.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里涉及到 2 个变量：</p>
<ul>
<li>mHaveCarrierPrivilegedApps 表示是否持有运营商特权应用程序；</li>
<li>mCarrierPrivilegedApps 是一个 list，保存了运营商特权应用程序；</li>
</ul>
<p>当然了，有删除也就有添加的方法 fetchCarrierPrivilegedAppsLocked：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fetchCarrierPrivilegedAppsLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用了 TelephonyManager 的方法获得运营商特权应用程序列表！</span></span><br><span class="line">    <span class="comment">// 同时设置 mHaveCarrierPrivilegedApps 为 true！</span></span><br><span class="line">    TelephonyManager telephonyManager =</span><br><span class="line">            getContext().getSystemService(TelephonyManager.class);</span><br><span class="line">    mCarrierPrivilegedApps = telephonyManager.getPackagesWithCarrierPrivileges();</span><br><span class="line">    mHaveCarrierPrivilegedApps = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">        Slog.d(TAG, <span class="string">"apps with carrier privilege "</span> + mCarrierPrivilegedApps);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至于运营商特权应用程序列表相关内容，我们后续在看！</p>
<h3 id="2-3-2-UsageStatsS-clearAppIdleForPackage"><a href="#2-3-2-UsageStatsS-clearAppIdleForPackage" class="headerlink" title="2.3.2 UsageStatsS.clearAppIdleForPackage"></a>2.3.2 UsageStatsS.clearAppIdleForPackage</h3><p>清楚 package 的 idle 状态：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearAppIdleForPackage</span><span class="params">(String packageName, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="comment">//【2.3.2.1】调用 AppIdleHistory.clearUsageLocked 方法！</span></span><br><span class="line">        mAppIdleHistory.clearUsageLocked(packageName, userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，调用的是 AppIdleHistory.clearUsageLocked 方法！</p>
<h4 id="2-3-2-1-AppIdleHistory-clearUsageLocked"><a href="#2-3-2-1-AppIdleHistory-clearUsageLocked" class="headerlink" title="2.3.2.1 AppIdleHistory.clearUsageLocked"></a>2.3.2.1 AppIdleHistory.clearUsageLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearUsageLocked</span><span class="params">(String packageName, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【2.3.2.2】获得指定 userId 下的所有应用的历史信息，然后从中移除 packageName 的信息！</span></span><br><span class="line">    ArrayMap&lt;String, PackageHistory&gt; userHistory = getUserHistoryLocked(userId);</span><br><span class="line">    userHistory.remove(packageName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-3-2-2-AppIdleHistory-getUserHistoryLocked"><a href="#2-3-2-2-AppIdleHistory-getUserHistoryLocked" class="headerlink" title="2.3.2.2 AppIdleHistory.getUserHistoryLocked"></a>2.3.2.2 AppIdleHistory.getUserHistoryLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ArrayMap&lt;String, PackageHistory&gt; <span class="title">getUserHistoryLocked</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】从 mIdleHistory 中查找 userId 的数据，如果 userHistory 为 null。就从本地数据恢复！</span></span><br><span class="line">    ArrayMap&lt;String, PackageHistory&gt; userHistory = mIdleHistory.get(userId);</span><br><span class="line">    <span class="keyword">if</span> (userHistory == <span class="keyword">null</span>) &#123;</span><br><span class="line">        userHistory = <span class="keyword">new</span> ArrayMap&lt;&gt;();</span><br><span class="line">        mIdleHistory.put(userId, userHistory);</span><br><span class="line">        <span class="comment">//【2.3.2.3】尝试从本地持久化文件中读取数据；</span></span><br><span class="line">        readAppIdleTimesLocked(userId, userHistory);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【2】返回！</span></span><br><span class="line">    <span class="keyword">return</span> userHistory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AppIdleHistory 内部有一个 mIdleHistory 集合，用于保存每个 userId 下的所有 package 的空闲历史信息！</p>
<h4 id="2-3-2-3-AppIdleHistory-readAppIdleTimesLocked"><a href="#2-3-2-3-AppIdleHistory-readAppIdleTimesLocked" class="headerlink" title="2.3.2.3 AppIdleHistory.readAppIdleTimesLocked"></a>2.3.2.3 AppIdleHistory.readAppIdleTimesLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readAppIdleTimesLocked</span><span class="params">(<span class="keyword">int</span> userId, ArrayMap&lt;String, PackageHistory&gt; userHistory)</span> </span>&#123;</span><br><span class="line">    FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//【1】准备读取 /data/system/users/&lt;userId&gt;/app_idle_stats.xml 文件</span></span><br><span class="line">        AtomicFile appIdleFile = <span class="keyword">new</span> AtomicFile(getUserFile(userId));</span><br><span class="line">        fis = appIdleFile.openRead();</span><br><span class="line">        XmlPullParser parser = Xml.newPullParser();</span><br><span class="line">        parser.setInput(fis, StandardCharsets.UTF_8.name());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> type;</span><br><span class="line">        <span class="keyword">while</span> ((type = parser.next()) != XmlPullParser.START_TAG</span><br><span class="line">                &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (type != XmlPullParser.START_TAG) &#123;</span><br><span class="line">            Slog.e(TAG, <span class="string">"Unable to read app idle file for user "</span> + userId);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!parser.getName().equals(TAG_PACKAGES)) &#123; <span class="comment">// packages 标签</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> ((type = parser.next()) != XmlPullParser.END_DOCUMENT) &#123;</span><br><span class="line">            <span class="keyword">if</span> (type == XmlPullParser.START_TAG) &#123;</span><br><span class="line">                <span class="keyword">final</span> String name = parser.getName();</span><br><span class="line">                <span class="comment">//【2】解析 package 标签和其属性！</span></span><br><span class="line">                <span class="keyword">if</span> (name.equals(TAG_PACKAGE)) &#123; <span class="comment">// 解析 “package” 标签</span></span><br><span class="line">                    <span class="keyword">final</span> String packageName = parser.getAttributeValue(<span class="keyword">null</span>, ATTR_NAME);  <span class="comment">// 解析 “name” 属性</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//【3】创建 PackageHistory 对象，封装解析到的信息；</span></span><br><span class="line">                    PackageHistory packageHistory = <span class="keyword">new</span> PackageHistory();</span><br><span class="line">                    </span><br><span class="line">                    packageHistory.lastUsedElapsedTime =   <span class="comment">// 解析 “screenIdleTime” 属性</span></span><br><span class="line">                            Long.parseLong(parser.getAttributeValue(<span class="keyword">null</span>, ATTR_ELAPSED_IDLE));</span><br><span class="line">                   </span><br><span class="line">                    packageHistory.lastUsedScreenTime =    <span class="comment">// 解析 “elapsedIdleTime” 属性</span></span><br><span class="line">                            Long.parseLong(parser.getAttributeValue(<span class="keyword">null</span>, ATTR_SCREEN_IDLE));</span><br><span class="line">                    <span class="comment">//【4】添加到 userHistory 中，最后返回！</span></span><br><span class="line">                    userHistory.put(packageName, packageHistory);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException | XmlPullParserException e) &#123;</span><br><span class="line">        Slog.e(TAG, <span class="string">"Unable to read app idle file for user "</span> + userId);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        IoUtils.closeQuietly(fis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看看 /data/system/users/0/app_idle_stats.xml 文件中的主要内容：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">'1.0'</span> encoding=<span class="string">'utf-8'</span> standalone=<span class="string">'yes'</span> ?&gt;</span><br><span class="line">&lt;packages&gt;</span><br><span class="line">    &lt;<span class="keyword">package</span> name=<span class="string">"com.github.shadowsocks"</span> elapsedIdleTime=<span class="string">"6836535861"</span> screenIdleTime=<span class="string">"2173999944"</span> /&gt;</span><br><span class="line">&lt;/packages&gt;</span><br></pre></td></tr></table></figure></p>
<p>getUserFile 方法返回的是：<code>/data/system/users/&lt;userId&gt;/app_idle_stats.xml</code> 文件对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String APP_IDLE_FILENAME = <span class="string">"app_idle_stats.xml"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> File <span class="title">getUserFile</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> File(<span class="keyword">new</span> File(<span class="keyword">new</span> File(mStorageDir, <span class="string">"users"</span>),</span><br><span class="line">            Integer.toString(userId)), APP_IDLE_FILENAME);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>#####2.3.2.3.1 new PackageHistory<br>创建 PackageHistory 对象！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PackageHistory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">byte</span>[] recent = <span class="keyword">new</span> <span class="keyword">byte</span>[HISTORY_SIZE];</span><br><span class="line">    <span class="keyword">long</span> lastUsedElapsedTime;</span><br><span class="line">    <span class="keyword">long</span> lastUsedScreenTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-4-new-DeviceStateReceiver-监听设备状态"><a href="#2-4-new-DeviceStateReceiver-监听设备状态" class="headerlink" title="2.4 new DeviceStateReceiver - 监听设备状态"></a>2.4 new DeviceStateReceiver - 监听设备状态</h2><p>DeviceStateReceiver 监听设备状态的变化！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">DeviceStateReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String action = intent.getAction();</span><br><span class="line">        <span class="keyword">if</span> (Intent.ACTION_BATTERY_CHANGED.equals(action)) &#123;</span><br><span class="line">            <span class="comment">//【2.4.1】设置充电状态！</span></span><br><span class="line">            setChargingState(intent.getIntExtra(<span class="string">"plugged"</span>, <span class="number">0</span>) != <span class="number">0</span>);</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED.equals(action)) &#123;</span><br><span class="line">            <span class="comment">//【2.4.2】处理 device idle (doze)模式变化！</span></span><br><span class="line">            onDeviceIdleModeChanged();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>如果广播是 Intent.ACTION_BATTERY_CHANGED，说明此时正在充电，那么会调用 setChargingState 设置充电状态；</li>
<li>如果广播是 PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED，说明此时 device idle 模式的状态发生了变化；</li>
</ul>
<h3 id="2-4-1-UsageStatsS-setChargingState-充电状态变化"><a href="#2-4-1-UsageStatsS-setChargingState-充电状态变化" class="headerlink" title="2.4.1 UsageStatsS.setChargingState - 充电状态变化"></a>2.4.1 UsageStatsS.setChargingState - 充电状态变化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setChargingState</span><span class="params">(<span class="keyword">boolean</span> charging)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCharging != charging) &#123;</span><br><span class="line">            <span class="comment">// 更新 mCharging！</span></span><br><span class="line">            mCharging = charging;</span><br><span class="line">            <span class="comment">//【2.4.1.1】调用 postParoleStateChanged 方法！</span></span><br><span class="line">            postParoleStateChanged();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mCharging 表示当前设备是否正在充电，可以看到，只有当设备在未充电和充电状态之间变化！</p>
<h4 id="2-4-1-1-UsageStatsS-postParoleStateChanged"><a href="#2-4-1-1-UsageStatsS-postParoleStateChanged" class="headerlink" title="2.4.1.1 UsageStatsS.postParoleStateChanged"></a>2.4.1.1 UsageStatsS.postParoleStateChanged</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postParoleStateChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">"Posting MSG_PAROLE_STATE_CHANGED"</span>);</span><br><span class="line">    <span class="comment">//【4.11】发送 MSG_PAROLE_STATE_CHANGED 消息给 H!</span></span><br><span class="line">    mHandler.removeMessages(MSG_PAROLE_STATE_CHANGED);</span><br><span class="line">    mHandler.sendEmptyMessage(MSG_PAROLE_STATE_CHANGED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发送 MSG_PAROLE_STATE_CHANGED 消息给 H！</p>
<h3 id="2-4-2-UsageStatsS-onDeviceIdleModeChanged-doze-状态变化"><a href="#2-4-2-UsageStatsS-onDeviceIdleModeChanged-doze-状态变化" class="headerlink" title="2.4.2 UsageStatsS.onDeviceIdleModeChanged - doze 状态变化"></a>2.4.2 UsageStatsS.onDeviceIdleModeChanged - doze 状态变化</h3><p>当 device idle (doze)模式发生了变化后，onDeviceIdleModeChanged 方法会被触发：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onDeviceIdleModeChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】调用 PowerManager.isDeviceIdleMode 方法，判断是否进入了 doze 模式！</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> deviceIdle = mPowerManager.isDeviceIdleMode();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (DEBUG) Slog.i(TAG, <span class="string">"DeviceIdleMode changed to "</span> + deviceIdle);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="comment">//【2】计算距离里上一次的应用假释时间，已经过去的时间！</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> timeSinceLastParole = checkAndGetTimeLocked() - mLastAppIdleParoledTime;</span><br><span class="line">        <span class="keyword">if</span> (!deviceIdle</span><br><span class="line">                &amp;&amp; timeSinceLastParole &gt;= mAppIdleParoleIntervalMillis) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG) Slog.i(TAG, <span class="string">"Bringing idle apps out of inactive state due to deviceIdleMode=false"</span>);</span><br><span class="line">            <span class="comment">//【2.1】如果已经退出了 device idle 模式，并且距离上一次的应用假释时间已经超过了 </span></span><br><span class="line">            <span class="comment">// mAppIdleParoleIntervalMillis，那么我们就进入假释状态！</span></span><br><span class="line">            setAppIdleParoled(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (deviceIdle) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG) Slog.i(TAG, <span class="string">"Device idle, back to prison"</span>);</span><br><span class="line">            <span class="comment">//【2.2】如果当前处于 device idle 状态，那么不允许应用假释；</span></span><br><span class="line">            setAppIdleParoled(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="2-4-2-1-UsageStatsS-checkAndGetTimeLocked"><a href="#2-4-2-1-UsageStatsS-checkAndGetTimeLocked" class="headerlink" title="2.4.2.1 UsageStatsS.checkAndGetTimeLocked"></a>2.4.2.1 UsageStatsS.checkAndGetTimeLocked</h4><p>checkAndGetTimeLocked 方法用于计算当前的时间！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">checkAndGetTimeLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】获得当前的系统时间，可以被系统设置修改；</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> actualSystemTime = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">//【2】获得自开机后，经过的时间，包括深度睡眠的时间；</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> actualRealtime = SystemClock.elapsedRealtime();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> expectedSystemTime = (actualRealtime - mRealTimeSnapshot) + mSystemTimeSnapshot;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> diffSystemTime = actualSystemTime - expectedSystemTime;</span><br><span class="line">    <span class="comment">//【3】判断时间是否有发生变化，</span></span><br><span class="line">    <span class="keyword">if</span> (Math.abs(diffSystemTime) &gt; TIME_CHANGE_THRESHOLD_MILLIS) &#123;</span><br><span class="line">        <span class="comment">// The time has changed.</span></span><br><span class="line">        Slog.i(TAG, <span class="string">"Time changed in UsageStats by "</span> + (diffSystemTime / <span class="number">1000</span>) + <span class="string">" seconds"</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> userCount = mUserState.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; userCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> UserUsageStatsService service = mUserState.valueAt(i);</span><br><span class="line">            <span class="comment">//【3.1】更新本地数据！</span></span><br><span class="line">            service.onTimeChanged(expectedSystemTime, actualSystemTime);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【3.2】记录本次的时间点到 mRealTimeSnapshot，mSystemTimeSnapshot！</span></span><br><span class="line">        mRealTimeSnapshot = actualRealtime;</span><br><span class="line">        mSystemTimeSnapshot = actualSystemTime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【4】返回当前的实际时间！</span></span><br><span class="line">    <span class="keyword">return</span> actualSystemTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 checkAndGetTimeLocked 返回的时间是  actualSystemTime 的值，也就是 System.currentTimeMillis()，这个时间值可以被系统设置修改，然后值就会发生跳变，比如联网对时，手动调时！</p>
<p>而 actualRealtime 的值为 System.elapsedRealtime 自开机后，经过的时间，包括深度睡眠的时间，这部分时间值是不会被修改；</p>
<p>如果判断时间是否有发生调时，对时情况呢？</p>
<ul>
<li>mSystemTimeSnapshot 中保存的是上一次 check 时的系统时间；</li>
<li>mRealTimeSnapshot 中保存的是上一次 check 时的自开机后，经过的时间；</li>
<li>先计算出期望的时间：<ul>
<li>本次距离开机的时间 actualRealtime - 上次距离开机的时间 mRealTimeSnapshot，这个时间差值是正常情况下的时间差值；</li>
<li>然后再加上上一次 check 时的系统时间 mSystemTimeSnapshot，如果没有发生调时的话，这个应该是理想的时间点 expectedSystemTime；</li>
<li>如果发生了调时，对时的情况，actualSystemTime 一定是会发生变化的！</li>
<li>计算 actualSystemTime 和 expectedSystemTime 的差值，如果大于 TIME_CHANGE_THRESHOLD_MILLIS，说明铁定发生了调时，对时；</li>
</ul>
</li>
</ul>
<p>如果发生上述情况，那就调用 UserUsageStatsService.onTimeChanged 更新本地持久化文件的日期！</p>
<p>对于 UsageStatsService 是如何存储应用数据，如何更新本地持久化文件的，这里我先不关注，我们只需要知道，该方法返回的时间值是实际的时间（正常，手动调时，联网对时）</p>
<h2 id="2-5-UsageStatsS-cleanUpRemovedUsersLocked-删除被移除的-User-使用数据"><a href="#2-5-UsageStatsS-cleanUpRemovedUsersLocked-删除被移除的-User-使用数据" class="headerlink" title="2.5 UsageStatsS.cleanUpRemovedUsersLocked - 删除被移除的 User 使用数据"></a>2.5 UsageStatsS.cleanUpRemovedUsersLocked - 删除被移除的 User 使用数据</h2><p>删除已经被移除的 User 的使用数据！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cleanUpRemovedUsersLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】获得所有的 user 信息！</span></span><br><span class="line">    <span class="keyword">final</span> List&lt;UserInfo&gt; users = mUserManager.getUsers(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (users == <span class="keyword">null</span> || users.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"There can't be no users"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【2】如果 /data/system/usagestats 目录下没有任何文件，不处理！</span></span><br><span class="line">    ArraySet&lt;String&gt; toDelete = <span class="keyword">new</span> ArraySet&lt;&gt;();</span><br><span class="line">    String[] fileNames = mUsageStatsDir.list();</span><br><span class="line">    <span class="keyword">if</span> (fileNames == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// No users to delete.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【3】去除那些存在的 user 的使用信息！</span></span><br><span class="line">    toDelete.addAll(Arrays.asList(fileNames));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> userCount = users.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; userCount; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> UserInfo userInfo = users.get(i);</span><br><span class="line">        toDelete.remove(Integer.toString(userInfo.id));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【4】移除剩下的没用的 user 信息；</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> deleteCount = toDelete.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; deleteCount; i++) &#123;</span><br><span class="line">        <span class="comment">// 递归删除！</span></span><br><span class="line">        deleteRecursively(<span class="keyword">new</span> File(mUsageStatsDir, toDelete.valueAt(i)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-6-new-AppIdleHistory-管理-App-Idle-信息"><a href="#2-6-new-AppIdleHistory-管理-App-Idle-信息" class="headerlink" title="2.6 new AppIdleHistory - 管理 App Idle 信息"></a>2.6 new AppIdleHistory - 管理 App Idle 信息</h2><p>创建一个 AppIdleHistory 对象，保存 app idle 相关的状态和信息！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">AppIdleHistory(<span class="keyword">long</span> elapsedRealtime) &#123;</span><br><span class="line">    <span class="keyword">this</span>(Environment.getDataSystemDirectory(), elapsedRealtime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@VisibleForTesting</span></span><br><span class="line">AppIdleHistory(File storageDir, <span class="keyword">long</span> elapsedRealtime) &#123;</span><br><span class="line">    <span class="comment">//【1】可以看到，初始化时候 mElapsedSnapshot 等于 mScreenOnSnapshot</span></span><br><span class="line">    mElapsedSnapshot = elapsedRealtime;</span><br><span class="line">    mScreenOnSnapshot = elapsedRealtime;</span><br><span class="line">    mStorageDir = storageDir;</span><br><span class="line">    <span class="comment">//【×2.6.1】读取亮屏时间信息！</span></span><br><span class="line">    readScreenOnTimeLocked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mStorageDir 指向 /data/system 目录！</p>
<h3 id="2-6-1-AppIdleHistory-readScreenOnTimeLocked"><a href="#2-6-1-AppIdleHistory-readScreenOnTimeLocked" class="headerlink" title="2.6.1 AppIdleHistory.readScreenOnTimeLocked"></a>2.6.1 AppIdleHistory.readScreenOnTimeLocked</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readScreenOnTimeLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】获得 /data/system/screen_on_time 文件</span></span><br><span class="line">    File screenOnTimeFile = getScreenOnTimeFile();</span><br><span class="line">    <span class="keyword">if</span> (screenOnTimeFile.exists()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(screenOnTimeFile));</span><br><span class="line">            <span class="comment">//【2】读取 mScreenOnDuration 和 mElapsedDuration 时间值！</span></span><br><span class="line">            mScreenOnDuration  = Long.parseLong(reader.readLine());</span><br><span class="line">            mElapsedDuration = Long.parseLong(reader.readLine());</span><br><span class="line">            reader.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | NumberFormatException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        writeScreenOnTimeLocked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个流程很简单，不多说了！</p>
<h2 id="2-7-publish-LocalService"><a href="#2-7-publish-LocalService" class="headerlink" title="2.7 publish LocalService"></a>2.7 publish LocalService</h2><p>LocalService 用于系统进程中服务间的相互通信，本地服务实现主要由ActivityManagerService 使用。ActivityManagerService 调用这些方法的时会持有自身的锁，不应该在这些方法中执行任何 IO 工作或其他长时间运行的任务。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalService</span> <span class="keyword">extends</span> <span class="title">UsageStatsManagerInternal</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】向 UsageStatsService 发送应用的使用信息 UsageEvents；</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reportEvent</span><span class="params">(ComponentName component, <span class="keyword">int</span> userId, <span class="keyword">int</span> eventType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (component == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Event reported without a component name"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        UsageEvents.Event event = <span class="keyword">new</span> UsageEvents.Event();</span><br><span class="line">        event.mPackage = component.getPackageName();</span><br><span class="line">        event.mClass = component.getClassName();</span><br><span class="line">        <span class="comment">// This will later be converted to system time.</span></span><br><span class="line">        event.mTimeStamp = SystemClock.elapsedRealtime();</span><br><span class="line">        event.mEventType = eventType;</span><br><span class="line">        <span class="comment">//【1.1】发送 MSG_REPORT_EVENT 给 H；</span></span><br><span class="line">        mHandler.obtainMessage(MSG_REPORT_EVENT, userId, <span class="number">0</span>, event).sendToTarget();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reportEvent</span><span class="params">(String packageName, <span class="keyword">int</span> userId, <span class="keyword">int</span> eventType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (packageName == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Event reported without a package name"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        UsageEvents.Event event = <span class="keyword">new</span> UsageEvents.Event();</span><br><span class="line">        event.mPackage = packageName;</span><br><span class="line">        event.mTimeStamp = SystemClock.elapsedRealtime();</span><br><span class="line">        event.mEventType = eventType;</span><br><span class="line">        mHandler.obtainMessage(MSG_REPORT_EVENT, userId, <span class="number">0</span>, event).sendToTarget();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】向 UsageStatsService 发送配置的使用信息 UsageEvents；</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reportConfigurationChange</span><span class="params">(Configuration config, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (config == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Configuration event reported with a null config"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        UsageEvents.Event event = <span class="keyword">new</span> UsageEvents.Event();</span><br><span class="line">        event.mPackage = <span class="string">"android"</span>;</span><br><span class="line">        event.mTimeStamp = SystemClock.elapsedRealtime();</span><br><span class="line">        event.mEventType = UsageEvents.Event.CONFIGURATION_CHANGE;</span><br><span class="line">        event.mConfiguration = <span class="keyword">new</span> Configuration(config);</span><br><span class="line">        <span class="comment">//【2.1】发送 MSG_REPORT_EVENT 给 H；</span></span><br><span class="line">        mHandler.obtainMessage(MSG_REPORT_EVENT, userId, <span class="number">0</span>, event).sendToTarget();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【3】向 UsageStatsService 发送 Shortcut 的使用信息 UsageEvents；</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reportShortcutUsage</span><span class="params">(String packageName, String shortcutId, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (packageName == <span class="keyword">null</span> || shortcutId == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Event reported without a package name or a shortcut ID"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        UsageEvents.Event event = <span class="keyword">new</span> UsageEvents.Event();</span><br><span class="line">        event.mPackage = packageName.intern();</span><br><span class="line">        event.mShortcutId = shortcutId.intern();</span><br><span class="line">        event.mTimeStamp = SystemClock.elapsedRealtime();</span><br><span class="line">        event.mEventType = Event.SHORTCUT_INVOCATION;</span><br><span class="line">        <span class="comment">//【3.1】发送 MSG_REPORT_EVENT 给 H；</span></span><br><span class="line">        mHandler.obtainMessage(MSG_REPORT_EVENT, userId, <span class="number">0</span>, event).sendToTarget();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【4】向 UsageStatsService 发送 ContentProvider 的使用信息；</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reportContentProviderUsage</span><span class="params">(String name, String packageName, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        SomeArgs args = SomeArgs.obtain();</span><br><span class="line">        args.arg1 = name;</span><br><span class="line">        args.arg2 = packageName;</span><br><span class="line">        args.arg3 = userId;</span><br><span class="line">        <span class="comment">//【4.1】发送 MSG_REPORT_CONTENT_PROVIDER_USAGE 给 H；</span></span><br><span class="line">        mHandler.obtainMessage(MSG_REPORT_CONTENT_PROVIDER_USAGE, args)</span><br><span class="line">                .sendToTarget();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【5】判断应用是否处于 idle 状态；</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAppIdle</span><span class="params">(String packageName, <span class="keyword">int</span> uidForAppId, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UsageStatsService.<span class="keyword">this</span>.isAppIdleFiltered(packageName, uidForAppId, userId,</span><br><span class="line">                SystemClock.elapsedRealtime());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【6】获得指定 userId 下的处于 idle 状态的 uid；</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getIdleUidsForUser(<span class="keyword">int</span> userId) &#123;</span><br><span class="line">        <span class="keyword">return</span> UsageStatsService.<span class="keyword">this</span>.getIdleUidsForUser(userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【7】获得指定 userId 下的处于 idle 状态的 uid；</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAppIdleParoleOn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isParoledOrCharging();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【8】关机时调用！</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepareShutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【9】添加和移除 app idle 状态改变监听器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAppIdleStateChangeListener</span><span class="params">(AppIdleStateChangeListener listener)</span> </span>&#123;</span><br><span class="line">        UsageStatsService.<span class="keyword">this</span>.addListener(listener);</span><br><span class="line">        listener.onParoleStateChanged(isAppIdleParoleOn());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeAppIdleStateChangeListener</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            AppIdleStateChangeListener listener)</span> </span>&#123;</span><br><span class="line">        UsageStatsService.<span class="keyword">this</span>.removeListener(listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] getBackupPayload(<span class="keyword">int</span> user, String key) &#123;</span><br><span class="line">        <span class="comment">// Check to ensure that only user 0's data is b/r for now</span></span><br><span class="line">        <span class="keyword">if</span> (user == UserHandle.USER_SYSTEM) &#123;</span><br><span class="line">            <span class="keyword">final</span> UserUsageStatsService userStats =</span><br><span class="line">                    getUserDataAndInitializeIfNeededLocked(user, checkAndGetTimeLocked());</span><br><span class="line">            <span class="keyword">return</span> userStats.getBackupPayload(key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applyRestoredPayload</span><span class="params">(<span class="keyword">int</span> user, String key, <span class="keyword">byte</span>[] payload)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (user == UserHandle.USER_SYSTEM) &#123;</span><br><span class="line">            <span class="keyword">final</span> UserUsageStatsService userStats =</span><br><span class="line">                    getUserDataAndInitializeIfNeededLocked(user, checkAndGetTimeLocked());</span><br><span class="line">            userStats.applyRestoredPayload(key, payload);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>关于 LocalService 中的方法的触发，我们后面再看！</p>
<h2 id="2-8-publish-BinderService"><a href="#2-8-publish-BinderService" class="headerlink" title="2.8 publish BinderService"></a>2.8 publish BinderService</h2><p>BinderService 的所用是跨进程通信！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BinderService</span> <span class="keyword">extends</span> <span class="title">IUsageStatsManager</span>.<span class="title">Stub</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】判断调用者是否有 PACKAGE_USAGE_STATS 相关的权限！</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasPermission</span><span class="params">(String callingPackage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> callingUid = Binder.getCallingUid();</span><br><span class="line">        <span class="keyword">if</span> (callingUid == Process.SYSTEM_UID) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> mode = mAppOps.checkOp(AppOpsManager.OP_GET_USAGE_STATS,</span><br><span class="line">                callingUid, callingPackage);</span><br><span class="line">        <span class="keyword">if</span> (mode == AppOpsManager.MODE_DEFAULT) &#123;</span><br><span class="line">            <span class="comment">// The default behavior here is to check if PackageManager has given the app</span></span><br><span class="line">            <span class="comment">// permission.</span></span><br><span class="line">            <span class="keyword">return</span> getContext().checkCallingPermission(Manifest.permission.PACKAGE_USAGE_STATS)</span><br><span class="line">                    == PackageManager.PERMISSION_GRANTED;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mode == AppOpsManager.MODE_ALLOWED;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//【2】查询应用的使用状态！</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ParceledListSlice&lt;UsageStats&gt; <span class="title">queryUsageStats</span><span class="params">(<span class="keyword">int</span> bucketType, <span class="keyword">long</span> beginTime,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">long</span> endTime, String callingPackage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasPermission(callingPackage)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> userId = UserHandle.getCallingUserId();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> token = Binder.clearCallingIdentity();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> List&lt;UsageStats&gt; results = UsageStatsService.<span class="keyword">this</span>.queryUsageStats(</span><br><span class="line">                    userId, bucketType, beginTime, endTime);</span><br><span class="line">            <span class="keyword">if</span> (results != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ParceledListSlice&lt;&gt;(results);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Binder.restoreCallingIdentity(token);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【3】查询配置的使用状态！</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ParceledListSlice&lt;ConfigurationStats&gt; <span class="title">queryConfigurationStats</span><span class="params">(<span class="keyword">int</span> bucketType,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">long</span> beginTime, <span class="keyword">long</span> endTime, String callingPackage)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasPermission(callingPackage)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> userId = UserHandle.getCallingUserId();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> token = Binder.clearCallingIdentity();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> List&lt;ConfigurationStats&gt; results =</span><br><span class="line">                    UsageStatsService.<span class="keyword">this</span>.queryConfigurationStats(userId, bucketType,</span><br><span class="line">                            beginTime, endTime);</span><br><span class="line">            <span class="keyword">if</span> (results != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ParceledListSlice&lt;&gt;(results);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Binder.restoreCallingIdentity(token);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【4】查询应用的使用事件信息！</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UsageEvents <span class="title">queryEvents</span><span class="params">(<span class="keyword">long</span> beginTime, <span class="keyword">long</span> endTime, String callingPackage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasPermission(callingPackage)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> userId = UserHandle.getCallingUserId();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> token = Binder.clearCallingIdentity();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> UsageStatsService.<span class="keyword">this</span>.queryEvents(userId, beginTime, endTime);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Binder.restoreCallingIdentity(token);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【5】判断应用是否处于 inactive 状态！</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAppInactive</span><span class="params">(String packageName, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            userId = ActivityManagerNative.getDefault().handleIncomingUser(Binder.getCallingPid(),</span><br><span class="line">                    Binder.getCallingUid(), userId, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="string">"isAppInactive"</span>, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException re) &#123;</span><br><span class="line">            <span class="keyword">throw</span> re.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> token = Binder.clearCallingIdentity();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> UsageStatsService.<span class="keyword">this</span>.isAppIdleFilteredOrParoled(packageName, userId,</span><br><span class="line">                    SystemClock.elapsedRealtime());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Binder.restoreCallingIdentity(token);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【5】判断应用是否处于 inactive 状态！</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAppInactive</span><span class="params">(String packageName, <span class="keyword">boolean</span> idle, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> callingUid = Binder.getCallingUid();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            userId = ActivityManagerNative.getDefault().handleIncomingUser(</span><br><span class="line">                    Binder.getCallingPid(), callingUid, userId, <span class="keyword">false</span>, <span class="keyword">true</span>,</span><br><span class="line">                    <span class="string">"setAppIdle"</span>, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException re) &#123;</span><br><span class="line">            <span class="keyword">throw</span> re.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">        getContext().enforceCallingPermission(Manifest.permission.CHANGE_APP_IDLE_STATE,</span><br><span class="line">                <span class="string">"No permission to change app idle state"</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> token = Binder.clearCallingIdentity();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> appId = getAppId(packageName);</span><br><span class="line">            <span class="keyword">if</span> (appId &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">            UsageStatsService.<span class="keyword">this</span>.setAppIdle(packageName, idle, userId);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Binder.restoreCallingIdentity(token);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【6】将应用添加到 doze 模式临时白名单中！</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whitelistAppTemporarily</span><span class="params">(String packageName, <span class="keyword">long</span> duration, <span class="keyword">int</span> userId)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        StringBuilder reason = <span class="keyword">new</span> StringBuilder(<span class="number">32</span>);</span><br><span class="line">        reason.append(<span class="string">"from:"</span>);</span><br><span class="line">        UserHandle.formatUid(reason, Binder.getCallingUid());</span><br><span class="line">        mDeviceIdleController.addPowerSaveTempWhitelistApp(packageName, duration, userId,</span><br><span class="line">                reason.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【7】运营商特权应用变化！</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCarrierPrivilegedAppsChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">            Slog.i(TAG, <span class="string">"Carrier privileged apps changed"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        getContext().enforceCallingOrSelfPermission(</span><br><span class="line">                android.Manifest.permission.BIND_CARRIER_SERVICES,</span><br><span class="line">                <span class="string">"onCarrierPrivilegedAppsChanged can only be called by privileged apps."</span>);</span><br><span class="line">        UsageStatsService.<span class="keyword">this</span>.clearCarrierPrivilegedApps();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【8】用于 dumpsys！</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dump</span><span class="params">(FileDescriptor fd, PrintWriter pw, String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (getContext().checkCallingOrSelfPermission(android.Manifest.permission.DUMP)</span><br><span class="line">                != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">            pw.println(<span class="string">"Permission Denial: can't dump UsageStats from pid="</span></span><br><span class="line">                    + Binder.getCallingPid() + <span class="string">", uid="</span> + Binder.getCallingUid()</span><br><span class="line">                    + <span class="string">" without permission "</span> + android.Manifest.permission.DUMP);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        UsageStatsService.<span class="keyword">this</span>.dump(args, pw);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于 BinderService 中的方法的触发，我们后面再看！</p>
<h1 id="3-UsageStatsS-onBootPhase"><a href="#3-UsageStatsS-onBootPhase" class="headerlink" title="3 UsageStatsS.onBootPhase"></a>3 UsageStatsS.onBootPhase</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBootPhase</span><span class="params">(<span class="keyword">int</span> phase)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (phase == PHASE_SYSTEM_SERVICES_READY) &#123;</span><br><span class="line">        <span class="comment">//【*3.1】创建一个 SettingsObserver， 监听数据库变化！</span></span><br><span class="line">        SettingsObserver settingsObserver = <span class="keyword">new</span> SettingsObserver(mHandler);</span><br><span class="line">        settingsObserver.registerObserver();</span><br><span class="line">        settingsObserver.updateSettings();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【2】获得系统中的一些其他重要服务管理对象：DeviceIdleController，</span></span><br><span class="line">        <span class="comment">// BatteryStats，DisplayManager 和 PowerManager！</span></span><br><span class="line">        mAppWidgetManager = getContext().getSystemService(AppWidgetManager.class);</span><br><span class="line">        mDeviceIdleController = IDeviceIdleController.Stub.asInterface(</span><br><span class="line">                ServiceManager.getService(Context.DEVICE_IDLE_CONTROLLER));</span><br><span class="line">        mBatteryStats = IBatteryStats.Stub.asInterface(</span><br><span class="line">                ServiceManager.getService(BatteryStats.SERVICE_NAME));</span><br><span class="line">        mDisplayManager = (DisplayManager) getContext().getSystemService(</span><br><span class="line">                Context.DISPLAY_SERVICE);</span><br><span class="line">        mPowerManager = getContext().getSystemService(PowerManager.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【*3.2】注册 DisplayListener</span></span><br><span class="line">        mDisplayManager.registerDisplayListener(mDisplayListener, mHandler);</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            <span class="comment">//【*3.2.1】初始化 AppIdleHistory 的亮屏信息！</span></span><br><span class="line">            mAppIdleHistory.updateDisplayLocked(isDisplayOn(), SystemClock.elapsedRealtime());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【*3.4】mPendingOneTimeCheckIdleStates 为 true 表示正在等待查询 idle 状态！</span></span><br><span class="line">        <span class="comment">// 那么就会再次调用 postOneTimeCheckIdleStates 方法！</span></span><br><span class="line">        <span class="keyword">if</span> (mPendingOneTimeCheckIdleStates) &#123;</span><br><span class="line">            postOneTimeCheckIdleStates();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mSystemServicesReady = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (phase == PHASE_BOOT_COMPLETED) &#123;</span><br><span class="line">        <span class="comment">//【*2.4.1】初始化充电状态信息；</span></span><br><span class="line">        setChargingState(getContext().getSystemService(BatteryManager.class).isCharging());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>onBootPhase 方法会在两个阶段下调用：</p>
<ul>
<li><strong>PHASE_SYSTEM_SERVICES_READY</strong>：此时系统服务已经都启动了；</li>
<li><strong>PHASE_BOOT_COMPLETED</strong>：此时设备重启完成了；</li>
</ul>
<h2 id="3-1-new-SettingsObserver-监听数据库变化"><a href="#3-1-new-SettingsObserver-监听数据库变化" class="headerlink" title="3.1 new SettingsObserver - 监听数据库变化"></a>3.1 new SettingsObserver - 监听数据库变化</h2><p>这里会创建一个 SettingsObserver 观察者，监听数据表变化！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SettingsObserver</span> <span class="keyword">extends</span> <span class="title">ContentObserver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> KeyValueListParser mParser = <span class="keyword">new</span> KeyValueListParser(<span class="string">','</span>);</span><br><span class="line"></span><br><span class="line">        SettingsObserver(Handler handler) &#123;</span><br><span class="line">            <span class="keyword">super</span>(handler);</span><br><span class="line">        &#125;</span><br><span class="line">        ... ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-1-1-SettingsObserver-registerObserver"><a href="#3-1-1-SettingsObserver-registerObserver" class="headerlink" title="3.1.1 SettingsObserver.registerObserver"></a>3.1.1 SettingsObserver.registerObserver</h3><p>监听的 Settings 表单是 app_idle_constants！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    getContext().getContentResolver().registerContentObserver(Settings.Global.getUriFor(</span><br><span class="line">            Settings.Global.APP_IDLE_CONSTANTS), <span class="keyword">false</span>, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-1-2-SettingsObserver-onChange"><a href="#3-1-2-SettingsObserver-onChange" class="headerlink" title="3.1.2 SettingsObserver.onChange"></a>3.1.2 SettingsObserver.onChange</h3><p>当数据库有变化后，会触发 onChange 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChange</span><span class="params">(<span class="keyword">boolean</span> selfChange)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【3.1.3】初始化数据！</span></span><br><span class="line">    updateSettings();</span><br><span class="line">    <span class="comment">//【3.4】调用 postOneTimeCheckIdleStates 方法进行一次 idle 检查！</span></span><br><span class="line">    postOneTimeCheckIdleStates();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-1-3-SettingsObserver-updateSettings"><a href="#3-1-3-SettingsObserver-updateSettings" class="headerlink" title="3.1.3 SettingsObserver.updateSettings"></a>3.1.3 SettingsObserver.updateSettings</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateSettings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mParser.setString(Settings.Global.getString(getContext().getContentResolver(),</span><br><span class="line">                        Settings.Global.APP_IDLE_CONSTANTS));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">                Slog.e(TAG, <span class="string">"Bad value for app idle settings: "</span> + e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 值为 12 hours；</span></span><br><span class="line">            mAppIdleScreenThresholdMillis = mParser.getLong(KEY_IDLE_DURATION,</span><br><span class="line">                   COMPRESS_TIME ? ONE_MINUTE * <span class="number">4</span> : <span class="number">12</span> * <span class="number">60</span> * ONE_MINUTE);</span><br><span class="line">            <span class="comment">// 值为 48 hours；</span></span><br><span class="line">            mAppIdleWallclockThresholdMillis = mParser.getLong(KEY_WALLCLOCK_THRESHOLD,</span><br><span class="line">                    COMPRESS_TIME ? ONE_MINUTE * <span class="number">8</span> : <span class="number">2L</span> * <span class="number">24</span> * <span class="number">60</span> * ONE_MINUTE);</span><br><span class="line">            <span class="comment">// 值为 8 hours；</span></span><br><span class="line">            mCheckIdleIntervalMillis = Math.min(mAppIdleScreenThresholdMillis / <span class="number">4</span>,</span><br><span class="line">                    COMPRESS_TIME ? ONE_MINUTE : <span class="number">8</span> * <span class="number">60</span> * ONE_MINUTE);</span><br><span class="line">            <span class="comment">// 置为 24 hours；</span></span><br><span class="line">            mAppIdleParoleIntervalMillis = mParser.getLong(KEY_PAROLE_INTERVAL,</span><br><span class="line">                    COMPRESS_TIME ? ONE_MINUTE * <span class="number">10</span> : <span class="number">24</span> * <span class="number">60</span> * ONE_MINUTE);</span><br><span class="line">            <span class="comment">// 置为 10 mins；</span></span><br><span class="line">            mAppIdleParoleDurationMillis = mParser.getLong(KEY_PAROLE_DURATION,</span><br><span class="line">                    COMPRESS_TIME ? ONE_MINUTE : <span class="number">10</span> * ONE_MINUTE);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【3.1.3.1】设置阈值到 AppIdleHistory 中！</span></span><br><span class="line">            mAppIdleHistory.setThresholds(mAppIdleWallclockThresholdMillis,</span><br><span class="line">                    mAppIdleScreenThresholdMillis);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里涉及到几个重要的时间变量：</p>
<ul>
<li><strong>mAppIdleScreenThresholdMillis</strong>：12 hours，是应用是否进入 idle 状态的临界值！</li>
</ul>
<p><br></p>
<ul>
<li><strong>mAppIdleWallclockThresholdMillis</strong>：48 hours，是应用是否进入 idle 状态的临界值！</li>
</ul>
<p><br></p>
<ul>
<li><strong>mCheckIdleIntervalMillis</strong>：表示执行 check idle 操作的时间间隔，8 hours！</li>
</ul>
<p><br></p>
<ul>
<li><strong>mAppIdleParoleIntervalMillis</strong>：相邻 2 次进入假释状态的时间间隔，24 hours！</li>
</ul>
<p><br></p>
<ul>
<li><strong>mAppIdleParoleDurationMillis</strong>：假释状态的持续时间，10mins！</li>
</ul>
<p>这里的 COMPRESS_TIME 的值恒定为 false！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> COMPRESS_TIME = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>
<h4 id="3-1-3-1-AppIdleHistory-setThresholds"><a href="#3-1-3-1-AppIdleHistory-setThresholds" class="headerlink" title="3.1.3.1 AppIdleHistory.setThresholds"></a>3.1.3.1 AppIdleHistory.setThresholds</h4><p>设置阈值信息，该阈值会用于判断应用是否处于 idle 状态！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setThresholds</span><span class="params">(<span class="keyword">long</span> elapsedTimeThreshold, <span class="keyword">long</span> screenOnTimeThreshold)</span> </span>&#123;</span><br><span class="line">    mElapsedTimeThreshold = elapsedTimeThreshold;</span><br><span class="line">    mScreenOnTimeThreshold = screenOnTimeThreshold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们来解释下这两个阈值的作用：</p>
<h2 id="3-2-register-DisplayListener-监听屏幕状态"><a href="#3-2-register-DisplayListener-监听屏幕状态" class="headerlink" title="3.2 register DisplayListener - 监听屏幕状态"></a>3.2 register DisplayListener - 监听屏幕状态</h2><p>UsageStatsService 内部有一个 DisplayListener 实例：mDisplayListener，专门用于监听屏幕的状态，然后触发 AppIdleHistory 的更新！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> DisplayManager.DisplayListener mDisplayListener</span><br><span class="line">        = <span class="keyword">new</span> DisplayManager.DisplayListener() &#123;</span><br><span class="line">    ... ... ...</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDisplayChanged</span><span class="params">(<span class="keyword">int</span> displayId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (displayId == Display.DEFAULT_DISPLAY) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> displayOn = isDisplayOn();</span><br><span class="line">            <span class="keyword">synchronized</span> (UsageStatsService.<span class="keyword">this</span>.mLock) &#123;</span><br><span class="line">                <span class="comment">//【3.3】更新 AppIdleHistory 中的屏幕信息！</span></span><br><span class="line">                mAppIdleHistory.updateDisplayLocked(displayOn, SystemClock.elapsedRealtime());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当屏幕的状态发生变化后，会触发 DisplayListener.onDisplayChanged 方法，紧接着触发 AppIdleHistory.updateDisplayLocked 方法！</p>
<h3 id="3-2-1-AppIdleHistory-updateDisplayLocked"><a href="#3-2-1-AppIdleHistory-updateDisplayLocked" class="headerlink" title="3.2.1 AppIdleHistory.updateDisplayLocked"></a>3.2.1 AppIdleHistory.updateDisplayLocked</h3><p>updateDisplayLocked 方法用于更新屏幕状态信息！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateDisplayLocked</span><span class="params">(<span class="keyword">boolean</span> screenOn, <span class="keyword">long</span> elapsedRealtime)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】如果相等，无需更新！</span></span><br><span class="line">    <span class="keyword">if</span> (screenOn == mScreenOn) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//【2】更新 mScreenOn 的值；</span></span><br><span class="line">    mScreenOn = screenOn;</span><br><span class="line">    <span class="comment">//【3】根据当前屏幕的状态，更新不同的值；</span></span><br><span class="line">    <span class="keyword">if</span> (mScreenOn) &#123;</span><br><span class="line">        <span class="comment">//【3.1】如果此时亮屏，记录亮屏时间点！</span></span><br><span class="line">        mScreenOnSnapshot = elapsedRealtime;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//【3.2】如果此时灭屏，记录本次亮屏时长，累加到 mScreenOnDuration；</span></span><br><span class="line">        mScreenOnDuration += elapsedRealtime - mScreenOnSnapshot; </span><br><span class="line">        <span class="comment">// 计算距离上次灭屏时间点的时间间隔，累加到 mElapsedDuration；</span></span><br><span class="line">        mElapsedDuration += elapsedRealtime - mElapsedSnapshot;</span><br><span class="line">        <span class="comment">// 记录最新灭屏时间点；</span></span><br><span class="line">        mElapsedSnapshot = elapsedRealtime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 isDisplayOn 方法，来判断当前是亮屏还是熄屏：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isDisplayOn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mDisplayManager</span><br><span class="line">            .getDisplay(Display.DEFAULT_DISPLAY).getState() == Display.STATE_ON;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>AppIdleHistory 内部是有一个变量 mScreenOn，保存屏幕的状态信息，默认为 false：</p>
<p>mScreenOnSnapshot 用于每次亮屏的时间点，mElapsedSnapshot 用于记录每次灭屏的时间点；</p>
<p>mScreenOnDuration 用于累计所有亮屏的总时长，mElapsedDuration 用于了累计所有相邻两次灭屏的总时长！</p>
<p>如果是此时是亮屏的话，会将时间记录到 mScreenOnSnapshot 中！</p>
<h2 id="3-4-UsageStatsS-postOneTimeCheckIdleStates"><a href="#3-4-UsageStatsS-postOneTimeCheckIdleStates" class="headerlink" title="3.4 UsageStatsS.postOneTimeCheckIdleStates"></a>3.4 UsageStatsS.postOneTimeCheckIdleStates</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOneTimeCheckIdleStates</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDeviceIdleController == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mPendingOneTimeCheckIdleStates = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//【4.7】发送 MSG_ONE_TIME_CHECK_IDLE_STATES 消息给 H，触发 check idle 操作！</span></span><br><span class="line">        mHandler.sendEmptyMessage(MSG_ONE_TIME_CHECK_IDLE_STATES);</span><br><span class="line">        mPendingOneTimeCheckIdleStates = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>如果 mDeviceIdleController 为 null，说明 UsageStatsService 还没有启动完成，这里会先将 mPendingOneTimeCheckIdleStates 置为 true！等到启动完成后会判断该变量的值，如果为 true，那就会继续调用 postOneTimeCheckIdleStates 方法！</p>
</li>
<li><p>如果 mDeviceIdleController 不为 null，发送 MSG_ONE_TIME_CHECK_IDLE_STATES 消息给 H，触发 check idle 操作！同时设置 mPendingOneTimeCheckIdleStates 为 false；</p>
</li>
</ul>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2016/10/29/Serivce 篇 8 - Service stopSelf 流程分析/">Serivce 篇 8 - Service stopSelf 流程分析</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2016-10-29</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/AndroidFramework源码分析/">AndroidFramework源码分析</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/AndroidFramework源码分析/Service服务/">Service服务</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Service服务/">Service服务</a></span><div class="content"><p>本文基于 <code>Android 7.1.1</code> 源码分析，转载请说明出处！</p>
<h1 id="0-综述"><a href="#0-综述" class="headerlink" title="0 综述"></a>0 综述</h1><p>对于 <code>Service</code>，我们除了可以调用 <code>stopService</code> 来停止服务，服务自身也可以调用 <code>stopSelf</code> 方法停止，下面我们来看看这几个方法！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public final void stopSelf() &#123;</span><br><span class="line">    stopSelf(-1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final void stopSelf(int startId) &#123;</span><br><span class="line">    if (mActivityManager == null) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        mActivityManager.stopServiceToken(</span><br><span class="line">                new ComponentName(this, mClassName), mToken, startId);</span><br><span class="line">    &#125; catch (RemoteException ex) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public final boolean stopSelfResult(int startId) &#123;</span><br><span class="line">    if (mActivityManager == null) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    try &#123;</span><br><span class="line">        return mActivityManager.stopServiceToken(</span><br><span class="line">                new ComponentName(this, mClassName), mToken, startId);</span><br><span class="line">    &#125; catch (RemoteException ex) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这几个方法有什么区别呢？这里先简单的说一下：</p>
<ul>
<li><code>stopSelf()</code> 方法，会调用第二个 <code>stopSelf(int startId)</code> 方法，如果服务之前通过 <code>startService</code> 方法启动过了，那该方法就等价于调用 <code>stopService</code> 方法！</li>
<li><code>stopSelf(int startId)</code> 方法，是 <code>stopSelfResult</code> 方法的旧版本，不会返回任何结果！</li>
<li><code>stopSelfResult(int startId)</code> 方法，通过指定启动项的 <code>startId</code> 来停止服务，该方法也等价于 <code>stopService</code> 方法，但是它能避免在停止服务时，服务仍没有接收到启动项！</li>
</ul>
<p>下面，我们来看看该方法的调用过程！</p>
<h1 id="1-系统进程"><a href="#1-系统进程" class="headerlink" title="1 系统进程"></a>1 系统进程</h1><p>这里省略了 <code>Binder</code> 调用的过程，<code>Binder</code> 客户端发送 <code>STOP_SERVICE_TOKEN_TRANSACTION</code> 到 <code>Binder</code> 服务端，进入系统进程中！！</p>
<h2 id="1-1-ActivityManagerS-stopServiceToken"><a href="#1-1-ActivityManagerS-stopServiceToken" class="headerlink" title="1.1 ActivityManagerS.stopServiceToken"></a>1.1 ActivityManagerS.stopServiceToken</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean stopServiceToken(ComponentName className, IBinder token,</span><br><span class="line">        int startId) &#123;</span><br><span class="line">        </span><br><span class="line">    synchronized(this) &#123;</span><br><span class="line">        return mServices.stopServiceTokenLocked(className, token, startId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们来解释一下参数：</p>
<ul>
<li><strong>ComponentName className</strong>：服务对应的 <code>ComponentName</code> 对象。封装了组件信息，包括其所在的运行环境，对应的 <code>.class</code> 文件名！</li>
<li><strong>IBinder token</strong>：<code>ServiceRecord</code> 对象，在启动服务时，会将该对象保存到 <code>Service</code> 的</li>
<li><strong>int startId</strong>：启动项的 <code>id</code> 值；</li>
</ul>
<h2 id="1-2-ActiveServices-stopServiceToken"><a href="#1-2-ActiveServices-stopServiceToken" class="headerlink" title="1.2 ActiveServices.stopServiceToken"></a>1.2 ActiveServices.stopServiceToken</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">stopServiceTokenLocked</span><span class="params">(ComponentName className, IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">"stopServiceToken: "</span> + className</span><br><span class="line">            + <span class="string">" "</span> + token + <span class="string">" startId="</span> + startId);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【1】尝试根据服务的信息，匹配到对应的 ServiceRecord 对象！</span></span><br><span class="line">    ServiceRecord r = findServiceLocked(className, token, UserHandle.getCallingUserId());</span><br><span class="line">    <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果指定了启动项目的 Id，进入该分支！</span></span><br><span class="line">        <span class="keyword">if</span> (startId &gt;= <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【2】从已经分发的启动项列表 deliveredStarts 中移除并返回找到 startId 对应的启动项 StartItem；</span></span><br><span class="line">            ServiceRecord.StartItem si = r.findDeliveredStart(startId, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (si != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (r.deliveredStarts.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    ServiceRecord.StartItem cur = r.deliveredStarts.remove(<span class="number">0</span>);</span><br><span class="line">                    cur.removeUriPermissionsLocked();</span><br><span class="line">                    <span class="keyword">if</span> (cur == si) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果指定的启动项 id 不是最后自动服务的启动项目，那就不能停止服务！</span></span><br><span class="line">            <span class="keyword">if</span> (r.getLastStartId() != startId) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (r.deliveredStarts.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"stopServiceToken startId "</span> + startId</span><br><span class="line">                        + <span class="string">" is last, but have "</span> + r.deliveredStarts.size()</span><br><span class="line">                        + <span class="string">" remaining args"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (r.stats.getBatteryStats()) &#123;</span><br><span class="line">            r.stats.stopRunningLocked();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将服务的 startRequested 置为 false，表示未请求启动；</span></span><br><span class="line">        r.startRequested = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (r.tracker != <span class="keyword">null</span>) &#123;</span><br><span class="line">            r.tracker.setStarted(<span class="keyword">false</span>, mAm.mProcessStats.getMemFactorLocked(),</span><br><span class="line">                    SystemClock.uptimeMillis());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将服务的 callStart 置为false，表示未执行启动；</span></span><br><span class="line">        r.callStart = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【3】停止服务！</span></span><br><span class="line">        bringDownServiceIfNeededLocked(r, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果没指定启动项的 <code>id</code>，即：<code>startId &gt;= 0</code>，那就要判断下该 <code>id</code> 是否对应了最后一个启动项，如果是，才会立刻停止！！<br>如果指定了启动项的 <code>id</code>，即：<code>startId &lt; 0</code>，那就立刻停止服务；</p>
<p>最后调用了 <code>bringDownServiceIfNeededLocked</code> 来停止服务，这里的逻辑就和 <code>stopService</code> 中的逻辑一样了！</p>
<p>下面我们来看看其他的几个方法：</p>
<ul>
<li><p>获得对应的 <code>ServiceRecord</code> 对象：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private final ServiceRecord findServiceLocked(ComponentName name,</span><br><span class="line">        IBinder token, int userId) &#123;</span><br><span class="line">    ServiceRecord r = getServiceByName(name, userId);</span><br><span class="line">    return r == token ? r : null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>找到 <code>id</code> 对应的启动项 <code>StartItem</code>： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public StartItem findDeliveredStart(int id, boolean remove) &#123;</span><br><span class="line">    final int N = deliveredStarts.size();</span><br><span class="line">    for (int i=0; i&lt;N; i++) &#123;</span><br><span class="line">        StartItem si = deliveredStarts.get(i);</span><br><span class="line">        if (si.id == id) &#123;</span><br><span class="line">            if (remove) deliveredStarts.remove(i);</span><br><span class="line">            return si;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这里就不在多书了，过程很清晰哦！</p>
</div><hr></div><div class="recent-post-item article-container"><a class="article-title" href="/2016/09/21/Serivce 篇 7 - Service restart 流程分析/">Serivce 篇 7 - Service restart 流程分析</a><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2016-09-21</time><span class="article-meta"><span class="article-meta__separator">|</span><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/AndroidFramework源码分析/">AndroidFramework源码分析</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox article-meta__icon" aria-hidden="true"></i><a class="article-meta__categories" href="/categories/AndroidFramework源码分析/Service服务/">Service服务</a></span><span class="article-meta tags"><span class="article-meta__separator">|</span><i class="fa fa-tag article-meta__icon" aria-hidden="true"></i><a class="article-meta__tags" href="/tags/Service服务/">Service服务</a></span><div class="content"><p>本文基于 Android 7.1.1 源码分析，转载请说明出处！</p>
<h1 id="0-综述"><a href="#0-综述" class="headerlink" title="0 综述"></a>0 综述</h1><p>当服务被 kill 掉后，会根据 onStartCommand 方法的返回值，来决定是否对服务进行重启，我们先来回顾下返回值类型：</p>
<ul>
<li><strong>START_STICKY</strong>：</li>
<li><strong>START_STICKY_COMPATIBILITY</strong>：<ul>
<li>删除本次启动的 startId 对应的启动项；</li>
<li>设置服务的 stopIfKilled 为 false；</li>
</ul>
</li>
<li><strong>START_NOT_STICKY</strong>： <ul>
<li>删除本次启动的服务的 startId 对应的启动项；</li>
<li>如果最后一次启动的启动项的 id(lastStartId) 等于本次启动的启动项的 id；<ul>
<li>设置服务的 stopIfKilled 为 true；</li>
</ul>
</li>
</ul>
</li>
<li><strong>START_REDELIVER_INTENT</strong>： <ul>
<li>不删除本次启动的 startId 对应的启动项；</li>
<li>如果本次启动的启动项不为 null；<ul>
<li>设置启动项的 deliveryCount 为 0；</li>
<li>设置启动项的 doneExecutingCount 加 1；</li>
<li>设置服务的 stopIfKilled 为 true；</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>下面，我们来分析下服务的重启过程，有两种情况会出现服务的重启：</p>
<p>第一种是，在拉起 Service 的 onCreate 方法时出现异常，这时如果服务没有被 destroy 掉，那就会尝试重新启动服务！</p>
<p>第二种是，服务所在的进程被 kill 掉了，这是会尝试重启服务！</p>
<h1 id="1-第一种情况"><a href="#1-第一种情况" class="headerlink" title="1 第一种情况"></a>1 第一种情况</h1><h2 id="1-1-ActiveServices-realStartServiceLocked"><a href="#1-1-ActiveServices-realStartServiceLocked" class="headerlink" title="1.1 ActiveServices.realStartServiceLocked"></a>1.1 ActiveServices.realStartServiceLocked</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">realStartServiceLocked</span><span class="params">(ServiceRecord r,</span></span></span><br><span class="line"><span class="function"><span class="params">        ProcessRecord app, <span class="keyword">boolean</span> execInFg)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line"></span><br><span class="line">    ... ... ... ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (r.stats.getBatteryStats()) &#123;</span><br><span class="line">            r.stats.startLaunchedLocked();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mAm.notifyPackageUse(r.serviceInfo.packageName,</span><br><span class="line">                             PackageManager.NOTIFY_PACKAGE_USE_SERVICE);</span><br><span class="line">        <span class="comment">// 更新服务的 state！</span></span><br><span class="line">        app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE);</span><br><span class="line">        <span class="comment">// 拉起服务的 onCreate 方法</span></span><br><span class="line">        app.thread.scheduleCreateService(r, r.serviceInfo,</span><br><span class="line">                mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),</span><br><span class="line">                app.repProcState);</span><br><span class="line">                </span><br><span class="line">        r.postNotification();</span><br><span class="line">        created = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (DeadObjectException e) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"Application dead when creating service "</span> + r);</span><br><span class="line">        mAm.appDiedLocked(app);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!created) &#123; <span class="comment">// created 为 false，表示拉起失败！</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> inDestroying = mDestroyingServices.contains(r);</span><br><span class="line">            serviceDoneExecutingLocked(r, inDestroying, inDestroying);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (newService) &#123;</span><br><span class="line">                app.services.remove(r);</span><br><span class="line">                r.app = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【1】如果服务没有被销毁掉，那就尝试重新启动服务！</span></span><br><span class="line">            <span class="keyword">if</span> (!inDestroying) &#123;</span><br><span class="line">                scheduleServiceRestartLocked(r, <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ... ... ... ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们继续来看！</p>
<h2 id="1-2-ActiveServices-scheduleServiceRestartLocked"><a href="#1-2-ActiveServices-scheduleServiceRestartLocked" class="headerlink" title="1.2 ActiveServices.scheduleServiceRestartLocked"></a>1.2 ActiveServices.scheduleServiceRestartLocked</h2><p>参数传递：</p>
<ul>
<li><code>ServiceRecord r</code>：要被重启的服务；</li>
<li><code>boolean allowCancel</code>：这里传入 <code>false</code>；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">scheduleServiceRestartLocked</span><span class="params">(ServiceRecord r,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> allowCancel)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 变量 cancel 用于表示是否放弃重启服务！</span></span><br><span class="line">        <span class="keyword">boolean</span> canceled = <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【1】如果系统在关机，那就不重启！</span></span><br><span class="line">        <span class="keyword">if</span> (mAm.isShuttingDownLocked()) &#123;</span><br><span class="line"></span><br><span class="line">            Slog.w(TAG, <span class="string">"Not scheduling restart of crashed service "</span> + r.shortName</span><br><span class="line">                    + <span class="string">" - system is shutting down"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ServiceMap smap = getServiceMap(r.userId);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【1】再次和服务集合中的服务匹配校验，如果不是同一个，那就停止重启！</span></span><br><span class="line">        <span class="keyword">if</span> (smap.mServicesByName.get(r.name) != r) &#123;</span><br><span class="line">            ServiceRecord cur = smap.mServicesByName.get(r.name);</span><br><span class="line"></span><br><span class="line">            Slog.wtf(TAG, <span class="string">"Attempting to schedule restart of "</span> + r</span><br><span class="line">                    + <span class="string">" when found in map: "</span> + cur);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【1.1】对于非常驻类型的服务，进入这个分支！    </span></span><br><span class="line">        <span class="keyword">if</span> ((r.serviceInfo.applicationInfo.flags</span><br><span class="line">                &amp;ApplicationInfo.FLAG_PERSISTENT) == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// minDuration 是被系统重启的时间间隔</span></span><br><span class="line">            <span class="keyword">long</span> minDuration = SERVICE_RESTART_DURATION;</span><br><span class="line">            <span class="comment">// resetTime 是重置这个重启时间的间隔</span></span><br><span class="line">            <span class="keyword">long</span> resetTime = SERVICE_RESET_RUN_DURATION;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 便利该服务的 deliveredStarts 集合，获得所有已经被分发的启动项！！</span></span><br><span class="line">            <span class="comment">// 对于那些之前已经分发但是没有完成的启动项，要重新加入到 pendingStarts 队列中！</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> N = r.deliveredStarts.size();</span><br><span class="line">            <span class="keyword">if</span> (N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=N-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">                    ServiceRecord.StartItem si = r.deliveredStarts.get(i);</span><br><span class="line">                    si.removeUriPermissionsLocked();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (si.intent == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!allowCancel || (si.deliveryCount &lt; ServiceRecord.MAX_DELIVERY_COUNT</span><br><span class="line">                            &amp;&amp; si.doneExecutingCount &lt; ServiceRecord.MAX_DONE_EXECUTING_COUNT)) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 如果不允许取消，显然这里 allowCancel 为 false；</span></span><br><span class="line">                        <span class="comment">// 或者该启动项的分发次数小于最大值 3 次，且处理次数小于最大值 6 次</span></span><br><span class="line">                        <span class="comment">// 才会把该启动项重新添加到 pendingStarts 列表中！</span></span><br><span class="line">                        r.pendingStarts.add(<span class="number">0</span>, si);</span><br><span class="line">                        </span><br><span class="line">                        <span class="keyword">long</span> dur = SystemClock.uptimeMillis() - si.deliveredTime;</span><br><span class="line">                        dur *= <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (minDuration &lt; dur) minDuration = dur;</span><br><span class="line">                        <span class="keyword">if</span> (resetTime &lt; dur) resetTime = dur;</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                        Slog.w(TAG, <span class="string">"Canceling start item "</span> + si.intent + <span class="string">" in service "</span></span><br><span class="line">                                + r.name);</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 置 canceled 为 true，表示放弃重启服务！</span></span><br><span class="line">                        canceled = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                r.deliveredStarts.clear();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 服务的重启次数加一；</span></span><br><span class="line">            r.totalRestartCount++;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 计算服务的重启延迟时间；</span></span><br><span class="line">            <span class="keyword">if</span> (r.restartDelay == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果没有重启过，restartDelay 为 0；</span></span><br><span class="line">                <span class="comment">// 那么重启延迟时间为 minDuration；</span></span><br><span class="line">                r.restartCount++;</span><br><span class="line">                r.restartDelay = minDuration;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果已经重启过了，进入以下分支；</span></span><br><span class="line">                <span class="comment">// restartTime 是上一次重启的时间；</span></span><br><span class="line">                <span class="keyword">if</span> (now &gt; (r.restartTime+resetTime)) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 并且当前时间距离上次重启时间超过了 resetTime，</span></span><br><span class="line">                    <span class="comment">// 则把 restartCount 重置为 1，restartDelay 设为 minDuration！</span></span><br><span class="line">                    r.restartCount = <span class="number">1</span>;</span><br><span class="line">                    r.restartDelay = minDuration;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 并且当前时间距离上次重启时间没有超过 resetTime，则调大 restartDelay！</span></span><br><span class="line">                    r.restartDelay *= SERVICE_RESTART_DURATION_FACTOR;</span><br><span class="line">                    <span class="keyword">if</span> (r.restartDelay &lt; minDuration) &#123;</span><br><span class="line">                        r.restartDelay = minDuration;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算服务的下一次重启时间</span></span><br><span class="line">            r.nextRestartTime = now + r.restartDelay;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置所有服务的重启时间差最小为 10 秒！</span></span><br><span class="line">            <span class="comment">// 一个服务重启后，下一个服务至少 10 后才能被重启！</span></span><br><span class="line">            <span class="keyword">boolean</span> repeat;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                repeat = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=mRestartingServices.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">                    ServiceRecord r2 = mRestartingServices.get(i);</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span> (r2 != r &amp;&amp; r.nextRestartTime</span><br><span class="line">                            &gt;= (r2.nextRestartTime-SERVICE_MIN_RESTART_TIME_BETWEEN)</span><br><span class="line">                            &amp;&amp; r.nextRestartTime</span><br><span class="line">                            &lt; (r2.nextRestartTime+SERVICE_MIN_RESTART_TIME_BETWEEN)) &#123;</span><br><span class="line"></span><br><span class="line">                        r.nextRestartTime = r2.nextRestartTime + SERVICE_MIN_RESTART_TIME_BETWEEN;</span><br><span class="line">                        r.restartDelay = r.nextRestartTime - now;</span><br><span class="line">                        repeat = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">while</span> (repeat);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【1.2】常驻进程的服务要被立刻重启！</span></span><br><span class="line">            r.totalRestartCount++;</span><br><span class="line">            r.restartCount = <span class="number">0</span>;</span><br><span class="line">            r.restartDelay = <span class="number">0</span>;</span><br><span class="line">            r.nextRestartTime = now;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【2】如果 mRestartingServices 列表中服务该服务，将该服务添加进去！</span></span><br><span class="line">        <span class="keyword">if</span> (!mRestartingServices.contains(r)) &#123;</span><br><span class="line">            r.createdFromFg = <span class="keyword">false</span>;</span><br><span class="line">            mRestartingServices.add(r);</span><br><span class="line">            r.makeRestarting(mAm.mProcessStats.getMemFactorLocked(), now);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【3】取消前台的 notification，这个是通过 startForegroud 的方式设置的！</span></span><br><span class="line">        cancelForegroudNotificationLocked(r);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【4】这里是最关键的地方，执行重启服务的操作！！</span></span><br><span class="line">        <span class="comment">// 这里会使用 AMS.MainHandler 来执行重启任务</span></span><br><span class="line">        mAm.mHandler.removeCallbacks(r.restarter);</span><br><span class="line">        mAm.mHandler.postAtTime(r.restarter, r.nextRestartTime);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算下次重启时间！</span></span><br><span class="line">        r.nextRestartTime = SystemClock.uptimeMillis() + r.restartDelay;</span><br><span class="line"></span><br><span class="line">        Slog.w(TAG, <span class="string">"Scheduling restart of crashed service "</span></span><br><span class="line">                + r.shortName + <span class="string">" in "</span> + r.restartDelay + <span class="string">"ms"</span>);</span><br><span class="line">        EventLog.writeEvent(EventLogTags.AM_SCHEDULE_SERVICE_RESTART,</span><br><span class="line">                r.userId, r.shortName, r.restartDelay);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> canceled;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这里涉及了几个常量：</p>
<ul>
<li><p>ActiveServices </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两个服务的重启间隔的最小值！</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SERVICE_MIN_RESTART_TIME_BETWEEN = <span class="number">10</span>*<span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务延迟重启的时间间隔</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SERVICE_RESTART_DURATION = <span class="number">1</span>*<span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置服务的重启时间的时间间隔</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SERVICE_RESET_RUN_DURATION = <span class="number">60</span>*<span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于扩大服务重启的时间间隔的乘法因子</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SERVICE_RESTART_DURATION_FACTOR = <span class="number">4</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ServiceRecord</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 放弃重启操作前，启动项分发的最大次数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_DELIVERY_COUNT = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 放弃重启操作前，启动项执行的最大次数</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_DONE_EXECUTING_COUNT = <span class="number">6</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>还记得 ServiceRestarter，在启动服务前，会创建一个 ServiceRestarter 对象，用于重启服务！</p>
<p>我们看到，如果服务之前重启过，并且当前时间距离上次重启时间没有超过 resetTime，则调大 restartDelay！</p>
<p>这是为了防止 service 被在内存不足的情况下被频繁重启，第一次内存不足时杀掉 service，1s 后重启该 service，重启后又消耗了一部分内存造成内存再次不足再次杀掉 service，这时1s后就不应该重启了，要往后推迟一段时间再尝试重启。</p>
<h1 id="3-ServiceRestarter-run"><a href="#3-ServiceRestarter-run" class="headerlink" title="3 ServiceRestarter.run"></a>3 ServiceRestarter.run</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceRestarter</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ServiceRecord mService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setService</span><span class="params">(ServiceRecord service)</span> </span>&#123;</span><br><span class="line">        mService = service;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(mAm) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//【1】重启服务！</span></span><br><span class="line">            performServiceRestartLocked(mService);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续看！</p>
<h1 id="4-ActiveServices-performServiceRestartLocked"><a href="#4-ActiveServices-performServiceRestartLocked" class="headerlink" title="4 ActiveServices.performServiceRestartLocked"></a>4 ActiveServices.performServiceRestartLocked</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performServiceRestartLocked</span><span class="params">(ServiceRecord r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果服务没有在重启列表中，就不重启！</span></span><br><span class="line">    <span class="keyword">if</span> (!mRestartingServices.contains(r)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果服务不再需要，就不重启！</span></span><br><span class="line">    <span class="keyword">if</span> (!isServiceNeeded(r, <span class="keyword">false</span>, <span class="keyword">false</span>)) &#123;</span><br><span class="line">        Slog.wtf(TAG, <span class="string">"Restarting service that is not needed: "</span> + r);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【1】进入 bringUpServiceLocked 方法，执行重启服务操作！</span></span><br><span class="line">        bringUpServiceLocked(r, r.intent.getIntent().getFlags(), r.createdFromFg, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TransactionTooLargeException e) &#123;</span><br><span class="line">        <span class="comment">// Ignore, it's been logged and nothing upstack cares.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里和前面的 startService 的逻辑是一样的！但是我们重点要看的是，对于 onStartCommand 方法的返回值，在重启的时候，系统是如何处理的！！</p>
<h1 id="5-onStartCommand-返回值的不同处理"><a href="#5-onStartCommand-返回值的不同处理" class="headerlink" title="5 onStartCommand 返回值的不同处理"></a>5 onStartCommand 返回值的不同处理</h1><h2 id="5-1-START-STICKY（默认返回值）"><a href="#5-1-START-STICKY（默认返回值）" class="headerlink" title="5.1 START_STICKY（默认返回值）"></a>5.1 START_STICKY（默认返回值）</h2><p>对于 Service.START_STICKY 的返回值，服务所在进程被 kill 后，系统会重新启动该服务以及所在进程！</p>
<p>onStartCommand 方法在返回 Service.START_STICKY 后，系统会做如下处理：</p>
<ul>
<li>从 r.deliveredStarts 中删除 startId 对应的启动项</li>
<li>设置 r.stopIfKilled = false</li>
<li>设置 r.callStart = true</li>
</ul>
<p>对于这种返回值，服务的 r.deliveredStarts 和 r.pendingStarts 中的启动项都为空，所以在 scheduleServiceRestartLocked 方法中，不会遍历 deliveredStarts 集合，所以 scheduleServiceRestartLocked 的返回值 canceled 为 false；</p>
<p>sr.startRequested 在开始启动时就被设置成了 true！这样，scheduleServiceRestartLocked 方法返回后，就不会进入这个分支：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sr.startRequested: true sr.stopIfKilled: false canceled: false，不进入该分支！</span></span><br><span class="line"><span class="keyword">if</span> (sr.startRequested &amp;&amp; (sr.stopIfKilled || canceled)) &#123;</span><br><span class="line"></span><br><span class="line">    ... ... ... </span><br><span class="line"></span><br><span class="line">    bringDownServiceLocked(sr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来，就是服务的重启了，这时就进入 bringUpServiceLocked 方法，因为对于 Service.START_STICKY 的返回值：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(r.startRequested &amp;&amp; r.callStart &amp;&amp; r.pendingStarts.size() == <span class="number">0</span>) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个的条件是满足的，那就会创建一个 Intent 为 null 启动项，添加到 r.pendingStarts 中，如果你在 onStartCommand 方法中，对参数 Intent 做一个非空判断，你会发现，这个 Intent 为 null！！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (intent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"the intent is null!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Service.START_STICKY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="5-2-START-NOT-STICKY"><a href="#5-2-START-NOT-STICKY" class="headerlink" title="5.2 START_NOT_STICKY"></a>5.2 START_NOT_STICKY</h2><p>对于 Service.START_NOT_STICKY 的返回值，服务所在进程被 kill 后，系统不会重新启动该服务以及所在进程！</p>
<p>onStartCommand 方法在返回 Service.START_NOT_STICKY 后，系统会做如下处理：</p>
<ul>
<li>从 r.deliveredStarts 中删除 startId 对应的启动项；</li>
<li>如果 r.getLastStartId() == startId，设置 r.stopIfKilled = true；（<strong>和 START_STICKY 的不同之处</strong>）</li>
<li>r.callStart = true；</li>
</ul>
<p>对于这种返回值，服务的 r.deliveredStarts 和 r.pendingStarts 中的启动项也都为空，所以在 scheduleServiceRestartLocked 方法中，不会遍历 deliveredStarts 集合，所以 scheduleServiceRestartLocked 的返回值 canceled 同样也为 false；</p>
<p>而 sr.startRequested 在开始启动时就被设置成了 true！这样，scheduleServiceRestartLocked 返回后，根据结果，就会进入这个分支：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sr.startRequested: true sr.stopIfKilled: true canceled: false</span></span><br><span class="line"><span class="keyword">if</span>(r.startRequested &amp;&amp; r.callStart &amp;&amp; r.pendingStarts.size() == <span class="number">0</span>) &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 同样的 sr.pendingStarts.size() == 0 满足条件，进入该分支！</span></span><br><span class="line">    <span class="keyword">if</span> (sr.pendingStarts.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        sr.startRequested = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (sr.tracker != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sr.tracker.setStarted(<span class="keyword">false</span>, mAm.mProcessStats.getMemFactorLocked(),</span><br><span class="line">                    SystemClock.uptimeMillis());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果之前服务没有自动创建的连接，就停止服务！</span></span><br><span class="line">        <span class="keyword">if</span> (!sr.hasAutoCreateConnections()) &#123;</span><br><span class="line">             bringDownServiceLocked(sr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果我们之前只是通过 startService 的方式，启动了服务，那么，这里就会调用 bringDownServiceLocked 停止服务，所以，<strong>单纯的 startService，如果 onStartCommand 返回值为 Service.START_NOT_STICKY，那么服务是不会重启的</strong>！</p>
<p>但是如果还通过 bindSerivce（Service.BIND_AUTO_CREATE）的方式创建了连接，那么还是会重启服务！</p>
<h2 id="5-2-START-REDELIVER-INTENT"><a href="#5-2-START-REDELIVER-INTENT" class="headerlink" title="5.2 START_REDELIVER_INTENT"></a>5.2 START_REDELIVER_INTENT</h2><p>对于 Service.START_REDELIVER_INTENT 的返回值，服务所在进程被 kill 后，系统会重新启动该服务以及所在进程，并且会将最后启动（startService）分发过的 Intent 再次通过 onStartCommand 方法传递给服务！</p>
<p>onStartCommand 方法在返回 START_REDELIVER_INTENT 后，系统会做如下处理:</p>
<ul>
<li>从 r.deliveredStarts 中获得 startId 对应的启动项 StartItem si ，【不删除】；</li>
<li>如果 si != null：<ul>
<li>si.deliveryCount = 0;</li>
<li>si.doneExecutingCount++;（这样设置，在 7.2.3 的时候，flags 就会被设置 START_FLAG_REDELIVER 的标签）</li>
<li>r.stopIfKilled = true;</li>
</ul>
</li>
<li>r.callStart = true;</li>
</ul>
<p>因为没有删除 r.deliveredStarts 中已经被分发的启动项，所以也就意味着，如果是多次 startSerivce，那么 r.deliveredStarts 会将所有的启动项都保留下来！</p>
<p>对于这种返回值，服务的 r.deliveredStarts 保存了所有的被分发的启动项，而 r.pendingStarts 中的启动项为空，我们先到 scheduleServiceRestartLocked 方法中去！</p>
<p>在 scheduleServiceRestartLocked 方法中，会将服务的 r.deliveredStarts 中所有的启动项，添加到 r.pendingStarts 中，用于重启后分发！</p>
<p>scheduleServiceRestartLocked 方法返回后，由于 sr.startRequested 为 true，sr.stopIfKilled 为 true， 且 canceled 为 false 满足条件，则会进入以下分支：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sr.startRequested: true sr.stopIfKilled: true canceled: false</span></span><br><span class="line"><span class="keyword">if</span>(r.startRequested &amp;&amp; r.callStart &amp;&amp; r.pendingStarts.size() == <span class="number">0</span>) &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 然而 sr.pendingStarts.size() ！= 0 ，不进入分支！</span></span><br><span class="line">    <span class="keyword">if</span> (sr.pendingStarts.size() == <span class="number">0</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是由于此时，sr.pendingStarts.size() 是不为 0 的，所以就不会停止服务，而是重启服务！因为所有的启动项 si.doneExecutingCount 都大于 0，所以 onStartCommand 方法的参数 flags 会设置 Service.START_FLAG_REDELIVERY 标志位！</p>
<p>当 onStartCommand 方法被拉起后，传入的 Intent 就是之前 startService 时传入的 Intent，如果之前多次调用了 startService 方法，那么当服务被重启后，onStartCommand 方法会被拉起多次，传入的 Intent 则是按照之前多次调用 startService 的 startId 顺序进行传入！</p>
<p>第二种是，当服务所在的进程因内存不足而被 <code>kill</code> 掉，会触发 <code>AMS.cleanUpApplicationRecordLocked</code> 方法，用于清理进程的资源：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">cleanUpApplicationRecordLocked</span><span class="params">(ProcessRecord app,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> restarting, <span class="keyword">boolean</span> allowRestart, <span class="keyword">int</span> index, <span class="keyword">boolean</span> replacingPid)</span> </span>&#123;</span><br><span class="line">    Slog.d(TAG, <span class="string">"cleanUpApplicationRecord -- "</span> + app.pid);</span><br><span class="line"></span><br><span class="line">    ... ... ... ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【1】这里会杀掉该进程中的所有服务，allownRestart 方式是否允许服务重启！</span></span><br><span class="line">    mServices.killServicesLocked(app, allowRestart);</span><br><span class="line">    </span><br><span class="line">    ... ... ... ...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="1-ActiveServices-killServicesLocked"><a href="#1-ActiveServices-killServicesLocked" class="headerlink" title="1 ActiveServices.killServicesLocked"></a>1 ActiveServices.killServicesLocked</h1><p>参数传递：</p>
<ul>
<li><code>ProcessRecord app</code>：被 <code>kill</code> 掉的进程！</li>
<li><code>boolean allowRestart</code>：表示是否重启服务，当进程被杀掉后，传入 <code>true</code>！</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">killServicesLocked</span><span class="params">(ProcessRecord app, <span class="keyword">boolean</span> allowRestart)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认不进入该分支，我们不看！</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">        ... ... ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清楚这个进程持有的所有的连接对象 ConnectionRecord！</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = app.connections.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        ConnectionRecord r = app.connections.valueAt(i);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这里和调用 unbindService 方法很类似，主要是解除该进程对其他服务的绑定！</span></span><br><span class="line">        removeConnectionLocked(r, app, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    updateServiceConnectionActivitiesLocked(app);</span><br><span class="line">    app.connections.clear();</span><br><span class="line"></span><br><span class="line">    app.whitelistManager = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】遍历被 kill 掉的进程中的所有服务!</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = app.services.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        ServiceRecord sr = app.services.valueAt(i);</span><br><span class="line">        <span class="keyword">synchronized</span> (sr.stats.getBatteryStats()) &#123;</span><br><span class="line">            sr.stats.stopLaunchedLocked();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果该服务所在进程不是当前进程，并且进程仍在运行，且不是常驻进程</span></span><br><span class="line">        <span class="comment">// 那就从服务所在进程中移除该服务！</span></span><br><span class="line">        <span class="keyword">if</span> (sr.app != app &amp;&amp; sr.app != <span class="keyword">null</span> &amp;&amp; !sr.app.persistent) &#123;</span><br><span class="line">            sr.app.services.remove(sr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sr.app = <span class="keyword">null</span>;</span><br><span class="line">        sr.isolatedProc = <span class="keyword">null</span>;</span><br><span class="line">        sr.executeNesting = <span class="number">0</span>;</span><br><span class="line">        sr.forceClearTracker();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mDestroyingServices.remove(sr)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">"killServices remove destroying "</span> + sr);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 在 ServiceRecord.bindings 中保存了绑定该服务的所有 intent 和 IntentBindRecord 的映射关系！</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> numClients = sr.bindings.size();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> bindingi=numClients-<span class="number">1</span>; bindingi&gt;=<span class="number">0</span>; bindingi--) &#123;</span><br><span class="line">            IntentBindRecord b = sr.bindings.valueAt(bindingi);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">"Killing binding "</span> + b</span><br><span class="line">                    + <span class="string">": shouldUnbind="</span> + b.hasBound);</span><br><span class="line">                </span><br><span class="line">            <span class="comment">// 初始化 IntentBindRecord 一切属性！  </span></span><br><span class="line">            b.binder = <span class="keyword">null</span>;</span><br><span class="line">            b.requested = b.received = b.hasBound = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If this binding is coming from a cached process and is asking to keep</span></span><br><span class="line">            <span class="comment">// the service created, then we'll kill the cached process as well -- we</span></span><br><span class="line">            <span class="comment">// don't want to be thrashing around restarting processes that are only</span></span><br><span class="line">            <span class="comment">// there to be cached.</span></span><br><span class="line">            <span class="comment">// 遍历 IntentBindRecord 对象的 apps 哈希表，该哈希表保存了使用该 Intent 绑定该服务的所有进程</span></span><br><span class="line">            <span class="comment">// ProcessRecord 和进程绑定信息 AppBindRecord 的映射关系！</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> appi=b.apps.size()-<span class="number">1</span>; appi&gt;=<span class="number">0</span>; appi--) &#123;</span><br><span class="line">                <span class="keyword">final</span> ProcessRecord proc = b.apps.keyAt(appi);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果进程被杀了或者没有启动，就跳过处理！</span></span><br><span class="line">                <span class="keyword">if</span> (proc.killedByAm || proc.thread == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Only do this for processes that have an auto-create binding;</span></span><br><span class="line">                <span class="comment">// otherwise the binding can be left, because it won't cause the</span></span><br><span class="line">                <span class="comment">// service to restart.</span></span><br><span class="line">                <span class="comment">// 判断该进程持有的所有连接对象 ConnectionRecord 是否是通过 BIND_FLAG_AUTO 方式创建的！</span></span><br><span class="line">                <span class="keyword">final</span> AppBindRecord abind = b.apps.valueAt(appi);</span><br><span class="line">                <span class="keyword">boolean</span> hasCreate = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> conni=abind.connections.size()-<span class="number">1</span>; conni&gt;=<span class="number">0</span>; conni--) &#123;</span><br><span class="line">                    ConnectionRecord conn = abind.connections.valueAt(conni);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> ((conn.flags&amp;(Context.BIND_AUTO_CREATE|Context.BIND_ALLOW_OOM_MANAGEMENT</span><br><span class="line">                            |Context.BIND_WAIVE_PRIORITY)) == Context.BIND_AUTO_CREATE) &#123;</span><br><span class="line">                            </span><br><span class="line">                        <span class="comment">// 设 hasCreate 为 true，表示存在自动创建的绑定！</span></span><br><span class="line">                        hasCreate = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!hasCreate) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 不存在自动创建的连接，就跳过这个服务！</span></span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果存在自动创建的连接，如果该进程不是常驻进程，并且该进程在运行中，</span></span><br><span class="line">                <span class="comment">// 该进程的 pid 不等于 0，也不等于系统进程 pid，且进程的状态不低于 PROCESS_STATE_LAST_ACTIVITY</span></span><br><span class="line">                <span class="comment">// 那就要尝试杀掉进程，解除绑定！</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">false</span> &amp;&amp; proc != <span class="keyword">null</span> &amp;&amp; !proc.persistent &amp;&amp; proc.thread != <span class="keyword">null</span></span><br><span class="line">                        &amp;&amp; proc.pid != <span class="number">0</span> &amp;&amp; proc.pid != ActivityManagerService.MY_PID</span><br><span class="line">                        &amp;&amp; proc.setProcState &gt;= ActivityManager.PROCESS_STATE_LAST_ACTIVITY) &#123;</span><br><span class="line"></span><br><span class="line">                    proc.kill(<span class="string">"bound to service "</span> + sr.name.flattenToShortString()</span><br><span class="line">                            + <span class="string">" in dying proc "</span> + (app != <span class="keyword">null</span> ? app.processName : <span class="string">"??"</span>), <span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ServiceMap smap = getServiceMap(app.userId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】开始处理被 kill 的进程中的服务！</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=app.services.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">        ServiceRecord sr = app.services.valueAt(i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果该进程不是常驻进程，就要从进程的 services 中移除该服务！</span></span><br><span class="line">        <span class="keyword">if</span> (!app.persistent) &#123;</span><br><span class="line">            app.services.removeAt(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前的服务和服务集合中的服务无法匹配，就跳过不处理！</span></span><br><span class="line">        <span class="keyword">final</span> ServiceRecord curRec = smap.mServicesByName.get(sr.name);</span><br><span class="line">        <span class="keyword">if</span> (curRec != sr) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curRec != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Slog.wtf(TAG, <span class="string">"Service "</span> + sr + <span class="string">" in process "</span> + app</span><br><span class="line">                        + <span class="string">" not same as in map: "</span> + curRec);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (allowRestart &amp;&amp; sr.crashCount &gt;= <span class="number">2</span> &amp;&amp; (sr.serviceInfo.applicationInfo.flags</span><br><span class="line">                &amp;ApplicationInfo.FLAG_PERSISTENT) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果允许重启，且服务的 crash 次数大于 2，并且服务不是常驻服务，停止服务！</span></span><br><span class="line">                </span><br><span class="line">            Slog.w(TAG, <span class="string">"Service crashed "</span> + sr.crashCount</span><br><span class="line">                    + <span class="string">" times, stopping: "</span> + sr);</span><br><span class="line"></span><br><span class="line">            EventLog.writeEvent(EventLogTags.AM_SERVICE_CRASHED_TOO_MUCH,</span><br><span class="line">                    sr.userId, sr.crashCount, sr.shortName, app.pid);</span><br><span class="line"></span><br><span class="line">            bringDownServiceLocked(sr);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!allowRestart</span><br><span class="line">                || !mAm.mUserController.isUserRunningLocked(sr.userId, <span class="number">0</span>)) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果不允许重启或者服务所在的设备用户不再运行状态，就停止服务！</span></span><br><span class="line">            bringDownServiceLocked(sr);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【2.1】尝试重启服务！</span></span><br><span class="line">            <span class="keyword">boolean</span> canceled = scheduleServiceRestartLocked(sr, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据尝试重启的结果，看是否需要停止服务！</span></span><br><span class="line">            <span class="keyword">if</span> (sr.startRequested &amp;&amp; (sr.stopIfKilled || canceled)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (sr.pendingStarts.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                    sr.startRequested = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (sr.tracker != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        sr.tracker.setStarted(<span class="keyword">false</span>, mAm.mProcessStats.getMemFactorLocked(),</span><br><span class="line">                                SystemClock.uptimeMillis());</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 如果之前服务没有自动创建的连接，就停止服务！</span></span><br><span class="line">                    <span class="keyword">if</span> (!sr.hasAutoCreateConnections()) &#123;</span><br><span class="line">                        bringDownServiceLocked(sr);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清理完成后！</span></span><br><span class="line">    <span class="comment">// 如果不允许重启，就把服务从 ServiceRecord 从 mRestartingServices 和 mPendingServices 中删除！</span></span><br><span class="line">    <span class="keyword">if</span> (!allowRestart) &#123;</span><br><span class="line">        app.services.clear();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=mRestartingServices.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line"></span><br><span class="line">            ServiceRecord r = mRestartingServices.get(i);</span><br><span class="line">            <span class="keyword">if</span> (r.processName.equals(app.processName) &amp;&amp;</span><br><span class="line">                    r.serviceInfo.applicationInfo.uid == app.info.uid) &#123;</span><br><span class="line"></span><br><span class="line">                mRestartingServices.remove(i);</span><br><span class="line">                clearRestartingIfNeededLocked(r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=mPendingServices.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            ServiceRecord r = mPendingServices.get(i);</span><br><span class="line">            <span class="keyword">if</span> (r.processName.equals(app.processName) &amp;&amp;</span><br><span class="line">                    r.serviceInfo.applicationInfo.uid == app.info.uid) &#123;</span><br><span class="line"></span><br><span class="line">                mPendingServices.remove(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 mDestroyingServices 中删除该服务！</span></span><br><span class="line">    <span class="keyword">int</span> i = mDestroyingServices.size();</span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        i--;</span><br><span class="line">        ServiceRecord sr = mDestroyingServices.get(i);</span><br><span class="line">        <span class="keyword">if</span> (sr.app == app) &#123;</span><br><span class="line"></span><br><span class="line">            sr.forceClearTracker();</span><br><span class="line">            mDestroyingServices.remove(i);</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">"killServices remove destroying "</span> + sr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    app.executingServices.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里会调用 <code>scheduleServiceRestartLocked</code> 方法来重启服务，我们继续看！</p>
<h1 id="10-总结"><a href="#10-总结" class="headerlink" title="10 总结"></a>10 总结</h1><h2 id="10-1-相关-Log"><a href="#10-1-相关-Log" class="headerlink" title="10.1 相关 Log"></a>10.1 相关 Log</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">01</span>-<span class="number">04</span> <span class="number">19</span>:<span class="number">28</span>:<span class="number">23.824</span>  <span class="number">1765</span>  <span class="number">3962</span> W ActiveServices:  scheduleServiceRestartLocked  N <span class="number">0</span> now <span class="number">7648574</span> r ServiceRecord&#123;<span class="number">9463951</span> u0 com.cooqi.servicedemo/.service.AService&#125;</span><br><span class="line"><span class="number">01</span>-<span class="number">04</span> <span class="number">19</span>:<span class="number">28</span>:<span class="number">23.824</span>  <span class="number">1765</span>  <span class="number">3962</span> W ActiveServices:  scheduleServiceRestartLocked  r.totalRestartCount <span class="number">2</span> r ServiceRecord&#123;<span class="number">9463951</span> u0 com.cooqi.servicedemo/.service.AService&#125;</span><br><span class="line"><span class="number">01</span>-<span class="number">04</span> <span class="number">19</span>:<span class="number">28</span>:<span class="number">23.824</span>  <span class="number">1765</span>  <span class="number">3962</span> W ActiveServices: r.name ComponentInfo&#123;com.cooqi.servicedemo/com.cooqi.servicedemo.service.AService&#125; N <span class="number">0</span> minDuration <span class="number">1000</span> resetTime <span class="number">60000</span> now <span class="number">7648574</span> r.restartDelay <span class="number">0</span> r.restartTime+resetTime <span class="number">7605288</span> allowCancel <span class="keyword">true</span></span><br><span class="line"><span class="number">01</span>-<span class="number">04</span> <span class="number">19</span>:<span class="number">28</span>:<span class="number">23.825</span>  <span class="number">1765</span>  <span class="number">3962</span> W ActiveServices: r.name ComponentInfo&#123;com.cooqi.servicedemo/com.cooqi.servicedemo.service.AService&#125; N <span class="number">0</span> minDuration <span class="number">1000</span> resetTime <span class="number">60000</span> now <span class="number">7648574</span> r.restartDelay <span class="number">1000</span> r.restartTime+resetTime <span class="number">7605288</span> r.nextRestartTime <span class="number">7649574</span> allowCancel <span class="keyword">true</span></span><br><span class="line"><span class="number">01</span>-<span class="number">04</span> <span class="number">19</span>:<span class="number">28</span>:<span class="number">23.825</span>  <span class="number">1765</span>  <span class="number">3962</span> W ActiveServices: r ServiceRecord&#123;<span class="number">9463951</span> u0 com.cooqi.servicedemo/.service.AService&#125; r.restartDelay <span class="number">1000</span> r.nextRestartTime <span class="number">7649574</span></span><br><span class="line"><span class="number">01</span>-<span class="number">04</span> <span class="number">19</span>:<span class="number">28</span>:<span class="number">23.825</span>  <span class="number">1765</span>  <span class="number">3962</span> W ActiveServices: r ServiceRecord&#123;<span class="number">9463951</span> u0 com.cooqi.servicedemo/.service.AService&#125; r.restartDelay <span class="number">1000</span> r.nextRestartTime <span class="number">7649575</span></span><br><span class="line"><span class="number">01</span>-<span class="number">04</span> <span class="number">19</span>:<span class="number">28</span>:<span class="number">23.825</span>  <span class="number">1765</span>  <span class="number">3962</span> W ActiveServices: Scheduling restart of crashed service com.cooqi.servicedemo/.service.AService in <span class="number">1000</span>ms</span><br><span class="line"><span class="number">01</span>-<span class="number">04</span> <span class="number">19</span>:<span class="number">28</span>:<span class="number">23.825</span>  <span class="number">1765</span>  <span class="number">3962</span> W ActiveServices: Restarting list - i <span class="number">0</span> r2.nextRestartTime <span class="number">7649575</span> r2.name ComponentInfo&#123;com.cooqi.servicedemo/com.cooqi.servicedemo.service.AService&#125;</span><br><span class="line"><span class="number">01</span>-<span class="number">04</span> <span class="number">19</span>:<span class="number">28</span>:<span class="number">23.826</span>  <span class="number">1765</span>  <span class="number">3962</span> V ActiveServices: scheduleServiceRestartLocked r ServiceRecord&#123;<span class="number">9463951</span> u0 com.cooqi.servicedemo/.service.AService&#125; call by com.android.server.am.ActiveServices.killServicesLocked:<span class="number">3066</span> com.android.server.am.ActivityManagerService.cleanUpApplicationRecordLocked:<span class="number">19081</span> com.android.server.am.ActivityManagerService.handleAppDiedLocked:<span class="number">5813</span> com.android.server.am.ActivityManagerService.appDiedLocked:<span class="number">5988</span> com.android.server.am.ActivityManagerService$AppDeathRecipient.binderDied:<span class="number">1656</span> android.os.BinderProxy.sendDeathNotice:<span class="number">688</span> &lt;bottom of call stack&gt; &lt;bottom of call stack&gt;</span><br><span class="line"><span class="number">01</span>-<span class="number">04</span> <span class="number">19</span>:<span class="number">28</span>:<span class="number">24.827</span>  <span class="number">1765</span>  <span class="number">1788</span> V ActiveServices: Bringing up ServiceRecord&#123;<span class="number">9463951</span> u0 com.cooqi.servicedemo/.service.AService&#125; android.content.Intent$FilterComparison@<span class="number">7</span>df9497b</span><br><span class="line"><span class="number">01</span>-<span class="number">04</span> <span class="number">19</span>:<span class="number">28</span>:<span class="number">24.828</span>  <span class="number">1765</span>  <span class="number">1788</span> V ActiveServices_MU: bringUpServiceLocked: appInfo.uid=<span class="number">10106</span> app=<span class="keyword">null</span></span><br><span class="line"><span class="number">01</span>-<span class="number">04</span> <span class="number">19</span>:<span class="number">28</span>:<span class="number">24.943</span>  <span class="number">1765</span>  <span class="number">1804</span> V ActiveServices_MU: realStartServiceLocked, ServiceRecord.uid = <span class="number">10106</span>, ProcessRecord.uid = <span class="number">10106</span></span><br><span class="line"><span class="number">01</span>-<span class="number">04</span> <span class="number">19</span>:<span class="number">28</span>:<span class="number">24.943</span>  <span class="number">1765</span>  <span class="number">1804</span> V ActiveServices: &gt;&gt;&gt; EXECUTING create of ServiceRecord&#123;<span class="number">9463951</span> u0 com.cooqi.servicedemo/.service.AService&#125; in app ProcessRecord&#123;ea46ad6 <span class="number">9319</span>:com.cooqi.servicedemo/u0a106&#125;</span><br><span class="line"><span class="number">01</span>-<span class="number">04</span> <span class="number">19</span>:<span class="number">28</span>:<span class="number">24.943</span>  <span class="number">1765</span>  <span class="number">1804</span> V ActiveServices: bumpServiceExecutingLocked r.executeNesting <span class="number">0</span></span><br><span class="line"><span class="number">01</span>-<span class="number">04</span> <span class="number">19</span>:<span class="number">28</span>:<span class="number">24.943</span>  <span class="number">1765</span>  <span class="number">1804</span> V ActiveServices: bumpServiceExecutingLocked r.app.executingServices.size() <span class="number">1</span></span><br><span class="line"><span class="number">01</span>-<span class="number">04</span> <span class="number">19</span>:<span class="number">28</span>:<span class="number">24.962</span>  <span class="number">1765</span>  <span class="number">1804</span> V ActiveServices: Sending arguments to: ServiceRecord&#123;<span class="number">9463951</span> u0 com.cooqi.servicedemo/.service.AService&#125; android.content.Intent$FilterComparison@<span class="number">7</span>df9497b args=<span class="keyword">null</span></span><br><span class="line"><span class="number">01</span>-<span class="number">04</span> <span class="number">19</span>:<span class="number">28</span>:<span class="number">24.962</span>  <span class="number">1765</span>  <span class="number">1804</span> V ActiveServices: &gt;&gt;&gt; EXECUTING start of ServiceRecord&#123;<span class="number">9463951</span> u0 com.cooqi.servicedemo/.service.AService&#125; in app ProcessRecord&#123;ea46ad6 <span class="number">9319</span>:com.cooqi.servicedemo/u0a106&#125;</span><br><span class="line"><span class="number">01</span>-<span class="number">04</span> <span class="number">19</span>:<span class="number">28</span>:<span class="number">24.962</span>  <span class="number">1765</span>  <span class="number">1804</span> V ActiveServices: bumpServiceExecutingLocked r.executeNesting <span class="number">1</span></span><br><span class="line"><span class="number">01</span>-<span class="number">04</span> <span class="number">19</span>:<span class="number">28</span>:<span class="number">25.112</span>  <span class="number">9319</span>  <span class="number">9319</span> D ServiceTest: AService: onCreate</span><br><span class="line"><span class="number">01</span>-<span class="number">04</span> <span class="number">19</span>:<span class="number">28</span>:<span class="number">25.112</span>  <span class="number">1765</span>  <span class="number">3964</span> V ActiveServices: serviceDoneExecutingLocked ServiceRecord= ServiceRecord&#123;<span class="number">9463951</span> u0 com.cooqi.servicedemo/.service.AService&#125; type= <span class="number">0</span> startId= <span class="number">0</span> res= <span class="number">0</span></span><br><span class="line"><span class="number">01</span>-<span class="number">04</span> <span class="number">19</span>:<span class="number">28</span>:<span class="number">25.112</span>  <span class="number">9319</span>  <span class="number">9319</span> D ServiceTest: AService: onStartCommand</span><br><span class="line"><span class="number">01</span>-<span class="number">04</span> <span class="number">19</span>:<span class="number">28</span>:<span class="number">25.113</span>  <span class="number">1765</span>  <span class="number">3964</span> V ActiveServices: &lt;&lt;&lt; DONE EXECUTING ServiceRecord&#123;<span class="number">9463951</span> u0 com.cooqi.servicedemo/.service.AService&#125;: nesting=<span class="number">2</span>, inDestroying=<span class="keyword">false</span>, app=ProcessRecord&#123;ea46ad6 <span class="number">9319</span>:com.cooqi.servicedemo/u0a106&#125;</span><br><span class="line"><span class="number">01</span>-<span class="number">04</span> <span class="number">19</span>:<span class="number">28</span>:<span class="number">25.113</span>  <span class="number">1765</span>  <span class="number">3964</span> V ActiveServices: serviceDoneExecutingLocked ServiceRecord= ServiceRecord&#123;<span class="number">9463951</span> u0 com.cooqi.servicedemo/.service.AService&#125; type= <span class="number">1</span> startId= <span class="number">6</span> res= <span class="number">1</span></span><br><span class="line"><span class="number">01</span>-<span class="number">04</span> <span class="number">19</span>:<span class="number">28</span>:<span class="number">25.113</span>  <span class="number">1765</span>  <span class="number">3964</span> V ActiveServices: &lt;&lt;&lt; DONE EXECUTING ServiceRecord&#123;<span class="number">9463951</span> u0 com.cooqi.servicedemo/.service.AService&#125;: nesting=<span class="number">1</span>, inDestroying=<span class="keyword">false</span>, app=ProcessRecord&#123;ea46ad6 <span class="number">9319</span>:com.cooqi.servicedemo/u0a106&#125;</span><br><span class="line"><span class="number">01</span>-<span class="number">04</span> <span class="number">19</span>:<span class="number">28</span>:<span class="number">25.113</span>  <span class="number">1765</span>  <span class="number">3964</span> V ActiveServices: Nesting at <span class="number">0</span> of com.cooqi.servicedemo/.service.AService</span><br><span class="line"><span class="number">01</span>-<span class="number">04</span> <span class="number">19</span>:<span class="number">28</span>:<span class="number">25.113</span>  <span class="number">1765</span>  <span class="number">3964</span> V ActiveServices: r.app.executingServices.size(): <span class="number">0</span></span><br><span class="line"><span class="number">01</span>-<span class="number">04</span> <span class="number">19</span>:<span class="number">28</span>:<span class="number">25.113</span>  <span class="number">1765</span>  <span class="number">3964</span> V ActiveServices: No more executingServices of com.cooqi.servicedemo/.service.AService</span><br></pre></td></tr></table></figure>
</div><hr></div><nav id="pagination"><div class="pagination"><a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-chevron-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2019 By Coolqi.Li</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_site_uv"><i class="fa fa-user"></i><span id="busuanzi_value_site_uv"></span><span></span></span><span class="footer-separator">|</span><span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i><span id="busuanzi_value_site_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.6"></script><script src="/js/fancybox.js?version=1.5.6"></script><script src="/js/sidebar.js?version=1.5.6"></script><script src="/js/copy.js?version=1.5.6"></script><script src="/js/fireworks.js?version=1.5.6"></script><script src="/js/transition.js?version=1.5.6"></script><script src="/js/scroll.js?version=1.5.6"></script><script src="/js/head.js?version=1.5.6"></script><script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"live2d-widget-model-hijiki"},"display":{"position":"right","width":110,"height":220},"mobile":{"show":false},"log":false});</script></body></html>