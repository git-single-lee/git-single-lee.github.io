<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Process篇 2 - Android 进程的创建"><meta name="keywords" content="Process进程"><meta name="author" content="Coolqi.Li"><meta name="copyright" content="Coolqi.Li"><title>Process篇 2 - Android 进程的创建 | Coolqi`s Blog</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://unpkg.com"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitment/style/default.min.css"><script src="https://cdn.jsdelivr.net/npm/gitment/dist/gitment.browser.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?b7acef5306e54116ad8a99e8b753a92d";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-前言"><span class="toc-text">1 前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-Process-prepare-fork"><span class="toc-text">2 Process - prepare fork</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-Process-start"><span class="toc-text">2.1 Process.start</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-Process-startViaZygote"><span class="toc-text">2.2 Process.startViaZygote</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-Process-openZygoteSocketIfNeeded"><span class="toc-text">2.2.1 Process.openZygoteSocketIfNeeded</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-Process-zygoteSendArgsAndGetResult"><span class="toc-text">2.3 Process.zygoteSendArgsAndGetResult</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-Zygote-fork-Process"><span class="toc-text">3 Zygote - fork Process</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-ZygoteInit-main"><span class="toc-text">3.1 ZygoteInit.main</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-ZygoteInit-runSelectLoop"><span class="toc-text">3.2 ZygoteInit.runSelectLoop</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-ZygoteConnection-runOnce"><span class="toc-text">3.3 ZygoteConnection.runOnce</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-1-Zygote-forkAndSpecialize-fork-子进程核心阶段"><span class="toc-text">3.3.1 Zygote.forkAndSpecialize - fork 子进程核心阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-1-ZygoteHooks-preFork-fork-准备工作"><span class="toc-text">3.3.1.1 ZygoteHooks.preFork - fork 准备工作</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-1-1-1-Daemons-stop"><span class="toc-text">3.3.1.1.1 Daemons.stop</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-1-1-2-ZygoteHooks-waitUntilAllThreadsStopped"><span class="toc-text">3.3.1.1.2 ZygoteHooks.waitUntilAllThreadsStopped</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-1-1-3-ZygoteHooks-nativePreFork"><span class="toc-text">3.3.1.1.3 ZygoteHooks.nativePreFork</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#3-3-1-1-3-1-Runtime-nativePreFork"><span class="toc-text">3.3.1.1.3.1 Runtime:nativePreFork</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-2-Zygote-nativeForkAndSpecialize-fork-子进程"><span class="toc-text">3.3.1.2 Zygote.nativeForkAndSpecialize - fork 子进程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-1-2-1-Zygote-CallPostForkChildHooks-子进程调用"><span class="toc-text">3.3.1.2.1 Zygote.CallPostForkChildHooks - 子进程调用</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#3-3-1-2-1-1-ZygoteHooks-postForkChild"><span class="toc-text">3.3.1.2.1.1 ZygoteHooks.postForkChild</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-3-1-2-1-2-ZygoteHooks-nativePostForkChild"><span class="toc-text">3.3.1.2.1.2 ZygoteHooks.nativePostForkChild</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#3-3-1-2-1-3-Runtime-InitNonZygoteOrPostFork"><span class="toc-text">3.3.1.2.1.3 Runtime.InitNonZygoteOrPostFork</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-3-ZygoteHooks-postForkCommon-fork-结束"><span class="toc-text">3.3.1.3 ZygoteHooks.postForkCommon - fork 结束</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-1-3-1-Daemons-start"><span class="toc-text">3.3.1.3.1 Daemons.start</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-4-阶段总结"><span class="toc-text">3.3.1.4 阶段总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-2-ZygoteConncection-handleChildProc-子进程处理"><span class="toc-text">3.3.2 ZygoteConncection.handleChildProc - 子进程处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-1-RuntimeInit-zygoteInit"><span class="toc-text">3.3.2.1 RuntimeInit.zygoteInit</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-2-1-1-RuntimeInit-commonInit-进程通用初始化"><span class="toc-text">3.3.2.1.1 RuntimeInit.commonInit - 进程通用初始化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-2-1-2-RuntimeInit-nativeZygoteInit-进程本地初始化"><span class="toc-text">3.3.2.1.2 RuntimeInit.nativeZygoteInit - 进程本地初始化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-2-1-3-RuntimeInit-applicationInit-初始化进程的-Application-对象"><span class="toc-text">3.3.2.1.3 RuntimeInit.applicationInit - 初始化进程的 Application 对象</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#3-3-2-1-3-1-RuntimeInit-invokeStaticMain"><span class="toc-text">3.3.2.1.3.1 RuntimeInit.invokeStaticMain</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-3-ZygoteConncection-handleParentProc-父进程处理"><span class="toc-text">3.3.3 ZygoteConncection.handleParentProc - 父进程处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-3-1-setChildPgid"><span class="toc-text">3.3.3.1 setChildPgid</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-MethodAndArgsCaller-run-处理异常"><span class="toc-text">3.4 MethodAndArgsCaller.run - 处理异常</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-总结"><span class="toc-text">4 总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-通信方式总结"><span class="toc-text">4.1 通信方式总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-调用流程总结"><span class="toc-text">4.2 调用流程总结</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.jpg"></div><div class="author-info__name text-center">Coolqi.Li</div><div class="author-info__description text-center">“Hi，我是李帅奇，Android 开发工程师，熬夜星人，一个努力赚钱，积极向上的好人。微信公众号：CoolOriLans (酷奇源语)”</div><div class="follow-button"><a href="https://github.com/single-li">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">88</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">21</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">26</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">coolqi 和他的朋友们</div><a class="author-info-links__name text-center" href="https://developer.android.google.cn/">AndroidDeveloper</a><a class="author-info-links__name text-center" href="http://www.android-studio.org/">AndroidStudio</a><a class="author-info-links__name text-center" href="https://www.jianshu.com/u/123a20a96441">个人简书</a><a class="author-info-links__name text-center" href="https://weibo.com/coolqiLi">个人微博</a><a class="author-info-links__name text-center" href="https://www.jianshu.com/u/fd0b722ce11f">小二哥的 Android 站</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/img/blog-bg.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Coolqi`s Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/about">About</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">Process篇 2 - Android 进程的创建</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2016-03-19</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/AndroidFramework源码分析/">AndroidFramework源码分析</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/AndroidFramework源码分析/Process进程/">Process进程</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">7k</span><span class="post-meta__separator">|</span><span>阅读时长: 33 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>[toc]</p>
<p>基于 Android 7.1.1 源码，分析进程的创建！</p>
<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h1><p>当 Android 系统在启动一个应用进程时，如果发现某个进程没有创建，那就要先创建这个进程， Android 系统中每一个应用进程，包括 SystemServer 进程都是由 Zygote 直接孵化出来的！</p>
<p>本片文章，就来总结下进程的 fork 流程！</p>
<h1 id="2-Process-prepare-fork"><a href="#2-Process-prepare-fork" class="headerlink" title="2 Process - prepare fork"></a>2 Process - prepare fork</h1><p>我们来继续看：</p>
<h2 id="2-1-Process-start"><a href="#2-1-Process-start" class="headerlink" title="2.1 Process.start"></a>2.1 Process.start</h2><p>框架层开始创建进程会调用 Process.start 方法，我们进入这个方法来看看：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ProcessStartResult <span class="title">start</span><span class="params">(<span class="keyword">final</span> String processClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">final</span> String niceName,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> uid, <span class="keyword">int</span> gid, <span class="keyword">int</span>[] gids,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> debugFlags, <span class="keyword">int</span> mountExternal,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> targetSdkVersion,</span></span></span><br><span class="line"><span class="function"><span class="params">                              String seInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                              String abi,</span></span></span><br><span class="line"><span class="function"><span class="params">                              String instructionSet,</span></span></span><br><span class="line"><span class="function"><span class="params">                              String appDataDir,</span></span></span><br><span class="line"><span class="function"><span class="params">                              String[] zygoteArgs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//【1】这里是进入 Zygote 方法了！</span></span><br><span class="line">        <span class="keyword">return</span> startViaZygote(processClass, niceName, uid, gid, gids,</span><br><span class="line">                debugFlags, mountExternal, targetSdkVersion, seInfo,</span><br><span class="line">                abi, instructionSet, appDataDir, zygoteArgs);</span><br><span class="line">                </span><br><span class="line">    &#125; <span class="keyword">catch</span> (ZygoteStartFailedEx ex) &#123;</span><br><span class="line">        Log.e(LOG_TAG,</span><br><span class="line">                <span class="string">"Starting VM process through Zygote failed"</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Starting VM process through Zygote failed"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-2-Process-startViaZygote"><a href="#2-2-Process-startViaZygote" class="headerlink" title="2.2 Process.startViaZygote"></a>2.2 Process.startViaZygote</h2><p>我们接着来看，进入了：startViaZygote 方法，参数传递：</p>
<ul>
<li>final String processClass,</li>
<li>final String niceName,</li>
<li>final int uid, </li>
<li>final int gid,</li>
<li>final int[] gids,</li>
<li>int debugFlags, </li>
<li>int mountExternal,</li>
<li>int targetSdkVersion,</li>
<li>String seInfo,</li>
<li>tring abi,</li>
<li>String instructionSet,</li>
<li>String appDataDir,</li>
<li>String[] extraArgs<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ProcessStartResult <span class="title">startViaZygote</span><span class="params">(<span class="keyword">final</span> String processClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">final</span> String niceName,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">final</span> <span class="keyword">int</span> uid, <span class="keyword">final</span> <span class="keyword">int</span> gid,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">final</span> <span class="keyword">int</span>[] gids,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> debugFlags, <span class="keyword">int</span> mountExternal,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> targetSdkVersion,</span></span></span><br><span class="line"><span class="function"><span class="params">                              String seInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">                              String abi,</span></span></span><br><span class="line"><span class="function"><span class="params">                              String instructionSet,</span></span></span><br><span class="line"><span class="function"><span class="params">                              String appDataDir,</span></span></span><br><span class="line"><span class="function"><span class="params">                              String[] extraArgs)</span></span></span><br><span class="line"><span class="function">                              <span class="keyword">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(Process.class) &#123;</span><br><span class="line">        <span class="comment">//【1】创建 cmd 命令libeia！ </span></span><br><span class="line">        ArrayList&lt;String&gt; argsForZygote = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// --runtime-args, --setuid=, --setgid=,</span></span><br><span class="line">        <span class="comment">// and --setgroups= must go first</span></span><br><span class="line">        argsForZygote.add(<span class="string">"--runtime-args"</span>);</span><br><span class="line">        argsForZygote.add(<span class="string">"--setuid="</span> + uid);</span><br><span class="line">        argsForZygote.add(<span class="string">"--setgid="</span> + gid);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> ((debugFlags &amp; Zygote.DEBUG_ENABLE_JNI_LOGGING) != <span class="number">0</span>) &#123;</span><br><span class="line">            argsForZygote.add(<span class="string">"--enable-jni-logging"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((debugFlags &amp; Zygote.DEBUG_ENABLE_SAFEMODE) != <span class="number">0</span>) &#123;</span><br><span class="line">            argsForZygote.add(<span class="string">"--enable-safemode"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((debugFlags &amp; Zygote.DEBUG_ENABLE_DEBUGGER) != <span class="number">0</span>) &#123;</span><br><span class="line">            argsForZygote.add(<span class="string">"--enable-debugger"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((debugFlags &amp; Zygote.DEBUG_ENABLE_CHECKJNI) != <span class="number">0</span>) &#123;</span><br><span class="line">            argsForZygote.add(<span class="string">"--enable-checkjni"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((debugFlags &amp; Zygote.DEBUG_GENERATE_DEBUG_INFO) != <span class="number">0</span>) &#123;</span><br><span class="line">            argsForZygote.add(<span class="string">"--generate-debug-info"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((debugFlags &amp; Zygote.DEBUG_ALWAYS_JIT) != <span class="number">0</span>) &#123;</span><br><span class="line">            argsForZygote.add(<span class="string">"--always-jit"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((debugFlags &amp; Zygote.DEBUG_NATIVE_DEBUGGABLE) != <span class="number">0</span>) &#123;</span><br><span class="line">            argsForZygote.add(<span class="string">"--native-debuggable"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((debugFlags &amp; Zygote.DEBUG_ENABLE_ASSERT) != <span class="number">0</span>) &#123;</span><br><span class="line">            argsForZygote.add(<span class="string">"--enable-assert"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mountExternal == Zygote.MOUNT_EXTERNAL_DEFAULT) &#123;</span><br><span class="line">            argsForZygote.add(<span class="string">"--mount-external-default"</span>);</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mountExternal == Zygote.MOUNT_EXTERNAL_READ) &#123;</span><br><span class="line">            argsForZygote.add(<span class="string">"--mount-external-read"</span>);</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mountExternal == Zygote.MOUNT_EXTERNAL_WRITE) &#123;</span><br><span class="line">            argsForZygote.add(<span class="string">"--mount-external-write"</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        argsForZygote.add(<span class="string">"--target-sdk-version="</span> + targetSdkVersion);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//TODO optionally enable debuger</span></span><br><span class="line">        <span class="comment">//argsForZygote.add("--enable-debugger");</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// --setgroups is a comma-separated list</span></span><br><span class="line">        <span class="keyword">if</span> (gids != <span class="keyword">null</span> &amp;&amp; gids.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            sb.append(<span class="string">"--setgroups="</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> sz = gids.length;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">                    sb.append(<span class="string">','</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                sb.append(gids[i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            argsForZygote.add(sb.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (niceName != <span class="keyword">null</span>) &#123;</span><br><span class="line">            argsForZygote.add(<span class="string">"--nice-name="</span> + niceName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (seInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">            argsForZygote.add(<span class="string">"--seinfo="</span> + seInfo);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (instructionSet != <span class="keyword">null</span>) &#123;</span><br><span class="line">            argsForZygote.add(<span class="string">"--instruction-set="</span> + instructionSet);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (appDataDir != <span class="keyword">null</span>) &#123;</span><br><span class="line">            argsForZygote.add(<span class="string">"--app-data-dir="</span> + appDataDir);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        argsForZygote.add(processClass);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (extraArgs != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String arg : extraArgs) &#123;</span><br><span class="line">                argsForZygote.add(arg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【2.3】接着调用 zygoteSendArgsAndGetResult 方法，让爱更进一步！</span></span><br><span class="line">        <span class="keyword">return</span> zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi), argsForZygote);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这个的过程是生成 argsForZygote 数组，里面分装了 Zygote 需要的参数！！</p>
<h3 id="2-2-1-Process-openZygoteSocketIfNeeded"><a href="#2-2-1-Process-openZygoteSocketIfNeeded" class="headerlink" title="2.2.1 Process.openZygoteSocketIfNeeded"></a>2.2.1 Process.openZygoteSocketIfNeeded</h3><p>这里调用了 openZygoteSocketIfNeeded 方法，根据当前的 abi 选择 Zygote 的位数：32 位还是 64 位的,然后连接 Zygote，并返回 Zygote 的引用对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ZygoteState <span class="title">openZygoteSocketIfNeeded</span><span class="params">(String abi)</span> <span class="keyword">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (primaryZygoteState == <span class="keyword">null</span> || primaryZygoteState.isClosed()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//【1】连接主zygote！ </span></span><br><span class="line">            primaryZygoteState = ZygoteState.connect(ZYGOTE_SOCKET);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(<span class="string">"Error connecting to primary zygote"</span>, ioe);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (primaryZygoteState.matches(abi)) &#123;</span><br><span class="line">        <span class="comment">//【2】主 Zygote 能和 abi 匹配，返回主 Zygote！</span></span><br><span class="line">        <span class="keyword">return</span> primaryZygoteState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (secondaryZygoteState == <span class="keyword">null</span> || secondaryZygoteState.isClosed()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//【3】主 Zygote 不能匹配，连接第二个zygote！ </span></span><br><span class="line">            secondaryZygoteState = ZygoteState.connect(SECONDARY_ZYGOTE_SOCKET);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(<span class="string">"Error connecting to secondary zygote"</span>, ioe);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (secondaryZygoteState.matches(abi)) &#123;</span><br><span class="line">        <span class="comment">//【4】返回第二个 Zygote！</span></span><br><span class="line">        <span class="keyword">return</span> secondaryZygoteState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(<span class="string">"Unsupported zygote ABI: "</span> + abi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们接着下面来看！</p>
<h2 id="2-3-Process-zygoteSendArgsAndGetResult"><a href="#2-3-Process-zygoteSendArgsAndGetResult" class="headerlink" title="2.3 Process.zygoteSendArgsAndGetResult"></a>2.3 Process.zygoteSendArgsAndGetResult</h2><p>最后，发送参数列表给 Zygote 进程，Zygote 进程会 fork 一个子进程，并返回子进程的 pid！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ProcessStartResult <span class="title">zygoteSendArgsAndGetResult</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ZygoteState zygoteState, ArrayList&lt;String&gt; args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ZygoteStartFailedEx </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//【1】判断输入参数格式是是否正确，中间不能有换行符！</span></span><br><span class="line">        <span class="keyword">int</span> sz = args.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (args.get(i).indexOf(<span class="string">'\n'</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(<span class="string">"embedded newlines not allowed"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> BufferedWriter writer = zygoteState.writer; <span class="comment">// 用于向 Zygote 写入数据！</span></span><br><span class="line">        <span class="keyword">final</span> DataInputStream inputStream = zygoteState.inputStream; <span class="comment">// 用于获得 Zygote 的返回数据！ </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//【2】首先，写入参数的个数！</span></span><br><span class="line">        writer.write(Integer.toString(args.size()));</span><br><span class="line">        writer.newLine();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span><br><span class="line">            String arg = args.get(i);</span><br><span class="line">            <span class="comment">//【2.1】写入每一个参数</span></span><br><span class="line">            writer.write(arg);</span><br><span class="line">            writer.newLine();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【3】flush BufferedWriter，参数会被写到 ZygoteConnection 对象的 abiList 集合中！</span></span><br><span class="line">        writer.flush();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【4】创建 ProcessStartResult 实例，记录启动结果，包括 pid</span></span><br><span class="line">        ProcessStartResult result = <span class="keyword">new</span> ProcessStartResult();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【5】systemServer 进入阻塞等待状态，直到进程创建成功，返回子进程的 pid！</span></span><br><span class="line">        result.pid = inputStream.readInt();</span><br><span class="line">        result.usingWrapper = inputStream.readBoolean();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (result.pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(<span class="string">"fork() failed"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        zygoteState.close();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteStartFailedEx(ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法的主要功能：通过 socket 向 Zygote 进程发送一个参数列表，然后进入阻塞等待状态，直到远端的 Socket 服务端发送回来新创建的进程 pid 才返回！！</p>
<p>以上这些过程仍然在 SystemServer 进程中，接下来，就要进入 Zygote 进程了！！！</p>
<h1 id="3-Zygote-fork-Process"><a href="#3-Zygote-fork-Process" class="headerlink" title="3 Zygote - fork Process"></a>3 Zygote - fork Process</h1><h2 id="3-1-ZygoteInit-main"><a href="#3-1-ZygoteInit-main" class="headerlink" title="3.1 ZygoteInit.main"></a>3.1 ZygoteInit.main</h2><p>接着是，进入了 Zygote 进程，我们先去看看 Zygote 的 main 方法看看：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String argv[])</span> </span>&#123;</span><br><span class="line">    ZygoteHooks.startZygoteNoThreadCreation();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        ... ... ...<span class="comment">// 这部分代码是启动 Zygote 时触发的，这个省略不看！</span></span><br><span class="line"></span><br><span class="line">        Log.i(TAG, <span class="string">"Accepting command socket connections"</span>);</span><br><span class="line">        <span class="comment">//【3.2】进入 runSeletLoop 方法！</span></span><br><span class="line">        runSelectLoop(abiList);</span><br><span class="line"></span><br><span class="line">        closeServerSocket();</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (MethodAndArgsCaller caller) &#123;</span><br><span class="line">        <span class="comment">//【3.4】上面的 runSelectLoop 方法会抛出 MethodAndArgsCaller 异常就会进入 caller.run 方法</span></span><br><span class="line">        <span class="comment">// 我们后面再看！</span></span><br><span class="line">        caller.run();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"Zygote died with exception"</span>, ex);</span><br><span class="line">        closeServerSocket();</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接着来看，进入了 runSelectLoop 方法，runSelectLoop 是一个死循环，不断的读取发送到 Zygote 的消息！</p>
<h2 id="3-2-ZygoteInit-runSelectLoop"><a href="#3-2-ZygoteInit-runSelectLoop" class="headerlink" title="3.2 ZygoteInit.runSelectLoop"></a>3.2 ZygoteInit.runSelectLoop</h2><p>这个方法很关键，在 openZygoteSocketIfNeeded 方法中，System Sever 会通过 Socket 建立和 Zygote 进程的连接，并向 Zygote 写入执行参数！</p>
<p>而 ZygoteInit.runSelectLoop 会创建一个循环，不断的读取 abiList 中的指令，进行处理！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runSelectLoop</span><span class="params">(String abiList)</span> <span class="keyword">throws</span> MethodAndArgsCaller </span>&#123;</span><br><span class="line">    ArrayList&lt;FileDescriptor&gt; fds = <span class="keyword">new</span> ArrayList&lt;FileDescriptor&gt;();</span><br><span class="line">    ArrayList&lt;ZygoteConnection&gt; peers = <span class="keyword">new</span> ArrayList&lt;ZygoteConnection&gt;();</span><br><span class="line"></span><br><span class="line">    fds.add(sServerSocket.getFileDescriptor());</span><br><span class="line">    peers.add(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【1】采用 I / O 多路复用机制，当客户端发出连接请求或者数据处理请求时，跳过 continue，执行后面的代码</span></span><br><span class="line">        StructPollfd[] pollFds = <span class="keyword">new</span> StructPollfd[fds.size()];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pollFds.length; ++i) &#123;</span><br><span class="line">            pollFds[i] = <span class="keyword">new</span> StructPollfd();</span><br><span class="line">            pollFds[i].fd = fds.get(i);</span><br><span class="line">            pollFds[i].events = (<span class="keyword">short</span>) POLLIN;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Os.poll(pollFds, -<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ErrnoException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"poll failed"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = pollFds.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((pollFds[i].revents &amp; POLLIN) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//【2】接收到客户端的连接请求，创建 ZygoteConnection 对象！</span></span><br><span class="line">                ZygoteConnection newPeer = acceptCommandPeer(abiList);</span><br><span class="line"></span><br><span class="line">                peers.add(newPeer);</span><br><span class="line">                fds.add(newPeer.getFileDesciptor());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//【3.3】执行 ZygoteConnection 的 runOnce 方法！</span></span><br><span class="line">                <span class="keyword">boolean</span> done = peers.get(i).runOnce();</span><br><span class="line">                <span class="keyword">if</span> (done) &#123;</span><br><span class="line">                    peers.remove(i);</span><br><span class="line">                    fds.remove(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>没有连接请求时会进入休眠状态，当有创建新进程的连接请求时，唤醒 Zygote 进程，创建 Socket 通道 ZygoteConnection，然后执行 ZygoteConnection 的 runOnce() 方法。</p>
<h2 id="3-3-ZygoteConnection-runOnce"><a href="#3-3-ZygoteConnection-runOnce" class="headerlink" title="3.3 ZygoteConnection.runOnce"></a>3.3 ZygoteConnection.runOnce</h2><p>这里我们看到 runOnce 方法会抛出一个 MethodAndArgsCaller 异常，但实际上 MethodAndArgsCaller 并不是在 runOnce 中抛出的！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">runOnce</span><span class="params">()</span> <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line"></span><br><span class="line">    String args[];</span><br><span class="line">    Arguments parsedArgs = <span class="keyword">null</span>;</span><br><span class="line">    FileDescriptor[] descriptors;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//【1】读取socket客户端发送过来的参数列表。</span></span><br><span class="line">        args = readArgumentList();</span><br><span class="line"></span><br><span class="line">        descriptors = mSocket.getAncillaryFileDescriptors();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">"IOException on command socket "</span> + ex.getMessage());</span><br><span class="line">        closeSocket();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (args == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// EOF reached.</span></span><br><span class="line">        closeSocket();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** the stderr of the most recent request, if avail */</span></span><br><span class="line">    PrintStream newStderr = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (descriptors != <span class="keyword">null</span> &amp;&amp; descriptors.length &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">        newStderr = <span class="keyword">new</span> PrintStream(</span><br><span class="line">                <span class="keyword">new</span> FileOutputStream(descriptors[<span class="number">2</span>]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> pid = -<span class="number">1</span>;</span><br><span class="line">    FileDescriptor childPipeFd = <span class="keyword">null</span>;</span><br><span class="line">    FileDescriptor serverPipeFd = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//【2】将 Socket 客户端传递过来的参数，解析成 Arguments 对象格式。</span></span><br><span class="line">        parsedArgs = <span class="keyword">new</span> Arguments(args);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (parsedArgs.abiListQuery) &#123;</span><br><span class="line">            <span class="keyword">return</span> handleAbiListQuery();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (parsedArgs.permittedCapabilities != <span class="number">0</span> || parsedArgs.effectiveCapabilities != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteSecurityException(<span class="string">"Client may not specify capabilities: "</span> +</span><br><span class="line">                    <span class="string">"permitted=0x"</span> + Long.toHexString(parsedArgs.permittedCapabilities) +</span><br><span class="line">                    <span class="string">", effective=0x"</span> + Long.toHexString(parsedArgs.effectiveCapabilities));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        applyUidSecurityPolicy(parsedArgs, peer);</span><br><span class="line">        applyInvokeWithSecurityPolicy(parsedArgs, peer);</span><br><span class="line"></span><br><span class="line">        applyDebuggerSystemProperty(parsedArgs);</span><br><span class="line">        applyInvokeWithSystemProperty(parsedArgs);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] rlimits = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (parsedArgs.rlimits != <span class="keyword">null</span>) &#123;</span><br><span class="line">            rlimits = parsedArgs.rlimits.toArray(intArray2d);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (parsedArgs.invokeWith != <span class="keyword">null</span>) &#123;</span><br><span class="line">            FileDescriptor[] pipeFds = Os.pipe2(O_CLOEXEC);</span><br><span class="line">            childPipeFd = pipeFds[<span class="number">1</span>];</span><br><span class="line">            serverPipeFd = pipeFds[<span class="number">0</span>];</span><br><span class="line">            Os.fcntlInt(childPipeFd, F_SETFD, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> [] fdsToClose = &#123; -<span class="number">1</span>, -<span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line">        FileDescriptor fd = mSocket.getFileDescriptor();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fd != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fdsToClose[<span class="number">0</span>] = fd.getInt$();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fd = ZygoteInit.getServerSocketFileDescriptor();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fd != <span class="keyword">null</span>) &#123;</span><br><span class="line">            fdsToClose[<span class="number">1</span>] = fd.getInt$();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fd = <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【3.3.1】这边是 Zygote 处理传入的参数，fork 子进程，返回 2 次</span></span><br><span class="line">        <span class="comment">// 分别进入父进程 Zygote 和新子进程中去！</span></span><br><span class="line">        pid = Zygote.forkAndSpecialize(parsedArgs.uid, parsedArgs.gid, parsedArgs.gids,</span><br><span class="line">                parsedArgs.debugFlags, rlimits, parsedArgs.mountExternal, parsedArgs.seInfo,</span><br><span class="line">                parsedArgs.niceName, fdsToClose, parsedArgs.instructionSet,</span><br><span class="line">                parsedArgs.appDataDir);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (ErrnoException ex) &#123;</span><br><span class="line">        logAndPrintError(newStderr, <span class="string">"Exception creating pipe"</span>, ex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">        logAndPrintError(newStderr, <span class="string">"Invalid zygote arguments"</span>, ex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ZygoteSecurityException ex) &#123;</span><br><span class="line">        logAndPrintError(newStderr,</span><br><span class="line">                <span class="string">"Zygote security policy prevents request: "</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//【4】fork一次，会返回两次，如果返回的是 0，表示当前是是在子进程中，</span></span><br><span class="line">        <span class="comment">// 如果返回值 &gt; 0，那当前就是在父进程中！</span></span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//【4.1】pid 为 0，在子进程中处理！</span></span><br><span class="line">            IoUtils.closeQuietly(serverPipeFd);</span><br><span class="line">            serverPipeFd = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【3.3.2】子进程执行，这里会抛出异常：MethodAndArgsCaller！</span></span><br><span class="line">            handleChildProc(parsedArgs, descriptors, childPipeFd, newStderr);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//【4.2】pid 大于 0，在父进程！</span></span><br><span class="line">            IoUtils.closeQuietly(childPipeFd);</span><br><span class="line">            childPipeFd = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【3.3.3】父进程 Zygote 执行！</span></span><br><span class="line">            <span class="keyword">return</span> handleParentProc(pid, descriptors, serverPipeFd, parsedArgs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        IoUtils.closeQuietly(childPipeFd);</span><br><span class="line">        IoUtils.closeQuietly(serverPipeFd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-1-Zygote-forkAndSpecialize-fork-子进程核心阶段"><a href="#3-3-1-Zygote-forkAndSpecialize-fork-子进程核心阶段" class="headerlink" title="3.3.1 Zygote.forkAndSpecialize - fork 子进程核心阶段"></a>3.3.1 Zygote.forkAndSpecialize - fork 子进程核心阶段</h3><p>这里开始 Fork 子进程！！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">forkAndSpecialize</span><span class="params">(<span class="keyword">int</span> uid, <span class="keyword">int</span> gid, <span class="keyword">int</span>[] gids, <span class="keyword">int</span> debugFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span>[][] rlimits, <span class="keyword">int</span> mountExternal, String seInfo, String niceName, <span class="keyword">int</span>[] fdsToClose,</span></span></span><br><span class="line"><span class="function"><span class="params">      String instructionSet, String appDataDir)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【3.3.1.1】fork 前的准备工作</span></span><br><span class="line">    VM_HOOKS.preFork();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【3.3.1.2】这里是 fork 子进程，调用了一个 naitve 方法。这个方法会返回 2 次！</span></span><br><span class="line">    <span class="keyword">int</span> pid = nativeForkAndSpecialize(</span><br><span class="line">              uid, gid, gids, debugFlags, rlimits, mountExternal, seInfo, niceName, fdsToClose,</span><br><span class="line">              instructionSet, appDataDir);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 监控子进程，直到 handleChildProc 结束！</span></span><br><span class="line">        Trace.setTracingEnabled(<span class="keyword">true</span>);</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"PostFork"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【3.3.1.3】fork 结束后的相关操作！</span></span><br><span class="line">    VM_HOOKS.postForkCommon();</span><br><span class="line">    <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里有一变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ZygoteHooks VM_HOOKS = <span class="keyword">new</span> ZygoteHooks();</span><br></pre></td></tr></table></figure>
<p>nativeForkAndSpecialize 方法会返回 2 次，一次 pid 为 0，表示是在子进程中；一次 pid 大于 0，表示是在 Zygote 进程中，意味着，postForkCommon 会执行 2 次！</p>
<p>接着来看：</p>
<h4 id="3-3-1-1-ZygoteHooks-preFork-fork-准备工作"><a href="#3-3-1-1-ZygoteHooks-preFork-fork-准备工作" class="headerlink" title="3.3.1.1 ZygoteHooks.preFork - fork 准备工作"></a>3.3.1.1 ZygoteHooks.preFork - fork 准备工作</h4><p>ZygoteHooks 的源码位于：D:\google\libcore\dalvik\src\main\java\dalvik\system\ZygoteHooks.java </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preFork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【3.3.1.1.1】停止 4 个 Daemon 子线程</span></span><br><span class="line">    Daemons.stop(); </span><br><span class="line">    <span class="comment">//【3.3.1.1.2】等待所有子线程结束</span></span><br><span class="line">    waitUntilAllThreadsStopped();</span><br><span class="line">    <span class="comment">//【3.3.1.1.3】完成 gc 堆的初始化工作</span></span><br><span class="line">    token = nativePreFork(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-3-1-1-1-Daemons-stop"><a href="#3-3-1-1-1-Daemons-stop" class="headerlink" title="3.3.1.1.1 Daemons.stop"></a>3.3.1.1.1 Daemons.stop</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HeapTaskDaemon.INSTANCE.stop();          <span class="comment">// Java堆整理线程</span></span><br><span class="line">    ReferenceQueueDaemon.INSTANCE.stop();    <span class="comment">// 引用队列线程</span></span><br><span class="line">    FinalizerDaemon.INSTANCE.stop();         <span class="comment">// 析构线程</span></span><br><span class="line">    FinalizerWatchdogDaemon.INSTANCE.stop(); <span class="comment">// 析构监控线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Zygote 是有 4 个子线程的，这里是需要停止这四个子线程，为 fork 操作空出资源来！</p>
<p>此处守护线程 Stop 方式是先调用目标线程 interrrupt 方法，然后再调用目标线程 join 方法，等待线程执行完成。</p>
<h5 id="3-3-1-1-2-ZygoteHooks-waitUntilAllThreadsStopped"><a href="#3-3-1-1-2-ZygoteHooks-waitUntilAllThreadsStopped" class="headerlink" title="3.3.1.1.2 ZygoteHooks.waitUntilAllThreadsStopped"></a>3.3.1.1.2 ZygoteHooks.waitUntilAllThreadsStopped</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">waitUntilAllThreadsStopped</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    File tasks = <span class="keyword">new</span> File(<span class="string">"/proc/self/task"</span>);</span><br><span class="line">    <span class="comment">//【1】判断 "/proc/self/task" 这个文件的长度！！</span></span><br><span class="line">    <span class="keyword">while</span> (tasks.list().length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">//【2】调用 yield 方法，出让 cpu！</span></span><br><span class="line">      Thread.yield();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-3-1-1-3-ZygoteHooks-nativePreFork"><a href="#3-3-1-1-3-ZygoteHooks-nativePreFork" class="headerlink" title="3.3.1.1.3 ZygoteHooks.nativePreFork"></a>3.3.1.1.3 ZygoteHooks.nativePreFork</h5><p>nativePreFork 通过 JNI 最终调用的是 dalvik_system_ZygoteHooks.cc 中的 ZygoteHooks_nativePreFork() 方法，如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">ZygoteHooks_nativePreFork</span><span class="params">(JNIEnv* env, jclass)</span> </span>&#123;</span><br><span class="line">    Runtime* runtime = Runtime::Current();</span><br><span class="line">    CHECK(runtime-&gt;IsZygote()) &lt;&lt; <span class="string">"runtime instance not started with -Xzygote"</span>;</span><br><span class="line">    <span class="comment">//【3.3.1.1.3.1】运行时堆的初始化！</span></span><br><span class="line">    runtime-&gt;PreZygoteFork(); </span><br><span class="line">    <span class="keyword">if</span> (Trace::GetMethodTracingMode() != TracingMode::kTracingInactive) &#123;</span><br><span class="line">        Trace::Pause();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【1】将线程类型转换为 long 型并保存到 token，该过程是非安全的。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;jlong&gt;(ThreadForEnv(env));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出：ZygoteHooks.preFork 方法主要的作用是：停止 Zygote 的停止这四个子线程，确保 fork 进程时，Zygote 是单线程的，同时初始化 gc 堆！！</p>
<p>ZygoteHooks_nativePreFork</p>
<h6 id="3-3-1-1-3-1-Runtime-nativePreFork"><a href="#3-3-1-1-3-1-Runtime-nativePreFork" class="headerlink" title="3.3.1.1.3.1 Runtime:nativePreFork"></a>3.3.1.1.3.1 Runtime:nativePreFork</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Runtime::PreZygoteFork() &#123;</span><br><span class="line">    <span class="comment">// 堆的初始化工作。这里是关于 art 虚拟机的，这里后面再说。</span></span><br><span class="line">    heap_-&gt;PreZygoteFork();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-1-2-Zygote-nativeForkAndSpecialize-fork-子进程"><a href="#3-3-1-2-Zygote-nativeForkAndSpecialize-fork-子进程" class="headerlink" title="3.3.1.2 Zygote.nativeForkAndSpecialize - fork 子进程"></a>3.3.1.2 Zygote.nativeForkAndSpecialize - fork 子进程</h4><p>调用这个方法 nativeForkAndSpecialize 来进行 fork 进程！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">native</span> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nativeForkAndSpecialize</span><span class="params">(<span class="keyword">int</span> uid, <span class="keyword">int</span> gid, <span class="keyword">int</span>[] gids,<span class="keyword">int</span> debugFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span>[][] rlimits, <span class="keyword">int</span> mountExternal, String seInfo, String niceName, <span class="keyword">int</span>[] fdsToClose,</span></span></span><br><span class="line"><span class="function"><span class="params">      String instructionSet, String appDataDir)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这是一个本地方法，最后调用的是  com_android_internal_os_Zygote_nativeForkAndSpecialize 方法，位于 frameworks\base\core\jni\com_android_internal_os_Zygote.cpp 中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jint <span class="title">com_android_internal_os_Zygote_nativeForkAndSpecialize</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        JNIEnv* env, jclass, jint uid, jint gid, jintArray gids,</span></span></span><br><span class="line"><span class="function"><span class="params">        jint debug_flags, jobjectArray rlimits,</span></span></span><br><span class="line"><span class="function"><span class="params">        jint mount_external, jstring se_info, jstring se_name,</span></span></span><br><span class="line"><span class="function"><span class="params">        jintArray fdsToClose, jstring instructionSet, jstring appDataDir)</span> </span>&#123;</span><br><span class="line">    jlong capabilities = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】这里对子进程的 uid 如果是 AID_BLUETOOTH 的情况做了处理！</span></span><br><span class="line">    <span class="comment">// 给你额外增加了一些权限和功能！！</span></span><br><span class="line">    <span class="keyword">if</span> (multiuser_get_app_id(uid) == AID_BLUETOOTH) &#123;</span><br><span class="line">      capabilities |= (<span class="number">1L</span>L &lt;&lt; CAP_WAKE_ALARM);</span><br><span class="line">      capabilities |= (<span class="number">1L</span>L &lt;&lt; CAP_NET_RAW);</span><br><span class="line">      capabilities |= (<span class="number">1L</span>L &lt;&lt; CAP_NET_BIND_SERVICE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】如果子进程的 gid 是 AID_WAKELOCK，我们会授予他 CAP_BLOCK_SUSPEND 的权限！</span></span><br><span class="line">    <span class="keyword">bool</span> gid_wakelock_found = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (gid == AID_WAKELOCK) &#123;</span><br><span class="line">      gid_wakelock_found = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (gids != <span class="literal">NULL</span>) &#123;</span><br><span class="line">      <span class="comment">//【3】如果子进程的 gids 中有 AID_WAKELOCK，会授予他 CAP_BLOCK_SUSPEND 的权限！</span></span><br><span class="line">      jsize gids_num = env-&gt;GetArrayLength(gids);</span><br><span class="line">      <span class="function">ScopedIntArrayRO <span class="title">ar</span><span class="params">(env, gids)</span></span>;</span><br><span class="line">      <span class="keyword">if</span> (ar.get() == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        RuntimeAbort(env, __LINE__, <span class="string">"Bad gids array"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; gids_num; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ar[i] == AID_WAKELOCK) &#123;</span><br><span class="line">          gid_wakelock_found = <span class="literal">true</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (gid_wakelock_found) &#123;</span><br><span class="line">      capabilities |= (<span class="number">1L</span>L &lt;&lt; CAP_BLOCK_SUSPEND);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【next】继续调用 ForkAndSpecializeCommon 方法！</span></span><br><span class="line">    <span class="keyword">return</span> ForkAndSpecializeCommon(env, uid, gid, gids, debug_flags,</span><br><span class="line">            rlimits, capabilities, capabilities, mount_external, se_info,</span><br><span class="line">            se_name, <span class="literal">false</span>, fdsToClose, instructionSet, appDataDir);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着，继续调用：ForkAndSpecializeCommon 方法，继续 fork！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> pid_t <span class="title">ForkAndSpecializeCommon</span><span class="params">(JNIEnv* env, uid_t uid, gid_t gid, jintArray javaGids,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     jint debug_flags, jobjectArray javaRlimits,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     jlong permittedCapabilities, jlong effectiveCapabilities,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     jint mount_external,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     jstring java_se_info, jstring java_se_name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     bool is_system_server, jintArray fdsToClose,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     jstring instructionSet, jstring dataDir)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//【1】设置子进程的 signal 信号处理函数! </span></span><br><span class="line">  SetSigChldHandler();</span><br><span class="line"></span><br><span class="line">#ifdef ENABLE_SCHED_BOOST</span><br><span class="line">  SetForkLoad(<span class="keyword">true</span>);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">  sigset_t sigchld;</span><br><span class="line">  sigemptyset(&amp;sigchld);</span><br><span class="line">  sigaddset(&amp;sigchld, SIGCHLD);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用 sigprocmask() 来暂时屏蔽/阻塞 SIGCHLD 信号，不然 SIGCHLD 信号会产生log，而被我们关闭掉的</span></span><br><span class="line">  <span class="comment">// logging 文件描述符会对这个信号进行响应，所以会报错</span></span><br><span class="line">  <span class="comment">// 到这里，zygote 进程就只有一个线程了！</span></span><br><span class="line">  <span class="keyword">if</span> (sigprocmask(SIG_BLOCK, &amp;sigchld, nullptr) == -<span class="number">1</span>) &#123;</span><br><span class="line">    ALOGE(<span class="string">"sigprocmask(SIG_SETMASK, &#123; SIGCHLD &#125;) failed: %s"</span>, strerror(errno));</span><br><span class="line">    RuntimeAbort(env, __LINE__, <span class="string">"Call to sigprocmask(SIG_BLOCK, &#123; SIGCHLD &#125;) failed."</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 关闭 log 系统</span></span><br><span class="line">  __android_log_close();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果是第一次 fork 进程，那么会创建 open FD table；否则，只需要检查 open FD 是否变化！</span></span><br><span class="line">  <span class="keyword">if</span> (gOpenFdTable == NULL) &#123;</span><br><span class="line">    gOpenFdTable = FileDescriptorTable::Create();</span><br><span class="line">    <span class="keyword">if</span> (gOpenFdTable == NULL) &#123;</span><br><span class="line">      RuntimeAbort(env, __LINE__, <span class="string">"Unable to construct file descriptor table."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!gOpenFdTable-&gt;Restat()) &#123;</span><br><span class="line">    RuntimeAbort(env, __LINE__, <span class="string">"Unable to restat file descriptor table."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//【2】这里是调用了 Linux 的 fork 方法，fork 进程，返回 2 次！</span></span><br><span class="line">  pid_t pid = fork();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//【3】根据 fork 的返回值，进行不同的处理！</span></span><br><span class="line">  <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//【3.1】pid 返回 0，进入子进程中执行！</span></span><br><span class="line">    gMallocLeakZygoteChild = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理掉那些需要被立刻关闭的文件描述符</span></span><br><span class="line">    DetachDescriptors(env, fdsToClose);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Re-open all remaining open file descriptors so that they aren't shared</span></span><br><span class="line">    <span class="comment">// with the zygote across a fork.</span></span><br><span class="line">    <span class="keyword">if</span> (!gOpenFdTable-&gt;ReopenOrDetach()) &#123;</span><br><span class="line">      RuntimeAbort(env, __LINE__, <span class="string">"Unable to reopen whitelisted descriptors."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sigprocmask(SIG_UNBLOCK, &amp;sigchld, nullptr) == -<span class="number">1</span>) &#123;</span><br><span class="line">      ALOGE(<span class="string">"sigprocmask(SIG_SETMASK, &#123; SIGCHLD &#125;) failed: %s"</span>, strerror(errno));</span><br><span class="line">      RuntimeAbort(env, __LINE__, <span class="string">"Call to sigprocmask(SIG_UNBLOCK, &#123; SIGCHLD &#125;) failed."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【3.1.1】非 root，禁止动态改变进程权限！</span></span><br><span class="line">    <span class="keyword">if</span> (uid != <span class="number">0</span>) &#123;</span><br><span class="line">      EnableKeepCapabilities(env);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【3.1.2】取消进程已有的 Capabilities 权限</span></span><br><span class="line">    DropCapabilitiesBoundingSet(env);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否使用 native bridge，这个模块基本上就是为了在JNI调用时进行动态转码用的！</span></span><br><span class="line">    <span class="comment">// 要使用 native bridge，至少要满足一下条件：</span></span><br><span class="line">    <span class="comment">// 1、不是 SystemServer 进程，NativeBridge 主要是用来解决 JNI 函数的兼容性问题的，SystemServer 是 fork 自 Zygote，</span></span><br><span class="line">    <span class="comment">// 但是它属于系统的一部分，肯定是根据所在平台而编译的，因此肯定不需要转指令集；</span></span><br><span class="line">    <span class="comment">// 2、NativeBridge 已经准备好了；</span></span><br><span class="line">    <span class="comment">// 3、dataDir 也不能为 null；</span></span><br><span class="line">    bool use_native_bridge = !is_system_server &amp;&amp; (instructionSet != NULL)</span><br><span class="line">        &amp;&amp; android::NativeBridgeAvailable();</span><br><span class="line">    <span class="keyword">if</span> (use_native_bridge) &#123;</span><br><span class="line">      <span class="function">ScopedUtfChars <span class="title">isa_string</span><span class="params">(env, instructionSet)</span></span>;</span><br><span class="line">      use_native_bridge = android::NeedsNativeBridge(isa_string.c_str());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (use_native_bridge &amp;&amp; dataDir == NULL) &#123;.</span><br><span class="line">      use_native_bridge = <span class="keyword">false</span>;</span><br><span class="line">      ALOGW(<span class="string">"Native bridge will not be used because dataDir == NULL."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!MountEmulatedStorage(uid, mount_external, use_native_bridge)) &#123;</span><br><span class="line">      ALOGW(<span class="string">"Failed to mount emulated storage: %s"</span>, strerror(errno));</span><br><span class="line">      <span class="keyword">if</span> (errno == ENOTCONN || errno == EROFS) &#123;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        RuntimeAbort(env, __LINE__, <span class="string">"Cannot continue without emulated storage"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【3.1.3】如果当前 fork 的子进程不是 system server 而是普通的应用进程的话，我们会创建进程组！</span></span><br><span class="line">    <span class="keyword">if</span> (!is_system_server) &#123;</span><br><span class="line">        <span class="keyword">int</span> rc = createProcessGroup(uid, getpid());</span><br><span class="line">        <span class="keyword">if</span> (rc != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (rc == -EROFS) &#123;</span><br><span class="line">                ALOGW(<span class="string">"createProcessGroup failed, kernel missing CONFIG_CGROUP_CPUACCT?"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ALOGE(<span class="string">"createProcessGroup(%d, %d) failed: %s"</span>, uid, pid, strerror(-rc));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【3.1.4】设置进程所属的 group！</span></span><br><span class="line">    SetGids(env, javaGids);</span><br><span class="line">    <span class="comment">//【3.1.5】设置资源 limit！</span></span><br><span class="line">    SetRLimits(env, javaRlimits);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (use_native_bridge) &#123;</span><br><span class="line">      <span class="function">ScopedUtfChars <span class="title">isa_string</span><span class="params">(env, instructionSet)</span></span>;</span><br><span class="line">      <span class="function">ScopedUtfChars <span class="title">data_dir</span><span class="params">(env, dataDir)</span></span>;</span><br><span class="line">      android::PreInitializeNativeBridge(data_dir.c_str(), isa_string.c_str());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【3.1.6】设置真实的、有效的和保存过的 gid</span></span><br><span class="line">    <span class="keyword">int</span> rc = setresgid(gid, gid, gid);</span><br><span class="line">    <span class="keyword">if</span> (rc == -<span class="number">1</span>) &#123;</span><br><span class="line">      ALOGE(<span class="string">"setresgid(%d) failed: %s"</span>, gid, strerror(errno));</span><br><span class="line">      RuntimeAbort(env, __LINE__, <span class="string">"setresgid failed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【3.1.7】设置真实的、有效的和保存过的 uid</span></span><br><span class="line">    rc = setresuid(uid, uid, uid);</span><br><span class="line">    <span class="keyword">if</span> (rc == -<span class="number">1</span>) &#123;</span><br><span class="line">      ALOGE(<span class="string">"setresuid(%d) failed: %s"</span>, uid, strerror(errno));</span><br><span class="line">      RuntimeAbort(env, __LINE__, <span class="string">"setresuid failed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (NeedsNoRandomizeWorkaround()) &#123;</span><br><span class="line">        <span class="comment">// Work around ARM kernel ASLR lossage (http://b/5817320).</span></span><br><span class="line">        <span class="keyword">int</span> old_personality = personality(<span class="number">0xffffffff</span>);</span><br><span class="line">        <span class="keyword">int</span> new_personality = personality(old_personality | ADDR_NO_RANDOMIZE);</span><br><span class="line">        <span class="keyword">if</span> (new_personality == -<span class="number">1</span>) &#123;</span><br><span class="line">            ALOGW(<span class="string">"personality(%d) failed: %s"</span>, new_personality, strerror(errno));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【3.1.8】设置新的 capabilities 权限</span></span><br><span class="line">    SetCapabilities(env, permittedCapabilities, effectiveCapabilities);</span><br><span class="line">    <span class="comment">//【3.1.9】设置调度策略</span></span><br><span class="line">    SetSchedulerPolicy(env);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得进程的主线程的 nice name</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* se_info_c_str = NULL;</span><br><span class="line">    ScopedUtfChars* se_info = NULL;</span><br><span class="line">    <span class="keyword">if</span> (java_se_info != NULL) &#123;</span><br><span class="line">        se_info = <span class="keyword">new</span> ScopedUtfChars(env, java_se_info);</span><br><span class="line">        se_info_c_str = se_info-&gt;c_str();</span><br><span class="line">        <span class="keyword">if</span> (se_info_c_str == NULL) &#123;</span><br><span class="line">          RuntimeAbort(env, __LINE__, <span class="string">"se_info_c_str == NULL"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* se_name_c_str = NULL;</span><br><span class="line">    ScopedUtfChars* se_name = NULL;</span><br><span class="line">    <span class="keyword">if</span> (java_se_name != NULL) &#123;</span><br><span class="line">        se_name = <span class="keyword">new</span> ScopedUtfChars(env, java_se_name);</span><br><span class="line">        se_name_c_str = se_name-&gt;c_str();</span><br><span class="line">        <span class="keyword">if</span> (se_name_c_str == NULL) &#123;</span><br><span class="line">          RuntimeAbort(env, __LINE__, <span class="string">"se_name_c_str == NULL"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【3.1.10】设置进程 selinux 上下文</span></span><br><span class="line">    rc = selinux_android_setcontext(uid, is_system_server, se_info_c_str, se_name_c_str);</span><br><span class="line">    <span class="keyword">if</span> (rc == -<span class="number">1</span>) &#123;</span><br><span class="line">      ALOGE(<span class="string">"selinux_android_setcontext(%d, %d, \"%s\", \"%s\") failed"</span>, uid,</span><br><span class="line">            is_system_server, se_info_c_str, se_name_c_str);</span><br><span class="line">      RuntimeAbort(env, __LINE__, <span class="string">"selinux_android_setcontext failed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【3.1.11】设置进程的主线程的 nice name，用于方便调试！</span></span><br><span class="line">    <span class="keyword">if</span> (se_info_c_str == NULL &amp;&amp; is_system_server) &#123;</span><br><span class="line">      se_name_c_str = <span class="string">"system_server"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (se_info_c_str != NULL) &#123;</span><br><span class="line">      SetThreadName(se_name_c_str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    delete se_info;</span><br><span class="line">    delete se_name;</span><br><span class="line">    <span class="comment">// 将子进程的 SIGCHLD 信号的处理函数修改回系统默认函数</span></span><br><span class="line">    UnsetSigChldHandler();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【*3.3.1.2.1】JNI 调，相当于 zygote.callPostForkChildHooks()，在子进程中执行</span></span><br><span class="line">    env-&gt;CallStaticVoidMethod(gZygoteClass, gCallPostForkChildHooks, debug_flags,</span><br><span class="line">                              is_system_server, instructionSet);</span><br><span class="line">    <span class="keyword">if</span> (env-&gt;ExceptionCheck()) &#123;</span><br><span class="line">      RuntimeAbort(env, __LINE__, <span class="string">"Error calling post fork hooks."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//【3.2】pid 大于 0 ，在父进程中执行，返回的 pid 的子进程的 pid！</span></span><br><span class="line"></span><br><span class="line">#ifdef ENABLE_SCHED_BOOST</span><br><span class="line">    <span class="comment">// unset scheduler knob</span></span><br><span class="line">    SetForkLoad(<span class="keyword">false</span>);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 sigprocmask() 取消屏蔽/阻塞 SIGCHLD 信号</span></span><br><span class="line">    <span class="keyword">if</span> (sigprocmask(SIG_UNBLOCK, &amp;sigchld, nullptr) == -<span class="number">1</span>) &#123;</span><br><span class="line">      ALOGE(<span class="string">"sigprocmask(SIG_SETMASK, &#123; SIGCHLD &#125;) failed: %s"</span>, strerror(errno));</span><br><span class="line">      RuntimeAbort(env, __LINE__, <span class="string">"Call to sigprocmask(SIG_UNBLOCK, &#123; SIGCHLD &#125;) failed."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Zygote 进程是所有 Android 进程的母体，包括 system_server 进程以及 App 进程都是由 Zygote 进程孵化而来。</p>
<p>zygote 利用 fork() 方法生成新进程，对于新进程 A 复用 Zygote 进程本身的资源，再加上新进程 A 相关的资源，构成新的应用进程 A 。</p>
<p>关于 native bridge，我没有过多研究，大家可以看看这个博客：</p>
<p><a href="https://blog.csdn.net/sinat_38172893/article/details/73274591" target="_blank" rel="noopener">https://blog.csdn.net/sinat_38172893/article/details/73274591</a></p>
<h5 id="3-3-1-2-1-Zygote-CallPostForkChildHooks-子进程调用"><a href="#3-3-1-2-1-Zygote-CallPostForkChildHooks-子进程调用" class="headerlink" title="3.3.1.2.1 Zygote.CallPostForkChildHooks - 子进程调用"></a>3.3.1.2.1 Zygote.CallPostForkChildHooks - 子进程调用</h5><p>上面通过反射再次调用了 Zygote 的 CallPostForkChildHooks 方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">callPostForkChildHooks</span><span class="params">(<span class="keyword">int</span> debugFlags, boolean isSystemServer,</span></span></span><br><span class="line"><span class="function"><span class="params">        String instructionSet)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【3.3.1.2.1.1】继续调用！</span></span><br><span class="line">    VM_HOOKS.postForkChild(debugFlags, isSystemServer, instructionSet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这边有调用了 ZygoteHooks 的 postForkChild 方法：</p>
<h6 id="3-3-1-2-1-1-ZygoteHooks-postForkChild"><a href="#3-3-1-2-1-1-ZygoteHooks-postForkChild" class="headerlink" title="3.3.1.2.1.1 ZygoteHooks.postForkChild"></a>3.3.1.2.1.1 ZygoteHooks.postForkChild</h6><p>这个方法是在 Zygote fork 出的子进程中调用的！！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postForkChild</span><span class="params">(<span class="keyword">int</span> debugFlags, boolean isSystemServer, String instructionSet)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【3.3.1.2.1.2】继续调用！ </span></span><br><span class="line">    nativePostForkChild(token, debugFlags, isSystemServer, instructionSet);</span><br><span class="line"></span><br><span class="line">    Math.setRandomSeedInternal(System.currentTimeMillis());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，这里传入了一个 token，这是是一个 long 型的值，用来保存线程的类型，在前面：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.3</span>.1.1.3 ZygoteHooks.nativePreFork</span><br></pre></td></tr></table></figure></p>
<p>nativePreFork 会将 Zygote 主线程的类型转换为 long 型，保存到 ZygoteHooks.token 中！</p>
<h6 id="3-3-1-2-1-2-ZygoteHooks-nativePostForkChild"><a href="#3-3-1-2-1-2-ZygoteHooks-nativePostForkChild" class="headerlink" title="3.3.1.2.1.2 ZygoteHooks.nativePostForkChild"></a>3.3.1.2.1.2 ZygoteHooks.nativePostForkChild</h6><p>我们继续看：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativePostForkChild</span><span class="params">(<span class="keyword">long</span> token, <span class="keyword">int</span> debugFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               <span class="keyword">boolean</span> isSystemServer, String instructionSet)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>这是一个 navtive 方法，最终调用 <strong>“\art\runtime\native\dalvik_system_ZygoteHooks.cc”</strong> 的 ZygoteHooks_nativePostForkChild 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ZygoteHooks_nativePostForkChild</span><span class="params">(JNIEnv* env,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            jclass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            jlong token,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            jint debug_flags,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            jboolean is_system_server,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            jstring instruction_set)</span> </span>&#123;</span><br><span class="line">                                            </span><br><span class="line">  Thread* thread = reinterpret_cast&lt;Thread*&gt;(token);</span><br><span class="line">  <span class="comment">// Our system thread ID, etc, has changed so reset Thread state.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//【1】初始化子进程的主线程！</span></span><br><span class="line">  <span class="comment">// 该方法主要是获得主线程的 tid！</span></span><br><span class="line">  thread-&gt;InitAfterFork();</span><br><span class="line">  </span><br><span class="line">  EnableDebugFeatures(debug_flags);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Update tracing.</span></span><br><span class="line">  <span class="keyword">if</span> (Trace::GetMethodTracingMode() != TracingMode::kTracingInactive) &#123;</span><br><span class="line">     ... ... ... ... <span class="comment">// 这里是和 tracing 相关，不是重点！</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (instruction_set != nullptr &amp;&amp; !is_system_server) &#123;</span><br><span class="line">    <span class="comment">//【2.1】非 SystemServer 子进程，走这里！</span></span><br><span class="line">    <span class="function">ScopedUtfChars <span class="title">isa_string</span><span class="params">(env, instruction_set)</span></span>;</span><br><span class="line">    InstructionSet isa = GetInstructionSetFromString(isa_string.c_str());</span><br><span class="line">    Runtime::NativeBridgeAction action = Runtime::NativeBridgeAction::kUnload;</span><br><span class="line">    <span class="keyword">if</span> (isa != kNone &amp;&amp; isa != kRuntimeISA) &#123;</span><br><span class="line">      action = Runtime::NativeBridgeAction::kInitialize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【3.3.1.2.1.3】调用 Runtime 的 InitNonZygoteOrPostFork 方法！！</span></span><br><span class="line">    Runtime::Current()-&gt;InitNonZygoteOrPostFork(</span><br><span class="line">        env, is_system_server, action, isa_string.c_str());</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="comment">//【2.2】SystemServer 进程，走这里，请看开机流程相关的内容！</span></span><br><span class="line">    Runtime::Current()-&gt;InitNonZygoteOrPostFork(</span><br><span class="line">        env, is_system_server, Runtime::NativeBridgeAction::kUnload, nullptr);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们主要分析下，非 SystemServer 子进程的逻辑处理，对于 SystemServer 进程的处理，请看开机启动流程文章内容！</p>
<h6 id="3-3-1-2-1-3-Runtime-InitNonZygoteOrPostFork"><a href="#3-3-1-2-1-3-Runtime-InitNonZygoteOrPostFork" class="headerlink" title="3.3.1.2.1.3 Runtime.InitNonZygoteOrPostFork"></a>3.3.1.2.1.3 Runtime.InitNonZygoteOrPostFork</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Runtime::InitNonZygoteOrPostFork(</span><br><span class="line">    JNIEnv* env, <span class="keyword">bool</span> is_system_server, NativeBridgeAction action, <span class="keyword">const</span> <span class="keyword">char</span>* isa) &#123;</span><br><span class="line">  is_zygote_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (is_native_bridge_loaded_) &#123; <span class="comment">// native bridge 相关逻辑！</span></span><br><span class="line">    <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">      <span class="keyword">case</span> NativeBridgeAction::kUnload:</span><br><span class="line">        UnloadNativeBridge();</span><br><span class="line">        is_native_bridge_loaded_ = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> NativeBridgeAction::kInitialize:</span><br><span class="line">        InitializeNativeBridge(env, isa);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建堆处理的线程池！</span></span><br><span class="line">  heap_-&gt;CreateThreadPool();</span><br><span class="line">  <span class="comment">// Reset the gc performance data at zygote fork so that the GCs</span></span><br><span class="line">  <span class="comment">// before fork aren't attributed to an app.</span></span><br><span class="line">  heap_-&gt;ResetGcPerformanceInfo();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 非 SystemServer 进程会进入这里！</span></span><br><span class="line">  <span class="keyword">if</span> (!is_system_server &amp;&amp;</span><br><span class="line">      !safe_mode_ &amp;&amp;</span><br><span class="line">      (jit_options_-&gt;UseJitCompilation() || jit_options_-&gt;GetSaveProfilingInfo()) &amp;&amp;</span><br><span class="line">      jit_.get() == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// 创建 JIT!</span></span><br><span class="line">    CreateJit();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置信号处理函数！</span></span><br><span class="line">  StartSignalCatcher();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 启动 JDWP 线程，当命令行 debuger 的 flags 指定"suspend=y"时，则暂停 runtime</span></span><br><span class="line">  Dbg::StartJdwp();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-1-3-ZygoteHooks-postForkCommon-fork-结束"><a href="#3-3-1-3-ZygoteHooks-postForkCommon-fork-结束" class="headerlink" title="3.3.1.3 ZygoteHooks.postForkCommon - fork 结束"></a>3.3.1.3 ZygoteHooks.postForkCommon - fork 结束</h4><p>这个方法会在父进程 Zygote 和子进程中各调用一次，也就是说，在父进程 Zygote 中是恢复 4 个 Daemon 线程，而在子进程中，是启动 4 个 Daemon 线程！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postForkCommon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【3.3.1.3.1】启动 Deamons 线程！</span></span><br><span class="line">    Daemons.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-3-1-3-1-Daemons-start"><a href="#3-3-1-3-1-Daemons-start" class="headerlink" title="3.3.1.3.1 Daemons.start"></a>3.3.1.3.1 Daemons.start</h5><p>ZygoteHooks.postForkCommon 方法很简单，启动 4 个 Daemon 线程，java堆整理，引用队列，以及析构线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ReferenceQueueDaemon.INSTANCE.start();</span><br><span class="line">    FinalizerDaemon.INSTANCE.start();</span><br><span class="line">    FinalizerWatchdogDaemon.INSTANCE.start();</span><br><span class="line">    HeapTaskDaemon.INSTANCE.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-1-4-阶段总结"><a href="#3-3-1-4-阶段总结" class="headerlink" title="3.3.1.4 阶段总结"></a>3.3.1.4 阶段总结</h4><p>首先来看看调用函数流程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Zygote.forkAndSpecialize</span><br><span class="line">    ZygoteHooks.preFork  <span class="comment">// 停掉 zygote 的子线程，为 fork 做准备！</span></span><br><span class="line">        Daemons.stop</span><br><span class="line">        ZygoteHooks.nativePreFork</span><br><span class="line">            dalvik_system_ZygoteHooks.ZygoteHooks_nativePreFork</span><br><span class="line">                Runtime::PreZygoteFork</span><br><span class="line">                    heap_-&gt;PreZygoteFork()</span><br><span class="line">                    </span><br><span class="line">    Zygote.nativeForkAndSpecialize   <span class="comment">// fork 阶段，该这个方法会返回 2 次！</span></span><br><span class="line">        com_android_internal_os_Zygote.ForkAndSpecializeCommon</span><br><span class="line">            fork()</span><br><span class="line">            Zygote.callPostForkChildHooks</span><br><span class="line">                ZygoteHooks.postForkChild</span><br><span class="line">                    dalvik_system_ZygoteHooks.nativePostForkChild</span><br><span class="line">                        Runtime::InitNonZygoteOrPostFork</span><br><span class="line">                        </span><br><span class="line">    ZygoteHooks.postForkCommon    <span class="comment">// 启动 4 个 Deamon 子线程！</span></span><br><span class="line">        Daemons.start</span><br></pre></td></tr></table></figure>
<p>这个流程很清楚啦，不都说了啦，嘿嘿嘿！</p>
<h3 id="3-3-2-ZygoteConncection-handleChildProc-子进程处理"><a href="#3-3-2-ZygoteConncection-handleChildProc-子进程处理" class="headerlink" title="3.3.2 ZygoteConncection.handleChildProc - 子进程处理"></a>3.3.2 ZygoteConncection.handleChildProc - 子进程处理</h3><p>我们知道，Zygote.forkAndSpecialize 会返回 2 次，当返回值为 0 时，进入子进程：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleChildProc</span><span class="params">(Arguments parsedArgs,</span></span></span><br><span class="line"><span class="function"><span class="params">        FileDescriptor[] descriptors, FileDescriptor pipeFd, PrintStream newStderr)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123; <span class="comment">// 抛出异常！</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】进程创建完毕，关闭 Socket 连接！</span></span><br><span class="line">    closeSocket();</span><br><span class="line">    ZygoteInit.closeServerSocket();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (descriptors != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Os.dup2(descriptors[<span class="number">0</span>], STDIN_FILENO);</span><br><span class="line">            Os.dup2(descriptors[<span class="number">1</span>], STDOUT_FILENO);</span><br><span class="line">            Os.dup2(descriptors[<span class="number">2</span>], STDERR_FILENO);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (FileDescriptor fd: descriptors) &#123;</span><br><span class="line">                IoUtils.closeQuietly(fd);</span><br><span class="line">            &#125;</span><br><span class="line">            newStderr = System.err;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ErrnoException ex) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">"Error reopening stdio"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (parsedArgs.niceName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//【2】设置进程的 niceName</span></span><br><span class="line">        Process.setArgV0(parsedArgs.niceName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// End of the postFork event.</span></span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (parsedArgs.invokeWith != <span class="keyword">null</span>) &#123;</span><br><span class="line">        WrapperInit.execApplication(parsedArgs.invokeWith,</span><br><span class="line">                parsedArgs.niceName, parsedArgs.targetSdkVersion,</span><br><span class="line">                VMRuntime.getCurrentInstructionSet(),</span><br><span class="line">                pipeFd, parsedArgs.remainingArgs);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//【3.3.2.1】看前面的参数传递，parsedArgs.invokeWith 为 null，进入这个分支！</span></span><br><span class="line">        RuntimeInit.zygoteInit(parsedArgs.targetSdkVersion,</span><br><span class="line">                parsedArgs.remainingArgs, <span class="keyword">null</span> <span class="comment">/* classLoader */</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们继续看：</p>
<h4 id="3-3-2-1-RuntimeInit-zygoteInit"><a href="#3-3-2-1-RuntimeInit-zygoteInit" class="headerlink" title="3.3.2.1 RuntimeInit.zygoteInit"></a>3.3.2.1 RuntimeInit.zygoteInit</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">zygoteInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, String[] argv, ClassLoader classLoader)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">"RuntimeInit: Starting application from zygote"</span>);</span><br><span class="line"></span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"RuntimeInit"</span>);</span><br><span class="line">    redirectLogStreams();</span><br><span class="line">    <span class="comment">//【3.3.2.1.1】进程的通用初始化</span></span><br><span class="line">    commonInit();</span><br><span class="line">    <span class="comment">//【3.3.2.1.2】本地的 Zygote 初始化</span></span><br><span class="line">    nativeZygoteInit();</span><br><span class="line">    <span class="comment">//【3.3.2.1.3】应用初始化！</span></span><br><span class="line">    applicationInit(targetSdkVersion, argv, classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>啦啦啦啦啦</p>
<h5 id="3-3-2-1-1-RuntimeInit-commonInit-进程通用初始化"><a href="#3-3-2-1-1-RuntimeInit-commonInit-进程通用初始化" class="headerlink" title="3.3.2.1.1 RuntimeInit.commonInit - 进程通用初始化"></a>3.3.2.1.1 RuntimeInit.commonInit - 进程通用初始化</h5><p>进程的通用初始化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">commonInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">"Entered RuntimeInit!"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】设置该进程中所有线程的默认 crash handler！！</span></span><br><span class="line">    Thread.setDefaultUncaughtExceptionHandler(<span class="keyword">new</span> UncaughtHandler());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】设置时区！</span></span><br><span class="line">    TimezoneGetter.setInstance(<span class="keyword">new</span> TimezoneGetter() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> SystemProperties.get(<span class="string">"persist.sys.timezone"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    TimeZone.setDefault(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【3】重置 LogManager</span></span><br><span class="line">    LogManager.getLogManager().reset();</span><br><span class="line">    <span class="keyword">new</span> AndroidConfig();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【4】设置默认的 http 用户代理，这个是 HttpURLConnection 必须的！</span></span><br><span class="line">    String userAgent = getDefaultUserAgent();</span><br><span class="line">    System.setProperty(<span class="string">"http.agent"</span>, userAgent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【5】安装网络</span></span><br><span class="line">    NetworkManagementSocketTagger.install();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【6】设置模拟器相关参数！</span></span><br><span class="line">    String trace = SystemProperties.get(<span class="string">"ro.kernel.android.tracing"</span>);</span><br><span class="line">    <span class="keyword">if</span> (trace.equals(<span class="string">"1"</span>)) &#123;</span><br><span class="line">        Slog.i(TAG, <span class="string">"NOTE: emulator trace profiling enabled"</span>);</span><br><span class="line">        Debug.enableEmulatorTraceOutput();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【7】表示初始化完成！</span></span><br><span class="line">    initialized = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-3-2-1-2-RuntimeInit-nativeZygoteInit-进程本地初始化"><a href="#3-3-2-1-2-RuntimeInit-nativeZygoteInit-进程本地初始化" class="headerlink" title="3.3.2.1.2 RuntimeInit.nativeZygoteInit - 进程本地初始化"></a>3.3.2.1.2 RuntimeInit.nativeZygoteInit - 进程本地初始化</h5><p>nativeZygoteInit 是一个 native 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativeZygoteInit</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>显然这是一个 native 方法，对应的 native 方法为 com_android_internal_os_RuntimeInit_nativeZygoteInit 方法，位于 AndroidRuntime.cpp 文件中：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">com_android_internal_os_RuntimeInit_nativeZygoteInit</span><span class="params">(JNIEnv* env, jobject clazz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//【1】调用了运行时的 onZygoteInit 方法！</span></span><br><span class="line">  gCurRuntime-&gt;onZygoteInit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接着，进入 App_main.cpp 文件中：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onZygoteInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//【1】获得当前进程的 ProcessState 对象！！</span></span><br><span class="line">    sp&lt;ProcessState&gt; proc = ProcessState::self();</span><br><span class="line">    ALOGV(<span class="string">"App process: starting thread pool.\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】创建一个新的 Binder 线程，不断的 talkWithDriver！！</span></span><br><span class="line">    proc-&gt;startThreadPool();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的 ProcessState 对象是一个单例模式，他会打开 /dev/binder 驱动设备，分配内核空间，然后 start 一个 binder 线程，不断地 talkWithDriver，用于进行进程间通信！</p>
<h5 id="3-3-2-1-3-RuntimeInit-applicationInit-初始化进程的-Application-对象"><a href="#3-3-2-1-3-RuntimeInit-applicationInit-初始化进程的-Application-对象" class="headerlink" title="3.3.2.1.3 RuntimeInit.applicationInit - 初始化进程的 Application 对象"></a>3.3.2.1.3 RuntimeInit.applicationInit - 初始化进程的 Application 对象</h5><p>这里很重要，初始化进程的 Application 对象！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">applicationInit</span><span class="params">(<span class="keyword">int</span> targetSdkVersion, String[] argv, ClassLoader classLoader)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line">    <span class="comment">// If the application calls System.exit(), terminate the process</span></span><br><span class="line">    <span class="comment">// immediately without running any shutdown hooks.  It is not possible to</span></span><br><span class="line">    <span class="comment">// shutdown an Android application gracefully.  Among other things, the</span></span><br><span class="line">    <span class="comment">// Android runtime shutdown hooks close the Binder driver, which can cause</span></span><br><span class="line">    <span class="comment">// leftover running threads to crash before the process actually exits.</span></span><br><span class="line">    nativeSetExitWithoutCleanup(<span class="keyword">true</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【1】设置 java 堆内存的利用率为 75%，以及目标 sdk 平台的版本！</span></span><br><span class="line">    VMRuntime.getRuntime().setTargetHeapUtilization(<span class="number">0.75f</span>);</span><br><span class="line">    VMRuntime.getRuntime().setTargetSdkVersion(targetSdkVersion);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Arguments args;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//【2】解析参数！</span></span><br><span class="line">        args = <span class="keyword">new</span> Arguments(argv);</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">        Slog.e(TAG, ex.getMessage());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【3】结束对子进程的监控！</span></span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【3.3.2.1.3.1】进一步解析参数，执行 startClass 类的 main 方法！！</span></span><br><span class="line">    invokeStaticMain(args.startClass, args.startArgs, classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里有人要问了，这个 startClass 是什么类，此处 args.startClass 为 “android.app.ActivityThread”。</p>
<h6 id="3-3-2-1-3-1-RuntimeInit-invokeStaticMain"><a href="#3-3-2-1-3-1-RuntimeInit-invokeStaticMain" class="headerlink" title="3.3.2.1.3.1 RuntimeInit.invokeStaticMain"></a>3.3.2.1.3.1 RuntimeInit.invokeStaticMain</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeStaticMain</span><span class="params">(String className, String[] argv, ClassLoader classLoader)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ZygoteInit.MethodAndArgsCaller </span>&#123;</span><br><span class="line">    Class&lt;?&gt; cl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//【1】反射获得 ActivityThread 类！</span></span><br><span class="line">        cl = Class.forName(className, <span class="keyword">true</span>, classLoader);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Missing class when invoking static main "</span> + className,</span><br><span class="line">                ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Method m;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//【2】获得 ActivityThread 的 main 方法！</span></span><br><span class="line">        m = cl.getMethod(<span class="string">"main"</span>, <span class="keyword">new</span> Class[] &#123; String[].class &#125;);</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Missing static main on "</span> + className, ex);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SecurityException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Problem getting static main on "</span> + className, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> modifiers = m.getModifiers();</span><br><span class="line">    <span class="keyword">if</span> (! (Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Main method is not public and static on "</span> + className);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【3.4】这个地方抛出了 MethodAndArgsCaller 异常！！！</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ZygoteInit.MethodAndArgsCaller(m, argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里通过反射，获得了 ActivityThread.main 方法，然后创建了一个异常：MethodAndArgsCaller，抛了出去！</p>
<p>这个异常会通过 ZygoteConnection.runOnce 方法传递出去，进入了 ZygoteInit.main 方法，那里会对这个异常进行 catch 并处理！</p>
<h3 id="3-3-3-ZygoteConncection-handleParentProc-父进程处理"><a href="#3-3-3-ZygoteConncection-handleParentProc-父进程处理" class="headerlink" title="3.3.3 ZygoteConncection.handleParentProc - 父进程处理"></a>3.3.3 ZygoteConncection.handleParentProc - 父进程处理</h3><p>当 fork 的返回值大于 0，那就进入父进程 Zygote，返回 pid 的值是子进程的进程值：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">handleParentProc</span><span class="params">(<span class="keyword">int</span> pid,</span></span></span><br><span class="line"><span class="function"><span class="params">        FileDescriptor[] descriptors, FileDescriptor pipeFd, Arguments parsedArgs)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】判断一下返回值，若大于 0，说明 fork 成功，</span></span><br><span class="line">    <span class="comment">// 设置子进程的 pgid！</span></span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//【*3.3.3.1】设置进程的 pgid！</span></span><br><span class="line">        setChildPgid(pid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (descriptors != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (FileDescriptor fd: descriptors) &#123;</span><br><span class="line">            IoUtils.closeQuietly(fd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> usingWrapper = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (pipeFd != <span class="keyword">null</span> &amp;&amp; pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        DataInputStream is = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> FileInputStream(pipeFd));</span><br><span class="line">        <span class="keyword">int</span> innerPid = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            innerPid = is.readInt();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">"Error reading pid from wrapped process, child may have died"</span>, ex);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                is.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Ensure that the pid reported by the wrapped process is either the</span></span><br><span class="line">        <span class="comment">// child process that we forked, or a descendant of it.</span></span><br><span class="line">        <span class="keyword">if</span> (innerPid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> parentPid = innerPid;</span><br><span class="line">            <span class="keyword">while</span> (parentPid &gt; <span class="number">0</span> &amp;&amp; parentPid != pid) &#123;</span><br><span class="line">                parentPid = Process.getParentPid(parentPid);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (parentPid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                Log.i(TAG, <span class="string">"Wrapped process has pid "</span> + innerPid);</span><br><span class="line">                pid = innerPid;</span><br><span class="line">                usingWrapper = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Log.w(TAG, <span class="string">"Wrapped process reported a pid that is not a child of "</span></span><br><span class="line">                        + <span class="string">"the process that we forked: childPid="</span> + pid</span><br><span class="line">                        + <span class="string">" innerPid="</span> + innerPid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mSocketOutStream.writeInt(pid);</span><br><span class="line">        mSocketOutStream.writeBoolean(usingWrapper);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"Error writing to command socket"</span>, ex);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="3-3-3-1-setChildPgid"><a href="#3-3-3-1-setChildPgid" class="headerlink" title="3.3.3.1 setChildPgid"></a>3.3.3.1 setChildPgid</h4><p>设置 fork 出的进程的 pgid：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setChildPgid</span><span class="params">(<span class="keyword">int</span> pid)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Try to move the new child into the peer's process group.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Os.setpgid(pid, Os.getpgid(peer.getPid()));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ErrnoException ex) &#123;</span><br><span class="line">        <span class="comment">// This exception is expected in the case where</span></span><br><span class="line">        <span class="comment">// the peer is not in our session</span></span><br><span class="line">        <span class="comment">// TODO get rid of this log message in the case where</span></span><br><span class="line">        <span class="comment">// getsid(0) != getsid(peer.getPid())</span></span><br><span class="line">        Log.i(TAG, <span class="string">"Zygote: setpgid failed. This is "</span></span><br><span class="line">            + <span class="string">"normal if peer is not in our session"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-4-MethodAndArgsCaller-run-处理异常"><a href="#3-4-MethodAndArgsCaller-run-处理异常" class="headerlink" title="3.4 MethodAndArgsCaller.run - 处理异常"></a>3.4 MethodAndArgsCaller.run - 处理异常</h2><p>MethodAndArgsCaller 类位于 ZygoteInit.java 中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAndArgsCaller</span> <span class="keyword">extends</span> <span class="title">Exception</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** method to call */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Method mMethod;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** argument array */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String[] mArgs;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MethodAndArgsCaller</span><span class="params">(Method method, String[] args)</span> </span>&#123;</span><br><span class="line">        mMethod = method;</span><br><span class="line">        mArgs = args;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//【1】执行进程的 ActivityThread.main 方法！！</span></span><br><span class="line">            mMethod.invoke(<span class="keyword">null</span>, <span class="keyword">new</span> Object[] &#123; mArgs &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">            Throwable cause = ex.getCause();</span><br><span class="line">            <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (RuntimeException) cause;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (Error) cause;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就正式进入了新进程的 ActivityThread.main 方法，我们知道 ActivityThread.main 是应用程序进程的入口，到这里就将从 native 进入 java 层了，进行进一步的进程启动！</p>
<h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h1><h2 id="4-1-通信方式总结"><a href="#4-1-通信方式总结" class="headerlink" title="4.1 通信方式总结"></a>4.1 通信方式总结</h2><p>可以看出，主要有以下的两种通信方式：Binder 和 Socket !!</p>
<ul>
<li>启动方进程 -&gt; SystemServer 进程: Binder</li>
<li>SystemServer 进程 -&gt; Zygote 进程：Socket</li>
<li>Zygote 进程 -&gt; 被启动进程：Socket</li>
</ul>
<p>主要的流程图如下：</p>
<p><img src="http://static.zybuluo.com/Coolqi/f50nyubiawx51w6dc4hqy5hd/Process%20%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="Process 创建流程图.png-19.8kB"></p>
<h2 id="4-2-调用流程总结"><a href="#4-2-调用流程总结" class="headerlink" title="4.2 调用流程总结"></a>4.2 调用流程总结</h2><p>UML 序列图先埋坑，以后再填。。</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Coolqi.Li</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lishuaiqi.top/2016/03/19/Process2-theCreateOfProcess/">https://lishuaiqi.top/2016/03/19/Process2-theCreateOfProcess/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lishuaiqi.top">Coolqi`s Blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Process进程/">Process进程</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="/img/zfb.jpg"><div class="post-qr-code__desc">支付宝打赏</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="/img/wechat.jpg"><div class="post-qr-code__desc">微信打赏</div></div></div><div class="social-share pull-right"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2016/04/02/JobScheduler2-JobSchedulerServiceStartProcess/"><i class="fa fa-chevron-left">  </i><span>JobScheduler第 2 篇 - JobSchedulerService 的启动</span></a></div><div class="next-post pull-right"><a href="/2016/03/13/Process1-theStartOfProcess/"><span>Process篇 1 - Android 进程的启动</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitment-container"></div><script>var gitment = new Gitment({
  id: md5(decodeURI(location.pathname)),
  owner: '',
  repo: '',
  oauth: {
    client_id: '7b4efbcd7027d15749d6',
    client_secret: '14b5d7e8580ee29f7aeca733a25c000795967448'
  }
})
gitment.render('gitment-container')</script></div></div><footer class="footer-bg" style="background-image: url(/img/blog-bg.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2015 - 2021 By Coolqi.Li</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://lishuaiqi.top/">blog</a>!</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>