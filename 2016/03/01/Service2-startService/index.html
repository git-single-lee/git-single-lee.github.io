<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Service 篇 2 - startService 流程分析"><meta name="keywords" content="Service服务"><meta name="author" content="Coolqi.Li,undefined"><meta name="copyright" content="Coolqi.Li"><title>Service 篇 2 - startService 流程分析 | Coolqi`s Blog</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.5.6"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css?version=1.5.6"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?b7acef5306e54116ad8a99e8b753a92d";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#0-综述"><span class="toc-text">0 综述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-启动端进程"><span class="toc-text">1 启动端进程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-ContextWrapper-startService"><span class="toc-text">1.1 ContextWrapper.startService</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-ContextImpl-startService"><span class="toc-text">1.2 ContextImpl.startService</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-ContextImpl-startServiceCommon"><span class="toc-text">1.3 ContextImpl.startServiceCommon</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-1-ContextImpl-validateServiceIntent"><span class="toc-text">1.3.1 ContextImpl.validateServiceIntent</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-2-ContextImpl-getOpPackageName"><span class="toc-text">1.3.2 ContextImpl.getOpPackageName</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-ActivityManagerP-startService"><span class="toc-text">1.4 ActivityManagerP.startService</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-系统进程"><span class="toc-text">2 系统进程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-ActivityManagerS-startService"><span class="toc-text">2.1 ActivityManagerS.startService</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-ActiveServices-startServiceLoced"><span class="toc-text">2.2 ActiveServices.startServiceLoced</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-ActiveServices-unscheduleServiceRestartLocked"><span class="toc-text">2.2.1 ActiveServices.unscheduleServiceRestartLocked</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-ActiveServices-startServiceInnerLocked"><span class="toc-text">2.3 ActiveServices.startServiceInnerLocked</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-ServiceMap-rescheduleDelayedStart"><span class="toc-text">2.3.1 ServiceMap.rescheduleDelayedStart</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-ServiceMap-ensureNotStartingBackground"><span class="toc-text">2.3.2 ServiceMap.ensureNotStartingBackground</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-3-阶段总结"><span class="toc-text">2.3.3 阶段总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-ActiveServices-bringUpServiceLocked"><span class="toc-text">2.4 ActiveServices.bringUpServiceLocked</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-ActivityManagerS-attachApplicationLocked"><span class="toc-text">2.5 ActivityManagerS.attachApplicationLocked</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-ActiveServices-attachApplicationLocked"><span class="toc-text">2.6 ActiveServices.attachApplicationLocked</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7-AS-realStartServiceLocked"><span class="toc-text">2.7 AS.realStartServiceLocked</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-1-AS-bumpServiceExecutingLocked"><span class="toc-text">2.7.1 AS.bumpServiceExecutingLocked</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-1-1-AS-scheduleServiceTimeoutLocked"><span class="toc-text">2.7.1.1 AS.scheduleServiceTimeoutLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-1-2-ActivityServiceS-MainHandler"><span class="toc-text">2.7.1.2 ActivityServiceS.MainHandler</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-1-3-ActiveServices-serviceTimeout"><span class="toc-text">2.7.1.3 ActiveServices.serviceTimeout</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-2-ApplicationThreadP-scheduleCreateService"><span class="toc-text">2.7.2 ApplicationThreadP.scheduleCreateService</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-3-AS-sendServiceArgsLocked"><span class="toc-text">2.7.3 AS.sendServiceArgsLocked</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-7-3-1-ApplicationThreadP-scheduleServiceArgs"><span class="toc-text">2.7.3.1 ApplicationThreadP.scheduleServiceArgs</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-被启动者进程"><span class="toc-text">3 被启动者进程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-ApplicationThread-scheduleCreateService"><span class="toc-text">3.1 ApplicationThread.scheduleCreateService</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-ApplicationThread-scheduleServiceArgs"><span class="toc-text">3.2 ApplicationThread.scheduleServiceArgs</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-ApplicationThread-H"><span class="toc-text">3.3 ApplicationThread.H</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-1-ApplicationThread-handleCreateService"><span class="toc-text">3.3.1 ApplicationThread.handleCreateService</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-1-service-onCreate"><span class="toc-text">3.3.1.1 service.onCreate</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-2-ApplicationThread-handleServiceArgs"><span class="toc-text">3.3.2 ApplicationThread.handleServiceArgs</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-1-service-onStartCommand"><span class="toc-text">3.3.2.1 service.onStartCommand</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-ActivityManagerP-serviceDoneExecuting"><span class="toc-text">3.4 ActivityManagerP.serviceDoneExecuting</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-系统进程"><span class="toc-text">4 系统进程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-ActivityManagerS-serviceDoneExecuting"><span class="toc-text">4.1 ActivityManagerS.serviceDoneExecuting</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-ActiveServices-serviceDoneExecutingLocked"><span class="toc-text">4.2 ActiveServices.serviceDoneExecutingLocked</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-ActiveServices-serviceDoneExecutingLocked"><span class="toc-text">4.3 ActiveServices.serviceDoneExecutingLocked</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-总结"><span class="toc-text">5 总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-数据结构总结"><span class="toc-text">6.1 数据结构总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-1-ProcessRecord"><span class="toc-text">6.1.1 ProcessRecord</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-2-ActivieServices"><span class="toc-text">6.1.2 ActivieServices</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-3-ServiceMap"><span class="toc-text">6.1.3 ServiceMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-4-ServiceRecord"><span class="toc-text">6.1.4 ServiceRecord</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-5-StartItem"><span class="toc-text">6.1.5  StartItem</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-6-ServiceRestarter"><span class="toc-text">6.1.6 ServiceRestarter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-7-CreateServiceData"><span class="toc-text">6.1.7 CreateServiceData</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-8-ServiceArgsData"><span class="toc-text">6.1.8 ServiceArgsData</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-生命周期总结"><span class="toc-text">6.2 生命周期总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-流程总结"><span class="toc-text">6.3 流程总结</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Coolqi.Li</div><div class="author-info__description text-center">“你好，我是李帅奇，Android 系统工程师，MineCraft 忠实玩家，设计和绘画爱好者，缺妹纸晚期患者，熬夜星人。”</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">75</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">16</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">18</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="https://developer.android.google.cn/">AndroidDeveloper</a><a class="author-info-links__name text-center" href="http://www.android-studio.org/">AndroidStudio</a><a class="author-info-links__name text-center" href="https://www.jianshu.com/u/123a20a96441">简书</a><a class="author-info-links__name text-center" href="https://weibo.com/coolqiLi">微博</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://ws1.sinaimg.cn/large/8700af19ly1fvpabr30o6j22yo1o0q7i.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Coolqi`s Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/about">About</a></span></div><div id="post-info"><div id="post-title">Service 篇 2 - startService 流程分析</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2016-03-01</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/AndroidFramework源码分析/">AndroidFramework源码分析</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/AndroidFramework源码分析/Service服务/">Service服务</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">13k</span><span class="post-meta__separator">|</span><span>阅读时长: 56 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>基于 <code>Android 7.1.1</code> 源码分析 <code>startService</code> 的流程，本文为作者原创，转载请说明出处！</p>
<h1 id="0-综述"><a href="#0-综述" class="headerlink" title="0 综述"></a>0 综述</h1><p>我们在应用中经常会启动 <code>Service</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">startService(intent);</span><br></pre></td></tr></table></figure>
<p>这个方法最终会拉起 <code>Service</code> 的 <code>onStartCommand</code> 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">    OppoLog.d(TAG, <span class="string">"onStartCommand"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onStartCommand(intent, flags, startId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该方法有三个参数：</p>
<ul>
<li><strong>Intent intent</strong>: 启动服务的 <code>Intent</code>！</li>
<li><strong>int flags</strong>: 启动时的额外参数，取值可以为 <code>0</code>，<code>START_FLAG_REDELIVERY</code> 和 <code>START_FLAG_RETRY</code>！</li>
<li><strong>int startId</strong>: 当前服务的唯一 <code>ID</code>，和 <code>StopSelfResult(int startId)</code> 配合使用！</li>
</ul>
<p><strong>1、</strong>下面我们来看看 <code>onStartCommand</code> 的 <code>flag</code> 参数：</p>
<p><br></p>
<ul>
<li><strong>START_FLAG_REDELIVERY</strong> <ul>
<li><strong>取值</strong>：<code>x0001</code></li>
<li><strong>解释</strong>：如果 <code>Service</code> 的 <code>onStartCommand</code> 返回值是 <code>START_REDELIVER_INTENT</code>，当服务被杀掉，服务会重启，这时 <code>flag</code> 会被传入这个值！</li>
</ul>
</li>
</ul>
<p><br></p>
<ul>
<li><strong>START_FLAG_RETRY</strong><ul>
<li><strong>取值</strong>：<code>0x0002</code></li>
<li><strong>解释</strong>：当 <code>onStartCommand</code> 方法调用后一直没有返回时，会尝试重新去调用 <code>onStartCommand</code> 方法，这时 <code>flag</code> 会被传入这个值！</li>
</ul>
</li>
</ul>
<p><strong>2、</strong>而 <code>onStartCommand</code> 有如下的返回值，这里先简单的介绍下：</p>
<p><br></p>
<ul>
<li><strong>START_STICKY_COMPATIBILITY</strong> <ul>
<li><strong>取值</strong>：<code>0</code></li>
</ul>
</li>
<li><strong>START_STICKY</strong><ul>
<li><strong>取值</strong>：<code>1</code></li>
<li><strong>说明</strong>：<ul>
<li>如果 <code>Service</code> 进程启动后被杀掉了，服务被启动的状态会被保留并抛弃本次启动的 <code>Intent</code>，然后系统会尝试重新创建和启动一个新的服务实例!</li>
<li>如果在重启期间，没有任何新的启动项 <code>Intent</code> 传递给 <code>Service</code>，那么会传递一个空的 <code>Intent</code> 对象，所以在 <code>onStartCommand</code> 方法中要做 <code>Intent</code> 非空的判断！ </li>
</ul>
</li>
<li><strong>用途</strong>：<ul>
<li>比较适用于不执行命令、但无限期运行并等待作业的媒体播放器或类似服务。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><br></p>
<ul>
<li><strong>START_NOT_STICKY</strong><ul>
<li><strong>取值</strong>：<code>2</code></li>
<li><strong>说明</strong>：<ul>
<li>如果 <code>Service</code> 进程启动后被杀掉了，并且没有新的启动 <code>Intent</code> 分发给服务，那么会移除服务被启动的状态，也不会重新创建服务，直到下一次显示地通过 <code>startService</code> 启动服务！</li>
<li>这种情况下，<code>onStartCommand</code> 不会传入空的 <code>Intent</code> 对象（因为在没有正在等待分发的 Intent 的情况下，该服务不会重启）！</li>
</ul>
</li>
<li><strong>用途</strong>：<ul>
<li>该模式比较适用于启动后需要做一些工作，但是在内存不够的情况下可以被停止，然后通过显示地再次启动去继续工作的情况！</li>
<li>一个简单的例子：从服务器获得数据的服务，通过设置一个 <code>alarm</code>，间隔一定时间启动服务<code>onStartCommand</code>，然后设置新的 <code>alarm</code>，如果服务进程被杀掉，那服务不会被触发，知道下一次 <code>alarm</code> 触发！</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><br></p>
<ul>
<li><strong>START_REDELIVER_INTENT</strong> <ul>
<li><strong>取值</strong>： <code>3</code></li>
<li><strong>说明</strong>：<ul>
<li>如果 <code>Service</code> 进程启动后被杀掉了，该 <code>Service</code> 将会被重启，并且会将最后启动（<code>startService</code>）分发过的 <code>Intent</code> 再次通过 <code>onStartCommand</code> 方法传递给 <code>Service</code> ，该 <code>Intent</code> 将会被保留用于下一次的重启分发，除非 <code>Service</code> 调用 <code>stopSelf(int startId)</code> 方法停止运行！</li>
<li>这种情况下，<code>onStartCommand</code> 也不会传入空的 <code>Intent</code> 对象，因为服务只有在没有完成处理所有分发给它的 <code>Intent</code> 的情况下或重启，一旦重启，就会将最后启动（<code>startService</code>）分发过的 <code>Intent</code> 再次通过 <code>onStartCommand</code> 方法传递给服务！</li>
</ul>
</li>
<li><strong>用途</strong>：<ul>
<li>这个模式适用于主动执行应该立即恢复的作业（例如下载文件）的服务。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><br></p>
<ul>
<li><strong>START_CONTINUATION_MASK</strong> 0xf</li>
</ul>
<p>这里是 <code>Android</code> 文档中的对这些参数的做的简单说明，下面我们来分析 startService 的过程！</p>
<h1 id="1-启动端进程"><a href="#1-启动端进程" class="headerlink" title="1 启动端进程"></a>1 启动端进程</h1><h2 id="1-1-ContextWrapper-startService"><a href="#1-1-ContextWrapper-startService" class="headerlink" title="1.1 ContextWrapper.startService"></a>1.1 ContextWrapper.startService</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ComponentName <span class="title">startService</span><span class="params">(Intent service)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mBase.startService(service);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ComponentName <span class="title">startServiceAsUser</span><span class="params">(Intent service, UserHandle user)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mBase.startServiceAsUser(service, user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ContextWrapper</code> 提供了两个方法来启动 <code>Service</code>，其中一个是隐藏方法：<code>startServiceAsUser</code>！</p>
<p><code>mBase</code> 是 <code>ContextImpl</code> 对象，继续看！</p>
<h2 id="1-2-ContextImpl-startService"><a href="#1-2-ContextImpl-startService" class="headerlink" title="1.2 ContextImpl.startService"></a>1.2 ContextImpl.startService</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContextImpl</span> <span class="keyword">extends</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ComponentName <span class="title">startService</span><span class="params">(Intent service)</span> </span>&#123;</span><br><span class="line">        warnIfCallingFromSystemProcess();</span><br><span class="line">        <span class="keyword">return</span> startServiceCommon(service, mUser);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ComponentName <span class="title">startServiceAsUser</span><span class="params">(Intent service, UserHandle user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> startServiceCommon(service, user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ContextImpl</code> 和 <code>ContextWrapper</code> 的具体关系，请看博文，这里我们不再详细说明！</p>
<p><code>mUser</code> 表示的是当前的设备 <code>user</code>！</p>
<p>最终，调用了 <code>startServiceCommon</code> 方法；</p>
<h2 id="1-3-ContextImpl-startServiceCommon"><a href="#1-3-ContextImpl-startServiceCommon" class="headerlink" title="1.3 ContextImpl.startServiceCommon"></a>1.3 ContextImpl.startServiceCommon</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ComponentName <span class="title">startServiceCommon</span><span class="params">(Intent service, UserHandle user)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果系统版本不低于 L，那就要抛出异常，提示必须是显示启动！</span></span><br><span class="line">        validateServiceIntent(service);</span><br><span class="line">        service.prepareToLeaveProcess(<span class="keyword">this</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【1】启动指定的 Service！</span></span><br><span class="line">        ComponentName cn = ActivityManagerNative.getDefault().startService(</span><br><span class="line">            mMainThread.getApplicationThread(), service, service.resolveTypeIfNeeded(</span><br><span class="line">                        getContentResolver()), getOpPackageName(), user.getIdentifier());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cn != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cn.getPackageName().equals(<span class="string">"!"</span>)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(</span><br><span class="line">                        <span class="string">"Not allowed to start service "</span> + service</span><br><span class="line">                        + <span class="string">" without permission "</span> + cn.getClassName());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cn.getPackageName().equals(<span class="string">"!!"</span>)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(</span><br><span class="line">                        <span class="string">"Unable to start service "</span> + service</span><br><span class="line">                        + <span class="string">": "</span> + cn.getClassName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cn;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>validateServiceIntent</code> 方法用用来校验启动用的 <code>intent</code> 是否安全：</p>
<h3 id="1-3-1-ContextImpl-validateServiceIntent"><a href="#1-3-1-ContextImpl-validateServiceIntent" class="headerlink" title="1.3.1 ContextImpl.validateServiceIntent"></a>1.3.1 ContextImpl.validateServiceIntent</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">c</span><span class="params">(Intent service)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (service.getComponent() == <span class="keyword">null</span> &amp;&amp; service.getPackage() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (getApplicationInfo().targetSdkVersion &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">            IllegalArgumentException ex = <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    <span class="string">"Service Intent must be explicit: "</span> + service);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Log.w(TAG, <span class="string">"Implicit intents with startService are not safe: "</span> + service</span><br><span class="line">                    + <span class="string">" "</span> + Debug.getCallers(<span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 <code>intent</code> 既没有设置 <code>component</code> 也没有设置 <code>package</code>，那就要判断一下系统的版本了: </p>
<ul>
<li>如果系统版本不低于 <code>L</code>，那就要抛出异常，提示必须是显示启动；</li>
<li>如果系统版本低于 <code>L</code>，那只提示隐式启动不安全；</li>
</ul>
<p>这里可以看出，<code>Intent</code> 必须要设置 <code>component</code> 或者 <code>package</code> 中的一个！</p>
<h3 id="1-3-2-ContextImpl-getOpPackageName"><a href="#1-3-2-ContextImpl-getOpPackageName" class="headerlink" title="1.3.2 ContextImpl.getOpPackageName"></a>1.3.2 ContextImpl.getOpPackageName</h3><p>通过 <code>getOpPackageName</code> 来获得启动者所在的包名：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getOpPackageName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mOpPackageName != <span class="keyword">null</span> ? mOpPackageName : getBasePackageName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的 <code>mOpPackageName</code> 是在创建 <code>ContextImpl</code> 的时候初始化的！</p>
<h2 id="1-4-ActivityManagerP-startService"><a href="#1-4-ActivityManagerP-startService" class="headerlink" title="1.4 ActivityManagerP.startService"></a>1.4 ActivityManagerP.startService</h2><p>接着，通过 <code>ActivityManagerP.startService</code> 方法，启动服务！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ComponentName <span class="title">startService</span><span class="params">(IApplicationThread caller, Intent service,</span></span></span><br><span class="line"><span class="function"><span class="params">     String resolvedType, String callingPackage, <span class="keyword">int</span> userId)</span> <span class="keyword">throws</span> RemoteException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Parcel data = Parcel.obtain();</span><br><span class="line">    Parcel reply = Parcel.obtain();</span><br><span class="line">    data.writeInterfaceToken(IActivityManager.descriptor);</span><br><span class="line"></span><br><span class="line">    data.writeStrongBinder(caller != <span class="keyword">null</span> ? caller.asBinder() : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    service.writeToParcel(data, <span class="number">0</span>);</span><br><span class="line">    data.writeString(resolvedType);</span><br><span class="line">    data.writeString(callingPackage);</span><br><span class="line">    data.writeInt(userId);</span><br><span class="line">    mRemote.transact(START_SERVICE_TRANSACTION, data, reply, <span class="number">0</span>);</span><br><span class="line">    reply.readException();</span><br><span class="line"></span><br><span class="line">    ComponentName res = ComponentName.readFromParcel(reply);</span><br><span class="line"></span><br><span class="line">    data.recycle();</span><br><span class="line">    reply.recycle();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过 <code>binder</code> 进程间通信，进入系统进程，参数分析：</p>
<ul>
<li><code>IApplicationThread caller</code>： 调用者进程的 <code>ApplicationThread</code> 对象，实现了 <code>IApplicationThread</code> 接口；</li>
<li><code>Intent service</code>： 启动的 <code>intent</code></li>
<li><code>String resolvedType</code>： 这个 <code>intent</code> 的 <code>MIME</code> 类型；</li>
<li><code>String callingPackage</code>： 启动者所属包名；</li>
<li><code>int userId</code>： 设备用户 <code>id</code>；</li>
</ul>
<h1 id="2-系统进程"><a href="#2-系统进程" class="headerlink" title="2 系统进程"></a>2 系统进程</h1><p>接下来，进入系统进程的 <code>ActivityManagerService</code> 中！</p>
<p>首先要进入 <code>ActivityManagerN.onTransact</code> 方法！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> START_SERVICE_TRANSACTION: &#123;</span><br><span class="line">    data.enforceInterface(IActivityManager.descriptor);</span><br><span class="line">    </span><br><span class="line">    IBinder b = data.readStrongBinder();</span><br><span class="line">    IApplicationThread app = ApplicationThreadNative.asInterface(b);</span><br><span class="line"></span><br><span class="line">    Intent service = Intent.CREATOR.createFromParcel(data);</span><br><span class="line">    String resolvedType = data.readString();</span><br><span class="line">    String callingPackage = data.readString();</span><br><span class="line">    <span class="keyword">int</span> userId = data.readInt();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【1】继续 startService！</span></span><br><span class="line">    ComponentName cn = startService(app, service, resolvedType, callingPackage, userId);</span><br><span class="line"></span><br><span class="line">    reply.writeNoException();</span><br><span class="line">    ComponentName.writeToParcel(cn, reply);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-1-ActivityManagerS-startService"><a href="#2-1-ActivityManagerS-startService" class="headerlink" title="2.1 ActivityManagerS.startService"></a>2.1 ActivityManagerS.startService</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ComponentName <span class="title">startService</span><span class="params">(IApplicationThread caller, Intent service,</span></span></span><br><span class="line"><span class="function"><span class="params">        String resolvedType, String callingPackage, <span class="keyword">int</span> userId)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用来校验启动者进程是否是隔离的，如果是隔离进程，抛出异常！！</span></span><br><span class="line">    enforceNotIsolatedCaller(<span class="string">"startService"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不能通过 intent 传递文件描述符，否则抛出非法异常！</span></span><br><span class="line">    <span class="keyword">if</span> (service != <span class="keyword">null</span> &amp;&amp; service.hasFileDescriptors() == <span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"File descriptors passed in Intent"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用者 package 为 null，抛出异常！</span></span><br><span class="line">    <span class="keyword">if</span> (callingPackage == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"callingPackage cannot be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE,</span><br><span class="line">            <span class="string">"startService: "</span> + service + <span class="string">" type="</span> + resolvedType);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得调用者的 uid 和 pid！</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> callingPid = Binder.getCallingPid();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> callingUid = Binder.getCallingUid();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【1】进入 ActiveServices，继续启动！</span></span><br><span class="line">        ComponentName res = mServices.startServiceLocked(caller, service,</span><br><span class="line">                resolvedType, callingPid, callingUid, callingPackage, userId);</span><br><span class="line"></span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>mServices</code> 是 <code>ActivityManagerService</code> 的一个内部管理对象，用于管理所有的 <code>Service</code>！</p>
<h2 id="2-2-ActiveServices-startServiceLoced"><a href="#2-2-ActiveServices-startServiceLoced" class="headerlink" title="2.2 ActiveServices.startServiceLoced"></a>2.2 ActiveServices.startServiceLoced</h2><p>参数和前面保持一致！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ComponentName <span class="title">startServiceLocked</span><span class="params">(IApplicationThread caller, Intent service, String resolvedType,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> callingPid, <span class="keyword">int</span> callingUid, String callingPackage, <span class="keyword">final</span> <span class="keyword">int</span> userId)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE, <span class="string">"startService: "</span> + service</span><br><span class="line">            + <span class="string">" type="</span> + resolvedType + <span class="string">" args="</span> + service.getExtras());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【1】判断是否是前台调用！</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> callerFg;</span><br><span class="line">    <span class="keyword">if</span> (caller != <span class="keyword">null</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获得调用者进程的 ProcessRecord 对象！</span></span><br><span class="line">        <span class="keyword">final</span> ProcessRecord callerApp = mAm.getRecordForAppLocked(caller);</span><br><span class="line">        <span class="keyword">if</span> (callerApp == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(</span><br><span class="line">                    <span class="string">"Unable to find app for caller "</span> + caller</span><br><span class="line">                    + <span class="string">" (pid="</span> + Binder.getCallingPid()</span><br><span class="line">                    + <span class="string">") when starting service "</span> + service);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        callerFg = callerApp.setSchedGroup != ProcessList.SCHED_GROUP_BACKGROUND;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        callerFg = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】检索要启动的服务的信息！</span></span><br><span class="line">    ServiceLookupResult res =</span><br><span class="line">        retrieveServiceLocked(service, resolvedType, callingPackage,</span><br><span class="line">                callingPid, callingUid, userId, <span class="keyword">true</span>, callerFg, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (res.record == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ComponentName(<span class="string">"!"</span>, res.permission != <span class="keyword">null</span></span><br><span class="line">                ? res.permission : <span class="string">"private to package"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【3】获得要启动的服务的数据对象：ServiceRecord！</span></span><br><span class="line">    ServiceRecord r = res.record;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果服务所属的设备用户不存在，直接返回！</span></span><br><span class="line">    <span class="keyword">if</span> (!mAm.mUserController.exists(r.userId)) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"Trying to start service with non-existent user! "</span> + r.userId);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【4】如果服务还没有被请求启动，要先判断服务是否允许在后台启动，如果不允许就直接返回！</span></span><br><span class="line">    <span class="keyword">if</span> (!r.startRequested) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> token = Binder.clearCallingIdentity();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> allowed = mAm.checkAllowBackgroundLocked(</span><br><span class="line">                    r.appInfo.uid, r.packageName, callingPid, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (allowed != ActivityManager.APP_START_MODE_NORMAL) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Background start not allowed: service "</span></span><br><span class="line">                        + service + <span class="string">" to "</span> + r.name.flattenToShortString()</span><br><span class="line">                        + <span class="string">" from pid="</span> + callingPid + <span class="string">" uid="</span> + callingUid</span><br><span class="line">                        + <span class="string">" pkg="</span> + callingPackage);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Binder.restoreCallingIdentity(token);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    NeededUriGrants neededGrants = mAm.checkGrantUriPermissionFromIntentLocked(</span><br><span class="line">            callingUid, r.packageName, service, service.getFlags(), <span class="keyword">null</span>, r.userId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【5】如果启动者属于前台应用，并且启动服务组件是需要校验权限，就需要弹出权限校验界面！</span></span><br><span class="line">    <span class="comment">// 只有权限校验成功，才会继续启动！</span></span><br><span class="line">    <span class="keyword">if</span> (Build.PERMISSIONS_REVIEW_REQUIRED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!requestStartTargetPermissionsReviewIfNeededLocked(r, callingPackage,</span><br><span class="line">                callingUid, service, callerFg, userId)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【6】取消服务重启的任务！</span></span><br><span class="line">    <span class="keyword">if</span> (unscheduleServiceRestartLocked(r, callingUid, <span class="keyword">false</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">"START SERVICE WHILE RESTART PENDING: "</span> + r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【7】设置服务 ServiceRecord 的属性值；</span></span><br><span class="line">    r.lastActivity = SystemClock.uptimeMillis();</span><br><span class="line">    <span class="comment">// 设置 startRequested 为 true，表示被请求启动！</span></span><br><span class="line">    r.startRequested = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 设置 delayedStop 为 false；表示服务没有被延迟停止，只对后台服务有效！</span></span><br><span class="line">    r.delayedStop = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将本次启动需要的数据，包括 intent，封装成 StartItem，保存到 pendingStarts 列表中！</span></span><br><span class="line">    r.pendingStarts.add(<span class="keyword">new</span> ServiceRecord.StartItem(r, <span class="keyword">false</span>, r.makeNextStartId(),</span><br><span class="line">            service, neededGrants));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获得 userId 下的所有 Service 的 Map 集合！</span></span><br><span class="line">    <span class="keyword">final</span> ServiceMap smap = getServiceMap(r.userId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示是否将服务添加到后台启动列表中；</span></span><br><span class="line">    <span class="keyword">boolean</span> addToStarting = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【8】对于后台启动的服务，需要做一些条件判断，看是延迟启动，还是立刻后台启动！</span></span><br><span class="line">    <span class="keyword">if</span> (!callerFg &amp;&amp; r.app == <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; mAm.mUserController.hasStartedUserState(r.userId)) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获得被启动的服务所在进程的 ProcessRecord 数据对象！</span></span><br><span class="line">        ProcessRecord proc = mAm.getProcessRecordLocked(r.processName, r.appInfo.uid, <span class="keyword">false</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 下面判断当前启动服务的进程状态来确定是否需要延时启动这个服务！</span></span><br><span class="line">        <span class="comment">// 对于非前台的启动，尝试延迟启动服务！ </span></span><br><span class="line">        <span class="keyword">if</span> (proc == <span class="keyword">null</span> || proc.curProcState &gt; ActivityManager.PROCESS_STATE_RECEIVER) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_DELAYED_SERVICE) Slog.v(TAG_SERVICE, <span class="string">"Potential start delay of "</span></span><br><span class="line">                    + r + <span class="string">" in "</span> + proc);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (r.delayed) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果该服务已经延迟启动，说明他已经被加入到了 smap.mDelayedStartList 列表中等待启动，直接返回！</span></span><br><span class="line">                <span class="keyword">if</span> (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE, <span class="string">"Continuing to delay: "</span> + r);</span><br><span class="line">                <span class="keyword">return</span> r.name;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 当同一时间正在后台启动的服务数超过了最大后台启动服务数，延迟启动！</span></span><br><span class="line">            <span class="keyword">if</span> (smap.mStartingBackground.size() &gt;= mMaxStartingBackground) &#123;</span><br><span class="line">                Slog.i(TAG_SERVICE, <span class="string">"Delaying start of: "</span> + r);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 就要将该服务加入 smap.mDelayedStartList 中；</span></span><br><span class="line">                smap.mDelayedStartList.add(r);</span><br><span class="line">                <span class="comment">// 设置其 r.delayed 为 true！</span></span><br><span class="line">                r.delayed = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> r.name;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE, <span class="string">"Not delaying: "</span> + r);</span><br><span class="line">            </span><br><span class="line">            addToStarting = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (proc.curProcState &gt;= ActivityManager.PROCESS_STATE_SERVICE) &#123;</span><br><span class="line"></span><br><span class="line">            addToStarting = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE,</span><br><span class="line">                    <span class="string">"Not delaying, but counting as bg: "</span> + r);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (DEBUG_DELAYED_STARTS) &#123; <span class="comment">// 和 debug 相关，只是输出一些 log 信息！</span></span><br><span class="line"></span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="number">128</span>);</span><br><span class="line">            sb.append(<span class="string">"Not potential delay (state="</span>).append(proc.curProcState)</span><br><span class="line">                    .append(<span class="string">' '</span>).append(proc.adjType);</span><br><span class="line">            String reason = proc.makeAdjReason();</span><br><span class="line">            <span class="keyword">if</span> (reason != <span class="keyword">null</span>) &#123;</span><br><span class="line">                sb.append(<span class="string">' '</span>);</span><br><span class="line">                sb.append(reason);</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(<span class="string">"): "</span>);</span><br><span class="line">            sb.append(r.toString());</span><br><span class="line">            Slog.v(TAG_SERVICE, sb.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (DEBUG_DELAYED_STARTS) &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 和 debug 相关，只是输出一些 log 信息！</span></span><br><span class="line">        <span class="keyword">if</span> (callerFg) &#123;</span><br><span class="line">            Slog.v(TAG_SERVICE, <span class="string">"Not potential delay (callerFg="</span> + callerFg + <span class="string">" uid="</span></span><br><span class="line">                    + callingUid + <span class="string">" pid="</span> + callingPid + <span class="string">"): "</span> + r);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.app != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Slog.v(TAG_SERVICE, <span class="string">"Not potential delay (cur app="</span> + r.app + <span class="string">"): "</span> + r);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Slog.v(TAG_SERVICE,</span><br><span class="line">                    <span class="string">"Not potential delay (user "</span> + r.userId + <span class="string">" not started): "</span> + r);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【9】进一步调用！</span></span><br><span class="line">    <span class="keyword">return</span> startServiceInnerLocked(smap, service, r, callerFg, addToStarting);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该方法的主要流程：</p>
<ul>
<li>判断是前台启动，还是后台启动；</li>
<li>检索需要启动的服务的信息；</li>
<li>如果不满足启动条件就取消本次启动；</li>
<li>创建本次启动对应的启动项；</li>
<li>对于后台启动的服务，需要判读是否延迟启动；</li>
<li>进一步启动服务！</li>
</ul>
<p>如何判断后台启动的服务是否需要延迟启动呢，依据如下：</p>
<p>这个地方会对进程的状态做一个判断：</p>
<ul>
<li>如果是前台进程的调度，就直接进行启动；</li>
<li>如果是后台进程的调度，就要先判断一下，是否延迟执行；</li>
</ul>
<p>对于如何判断进程是否是前台进程，还是后台进程，我会在另外一篇文章中说明！！</p>
<h3 id="2-2-1-ActiveServices-unscheduleServiceRestartLocked"><a href="#2-2-1-ActiveServices-unscheduleServiceRestartLocked" class="headerlink" title="2.2.1 ActiveServices.unscheduleServiceRestartLocked"></a>2.2.1 ActiveServices.unscheduleServiceRestartLocked</h3><p>这里有一个方法，取消上一次的重启任务，参数传入：</p>
<ul>
<li>boolean force：传入 false！<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">unscheduleServiceRestartLocked</span><span class="params">(ServiceRecord r, <span class="keyword">int</span> callingUid,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> force)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!force &amp;&amp; r.restartDelay == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】将服务从重启列表中移除！</span></span><br><span class="line">    <span class="keyword">boolean</span> removed = mRestartingServices.remove(r);</span><br><span class="line">    <span class="keyword">if</span> (removed || callingUid != r.appInfo.uid) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 清空 restartCount，restartDelay，restartTime！</span></span><br><span class="line">        r.resetRestartCounter();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (removed) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 让 restartTracker 对 ServiceRecord 重新监控！</span></span><br><span class="line">        clearRestartingIfNeededLocked(r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【2】移除重启任务！</span></span><br><span class="line">    mAm.mHandler.removeCallbacks(r.restarter);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这里有一个数据结构：r.restarter，他是在创建 ServiceRecord 时传入的，他是一个 ServiceRestarter 对象！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceRestarter</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ServiceRecord mService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setService</span><span class="params">(ServiceRecord service)</span> </span>&#123;</span><br><span class="line">        mService = service;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(mAm) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//【1】执行重启操作！</span></span><br><span class="line">            performServiceRestartLocked(mService);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们再去看看 performServiceRestartLocked 方法，是如何实现服务的重启的！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performServiceRestartLocked</span><span class="params">(ServiceRecord r)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】mRestartingServices 没有当前服务，无法执行重启！</span></span><br><span class="line">    <span class="keyword">if</span> (!mRestartingServices.contains(r)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【2】不需要重启服务！</span></span><br><span class="line">    <span class="keyword">if</span> (!isServiceNeeded(r, <span class="keyword">false</span>, <span class="keyword">false</span>)) &#123;</span><br><span class="line">        Slog.wtf(TAG, <span class="string">"Restarting service that is not needed: "</span> + r);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//【3】再次拉起服务！！</span></span><br><span class="line">        bringUpServiceLocked(r, r.intent.getIntent().getFlags(), r.createdFromFg, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (TransactionTooLargeException e) &#123;</span><br><span class="line">        <span class="comment">// Ignore, it's been logged and nothing upstack cares.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>用于执行重启操作，这里我们只是简单地看看！</p>
<h2 id="2-3-ActiveServices-startServiceInnerLocked"><a href="#2-3-ActiveServices-startServiceInnerLocked" class="headerlink" title="2.3 ActiveServices.startServiceInnerLocked"></a>2.3 ActiveServices.startServiceInnerLocked</h2><p>接下来，进一步地启动服务，如果 addToStarting 为 true，表示该服务是后台启动的，需要将其添加到 mStartingBackground 集合中！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ComponentName <span class="title">startServiceInnerLocked</span><span class="params">(ServiceMap smap, Intent service, ServiceRecord r,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> callerFg, <span class="keyword">boolean</span> addToStarting)</span> <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line"></span><br><span class="line">    ServiceState stracker = r.getTracker();</span><br><span class="line">    <span class="keyword">if</span> (stracker != <span class="keyword">null</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 通知服务的 tracker 对象，开始监控服务!</span></span><br><span class="line">        stracker.setStarted(<span class="keyword">true</span>, mAm.mProcessStats.getMemFactorLocked(), r.lastActivity);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 表示是否被启动了，在启动前初始化为 false！</span></span><br><span class="line">    r.callStart = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (r.stats.getBatteryStats()) &#123;</span><br><span class="line">        r.stats.startRunningLocked();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//【1】拉起服务，这个方法会拉起服务的 onCreate 和 onStartCommand 方法！</span></span><br><span class="line">    String error = bringUpServiceLocked(r, service.getFlags(), callerFg, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (error != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ComponentName(<span class="string">"!!"</span>, error);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【2】如果服务已经被请求启动（startRequested 为 true），且是后台启动（addToStarting 为 true）</span></span><br><span class="line">    <span class="keyword">if</span> (r.startRequested &amp;&amp; addToStarting) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">boolean</span> first = smap.mStartingBackground.size() == <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将服务添加到 mStartingBackground 列表中，表示正在后台启动！</span></span><br><span class="line">        smap.mStartingBackground.add(r);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置后台启动服务的超时时间！</span></span><br><span class="line">        r.startingBgTimeout = SystemClock.uptimeMillis() + BG_START_TIMEOUT;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DEBUG_DELAYED_SERVICE) &#123;</span><br><span class="line"></span><br><span class="line">            RuntimeException here = <span class="keyword">new</span> RuntimeException(<span class="string">"here"</span>);</span><br><span class="line">            here.fillInStackTrace();</span><br><span class="line">            Slog.v(TAG_SERVICE, <span class="string">"Starting background (first="</span> + first + <span class="string">"): "</span> + r, here);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (DEBUG_DELAYED_STARTS) &#123;</span><br><span class="line">            Slog.v(TAG_SERVICE, <span class="string">"Starting background (first="</span> + first + <span class="string">"): "</span> + r);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【2.1】如果 first 为 true，表示这是第一个后台启动的服务！那就需要初始化延迟启动的任务调度！</span></span><br><span class="line">        <span class="keyword">if</span> (first) &#123;</span><br><span class="line">            smap.rescheduleDelayedStarts();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (callerFg) &#123;</span><br><span class="line">        <span class="comment">//【2.2】如果是前台启动该服务，就取消该服务之前的后台运行任务！</span></span><br><span class="line">        smap.ensureNotStartingBackground(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于前台启动的方式：<code>callerFg</code> 为 <code>true</code>，<code>addToStarting</code> 为 <code>false</code>，就会执行 <code>ensureNotStartingBackground</code> 取消服务后台启动！<br>对于后台启动的方式：<code>callerFg</code> 为 <code>false</code>，<code>addToStarting</code> 为 <code>true</code>，就会将服务添加到 <code>mStartingBackground</code> 集合中！</p>
<h3 id="2-3-1-ServiceMap-rescheduleDelayedStart"><a href="#2-3-1-ServiceMap-rescheduleDelayedStart" class="headerlink" title="2.3.1 ServiceMap.rescheduleDelayedStart"></a>2.3.1 ServiceMap.rescheduleDelayedStart</h3><p>对于后台启动的方式，如果 <code>mStartingBackground.size() == 0</code>，那就需要对延迟启动的调度做一次初始化，我们先来看看 <code>rescheduleDelayedStarts</code> 方法！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rescheduleDelayedStarts</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 移除 MSG_BG_START_TIMEOUT 后台启动超时消息！</span></span><br><span class="line">        removeMessages(MSG_BG_START_TIMEOUT);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【1】对于后台启动的服务，如果后台启动超时，就从移除该服务！ 为延迟后台启动的服务腾出位置！</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>, N=mStartingBackground.size(); i&lt;N; i++) &#123;</span><br><span class="line">            ServiceRecord r = mStartingBackground.get(i);</span><br><span class="line">            <span class="keyword">if</span> (r.startingBgTimeout &lt;= now) &#123;</span><br><span class="line">                Slog.i(TAG, <span class="string">"Waited long enough for: "</span> + r);</span><br><span class="line">                mStartingBackground.remove(i);</span><br><span class="line">                N--;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【2】处理后台延迟启动的服务，如果此时延迟启动列表不为空，且正在后台启动的服务数不超过最大后台启动数</span></span><br><span class="line">        <span class="comment">// 那这个时候就要处理后台延迟服务的启动了！</span></span><br><span class="line">        <span class="keyword">while</span> (mDelayedStartList.size() &gt; <span class="number">0</span></span><br><span class="line">                &amp;&amp; mStartingBackground.size() &lt; mMaxStartingBackground) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//【2.1】从 mDelayedStartList 移除该服务，保存到 r 中！</span></span><br><span class="line">            ServiceRecord r = mDelayedStartList.remove(<span class="number">0</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE,</span><br><span class="line">                    <span class="string">"REM FR DELAY LIST (exec next): "</span> + r);</span><br><span class="line">            <span class="keyword">if</span> (r.pendingStarts.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"**** NO PENDING STARTS! "</span> + r + <span class="string">" startReq="</span> + r.startRequested</span><br><span class="line">                        + <span class="string">" delayedStop="</span> + r.delayedStop);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (DEBUG_DELAYED_SERVICE) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mDelayedStartList.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    Slog.v(TAG_SERVICE, <span class="string">"Remaining delayed list:"</span>);</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;mDelayedStartList.size(); i++) &#123;</span><br><span class="line">                        Slog.v(TAG_SERVICE, <span class="string">"  #"</span> + i + <span class="string">": "</span> + mDelayedStartList.get(i));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将 r.delayed 设为 false；</span></span><br><span class="line">            r.delayed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//【2.2】后台启动该服务（callerFg 为 false，addStarting 为 true）</span></span><br><span class="line">                <span class="comment">// 服务会被添加到 mStartingBackground 列表中！</span></span><br><span class="line">                startServiceInnerLocked(<span class="keyword">this</span>, r.pendingStarts.get(<span class="number">0</span>).intent, r, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (TransactionTooLargeException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【3】设置后台启动的超时处理！</span></span><br><span class="line">        <span class="keyword">if</span> (mStartingBackground.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// 设置后台超时消息的发送的时间 when 为 startingBgTimeout 和 now 中的最大值！</span></span><br><span class="line">            ServiceRecord next = mStartingBackground.get(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">long</span> when = next.startingBgTimeout &gt; now ? next.startingBgTimeout : now;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (DEBUG_DELAYED_SERVICE) Slog.v(TAG_SERVICE, <span class="string">"Top bg start is "</span> + next</span><br><span class="line">                    + <span class="string">", can delay others up to "</span> + when);</span><br><span class="line"></span><br><span class="line">            Message msg = obtainMessage(MSG_BG_START_TIMEOUT);</span><br><span class="line">            sendMessageAtTime(msg, when);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【4】发送那些等待后台服务启动的后台广播！</span></span><br><span class="line">        <span class="keyword">if</span> (mStartingBackground.size() &lt; mMaxStartingBackground) &#123;</span><br><span class="line">            mAm.backgroundServicesFinishedLocked(mUserId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到，对于延迟后台启动的服务，最后又会调用 <code>startServiceInnerLocked</code> 后台启动，然后，该服务会被添加到 <code>mStartingBackground</code> 列表中，表示正在启动，这个我们后面会分析到！</p>
<p>该方法的主要作用是：</p>
<ul>
<li>移除 <code>mStartingBackground</code> 中已经启动超时的服务；</li>
<li>如果后台启动的服务数小于最大允许后台启动的服务数，且 <code>mDelayedStartList</code> 中有延迟启动的服务，就立刻启动并移除 <code>mDelayedStartList</code> 中的服务，然后将其添加到 <code>mStartingBackground</code> 列表中！</li>
<li>设置后台启动的超时处理！</li>
<li>发送那些等待后台服务启动的后台广播！</li>
</ul>
<p><br></p>
<p>这里要简单的说一下 <strong>ServiceMap</strong>：</p>
<p><code>ServiceMap</code> 是 <code>Handler</code> 的子类，其内部封装了指定设备用户所有的服务信息对象，还有后台启动的服务对象列表 <code>mStartingBackground</code>，以及延迟后台启动的服务对象列表 <code>mDelayedStartList</code>！</p>
<p>其本身是 <code>Handler</code>，用于处理 <code>MSG_BG_START_TIMEOUT</code>消息：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">        <span class="keyword">case</span> MSG_BG_START_TIMEOUT: &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mAm) &#123;</span><br><span class="line">                <span class="comment">//【1】</span></span><br><span class="line">                rescheduleDelayedStarts();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>ServiceMap</code> 收到该消息后，会再次触发 <code>rescheduleDelayedStart</code> 方法，该内部又会发送 <code>MSG_BG_START_TIMEOUT</code> 消息，这样就会不断的循环发送 <code>MSG_BG_START_TIMEOUT</code> 消息，不断的处理  <code>mDelayedStartList</code> 和 <code>mStartingBackground</code><br>列表，保证所有的后台延迟启动的服务能够即使启动，同时设置后台启动的超时处理！</p>
<h3 id="2-3-2-ServiceMap-ensureNotStartingBackground"><a href="#2-3-2-ServiceMap-ensureNotStartingBackground" class="headerlink" title="2.3.2 ServiceMap.ensureNotStartingBackground"></a>2.3.2 ServiceMap.ensureNotStartingBackground</h3><p>对于前台启动的方式，就需要更新 <code>mStartingBackground</code> 和 <code>mDelayedStartList</code> 集合中的元素了，尝试将当前的服务从这两个集合中删除，因为这里是前台启动，我们继续看：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ensureNotStartingBackground</span><span class="params">(ServiceRecord r)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】从 mStartingBackground 中删除当前服务；</span></span><br><span class="line">    <span class="keyword">if</span> (mStartingBackground.remove(r)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE,</span><br><span class="line">                <span class="string">"No longer background starting: "</span> + r);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【1.1】再次启动后台延迟服务的调度！</span></span><br><span class="line">        rescheduleDelayedStarts();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】从 mDelayedStartList 中删除当前服务；</span></span><br><span class="line">    <span class="keyword">if</span> (mDelayedStartList.remove(r)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE, <span class="string">"No longer delaying start: "</span> + r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先是尝试从 <code>mStartingBackground</code> 中删除当前服务，如果删除成功，就要再次调用 <code>rescheduleDelayedStarts</code> 方法，尝试后台启动被延迟后台启动的服务，并再次发送 <code>MSG_BG_START_TIMEOUT</code> 消息！</p>
<h3 id="2-3-3-阶段总结"><a href="#2-3-3-阶段总结" class="headerlink" title="2.3.3 阶段总结"></a>2.3.3 阶段总结</h3><p>对于立刻后台启动的服务 <code>r</code>，启动时，都会被添加到 <code>mStartingBackground</code> 列表中，并且设置 <code>r.startingBgTimeout</code> 后台启动超时时间为 <code>now + 15s</code>；每个后台启动的服务 <code>r</code>，当其 <code>r.startingBgTimeout</code> 时间到了后，会从 <code>mStartingBackground</code> 列表中删除；</p>
<p>对于延迟后台启动的服务 <code>r</code>，都会添加到 <code>mDelayedStartList</code> 列表中，并且设置 <code>r.delayed</code> 为 <code>true</code>，每个延迟后台启动的服务的启动都依赖于一个条件：<code>mStartingBackground.size() &lt; mMaxStartingBackground</code>；</p>
<p>通过上面的分析，我们可以知道 <code>rescheduleDelayedStarts</code> 和 <code>ensureNotStartingBackground</code> 作用是什么了:</p>
<p>就是不断处理 <code>mStartingBackground</code> 中的服务，不断的根据 <code>mStartingBackground</code> 中服务的 <code>r.startingBgTimeout</code> 发送 <code>MSG_BG_START_TIMEOUT</code> 消息，不断的处理该消息，删除对应的服务，使得 <code>mStartingBackground.size() &lt; mMaxStartingBackground</code>，为 <code>mDelayedStartList</code> 中的服务腾出位置，保证这些延迟后台启动的服务能够后台启动！</p>
<h2 id="2-4-ActiveServices-bringUpServiceLocked"><a href="#2-4-ActiveServices-bringUpServiceLocked" class="headerlink" title="2.4 ActiveServices.bringUpServiceLocked"></a>2.4 ActiveServices.bringUpServiceLocked</h2><p>下面我们来看看，系统进程是如何拉起 Serivce 的，传入参数分析：</p>
<ul>
<li><strong>ServiceRecord r</strong>：服务的 ServiceRecord 对象；</li>
<li><strong>int intentFlags</strong>：启动服务的 intent 的 flag，通过 getFlags 获得；</li>
<li><strong>boolean execInFg</strong>：传入 callFg，表示本次启动是前台调用还是后台调用；</li>
<li><strong>boolean whileRestarting</strong>：表示是否是正在重启，传入 false；</li>
<li><strong>boolean permissionsReviewRequired</strong>：false；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">bringUpServiceLocked</span><span class="params">(ServiceRecord r, <span class="keyword">int</span> intentFlags, <span class="keyword">boolean</span> execInFg,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> whileRestarting, <span class="keyword">boolean</span> permissionsReviewRequired)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】如果 r.app 和 r.app.thread 都不为 null。说明不仅服务所在进程已经被启动，服务也已经被创建（onCreate）；</span></span><br><span class="line">    <span class="comment">// 那就直接拉起 onStartCommand() 方法！这里我们先假设服务所在的进程还没有被启动！</span></span><br><span class="line">    <span class="keyword">if</span> (r.app != <span class="keyword">null</span> &amp;&amp; r.app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        sendServiceArgsLocked(r, execInFg, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】如果服务正在等待重启，就退出！</span></span><br><span class="line">    <span class="keyword">if</span> (!whileRestarting &amp;&amp; r.restartDelay &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">"Bringing up "</span> + r + <span class="string">" "</span> + r.intent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【3】如果服务是被启动了，所以要从 mRestartingServices 列表中移除它，并清除内部的启动计数！</span></span><br><span class="line">    <span class="keyword">if</span> (mRestartingServices.remove(r)) &#123;</span><br><span class="line">        r.resetRestartCounter();</span><br><span class="line">        clearRestartingIfNeededLocked(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【4】如果这个服务被延迟后台启动，即 delayed 为 true，那就从 mDelayedStartList 中移除它，</span></span><br><span class="line">    <span class="comment">// 并置 r.delayed 为 false；</span></span><br><span class="line">    <span class="keyword">if</span> (r.delayed) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE, <span class="string">"REM FR DELAY LIST (bring up): "</span> + r);</span><br><span class="line">        getServiceMap(r.userId).mDelayedStartList.remove(r);</span><br><span class="line">        r.delayed = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果这个服务所在的设备用户没有被启动，那就不允许启动这个服务！</span></span><br><span class="line">    <span class="keyword">if</span> (!mAm.mUserController.hasStartedUserState(r.userId)) &#123;</span><br><span class="line">        String msg = <span class="string">"Unable to launch app "</span></span><br><span class="line">                + r.appInfo.packageName + <span class="string">"/"</span></span><br><span class="line">                + r.appInfo.uid + <span class="string">" for service "</span></span><br><span class="line">                + r.intent.getIntent() + <span class="string">": user "</span> + r.userId + <span class="string">" is stopped"</span>;</span><br><span class="line">        Slog.w(TAG, msg);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 停止这个服务！</span></span><br><span class="line">        bringDownServiceLocked(r);</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 服务将要被启动，所以要设置其 package 的停止状态为 false；</span></span><br><span class="line">        AppGlobals.getPackageManager().setPackageStoppedState(</span><br><span class="line">                r.packageName, <span class="keyword">false</span>, r.userId);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"Failed trying to unstop package "</span></span><br><span class="line">                + r.packageName + <span class="string">": "</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断这个服务是否属于隔离进程；</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isolated = (r.serviceInfo.flags&amp;ServiceInfo.FLAG_ISOLATED_PROCESS) != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【5】获得要启动的服务的目标进程名和进程对象；</span></span><br><span class="line">    <span class="keyword">final</span> String procName = r.processName;</span><br><span class="line">    ProcessRecord app;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isolated) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对于非隔离进程，先获得所在进程的 ProcessRecord 对象；</span></span><br><span class="line">        app = mAm.getProcessRecordLocked(procName, r.appInfo.uid, <span class="keyword">false</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (DEBUG_MU) Slog.v(TAG_MU, <span class="string">"bringUpServiceLocked: appInfo.uid="</span> + r.appInfo.uid</span><br><span class="line">                    + <span class="string">" app="</span> + app);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (app != <span class="keyword">null</span> &amp;&amp; app.thread != <span class="keyword">null</span>) &#123; <span class="comment">// 如果进程已经启动；</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                app.addPackage(r.appInfo.packageName, r.appInfo.versionCode, mAm.mProcessStats);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//【5.1】启动指定服务！</span></span><br><span class="line">                realStartServiceLocked(r, app, execInFg);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (TransactionTooLargeException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Exception when starting service "</span> + r.shortName, e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对于隔离进程，获得服务之前所在的进程！</span></span><br><span class="line">        app = r.isolatedProc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果服务所在的进程没有启动！</span></span><br><span class="line">    <span class="keyword">if</span> (app == <span class="keyword">null</span> &amp;&amp; !permissionsReviewRequired) &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//【6】首先要启动服务所在的进程，这里请去看进程启动和创建的博文！</span></span><br><span class="line">        <span class="keyword">if</span> ((app=mAm.startProcessLocked(procName, r.appInfo, <span class="keyword">true</span>, intentFlags,</span><br><span class="line">                <span class="string">"service"</span>, r.name, <span class="keyword">false</span>, isolated, <span class="keyword">false</span>)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            String msg = <span class="string">"Unable to launch app "</span></span><br><span class="line">                    + r.appInfo.packageName + <span class="string">"/"</span></span><br><span class="line">                    + r.appInfo.uid + <span class="string">" for service "</span></span><br><span class="line">                    + r.intent.getIntent() + <span class="string">": process is bad"</span>;</span><br><span class="line">            Slog.w(TAG, msg);</span><br><span class="line"></span><br><span class="line">            bringDownServiceLocked(r); <span class="comment">// 进程启动失败；</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> msg;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果服务要运行在隔离进程中，就把创建的 ProcessRecord 保存到 r.isolatedProc 中！</span></span><br><span class="line">        <span class="keyword">if</span> (isolated) &#123;</span><br><span class="line">            r.isolatedProc = app;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【7】将这个服务加入到 mPendingServices 中，表示该服务正在其所在的进程启动；</span></span><br><span class="line">    <span class="keyword">if</span> (!mPendingServices.contains(r)) &#123;</span><br><span class="line">        mPendingServices.add(r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.delayedStop) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Oh and hey we've already been asked to stop!</span></span><br><span class="line">        r.delayedStop = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (r.startRequested) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE,</span><br><span class="line">                    <span class="string">"Applying delayed stop (in bring up): "</span> + r);</span><br><span class="line">            stopServiceLocked(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来总结一下，这个方法的流程：</p>
<blockquote>
<p>第一阶段： </p>
</blockquote>
<ul>
<li>如果服务所在的进程已经启动，就调用 <code>sendServiceArgsLocked</code>，通过 <code>ApplicationThread</code> 拉起 <code>onStartCommand</code> 的方法，<strong>结束流程</strong>；</li>
<li>如果服务所在的进程没有被启动，进入下面的流程：</li>
</ul>
<blockquote>
<p>第二阶段： </p>
</blockquote>
<ul>
<li>如果服务正在等待重启，不处理，<strong>结束流程</strong>；</li>
<li>否则，进入下面的流程：</li>
</ul>
<blockquote>
<p>第三阶段： </p>
</blockquote>
<ul>
<li>当前服务要被启动了，就从等待重启 <code>mRestartingServices</code> 中移除它；</li>
<li>如果这个服务是被延迟启动（<code>delayed</code> 的值为 <code>true</code>）的，就从 <code>mDelayedStartList</code> 中移除它，并置其 <code>delayed</code> 为 <code>false</code>；</li>
<li>当前服务将要被启动，所以要设置其 <code>package</code> 的停止状态为 <code>false</code>；</li>
<li>判断这个进程是否是隔离进程：<ul>
<li>如果是非隔离进程，根据进程名和 <code>uid</code>，获得其所在进程的 <code>ProcessRecord</code> 对象，如果进程已经启动，就启动指定服务，<strong>结束流程</strong>；</li>
<li>如果是隔离进程，获得服务之前所在的隔离进程的 <code>ProcessRecord</code> 对象；</li>
</ul>
</li>
</ul>
<blockquote>
<p>第四阶段： </p>
</blockquote>
<ul>
<li>根据获得的 <code>ProcessRecord</code> 对象，判断，如果之前服务所在进程没有启动，就需要先启动进程；</li>
<li>将服务添加到 <code>mPendingServices</code> 中，表示正在启动该服务；</li>
</ul>
<p>之前我们有说，我们假设要启动的服务所在的进程没有被启动，那么就要先启动目标进程，具体的启动过程，大家可以去看我的其他几篇博客：<br><strong>Android 进程的创建和启动</strong></p>
<p>这里我们直接用之前的结果，进入 <code>AMS.attachApplicationLocked</code> 方法！</p>
<h2 id="2-5-ActivityManagerS-attachApplicationLocked"><a href="#2-5-ActivityManagerS-attachApplicationLocked" class="headerlink" title="2.5 ActivityManagerS.attachApplicationLocked"></a>2.5 ActivityManagerS.attachApplicationLocked</h2><p>当应用进程启动后，会通过 Binder 通信，调用 AMS.attachApplicationLocked，我们去看看：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">attachApplicationLocked</span><span class="params">(IApplicationThread thread,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> pid)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        ... ... ... ...</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这里会回到应用进程中，创建 Applicaiton 对象，并调用其 onCreate 方法，这里我们先不说！</span></span><br><span class="line">        thread.bindApplication(processName, appInfo, providers, app.instrumentationClass,</span><br><span class="line">                profilerInfo, app.instrumentationArguments, app.instrumentationWatcher,</span><br><span class="line">                app.instrumentationUiAutomationConnection, testMode,</span><br><span class="line">                mBinderTransactionTrackingEnabled, enableTrackAllocation,</span><br><span class="line">                isRestrictedBackupMode || !normalMode, app.persistent,</span><br><span class="line">                <span class="keyword">new</span> Configuration(mConfiguration), app.compat,</span><br><span class="line">                getCommonServicesLocked(app.isolated),</span><br><span class="line">                mCoreSettingsObserver.getCoreSettingsLocked());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新进程 LRU 队列！</span></span><br><span class="line">        updateLruProcessLocked(app, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        app.lastRequestedGc = app.lastLowMemory = SystemClock.uptimeMillis();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        app.resetPackageList(mProcessStats);</span><br><span class="line">        app.unlinkDeathRecipient();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每当 bind 操作失败，则重新启动进程, 此处有可能会导致进程无限重启。</span></span><br><span class="line">        startProcessLocked(app, <span class="string">"bind fail"</span>, processName);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将当前已经被启动的新进程的 ProcessRecord 从正在启动的进程集合 mPersistentStartingProcesses</span></span><br><span class="line">    <span class="comment">// 和等待启动的进程集合 mProcessesOnHold 中移除！</span></span><br><span class="line">    mPersistentStartingProcesses.remove(app);</span><br><span class="line">    mProcessesOnHold.remove(app);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> badApp = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> didSomething = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    ... ... ... ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!badApp) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 检查是否有 sevvce 组件要在这个新进程中运行！</span></span><br><span class="line">            didSomething |= mServices.attachApplicationLocked(app, processName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Slog.wtf(TAG, <span class="string">"Exception thrown starting services in "</span> + app, e);</span><br><span class="line">            badApp = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ... ... ... ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (badApp) &#123; <span class="comment">// badApp 为 true，就杀掉这个进程</span></span><br><span class="line">        app.kill(<span class="string">"error during init"</span>, <span class="keyword">true</span>);</span><br><span class="line">        handleAppDiedLocked(app, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!didSomething) &#123; <span class="comment">// 检查后发现，没有任何组件要运行在新进程，更新 OomAdj 的值！</span></span><br><span class="line">        updateOomAdjLocked();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>bindApplication</code> 方法会回到应用进程中，创建 <code>Applicaiton</code> 对象，并调用其 <code>onCreate</code> 方法，这里我们不看！</p>
<p>这里会调用 <code>ActiveServices</code> 的 <code>attachApplicationLocked</code> 方法！</p>
<h2 id="2-6-ActiveServices-attachApplicationLocked"><a href="#2-6-ActiveServices-attachApplicationLocked" class="headerlink" title="2.6 ActiveServices.attachApplicationLocked"></a>2.6 ActiveServices.attachApplicationLocked</h2><p>当应用进程启动成功，并且 Application 对象已经创建，其 onCreate 方法已经调用后，就要启动指定的服务了！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">attachApplicationLocked</span><span class="params">(ProcessRecord proc, String processName)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> didSomething = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【1】启动该进程中所有的服务！</span></span><br><span class="line">    <span class="keyword">if</span> (mPendingServices.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        ServiceRecord sr = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历 mPendingServices 集合中的所有服务，启动属于这个进程的所有服务！</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;mPendingServices.size(); i++) &#123;</span><br><span class="line">                sr = mPendingServices.get(i);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (proc != sr.isolatedProc &amp;&amp; (proc.uid != sr.appInfo.uid</span><br><span class="line">                        || !processName.equals(sr.processName))) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                mPendingServices.remove(i);</span><br><span class="line"></span><br><span class="line">                i--;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 将服务的包名，版本号以及 AMS 的进程状态对象保存到进程对象中！</span></span><br><span class="line">                proc.addPackage(sr.appInfo.packageName, sr.appInfo.versionCode,</span><br><span class="line">                        mAm.mProcessStats);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//【1】启动服务，这里又回到了之前的方法中！</span></span><br><span class="line">                realStartServiceLocked(sr, proc, sr.createdFromFg);</span><br><span class="line"></span><br><span class="line">                didSomething = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!isServiceNeeded(sr, <span class="keyword">false</span>, <span class="keyword">false</span>)) &#123; <span class="comment">// 如果已经不需要启动了，就取消启动！</span></span><br><span class="line"></span><br><span class="line">                    bringDownServiceLocked(sr);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Exception in new application when starting service "</span></span><br><span class="line">                    + sr.shortName, e);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】接着启动那些需要重启的服务，重启的服务都会保存到 mRestartingServices 服务中！</span></span><br><span class="line">    <span class="comment">// 因为重启的时间可能还没有到，所以这里并不是立刻启动它们，而是启动了一个任务，交给了 AMS 的 MainHandler 去做！</span></span><br><span class="line">    <span class="keyword">if</span> (mRestartingServices.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ServiceRecord sr;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;mRestartingServices.size(); i++) &#123;</span><br><span class="line"></span><br><span class="line">            sr = mRestartingServices.get(i);</span><br><span class="line">            <span class="keyword">if</span> (proc != sr.isolatedProc &amp;&amp; (proc.uid != sr.appInfo.uid</span><br><span class="line">                    || !processName.equals(sr.processName))) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// sr.restarter 是一个 ServiceRestarter 对象，是一个 Runnable，这里会执行重启！</span></span><br><span class="line">            mAm.mHandler.removeCallbacks(sr.restarter);</span><br><span class="line">            mAm.mHandler.post(sr.restarter);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> didSomething;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里有一个方法 <code>isServiceNeeded</code> 是否需要启动服务：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isServiceNeeded</span><span class="params">(ServiceRecord r, <span class="keyword">boolean</span> knowConn, <span class="keyword">boolean</span> hasConn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r.startRequested) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!knowConn) &#123;</span><br><span class="line">        hasConn = r.hasAutoCreateConnections();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (hasConn) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>判断依据很简单:</p>
<ul>
<li><code>r.startRequested</code> 为 <code>true</code>，说明服务被请求启动，那么就需要；</li>
<li><code>r.hasAutoCreateConnections</code> 为 <code>true</code>；说明有应用已经和该服务建立了自动创建的连接，那么就需要；</li>
</ul>
<p>我们发现无论进程是否已经被创建，最终都会调用 <code>realStartServiceLocked</code> 方法！</p>
<h2 id="2-7-AS-realStartServiceLocked"><a href="#2-7-AS-realStartServiceLocked" class="headerlink" title="2.7 AS.realStartServiceLocked"></a>2.7 AS.realStartServiceLocked</h2><p>通过调用 realStartServiceLocked 方法来启动进程中的指定服务：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">realStartServiceLocked</span><span class="params">(ServiceRecord r,</span></span></span><br><span class="line"><span class="function"><span class="params">        ProcessRecord app, <span class="keyword">boolean</span> execInFg)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (app.thread == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RemoteException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG_MU)</span><br><span class="line">        Slog.v(TAG_MU, <span class="string">"realStartServiceLocked, ServiceRecord.uid = "</span> + r.appInfo.uid</span><br><span class="line">                + <span class="string">", ProcessRecord.uid = "</span> + app.uid);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置服务的进程对象；</span></span><br><span class="line">    r.app = app;</span><br><span class="line">    <span class="comment">// 设置服务的启动和活跃时间；</span></span><br><span class="line">    r.restartTime = r.lastActivity = SystemClock.uptimeMillis();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将被启动服务的 ServiceRecord 对象添加到所属进程的 app.services 中！</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> newService = app.services.add(r);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【1】针对 onCreate 方法，设置超时处理！</span></span><br><span class="line">    bumpServiceExecutingLocked(r, execInFg, <span class="string">"create"</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 更新 LruProcess 和 OomAdj！</span></span><br><span class="line">    mAm.updateLruProcessLocked(app, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">    mAm.updateOomAdjLocked();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> created = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (LOG_SERVICE_START_STOP) &#123; <span class="comment">// log 相关！</span></span><br><span class="line">            String nameTerm;</span><br><span class="line">            <span class="keyword">int</span> lastPeriod = r.shortName.lastIndexOf(<span class="string">'.'</span>);</span><br><span class="line">            nameTerm = lastPeriod &gt;= <span class="number">0</span> ? r.shortName.substring(lastPeriod) : r.shortName;</span><br><span class="line">            EventLogTags.writeAmCreateService(</span><br><span class="line">                    r.userId, System.identityHashCode(r), nameTerm, r.app.uid, r.app.pid);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (r.stats.getBatteryStats()) &#123;</span><br><span class="line">            r.stats.startLaunchedLocked();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mAm.notifyPackageUse(r.serviceInfo.packageName,</span><br><span class="line">                             PackageManager.NOTIFY_PACKAGE_USE_SERVICE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将进程的状态更新为 ActivityManager.PROCESS_STATE_SERVICE！</span></span><br><span class="line">        app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【2】通过 binder 通信，拉起服务的 onCreate 方法！</span></span><br><span class="line">        app.thread.scheduleCreateService(r, r.serviceInfo,</span><br><span class="line">                mAm.compatibilityInfoForPackageLocked(r.serviceInfo.applicationInfo),</span><br><span class="line">                app.repProcState);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果服务通过 setForeground 方法设置了通知，就显示通知！</span></span><br><span class="line">        r.postNotification();</span><br><span class="line"></span><br><span class="line">        created = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (DeadObjectException e) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"Application dead when creating service "</span> + r);</span><br><span class="line">        mAm.appDiedLocked(app); <span class="comment">// 如果在服务启动时，应用进程死了，调用 appDiedLocked 通知死亡仆告对象！</span></span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!created) &#123; <span class="comment">// 如果启动失败，并且不死一个被销毁的服务，那就尝试重启他！</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> inDestroying = mDestroyingServices.contains(r);</span><br><span class="line">            serviceDoneExecutingLocked(r, inDestroying, inDestroying);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (newService) &#123;</span><br><span class="line">                app.services.remove(r);</span><br><span class="line">                r.app = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!inDestroying) &#123;</span><br><span class="line">                scheduleServiceRestartLocked(r, <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.whitelistManager) &#123;</span><br><span class="line">        app.whitelistManager = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 拉起 onBind 相关的方法，但是这里是不会触发的，因为 r.bindings 集合只有在 bindService 才会有元素！</span></span><br><span class="line">    <span class="comment">// 但是，如果之前 bindService 的标志位设置的不是 Context.BIND_AUTO_CREATE，而是其他参数，那么其 r.bindings</span></span><br><span class="line">    <span class="comment">// 是有元素的，这里才会调用服务的 onBind 方法，为之前的 bindService 返回代理对象！</span></span><br><span class="line">    requestServiceBindingsLocked(r, execInFg);</span><br><span class="line"></span><br><span class="line">    updateServiceClientActivitiesLocked(app, <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果服务被请求启动，但是其内部的启动项为 0，那就创建一个启动项，保证 Service 的 onStartCommand 可以被调用；</span></span><br><span class="line">    <span class="keyword">if</span> (r.startRequested &amp;&amp; r.callStart &amp;&amp; r.pendingStarts.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        r.pendingStarts.add(<span class="keyword">new</span> ServiceRecord.StartItem(r, <span class="keyword">false</span>, r.makeNextStartId(),</span><br><span class="line">                <span class="keyword">null</span>, <span class="keyword">null</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【2】通过 binder 通信，拉起服务的 onStartCommand 方法！</span></span><br><span class="line">    sendServiceArgsLocked(r, execInFg, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是延迟启动的话，在这里将其移除！</span></span><br><span class="line">    <span class="keyword">if</span> (r.delayed) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE, <span class="string">"REM FR DELAY LIST (new proc): "</span> + r);</span><br><span class="line">        getServiceMap(r.userId).mDelayedStartList.remove(r);</span><br><span class="line">        r.delayed = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.delayedStop) &#123;</span><br><span class="line">        <span class="comment">// Oh and hey we've already been asked to stop!</span></span><br><span class="line">        r.delayedStop = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (r.startRequested) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_DELAYED_STARTS) Slog.v(TAG_SERVICE,</span><br><span class="line">                    <span class="string">"Applying delayed stop (from start): "</span> + r);</span><br><span class="line">            stopServiceLocked(r);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>这里要注意</strong>：</p>
<p>方法 <code>requestServiceBindingsLocked</code>，一般是不会触发的，因为 <code>r.bindings</code> 集合只有在 <code>bindService</code> 的情况才会被添加元素！但是，如果之前 <code>bindService</code> 的标志位没有设置 <code>Context.BIND_AUTO_CREATE</code>，而是其他标志位，那么其 <code>r.bindings</code> 是有元素的，这里就会调用服务的 <code>onBind</code> 方法，为之前的 <code>bindService</code> 返回代理对象！</p>
<h3 id="2-7-1-AS-bumpServiceExecutingLocked"><a href="#2-7-1-AS-bumpServiceExecutingLocked" class="headerlink" title="2.7.1 AS.bumpServiceExecutingLocked"></a>2.7.1 AS.bumpServiceExecutingLocked</h3><p>针对 <code>onCreate</code> 方法，设置超时处理，参数 <code>fg</code> 表示这个服务是前台执行，还是后台执行的！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">bumpServiceExecutingLocked</span><span class="params">(ServiceRecord r, <span class="keyword">boolean</span> fg, String why)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">"&gt;&gt;&gt; EXECUTING "</span></span><br><span class="line">            + why + <span class="string">" of "</span> + r + <span class="string">" in app "</span> + r.app);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (DEBUG_SERVICE_EXECUTING) Slog.v(TAG_SERVICE_EXECUTING, <span class="string">"&gt;&gt;&gt; EXECUTING "</span></span><br><span class="line">            + why + <span class="string">" of "</span> + r.shortName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.executeNesting == <span class="number">0</span>) &#123; <span class="comment">// executeNesting 用来记录是否有超时处理操作！</span></span><br><span class="line"></span><br><span class="line">        r.executeFg = fg;</span><br><span class="line">        ServiceState stracker = r.getTracker();</span><br><span class="line">        <span class="keyword">if</span> (stracker != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对该服务进行内存监控处理！</span></span><br><span class="line">            stracker.setExecuting(<span class="keyword">true</span>, mAm.mProcessStats.getMemFactorLocked(), now);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (r.app != <span class="keyword">null</span>) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将服务添加到 ProcessRecord 的 executingServices 集合中，表示服务正在执行某段代码！</span></span><br><span class="line">            r.app.executingServices.add(r);</span><br><span class="line">            r.app.execServicesFg |= fg;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果正在执行指定函数的服务个数为 1，设置超时处理！</span></span><br><span class="line">            <span class="keyword">if</span> (r.app.executingServices.size() == <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">                scheduleServiceTimeoutLocked(r.app);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.app != <span class="keyword">null</span> &amp;&amp; fg &amp;&amp; !r.app.execServicesFg) &#123;</span><br><span class="line"></span><br><span class="line">        r.app.execServicesFg = <span class="keyword">true</span>;</span><br><span class="line">        scheduleServiceTimeoutLocked(r.app);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r.executeFg |= fg;</span><br><span class="line">    r.executeNesting++;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录启动时间！</span></span><br><span class="line">    r.executingStart = now;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们来看看超市处理的操作！</p>
<h4 id="2-7-1-1-AS-scheduleServiceTimeoutLocked"><a href="#2-7-1-1-AS-scheduleServiceTimeoutLocked" class="headerlink" title="2.7.1.1 AS.scheduleServiceTimeoutLocked"></a>2.7.1.1 AS.scheduleServiceTimeoutLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleServiceTimeoutLocked</span><span class="params">(ProcessRecord proc)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果进程没有正在执行某段代码的服务就返回！</span></span><br><span class="line">    <span class="keyword">if</span> (proc.executingServices.size() == <span class="number">0</span> || proc.thread == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">    Message msg = mAm.mHandler.obtainMessage(</span><br><span class="line">            ActivityManagerService.SERVICE_TIMEOUT_MSG);</span><br><span class="line">    msg.obj = proc;</span><br><span class="line"></span><br><span class="line">    mAm.mHandler.sendMessageAtTime(msg,</span><br><span class="line">            proc.execServicesFg ? (now+SERVICE_TIMEOUT) : (now+ SERVICE_BACKGROUND_TIMEOUT));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到：</p>
<ul>
<li>对于前台服务：超时时间是 20s</li>
<li>对于后台服务：超市时间是 200s</li>
</ul>
<p>最后发送 SERVICE_TIMEOUT_MSG 消息到 AMS 的 MainHandler 中！</p>
<h4 id="2-7-1-2-ActivityServiceS-MainHandler"><a href="#2-7-1-2-ActivityServiceS-MainHandler" class="headerlink" title="2.7.1.2 ActivityServiceS.MainHandler"></a>2.7.1.2 ActivityServiceS.MainHandler</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MainHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line"></span><br><span class="line">        ... ... ... ...</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">case</span> SERVICE_TIMEOUT_MSG: &#123;</span><br><span class="line">            <span class="keyword">if</span> (mDidDexOpt) &#123; <span class="comment">// 表示是否延迟执行 odex</span></span><br><span class="line">                mDidDexOpt = <span class="keyword">false</span>;</span><br><span class="line">                Message nmsg = mHandler.obtainMessage(SERVICE_TIMEOUT_MSG);</span><br><span class="line">                nmsg.obj = msg.obj;</span><br><span class="line">                mHandler.sendMessageDelayed(nmsg, ActiveServices.SERVICE_TIMEOUT);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 调用 serviceTimeout，设置超时处理！</span></span><br><span class="line">            mServices.serviceTimeout((ProcessRecord)msg.obj);</span><br><span class="line">        &#125; <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        ... ... ... ...</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着进入 ActiveServices 中！</p>
<h4 id="2-7-1-3-ActiveServices-serviceTimeout"><a href="#2-7-1-3-ActiveServices-serviceTimeout" class="headerlink" title="2.7.1.3 ActiveServices.serviceTimeout"></a>2.7.1.3 ActiveServices.serviceTimeout</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serviceTimeout</span><span class="params">(ProcessRecord proc)</span> </span>&#123;</span><br><span class="line">    String anrMessage = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span>(mAm) &#123;</span><br><span class="line">        <span class="keyword">if</span> (proc.executingServices.size() == <span class="number">0</span> || proc.thread == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> maxTime =  now -</span><br><span class="line">                (proc.execServicesFg ? SERVICE_TIMEOUT : SERVICE_BACKGROUND_TIMEOUT);</span><br><span class="line"></span><br><span class="line">        ServiceRecord timeout = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">long</span> nextTime = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从正在执行代码逻辑的服务列表中，获得判断是否超时的服务！</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=proc.executingServices.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            ServiceRecord sr = proc.executingServices.valueAt(i);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (sr.executingStart &lt; maxTime) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 服务启动已经超时，timeout 不为 null；</span></span><br><span class="line">                timeout = sr;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sr.executingStart &gt; nextTime) &#123;</span><br><span class="line">                nextTime = sr.executingStart;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (timeout != <span class="keyword">null</span> &amp;&amp; mAm.mLruProcesses.contains(proc)) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Timeout executing service: "</span> + timeout);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 启动服务超时了，进入这个分支!</span></span><br><span class="line">            StringWriter sw = <span class="keyword">new</span> StringWriter();</span><br><span class="line">            PrintWriter pw = <span class="keyword">new</span> FastPrintWriter(sw, <span class="keyword">false</span>, <span class="number">1024</span>);</span><br><span class="line">            pw.println(timeout);</span><br><span class="line">            timeout.dump(pw, <span class="string">"    "</span>);</span><br><span class="line">            pw.close();</span><br><span class="line">            mLastAnrDump = sw.toString();</span><br><span class="line">            mAm.mHandler.removeCallbacks(mLastAnrDumpClearer);</span><br><span class="line">            mAm.mHandler.postDelayed(mLastAnrDumpClearer, LAST_ANR_LIFETIME_DURATION_MSECS);</span><br><span class="line">            anrMessage = <span class="string">"executing service "</span> + timeout.shortName;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">// 继续发送超时消息，进行下一轮超时判断！</span></span><br><span class="line">            Message msg = mAm.mHandler.obtainMessage(</span><br><span class="line">                    ActivityManagerService.SERVICE_TIMEOUT_MSG);</span><br><span class="line"></span><br><span class="line">            msg.obj = proc;</span><br><span class="line">            mAm.mHandler.sendMessageAtTime(msg, proc.execServicesFg</span><br><span class="line">                    ? (nextTime+SERVICE_TIMEOUT) : (nextTime + SERVICE_BACKGROUND_TIMEOUT));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (anrMessage != <span class="keyword">null</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 捕捉到 ANR！</span></span><br><span class="line">        mAm.mAppErrors.appNotResponding(proc, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>, anrMessage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到，判断启动服务是否超时：不断的给 AMS 的 MainHandler 发送  SERVICE_TIMEOUT_MSG 消息，不断的判断时间是否超时！</p>
<p>如果超时的话，会触发 AppErrors.appNotResponding 方法，这个我们以后再看！</p>
<h3 id="2-7-2-ApplicationThreadP-scheduleCreateService"><a href="#2-7-2-ApplicationThreadP-scheduleCreateService" class="headerlink" title="2.7.2 ApplicationThreadP.scheduleCreateService"></a>2.7.2 ApplicationThreadP.scheduleCreateService</h3><p>拉起其 onCreate 方法，参数说明：</p>
<ul>
<li>IBinder token：服务的 ServiceRecord 对象，实现了 IBinder 接口！</li>
<li>erviceInfo info：服务的组件信息；</li>
<li>CompatibilityInfo compatInfo：</li>
<li>int processState：服务所在进程的状态；<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApplicationThreadProxy</span> <span class="keyword">implements</span> <span class="title">IApplicationThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleCreateService</span><span class="params">(IBinder token, ServiceInfo info,</span></span></span><br><span class="line"><span class="function"><span class="params">            CompatibilityInfo compatInfo, <span class="keyword">int</span> processState)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Parcel data = Parcel.obtain();</span><br><span class="line">        data.writeInterfaceToken(IApplicationThread.descriptor);</span><br><span class="line">        data.writeStrongBinder(token);</span><br><span class="line">        info.writeToParcel(data, <span class="number">0</span>);</span><br><span class="line">        compatInfo.writeToParcel(data, <span class="number">0</span>);</span><br><span class="line">        data.writeInt(processState);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">// 通过 binder 通信！</span></span><br><span class="line">            mRemote.transact(SCHEDULE_CREATE_SERVICE_TRANSACTION, data, <span class="keyword">null</span>,</span><br><span class="line">                    IBinder.FLAG_ONEWAY);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (TransactionTooLargeException e) &#123;</span><br><span class="line">            Log.e(<span class="string">"CREATE_SERVICE"</span>, <span class="string">"Binder failure starting service; service="</span> + info);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        data.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>binder 通信，进入应用进程！</p>
<h3 id="2-7-3-AS-sendServiceArgsLocked"><a href="#2-7-3-AS-sendServiceArgsLocked" class="headerlink" title="2.7.3 AS.sendServiceArgsLocked"></a>2.7.3 AS.sendServiceArgsLocked</h3><p>拉起其 onStartCommand 方法：</p>
<p>参数传递：</p>
<ul>
<li>ServiceRecord r：被启动的服务的数据对象，它实现了 Binder 接口，可以跨进程传递；</li>
<li>boolean execInFg：callFg，表示本次启动是前台调用还是后台调用；</li>
<li>oomAdjusted：传入 false；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">sendServiceArgsLocked</span><span class="params">(ServiceRecord r, <span class="keyword">boolean</span> execInFg,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> oomAdjusted)</span> <span class="keyword">throws</span> TransactionTooLargeException </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 还记得 pendingStarts 吗，在前面启动的时候，</span></span><br><span class="line">    <span class="comment">// 会将 intent 等等的数据封装成 StartItem，保存到 pendingStarts 中；</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> N = r.pendingStarts.size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (N == <span class="number">0</span>) &#123; <span class="comment">// 如果 N 为 null，说明没有启动操作；</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (r.pendingStarts.size() &gt; <span class="number">0</span>) &#123; <span class="comment">// 遍历要启动服务 ServiceRecord 的 pendingStarts！</span></span><br><span class="line">        Exception caughtException = <span class="keyword">null</span>;</span><br><span class="line">        ServiceRecord.StartItem si = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 将要处理的启动项从 pendingStarts 中移除！</span></span><br><span class="line">            si = r.pendingStarts.remove(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">"Sending arguments to: "</span></span><br><span class="line">                    + r + <span class="string">" "</span> + r.intent + <span class="string">" args="</span> + si.intent);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (si.intent == <span class="keyword">null</span> &amp;&amp; N &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果有启动项的 intent 为 null，且启动项目总数大于 1，那就会忽视掉这个 intent！</span></span><br><span class="line">                 <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将要处理的启动项添加到 deliveredStarts 中，表示启动项已经分发处理！</span></span><br><span class="line">            si.deliveredTime = SystemClock.uptimeMillis();</span><br><span class="line">            r.deliveredStarts.add(si);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 增加启动项目的 deliveryCount 计数，表示这个启动项的处理次数！</span></span><br><span class="line">            si.deliveryCount++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (si.neededGrants != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mAm.grantUriPermissionUncheckedFromIntentLocked(si.neededGrants,</span><br><span class="line">                        si.getUriPermissionsLocked());</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 为 onStartCommand 方法设置超时任务！</span></span><br><span class="line">            bumpServiceExecutingLocked(r, execInFg, <span class="string">"start"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!oomAdjusted) &#123; <span class="comment">// 更新服务所在进程的 abj 值；</span></span><br><span class="line">                oomAdjusted = <span class="keyword">true</span>;</span><br><span class="line">                mAm.updateOomAdjLocked(r.app);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> flags = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (si.deliveryCount &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                flags |= Service.START_FLAG_RETRY;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (si.doneExecutingCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                flags |= Service.START_FLAG_REDELIVERY;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// thread 是 ApplicationThreadProxy 对象；</span></span><br><span class="line">            r.app.thread.scheduleServiceArgs(r, si.taskRemoved, si.id, flags, si.intent);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (TransactionTooLargeException e) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">"Transaction too large: intent="</span></span><br><span class="line">                    + si.intent);</span><br><span class="line">            caughtException = e;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Remote process gone...  we'll let the normal cleanup take care of this.</span></span><br><span class="line">            <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">"Crashed while sending args: "</span> + r);</span><br><span class="line">            caughtException = e;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Unexpected exception"</span>, e);</span><br><span class="line">            caughtException = e;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (caughtException != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Keep nesting count correct</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> inDestroying = mDestroyingServices.contains(r);</span><br><span class="line">            serviceDoneExecutingLocked(r, inDestroying, inDestroying);</span><br><span class="line">            <span class="keyword">if</span> (caughtException <span class="keyword">instanceof</span> TransactionTooLargeException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (TransactionTooLargeException)caughtException;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，如果服务所在的进程已经被启动了，那就直接调用 <code>sendServiceArgsLocked</code> 方法，通过服务所属进程在系统进程中的 <code>Binder</code> 对象 <code>ApplicationThreadProxy</code>，通过 <code>Binder</code> 间通信，调用应用进程的 <code>ApplicationThread</code> 的 <code>scheduleServiceArgs</code> 对象，拉起指定服务的 <code>onStartCommand</code> 方法；</p>
<h4 id="2-7-3-1-ApplicationThreadP-scheduleServiceArgs"><a href="#2-7-3-1-ApplicationThreadP-scheduleServiceArgs" class="headerlink" title="2.7.3.1 ApplicationThreadP.scheduleServiceArgs"></a>2.7.3.1 ApplicationThreadP.scheduleServiceArgs</h4><p>拉起 onStartCommand 方法，参数说明：</p>
<ul>
<li><code>IBinder token</code>：服务的 <code>ServiceRecord</code> 对象，实现了 <code>IBinder</code> 接口！</li>
<li><code>boolean taskRemoved</code>：启动项的 <code>taskRemoved</code>；</li>
<li><code>int startId</code>：启动项的 <code>id</code>，用来表示本次启动的 <code>id</code> 值！</li>
<li><code>int flags</code>：</li>
<li><code>Intent args</code>：启动项用的 <code>intent</code>，用来启动 <code>Service</code>！</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApplicationThreadProxy</span> <span class="keyword">implements</span> <span class="title">IApplicationThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleServiceArgs</span><span class="params">(IBinder token, <span class="keyword">boolean</span> taskRemoved, <span class="keyword">int</span> startId,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> flags, Intent args)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Parcel data = Parcel.obtain();</span><br><span class="line">        data.writeInterfaceToken(IApplicationThread.descriptor);</span><br><span class="line">        data.writeStrongBinder(token);</span><br><span class="line">        data.writeInt(taskRemoved ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        data.writeInt(startId);</span><br><span class="line">        data.writeInt(flags);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">            data.writeInt(<span class="number">1</span>);</span><br><span class="line">            args.writeToParcel(data, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            data.writeInt(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// binder 通信，进入到应用进程</span></span><br><span class="line">        mRemote.transact(SCHEDULE_SERVICE_ARGS_TRANSACTION, data, <span class="keyword">null</span>,</span><br><span class="line">                IBinder.FLAG_ONEWAY);</span><br><span class="line"></span><br><span class="line">        data.recycle();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>binder 通信，进入应用进程！</p>
<h1 id="3-被启动者进程"><a href="#3-被启动者进程" class="headerlink" title="3 被启动者进程"></a>3 被启动者进程</h1><p>在之前的进程启动分析中，当进程被拉起后，应用进程会创建进程的 <code>ActivityThread</code> 对象，用于托管进程的主线程，组件信息，<code>ApplicationThread</code> 对象等等的信息！</p>
<p>首先会进入 <code>ApplicationThreadNative.onTransact</code> 方法！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** &#123;<span class="doctag">@hide</span>&#125; */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationThreadNative</span> <span class="keyword">extends</span> <span class="title">Binder</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">IApplicationThread</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">// 拉起 onCreate 方法！</span></span><br><span class="line">            <span class="keyword">case</span> SCHEDULE_CREATE_SERVICE_TRANSACTION: &#123;</span><br><span class="line">                data.enforceInterface(IApplicationThread.descriptor);</span><br><span class="line"></span><br><span class="line">                IBinder token = data.readStrongBinder();</span><br><span class="line">                ServiceInfo info = ServiceInfo.CREATOR.createFromParcel(data);</span><br><span class="line">                CompatibilityInfo compatInfo = CompatibilityInfo.CREATOR.createFromParcel(data);</span><br><span class="line">                <span class="keyword">int</span> processState = data.readInt();</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 继续来看！</span></span><br><span class="line">                scheduleCreateService(token, info, compatInfo, processState);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">// 拉起 onStartCommand 方法！</span></span><br><span class="line">            <span class="keyword">case</span> SCHEDULE_SERVICE_ARGS_TRANSACTION:</span><br><span class="line">            &#123;</span><br><span class="line">                data.enforceInterface(IApplicationThread.descriptor);</span><br><span class="line"></span><br><span class="line">                IBinder token = data.readStrongBinder();</span><br><span class="line">                <span class="keyword">boolean</span> taskRemoved = data.readInt() != <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> startId = data.readInt();</span><br><span class="line">                <span class="keyword">int</span> fl = data.readInt();</span><br><span class="line">                Intent args;</span><br><span class="line">                <span class="keyword">if</span> (data.readInt() != <span class="number">0</span>) &#123;</span><br><span class="line">                    args = Intent.CREATOR.createFromParcel(data);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    args = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 继续来看！</span></span><br><span class="line">                scheduleServiceArgs(token, taskRemoved, startId, fl, args);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下来，进入 binder 通信服务端 ApplicationThread！</p>
<h2 id="3-1-ApplicationThread-scheduleCreateService"><a href="#3-1-ApplicationThread-scheduleCreateService" class="headerlink" title="3.1 ApplicationThread.scheduleCreateService"></a>3.1 ApplicationThread.scheduleCreateService</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationThread</span> <span class="keyword">extends</span> <span class="title">ApplicationThreadNative</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleCreateService</span><span class="params">(IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">                ServiceInfo info, CompatibilityInfo compatInfo, <span class="keyword">int</span> processState)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            updateProcessState(processState, <span class="keyword">false</span>);</span><br><span class="line">            CreateServiceData s = <span class="keyword">new</span> CreateServiceData();</span><br><span class="line">            s.token = token;</span><br><span class="line">            s.info = info;</span><br><span class="line">            s.compatInfo = compatInfo;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 发送 H.CREATE_SERVICE 到主线程的 Handler!</span></span><br><span class="line">            sendMessage(H.CREATE_SERVICE, s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，最后会调用 sendMessage 方法，将消息  H.CREATE_SERVICE 发送给进程的主线程！</p>
<h2 id="3-2-ApplicationThread-scheduleServiceArgs"><a href="#3-2-ApplicationThread-scheduleServiceArgs" class="headerlink" title="3.2 ApplicationThread.scheduleServiceArgs"></a>3.2 ApplicationThread.scheduleServiceArgs</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationThread</span> <span class="keyword">extends</span> <span class="title">ApplicationThreadNative</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleServiceArgs</span><span class="params">(IBinder token, <span class="keyword">boolean</span> taskRemoved, <span class="keyword">int</span> startId,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> flags ,Intent args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            ServiceArgsData s = <span class="keyword">new</span> ServiceArgsData();</span><br><span class="line">            s.token = token;</span><br><span class="line">            s.taskRemoved = taskRemoved;</span><br><span class="line">            s.startId = startId;</span><br><span class="line">            s.flags = flags;</span><br><span class="line">            s.args = args;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发送 H.SERVICE_ARGS 到主线程的 Handler!</span></span><br><span class="line">            sendMessage(H.SERVICE_ARGS, s);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，最后会调用 sendMessage 方法，将消息  H.SERVICE_ARGS 发送给进程的主线程！</p>
<h2 id="3-3-ApplicationThread-H"><a href="#3-3-ApplicationThread-H" class="headerlink" title="3.3 ApplicationThread.H"></a>3.3 ApplicationThread.H</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">H</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">case</span> CREATE_SERVICE:</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER,</span><br><span class="line">                                        (<span class="string">"serviceCreate: "</span> + String.valueOf(msg.obj)));</span><br><span class="line">            handleCreateService((CreateServiceData)msg.obj);</span><br><span class="line">              </span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">              </span><br><span class="line">        <span class="keyword">case</span> SERVICE_ARGS:</span><br><span class="line">            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, </span><br><span class="line">                                        (<span class="string">"serviceStart: "</span> + String.valueOf(msg.obj)));</span><br><span class="line">            handleServiceArgs((ServiceArgsData)msg.obj);</span><br><span class="line">            </span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">            <span class="keyword">break</span>;              </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里省略了其他消息的处理！</p>
<p>最后分别调用：handleCreateService 和 handleServiceArgs 拉起指定的方法！</p>
<h3 id="3-3-1-ApplicationThread-handleCreateService"><a href="#3-3-1-ApplicationThread-handleCreateService" class="headerlink" title="3.3.1 ApplicationThread.handleCreateService"></a>3.3.1 ApplicationThread.handleCreateService</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleCreateService</span><span class="params">(CreateServiceData data)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果此时准备要 GC，那就跳过本次 GC！</span></span><br><span class="line">    unscheduleGcIdler();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获得应用程序的加载信息，先会从缓存中获取，找不到才创建！</span></span><br><span class="line">    LoadedApk packageInfo = getPackageInfoNoCheck(</span><br><span class="line">            data.info.applicationInfo, data.compatInfo);</span><br><span class="line"></span><br><span class="line">    Service service = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 通过反射创建要启动的服务的实例！</span></span><br><span class="line">        java.lang.ClassLoader cl = packageInfo.getClassLoader();</span><br><span class="line">        service = (Service) cl.loadClass(data.info.name).newInstance();</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mInstrumentation.onException(service, e)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Unable to instantiate service "</span> + data.info.name</span><br><span class="line">                + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (localLOGV) Slog.v(TAG, <span class="string">"Creating service "</span> + data.info.name);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建该 Serivce Context 对象！</span></span><br><span class="line">        ContextImpl context = ContextImpl.createAppContext(<span class="keyword">this</span>, packageInfo);</span><br><span class="line">        context.setOuterContext(service);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回该进程的 Application 对象！</span></span><br><span class="line">        Application app = packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将服务实例和 context，Application 进行绑定！</span></span><br><span class="line">        service.attach(context, <span class="keyword">this</span>, data.info.name, data.token, app,</span><br><span class="line">                ActivityManagerNative.getDefault());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用了服务的 onCreate 方法！</span></span><br><span class="line">        service.onCreate();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将创建的服务实例保存到 AT 的托管集合中！</span></span><br><span class="line">        mServices.put(data.token, service);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 通知 AMS，操作完成；</span></span><br><span class="line">            ActivityManagerNative.getDefault().serviceDoneExecuting(</span><br><span class="line">                    data.token, SERVICE_DONE_EXECUTING_ANON, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!mInstrumentation.onException(service, e)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Unable to create service "</span> + data.info.name</span><br><span class="line">                + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着，进入了 Service 的 onCreate 方法中：</p>
<h4 id="3-3-1-1-service-onCreate"><a href="#3-3-1-1-service-onCreate" class="headerlink" title="3.3.1.1 service.onCreate"></a>3.3.1.1 service.onCreate</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Service</span> <span class="keyword">extends</span> <span class="title">ContextWrapper</span> <span class="keyword">implements</span> <span class="title">ComponentCallbacks2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@hide</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            Context context,</span></span></span><br><span class="line"><span class="function"><span class="params">            ActivityThread thread, String className, IBinder token,</span></span></span><br><span class="line"><span class="function"><span class="params">            Application application, Object activityManager)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        attachBaseContext(context);</span><br><span class="line">        mThread = thread;           <span class="comment">// <span class="doctag">NOTE:</span>  unused - remove?</span></span><br><span class="line">        mClassName = className;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这个 mToken 在系统进程对应着的是服务的 ServiceRecord 对象</span></span><br><span class="line">        mToken = token;</span><br><span class="line">        mApplication = application;</span><br><span class="line">        mActivityManager = (IActivityManager)activityManager;</span><br><span class="line">        mStartCompatibility = getApplicationInfo().targetSdkVersion</span><br><span class="line">                &lt; Build.VERSION_CODES.ECLAIR;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 由于用户实现具体的调用内容！</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意这个 mToken， 它在系统进程对应着的是服务的 ServiceRecord 对象，之前在系统进程通过 ApplicationThreadP 传递对象的时候，会将 ServiceRecord 通过 binder 通信传递过来！</p>
<h3 id="3-3-2-ApplicationThread-handleServiceArgs"><a href="#3-3-2-ApplicationThread-handleServiceArgs" class="headerlink" title="3.3.2 ApplicationThread.handleServiceArgs"></a>3.3.2 ApplicationThread.handleServiceArgs</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleServiceArgs</span><span class="params">(ServiceArgsData data)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得之前创建的服务对象！</span></span><br><span class="line">    Service s = mServices.get(data.token);</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (data.args != <span class="keyword">null</span>) &#123;</span><br><span class="line">                data.args.setExtrasClassLoader(s.getClassLoader());</span><br><span class="line">                data.args.prepareToEnterProcess();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> res;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (!data.taskRemoved) &#123; <span class="comment">// 如果 data.taskRemoved 为 false，就拉起 onStartCommand 方法！</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 拉起服务的 onStartCommand 方法！</span></span><br><span class="line">                res = s.onStartCommand(data.args, data.flags, data.startId);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 否则，拉起 onTaskRemoved 方法！</span></span><br><span class="line">                s.onTaskRemoved(data.args);</span><br><span class="line">                res = Service.START_TASK_REMOVED_COMPLETE;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            QueuedWork.waitToFinish();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 通知 AMS，操作完成，并传递 onStartCommand 的返回结果；</span></span><br><span class="line">                ActivityManagerNative.getDefault().serviceDoneExecuting(</span><br><span class="line">                        data.token, SERVICE_DONE_EXECUTING_START, data.startId, res);</span><br><span class="line">                        </span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            ensureJitEnabled();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!mInstrumentation.onException(s, e)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                        <span class="string">"Unable to start service "</span> + s</span><br><span class="line">                        + <span class="string">" with "</span> + data.args + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-2-1-service-onStartCommand"><a href="#3-3-2-1-service-onStartCommand" class="headerlink" title="3.3.2.1 service.onStartCommand"></a>3.3.2.1 service.onStartCommand</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@StartResult</span> <span class="function"><span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, @StartArgFlags <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">    onStart(intent, startId);</span><br><span class="line">    <span class="keyword">return</span> mStartCompatibility ? START_STICKY_COMPATIBILITY : START_STICKY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后进入了 Service 的 onStartCommand 方法！</p>
<h2 id="3-4-ActivityManagerP-serviceDoneExecuting"><a href="#3-4-ActivityManagerP-serviceDoneExecuting" class="headerlink" title="3.4 ActivityManagerP.serviceDoneExecuting"></a>3.4 ActivityManagerP.serviceDoneExecuting</h2><p>当服务的指定方法被拉起后，会通知 AMS，拉起操作执行成功，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通知 AMS，拉起 onCreate 操作完成；</span></span><br><span class="line">ActivityManagerNative.getDefault().serviceDoneExecuting(</span><br><span class="line">            data.token, SERVICE_DONE_EXECUTING_ANON, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            </span><br><span class="line"><span class="comment">// 通知 AMS，拉起 onStart 操作完成；</span></span><br><span class="line">ActivityManagerNative.getDefault().serviceDoneExecuting(</span><br><span class="line">            data.token, SERVICE_DONE_EXECUTING_START, data.startId, res);</span><br></pre></td></tr></table></figure></p>
<p>这里进入 ActivityManagerP：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serviceDoneExecuting</span><span class="params">(IBinder token, <span class="keyword">int</span> type, <span class="keyword">int</span> startId,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> res)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Parcel data = Parcel.obtain();</span><br><span class="line">    Parcel reply = Parcel.obtain();</span><br><span class="line">    data.writeInterfaceToken(IActivityManager.descriptor);</span><br><span class="line">    data.writeStrongBinder(token);</span><br><span class="line">    data.writeInt(type);</span><br><span class="line">    data.writeInt(startId);</span><br><span class="line">    data.writeInt(res);</span><br><span class="line">    mRemote.transact(SERVICE_DONE_EXECUTING_TRANSACTION, data, reply, IBinder.FLAG_ONEWAY);</span><br><span class="line">    reply.readException();</span><br><span class="line">    data.recycle();</span><br><span class="line">    reply.recycle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里再次进入系统进程，我们去看看发生了什么！！</p>
<h1 id="4-系统进程"><a href="#4-系统进程" class="headerlink" title="4 系统进程"></a>4 系统进程</h1><p>接下来，进入系统进程，处理反馈结果，首先要进入 ActivityManagerN.onTransact 方法！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> SERVICE_DONE_EXECUTING_TRANSACTION: &#123;</span><br><span class="line">    data.enforceInterface(IActivityManager.descriptor);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    IBinder token = data.readStrongBinder();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> type = data.readInt();</span><br><span class="line">    <span class="keyword">int</span> startId = data.readInt();</span><br><span class="line">    <span class="keyword">int</span> res = data.readInt();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 进入 AMS!</span></span><br><span class="line">    serviceDoneExecuting(token, type, startId, res);</span><br><span class="line">    reply.writeNoException();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="4-1-ActivityManagerS-serviceDoneExecuting"><a href="#4-1-ActivityManagerS-serviceDoneExecuting" class="headerlink" title="4.1 ActivityManagerS.serviceDoneExecuting"></a>4.1 ActivityManagerS.serviceDoneExecuting</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serviceDoneExecuting</span><span class="params">(IBinder token, <span class="keyword">int</span> type, <span class="keyword">int</span> startId, <span class="keyword">int</span> res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 如果 token 不是 ServiceRecord 的实例，就会抛出异常！</span></span><br><span class="line">        <span class="keyword">if</span> (!(token <span class="keyword">instanceof</span> ServiceRecord)) &#123;</span><br><span class="line">            Slog.e(TAG, <span class="string">"serviceDoneExecuting: Invalid service token="</span> + token);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid service token"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 进入 ActiveServices！</span></span><br><span class="line">        mServices.serviceDoneExecutingLocked((ServiceRecord)token, type, startId, res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续看！</p>
<h2 id="4-2-ActiveServices-serviceDoneExecutingLocked"><a href="#4-2-ActiveServices-serviceDoneExecutingLocked" class="headerlink" title="4.2 ActiveServices.serviceDoneExecutingLocked"></a>4.2 ActiveServices.serviceDoneExecutingLocked</h2><ul>
<li>对于拉起 onCreate  方法，type 的值为 SERVICE_DONE_EXECUTING_ANON；</li>
<li>对于拉起 onStartCommand 方法，type 的值为 SERVICE_DONE_EXECUTING_START；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">serviceDoneExecutingLocked</span><span class="params">(ServiceRecord r, <span class="keyword">int</span> type, <span class="keyword">int</span> startId, <span class="keyword">int</span> res)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断这个服务是否正在被销毁！</span></span><br><span class="line">    <span class="keyword">boolean</span> inDestroying = mDestroyingServices.contains(r);</span><br><span class="line">    <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 这里处理拉起 onStartCommand 方法后的，onStart 方法的返回值！</span></span><br><span class="line">        <span class="keyword">if</span> (type == ActivityThread.SERVICE_DONE_EXECUTING_START) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将 r.callStart 置为 true！</span></span><br><span class="line">            r.callStart = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (res) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> Service.START_STICKY_COMPATIBILITY:</span><br><span class="line">                <span class="keyword">case</span> Service.START_STICKY: &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 从服务的 deliveredStarts 集合中删除本次启动对应的启动项！</span></span><br><span class="line">                    r.findDeliveredStart(startId, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 表示服务被杀死后不会被停止，会被重启！</span></span><br><span class="line">                    r.stopIfKilled = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> Service.START_NOT_STICKY: &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 从服务的 deliveredStarts 集合中删除本次启动对应的启动项！</span></span><br><span class="line">                    r.findDeliveredStart(startId, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 判断服务最后一次启动的 id 是否为本次 id！</span></span><br><span class="line">                    <span class="keyword">if</span> (r.getLastStartId() == startId) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 表示服务被杀死后会被停止，不会被重启！</span></span><br><span class="line">                        r.stopIfKilled = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> Service.START_REDELIVER_INTENT: &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 第二个参数为 false，并没有删除 startId 对应的启动项目，这里只是返回了！</span></span><br><span class="line">                    <span class="comment">// 这个启动项 Intent 被保留下来了！</span></span><br><span class="line">                    ServiceRecord.StartItem si = r.findDeliveredStart(startId, <span class="keyword">false</span>);</span><br><span class="line">                    <span class="keyword">if</span> (si != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        si.deliveryCount = <span class="number">0</span>;</span><br><span class="line">                        si.doneExecutingCount++;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// Don't stop if killed.</span></span><br><span class="line">                        r.stopIfKilled = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> Service.START_TASK_REMOVED_COMPLETE: &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Special processing for onTaskRemoved().  Don't</span></span><br><span class="line">                    <span class="comment">// impact normal onStartCommand() processing.</span></span><br><span class="line">                    r.findDeliveredStart(startId, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                            <span class="string">"Unknown service start result: "</span> + res);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (res == Service.START_STICKY_COMPATIBILITY) &#123;</span><br><span class="line">                r.callStart = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == ActivityThread.SERVICE_DONE_EXECUTING_STOP) &#123;</span><br><span class="line">            <span class="comment">// 这里是处理 destroy 服务的情况，这里先不看！</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 对于拉起 onCreate 方法的返回 type，直接进入这里！！</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">        serviceDoneExecutingLocked(r, inDestroying, inDestroying);</span><br><span class="line"></span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"Done executing unknown service from pid "</span></span><br><span class="line">                + Binder.getCallingPid());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>findDeliveredStart 方法用于从 ServiceRecord 的 deliveredStarts 集合中返回指定 id 的启动项，如果 remove 为 true，也要移除指定 id 的启动项！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StartItem <span class="title">findDeliveredStart</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">boolean</span> remove)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> N = deliveredStarts.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">        StartItem si = deliveredStarts.get(i);</span><br><span class="line">        <span class="keyword">if</span> (si.id == id) &#123;</span><br><span class="line">            <span class="keyword">if</span> (remove) deliveredStarts.remove(i);</span><br><span class="line">            <span class="keyword">return</span> si;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们来看看 <code>Service</code> 的 <code>onStartCommand</code> 方法的返回值的处理总结：</p>
<ul>
<li><strong>START_STICKY</strong>：</li>
<li><strong>START_STICKY_COMPATIBILITY</strong>：<ul>
<li>删除本次启动的 <code>startId</code> 对应的启动项；</li>
<li>设置服务的 <code>stopIfKilled</code> 为 <code>false</code>；</li>
</ul>
</li>
<li><strong>START_NOT_STICKY</strong>： <ul>
<li>删除本次启动的服务的 <code>startId</code> 对应的启动项；</li>
<li>如果最后一次启动的启动项的 <code>id</code> (lastStartId) 等于本次启动的启动项的 <code>id</code>；<ul>
<li>设置服务的 <code>stopIfKilled</code> 为 <code>true</code>；</li>
</ul>
</li>
</ul>
</li>
<li><strong>START_REDELIVER_INTENT</strong>： <ul>
<li>不删除本次启动的 <code>startId</code> 对应的启动项；</li>
<li>如果本次启动的启动项不为 null；<ul>
<li>设置启动项的 <code>deliveryCount</code> 为 <code>0</code>；</li>
<li>设置启动项的 <code>doneExecutingCount</code> 加 <code>1</code>；</li>
<li>设置服务的 <code>stopIfKilled</code> 为 <code>true</code>；</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>那么，如果服务被启动后，因为一些原因，所在的进程被杀掉了，那么系统会根据服务以上的属性对服务进行重启！</p>
<p>这里的 <code>r.stopIfKilled</code> 属性在 <code>AS.killServicesLocked</code> 的方法中会处理，用于判断服务在被 <code>kill</code> 掉后，是否被重启起！对于 <code>Service</code> 的重启，我会在另外一篇博文中分析，尽情期待！</p>
<h2 id="4-3-ActiveServices-serviceDoneExecutingLocked"><a href="#4-3-ActiveServices-serviceDoneExecutingLocked" class="headerlink" title="4.3 ActiveServices.serviceDoneExecutingLocked"></a>4.3 ActiveServices.serviceDoneExecutingLocked</h2><p>我们继续看，参数传递： </p>
<ul>
<li><code>boolean inDestroying</code>：服务正在被销毁！</li>
<li><code>boolean finishing</code>：服务正在完成！</li>
</ul>
<p>因为这里是刚刚启动服务，所以传入均为 false；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">serviceDoneExecutingLocked</span><span class="params">(ServiceRecord r, <span class="keyword">boolean</span> inDestroying,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> finishing)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">"&lt;&lt;&lt; DONE EXECUTING "</span> + r</span><br><span class="line">            + <span class="string">": nesting="</span> + r.executeNesting</span><br><span class="line">            + <span class="string">", inDestroying="</span> + inDestroying + <span class="string">", app="</span> + r.app);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (DEBUG_SERVICE_EXECUTING) Slog.v(TAG_SERVICE_EXECUTING,</span><br><span class="line">            <span class="string">"&lt;&lt;&lt; DONE EXECUTING "</span> + r.shortName);</span><br><span class="line"></span><br><span class="line">    r.executeNesting--;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.executeNesting &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r.app != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE,</span><br><span class="line">                    <span class="string">"Nesting at 0 of "</span> + r.shortName);</span><br><span class="line"></span><br><span class="line">            r.app.execServicesFg = <span class="keyword">false</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 从 r.app.executingServices 移除该服务！</span></span><br><span class="line">            r.app.executingServices.remove(r);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果该进程中所有的服务都执行成功了，进入该分支！</span></span><br><span class="line">            <span class="keyword">if</span> (r.app.executingServices.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_SERVICE || DEBUG_SERVICE_EXECUTING) </span><br><span class="line">                     Slog.v(TAG_SERVICE_EXECUTING,</span><br><span class="line">                        <span class="string">"No more executingServices of "</span> + r.shortName);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 移除服务启动超时的消息！</span></span><br><span class="line">                mAm.mHandler.removeMessages(ActivityManagerService.SERVICE_TIMEOUT_MSG, r.app);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.executeFg) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Need to re-evaluate whether the app still needs to be in the foreground.</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=r.app.executingServices.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (r.app.executingServices.valueAt(i).executeFg) &#123;</span><br><span class="line">                        r.app.execServicesFg = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (inDestroying) &#123; <span class="comment">// 不进入！</span></span><br><span class="line">                <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE,</span><br><span class="line">                        <span class="string">"doneExecuting remove destroying "</span> + r);</span><br><span class="line">                mDestroyingServices.remove(r);</span><br><span class="line"></span><br><span class="line">                r.bindings.clear();</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 更新 oomAdj！</span></span><br><span class="line">            mAm.updateOomAdjLocked(r.app);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        r.executeFg = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (r.tracker != <span class="keyword">null</span>) &#123;</span><br><span class="line">            r.tracker.setExecuting(<span class="keyword">false</span>, mAm.mProcessStats.getMemFactorLocked(),</span><br><span class="line">                    SystemClock.uptimeMillis());</span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                r.tracker.clearCurrentOwner(r, <span class="keyword">false</span>);</span><br><span class="line">                r.tracker = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (finishing) &#123; <span class="comment">// 不进入！</span></span><br><span class="line">            <span class="keyword">if</span> (r.app != <span class="keyword">null</span> &amp;&amp; !r.app.persistent) &#123;</span><br><span class="line">                r.app.services.remove(r);</span><br><span class="line">                <span class="keyword">if</span> (r.whitelistManager) &#123;</span><br><span class="line">                    updateWhitelistManagerLocked(r.app);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            r.app = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里会让 AMS 的 MainHandler 不再处理超时的消息！</p>
<h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h1><p>到这里，startService 的启动流程就分析完了，我们来回顾一下！！</p>
<h2 id="6-1-数据结构总结"><a href="#6-1-数据结构总结" class="headerlink" title="6.1 数据结构总结"></a>6.1 数据结构总结</h2><p>我们先来看看，在 start 流程中，会涉及到的一些重要的数据结构，以及他们之间的关系！</p>
<h3 id="6-1-1-ProcessRecord"><a href="#6-1-1-ProcessRecord" class="headerlink" title="6.1.1 ProcessRecord"></a>6.1.1 <strong>ProcessRecord</strong></h3><p>启动者和被启动者所在进程的信息对象；<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> curProcState <span class="comment">// 表示当前进程的状态，可以通过其来判断是否是前台进程调度，还是后台进调度</span></span><br><span class="line"><span class="keyword">int</span> setSchedGroup <span class="comment">// 进程的最新状态</span></span><br><span class="line"></span><br><span class="line">ArraySet&lt;ServiceRecord&gt; services <span class="comment">// 运行在这个进程中的所有服务</span></span><br><span class="line">ArraySet&lt;ServiceRecord&gt; executingServices <span class="comment">// 当前正在执行某段代码逻辑的服务列表，比如正在拉起 onCreate 等</span></span><br></pre></td></tr></table></figure></p>
<p>属性解释：</p>
<h3 id="6-1-2-ActivieServices"><a href="#6-1-2-ActivieServices" class="headerlink" title="6.1.2 ActivieServices"></a>6.1.2 <strong>ActivieServices</strong></h3><p>用来保存和管理系统中所有活跃的 Service！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   SparseArray&lt;ServiceMap&gt; mServiceMap <span class="comment">// 所有设备用户下的 Service 集合，key 为 userId，value 是 ServiceMap 类型的实例；</span></span><br><span class="line">   </span><br><span class="line">   ArrayList&lt;ServiceRecord&gt; mRestartingServices  <span class="comment">// 因为 CRASH 需要重启的  ServiceRecord 集合！</span></span><br><span class="line">   ArrayList&lt;ServiceRecord&gt; mDestroyingServices <span class="comment">// 进程被销毁的 ServiceRecord 集合！</span></span><br><span class="line">ArrayList&lt;ServiceRecord&gt; mPendingServices <span class="comment">// 所有正在启动的 ServiceRecord 集合</span></span><br></pre></td></tr></table></figure></p>
<p>属性解释：</p>
<h3 id="6-1-3-ServiceMap"><a href="#6-1-3-ServiceMap" class="headerlink" title="6.1.3 ServiceMap"></a>6.1.3 <strong>ServiceMap</strong></h3><p>是 Handler 的子类，用来保存制定 userId 目录下的所有 ServiceRecord！ </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mUserId： <span class="comment">// 指定的 uid</span></span><br><span class="line"></span><br><span class="line">ArrayMap&lt;ComponentName, ServiceRecord&gt; mServicesByName：<span class="comment">// 通过组件名为 key，存储对应的 ServiceRecord</span></span><br><span class="line">ArrayMap&lt;Intent.FilterComparison, ServiceRecord&gt; mServicesByIntent；<span class="comment">// 通过 intent 为 key，存储对应的 ServiceRecord</span></span><br><span class="line"></span><br><span class="line">ArrayList&lt;ServiceRecord&gt; mDelayedStartList: <span class="comment">// 延迟启动的 ServiceRecord 列表</span></span><br><span class="line">ArrayList&lt;ServiceRecord&gt; mStartingBackground：<span class="comment">// 正在后台启动的 ServiceRecord 列表</span></span><br></pre></td></tr></table></figure>
<p>属性解释：</p>
<h3 id="6-1-4-ServiceRecord"><a href="#6-1-4-ServiceRecord" class="headerlink" title="6.1.4 ServiceRecord"></a>6.1.4 <strong>ServiceRecord</strong></h3><p>要启动的 Service 的数据对象！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">      ServiceInfo serviceInfo <span class="comment">// 该服务的解析信息，来自 PMS</span></span><br><span class="line">      ApplicationInfo appInfo <span class="comment">// 该服务所属应用的信息，来自 PMS</span></span><br><span class="line">      <span class="keyword">int</span> userId <span class="comment">// 该服务所属的设备用户</span></span><br><span class="line">      Intent.FilterComparison intent <span class="comment">// 用来匹配该服务的 intent 封装类，等价于 intent</span></span><br><span class="line">      String permission <span class="comment">// 访问该服务需要的权限</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">long</span> createTime <span class="comment">// 该服务创建的时间</span></span><br><span class="line">      <span class="keyword">boolean</span> createdFromFg <span class="comment">// 表示服务是通过前台进程调度创建的还是后台进程</span></span><br><span class="line">      <span class="keyword">long</span> lastActivity <span class="comment">// 服务的活跃时间；</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">boolean</span> startRequested <span class="comment">// 服务是否被请求启动，开始启动时会置为 true；</span></span><br><span class="line">      <span class="keyword">boolean</span> delayedStop <span class="comment">// 服务是否被延迟停止，开始启动时会置为 false；</span></span><br><span class="line"><span class="keyword">boolean</span> delayed <span class="comment">// 服务是否延迟启动，默认为 false；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> restartDelay <span class="comment">// 服务重启延迟时间！</span></span><br><span class="line"><span class="keyword">int</span> restartCount <span class="comment">// 服务重启次数！</span></span><br><span class="line">      <span class="keyword">long</span> restartTime <span class="comment">// 服务重启时间！</span></span><br><span class="line"></span><br><span class="line">ArrayList&lt;StartItem&gt; pendingStarts <span class="comment">// 待处理的启动项列表；</span></span><br><span class="line">ArrayList&lt;StartItem&gt; deliveredStarts <span class="comment">// 已经被处理的启动项列表；</span></span><br><span class="line"></span><br><span class="line">Runnable restarter <span class="comment">// 这是一个 ServiceRestarter 对象，用于处理重启任务！</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> callStart</span><br><span class="line">ProcessRecord app <span class="comment">// 服务所在的进程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> executeFg <span class="comment">// 表示该服务是否是前台执行</span></span><br><span class="line">      <span class="keyword">int</span> executeNesting <span class="comment">// </span></span><br><span class="line">      <span class="keyword">long</span> executingStart <span class="comment">// 表示服务开始执行的时间</span></span><br></pre></td></tr></table></figure>
<p>属性解释：</p>
<ul>
<li><strong>r.pendingStarts</strong>：AS 会把启动相关的信息封装成一个 StartItem，保存到 pendingStarts 中！</li>
<li><strong>r.delayed：</strong>于后台启动的方式，如果 ServiceMap.mStartingBackground 的大小超过 mMaxStartingBackground 的话，会被置为 true，同时，将 ServiceRecord 添加到  ServiceMap.mDelayedStartList 中！</li>
</ul>
<h3 id="6-1-5-StartItem"><a href="#6-1-5-StartItem" class="headerlink" title="6.1.5  StartItem"></a>6.1.5  <strong>StartItem</strong></h3><p>这是一个启动项，封装一次 <code>startService</code> 的数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ServiceRecord sr; <span class="comment">// 要启动的服务</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> taskRemoved; <span class="comment">//  </span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> id; <span class="comment">// 启动项 id ，最小从 1 开始</span></span><br><span class="line"><span class="keyword">final</span> Intent intent; <span class="comment">// 启动用的 Intent</span></span><br><span class="line"><span class="keyword">final</span> ActivityManagerService.NeededUriGrants neededGrants;</span><br><span class="line"><span class="keyword">long</span> deliveredTime;</span><br><span class="line"><span class="keyword">int</span> deliveryCount;</span><br><span class="line"><span class="keyword">int</span> doneExecutingCount;</span><br><span class="line">UriPermissionOwner uriPermissions;</span><br></pre></td></tr></table></figure>
<p>属性解释：</p>
<h3 id="6-1-6-ServiceRestarter"><a href="#6-1-6-ServiceRestarter" class="headerlink" title="6.1.6 ServiceRestarter"></a>6.1.6 <strong>ServiceRestarter</strong></h3><p>这是 <code>Runnable</code> 对象，用于处理服务的重启！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServiceRecord mService <span class="comment">// 对应的服务！</span></span><br></pre></td></tr></table></figure>
<p>属性解释：</p>
<h3 id="6-1-7-CreateServiceData"><a href="#6-1-7-CreateServiceData" class="headerlink" title="6.1.7 CreateServiceData"></a>6.1.7 <strong>CreateServiceData</strong></h3><p><code>ActivityThread</code> 的内部类，用于封装拉起 <code>onCreate</code> 方法的数据：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IBinder token; <span class="comment">// ServiceRecord 对象</span></span><br><span class="line">ServiceInfo info;</span><br><span class="line">CompatibilityInfo compatInfo;</span><br><span class="line">Intent intent;</span><br></pre></td></tr></table></figure></p>
<p>属性解释：</p>
<h3 id="6-1-8-ServiceArgsData"><a href="#6-1-8-ServiceArgsData" class="headerlink" title="6.1.8 ServiceArgsData"></a>6.1.8 <strong>ServiceArgsData</strong></h3><p><code>ActivityThread</code> 的内部类，用于封装拉起 <code>onStartCommand</code> 方法的数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IBinder token; <span class="comment">// ServiceRecord 对象</span></span><br><span class="line"><span class="keyword">boolean</span> taskRemoved;</span><br><span class="line"><span class="keyword">int</span> startId; <span class="comment">// 本次启动的 id</span></span><br><span class="line"><span class="keyword">int</span> flags; <span class="comment">// 如果</span></span><br><span class="line">Intent args; <span class="comment">// 启动的 Intent</span></span><br></pre></td></tr></table></figure>
<p>属性解释：</p>
<h2 id="6-2-生命周期总结"><a href="#6-2-生命周期总结" class="headerlink" title="6.2 生命周期总结"></a>6.2 生命周期总结</h2><p>startService 方法周期很简单：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Serice.onCreate()(once) -&gt; Service.onStartCommand()(more)</span><br></pre></td></tr></table></figure></p>
<h2 id="6-3-流程总结"><a href="#6-3-流程总结" class="headerlink" title="6.3 流程总结"></a>6.3 流程总结</h2><p>下面是整个过程的 UML 序列图：</p>
<p>（我先填个坑，毕竟画图太累）</p>
<p>我们来看一下，这里面的一些细节：</p>
<ul>
<li>如果多次调用 <code>startService</code>，只有第一次会拉起服务的 <code>onCreate</code> 方法，因为 <code>r.app</code> 和 <code>r.app.thread</code> 为 <code>null</code>，<code>r.app</code> 是在创建 <code>Serivce（onCreate）</code>时被赋值的，多次调用 <code>StartService</code>，会直接进入 <code>sendServiceArgsLocked</code> 方法，拉起服务的 <code>onStartCommand</code> 方法；</li>
<li><code>onCreate</code> 方法的 <code>startId</code> 为 <code>0</code>，<code>onStartCommand</code> 方法的 <code>startId</code> 从 <code>1</code> 开始，一次递增！</li>
<li>如果服务启动后，因为内存不足等情况，被杀掉了，那么系统会重启该服务，如果在重启之前，用户通过 <code>startService</code> 再次启动了服务，那么就会取消之前的重启任务！（<code>r.restartDelay</code> 是在设置服务重启任务时设置的，我们后面再看）</li>
<li><code>onStartCommand</code> 方法的返回值有多个，这些返回值会影响 <code>Serivce</code> 的重启，请看 <code>Service reStart</code> 流程处理的分析，这里就不再多说了！</li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Coolqi.Li</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://coolqi.top/2016/03/01/Service2-startService/">https://coolqi.top/2016/03/01/Service2-startService/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://coolqi.top">Coolqi`s Blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Service服务/">Service服务</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="/img/zfb.jpg"><div class="post-qr-code__desc">支付宝打赏</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="/img/wechat.jpg"><div class="post-qr-code__desc">微信打赏</div></div></div><div class="social-share"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2016/03/13/Process1-theStartOfProcess/"><i class="fa fa-chevron-left">  </i><span>Process篇 1 - Android 进程的启动</span></a></div><div class="next-post pull-right"><a href="/2016/02/19/ActivityManager1-ActivityManagerServiceStartProcess/"><span>ActivityManager第 1 篇 - ActivityManagerService 的启动</span><i class="fa fa-chevron-right"></i></a></div></nav><div class="post-adv"><a href="https://www.vultr.com/?ref=7231808"><img src="https://www.vultr.com/media/banner_1.png" width="728" height="90"></a></div></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2015 - 2019 By Coolqi.Li</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://lishuaiqi.top/">blog</a>!</div><div class="busuanzi"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.6"></script><script src="/js/fancybox.js?version=1.5.6"></script><script src="/js/sidebar.js?version=1.5.6"></script><script src="/js/copy.js?version=1.5.6"></script><script src="/js/fireworks.js?version=1.5.6"></script><script src="/js/transition.js?version=1.5.6"></script><script src="/js/scroll.js?version=1.5.6"></script><script src="/js/head.js?version=1.5.6"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="/js/search/local-search.js"></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"live2d-widget-model-hijiki"},"display":{"position":"right","width":110,"height":220},"mobile":{"show":false},"log":false});</script></body></html>