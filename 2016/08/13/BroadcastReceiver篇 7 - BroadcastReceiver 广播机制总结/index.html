<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="BroadcastReceiver篇 7 - BroadcastReceiver 广播机制总结"><meta name="keywords" content="BroadcastReceiver广播接收者"><meta name="author" content="Coolqi.Li,undefined"><meta name="copyright" content="Coolqi.Li"><title>BroadcastReceiver篇 7 - BroadcastReceiver 广播机制总结 | Coolqi`s Blog</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.5.6"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css?version=1.5.6"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/gh/upupming/gitalk@36368e5dffd049e956cdbbd751ff96c28d8255cf/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#0-综述"><span class="toc-text">0 综述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-广播的使用"><span class="toc-text">1 广播的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-广播的类型"><span class="toc-text">1.1 广播的类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-Flags-标志位"><span class="toc-text">1.2 Flags 标志位</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-广播的发送方法"><span class="toc-text">1.3 广播的发送方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-接收者的使用"><span class="toc-text">2 接收者的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-静态注册的接收者"><span class="toc-text">2.1 静态注册的接收者</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-动态注册的接收者"><span class="toc-text">2.2 动态注册的接收者</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-广播的发送和处理"><span class="toc-text">3 广播的发送和处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-接收者的收集流程"><span class="toc-text">3.1 接收者的收集流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-广播发送流程"><span class="toc-text">3.2 广播发送流程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-总结"><span class="toc-text">4 总结</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Coolqi.Li</div><div class="author-info__description text-center">“你好，我是李帅奇，Android 系统工程师，MineCraft 忠实玩家，设计和绘画爱好者，缺妹纸晚期患者，熬夜星人。”</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">64</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">14</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">15</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="https://developer.android.google.cn/">AndroidDeveloper</a><a class="author-info-links__name text-center" href="http://www.android-studio.org/">AndroidStudio</a><a class="author-info-links__name text-center" href="https://www.jianshu.com/u/123a20a96441">简书</a><a class="author-info-links__name text-center" href="https://weibo.com/coolqiLi">微博</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://ws1.sinaimg.cn/large/8700af19ly1fvpabr30o6j22yo1o0q7i.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Coolqi`s Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/about">About</a><a class="site-page" href="/archives">Archives</a></span></div><div id="post-info"><div id="post-title">BroadcastReceiver篇 7 - BroadcastReceiver 广播机制总结</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2016-08-13</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/AndroidFramework源码分析/">AndroidFramework源码分析</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/AndroidFramework源码分析/BroadcastReceiver广播接收者/">BroadcastReceiver广播接收者</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">3.8k</span><span class="post-meta__separator">|</span><span>阅读时长: 13 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>基于 <code>Android 7.1.1</code> 分析 <code>BroadcastReceiver</code> 组件的机制，本文为作者原创，转载请说明出处！</p>
<h1 id="0-综述"><a href="#0-综述" class="headerlink" title="0 综述"></a>0 综述</h1><p>本篇文章总结一下广播和广播接收者相关的知识点，广播是 Android 组件间的通信方式，本质上是 Intent 意图，可用于以下场景：</p>
<ul>
<li>同一应用内部的同一进程间；</li>
<li>同一应用内部的不同进程间的不同组件的通信；</li>
</ul>
<h1 id="1-广播的使用"><a href="#1-广播的使用" class="headerlink" title="1 广播的使用"></a>1 广播的使用</h1><p><code>Android</code> 系统的广播，本质上就是 <code>Intent</code>，对其熟悉的朋友都知道，<code>Intent</code> 可以携带一些重要的数据，下面，我列举些和广播相关的参数，对于 <code>Intent</code> 的具体分析，请看其他的博文！</p>
<h2 id="1-1-广播的类型"><a href="#1-1-广播的类型" class="headerlink" title="1.1 广播的类型"></a>1.1 广播的类型</h2><p>按照前台和后台来区分，会有前台广播和后台广播，<code>AMS</code> 内部有 <code>2</code> 个队列来管理前台和后台广播：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BroadcastQueue mFgBroadcastQueue;</span><br><span class="line">BroadcastQueue mBgBroadcastQueue;</span><br></pre></td></tr></table></figure></p>
<p>按照有序和无序来区分，分为无序发送广播和有序发送广播，前台和后台队列中都有如下两个列表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">final ArrayList&lt;BroadcastRecord&gt; mParallelBroadcasts = new ArrayList&lt;&gt;();</span><br><span class="line">final ArrayList&lt;BroadcastRecord&gt; mOrderedBroadcasts = new ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure></p>
<p><code>mParallelBroadcasts</code> 是并发发送列表，<code>mOrderedBroadcasts</code> 是有序发送列表；</p>
<p>按照发送的方式来分，又可以分为以下的几种：</p>
<ul>
<li><strong>普通广播</strong></li>
</ul>
<p>发送的接口为：<code>sendBroadcast(intent)</code>，对于普通类型的广播，如果他的目标接收者是动态接收者，那就会添加到 <code>mParallelBroadcasts</code>列表中并发发送，如果他的目标接收者是静态接收者，那就会添加到 <code>mOrderedBroadcasts</code>中有序发送；</p>
<ul>
<li><strong>有序广播</strong></li>
</ul>
<p>发送的接口为：<code>sendOrderedBroadcast(intent)</code>，对于有序类型的广播，不管是静态接收者，还是动态接收者，都会被添加到 <code>mOrderedBroadcasts</code>中有序发送；</p>
<ul>
<li><strong>粘性广播</strong></li>
<li><strong>粘性有序广播</strong></li>
</ul>
<p>粘性广播很特殊，系统会将其保存到一个列表 <code>mStickyBroadcasts</code>中，当还有新的接收者注册后，系统会将其发送给接收者！！但是，在 <code>Android5.0/API level 21</code> 开始粘性广播和粘性有序广播都不再建议使用了，主要还是安全性问题；</p>
<p>除此之外，还有以下类型的广播：</p>
<ul>
<li><strong>系统广播</strong>：安卓系统内置了很多的广播，用于满足系统功能的基本需求，比如：熄屏亮屏广播，开关机广播的等等，都是由系统发送的；</li>
<li><p><strong>本地广播</strong>：本地广播也叫做应用内部广播，为什么会有这种广播呢，主要也是为了安全，防止其他应用通过一些途径平凡的拉起接收者的方法，或者伪装成接收者接收者指定的广播，为了解决这种问题，可以有如下几种方法：</p>
<ul>
<li>将接收者的 <code>android：exported</code> 属性改为 <code>false</code>，但是这样就只能接受来自应用内部的广播了；</li>
<li>发送方和接收者都指定权限信息，权限不匹配，就不能发送和接受；</li>
<li>对于广播可以显示指定包名和组件名；</li>
</ul>
</li>
</ul>
<p>最后一种方式，就是使用本地广播，有一个专门的实现类 <code>LocalBroadcastManager</code>，这个我后面会单独分析！</p>
<h2 id="1-2-Flags-标志位"><a href="#1-2-Flags-标志位" class="headerlink" title="1.2 Flags 标志位"></a>1.2 Flags 标志位</h2><p><code>Android 7.1.1</code> 一共提供了以下几种和 <code>Receiver</code> 相关的 <code>flags</code>，我们来看一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAG_RECEIVER_REGISTERED_ONLY = <span class="number">0x40000000</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAG_RECEIVER_REPLACE_PENDING = <span class="number">0x20000000</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAG_RECEIVER_FOREGROUND = <span class="number">0x10000000</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAG_RECEIVER_NO_ABORT = <span class="number">0x08000000</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT = <span class="number">0x04000000</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAG_RECEIVER_BOOT_UPGRADE = <span class="number">0x02000000</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAG_RECEIVER_INCLUDE_BACKGROUND = <span class="number">0x01000000</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAG_RECEIVER_EXCLUDE_BACKGROUND = <span class="number">0x00800000</span>;</span><br></pre></td></tr></table></figure>
<p>下面我逐个解释一下每个标签的作用，和他们在系统中是如何处理的：</p>
<ul>
<li><strong>FLAG_RECEIVER_REGISTERED_ONLY</strong>：只有动态注册的接收者才能接受该广播，静态接收者无法接受；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Figure out who all will receive this broadcast.</span></span><br><span class="line">List receivers = <span class="keyword">null</span>;</span><br><span class="line">List&lt;BroadcastFilter&gt; registeredReceivers = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// Need to resolve the intent to interested receivers...</span></span><br><span class="line"><span class="keyword">if</span> ((intent.getFlags()&amp;Intent.FLAG_RECEIVER_REGISTERED_ONLY)</span><br><span class="line">         == <span class="number">0</span>) &#123;</span><br><span class="line">    receivers = collectReceiverComponents(intent, resolvedType, callingUid, users);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>AMS</code> 内部会做处理，如果广播设置了 <code>FLAG_RECEIVER_REGISTERED_ONLY</code> 标签，那他就不会收集静态注册的接收者；</p>
<p><br></p>
<ul>
<li><strong>FLAG_RECEIVER_REPLACE_PENDING</strong>：新发送的广播会取代之前的已发送但未处理的相同广播，广播是否相同，是通过 <code>Intent.filterEquals</code> 方法进行匹配的；如果匹配成功，新广播会取代旧广播，但在等待列表中的位置不变，该 <code>flags</code> 常常被粘性广播使用，只保证将最新的广播发送给对应的接收者；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> replacePending =</span><br><span class="line">        (intent.getFlags()&amp;Intent.FLAG_RECEIVER_REPLACE_PENDING) != <span class="number">0</span>;</span><br><span class="line">... ... ...        </span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> ((receivers != <span class="keyword">null</span> &amp;&amp; receivers.size() &gt; <span class="number">0</span>)</span><br><span class="line">        || resultTo != <span class="keyword">null</span>) &#123;</span><br><span class="line">    ... ... ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> replaced = replacePending &amp;&amp; queue.replaceOrderedBroadcastLocked(r);</span><br><span class="line">    <span class="keyword">if</span> (!replaced) &#123;</span><br><span class="line">        queue.enqueueOrderedBroadcastLocked(r);</span><br><span class="line">        queue.scheduleBroadcastsLocked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，省略了一下重要的代码，可以看到，如果广播设置了 <code>FLAG_RECEIVER_REPLACE_PENDING</code>，他会取代之前的旧的未被处理的相同广播，这里就不多说了！！</p>
<p><br></p>
<ul>
<li><strong>FLAG_RECEIVER_FOREGROUND</strong>：设置该标志位后，广播的接收者会以前台的优先级运行，超时时间会变短，正常的接收者是后台优先级的，是不会被自动提升的！<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BroadcastQueue <span class="title">broadcastQueueForIntent</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isFg = (intent.getFlags() &amp; Intent.FLAG_RECEIVER_FOREGROUND) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_BROADCAST_BACKGROUND) Slog.i(TAG_BROADCAST,</span><br><span class="line">            <span class="string">"Broadcast intent "</span> + intent + <span class="string">" on "</span></span><br><span class="line">            + (isFg ? <span class="string">"foreground"</span> : <span class="string">"background"</span>) + <span class="string">" queue"</span>);</span><br><span class="line">    <span class="keyword">return</span> (isFg) ? mFgBroadcastQueue : mBgBroadcastQueue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>在 AMS 中，有两个广播队列：前台队列和后台队列，可以看到，默认情况下，不设置该标志位，广播都是被添加到后台队列中的！！</p>
<p><br></p>
<ul>
<li><strong>FLAG_RECEIVER_NO_ABORT</strong>：设置该标志位后，如果该广播是一个有序发送的广播，不允许接收者过滤不处理该广播；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (resultAbort &amp;&amp; (r.intent.getFlags()&amp;Intent.FLAG_RECEIVER_NO_ABORT) == <span class="number">0</span>) &#123;</span><br><span class="line">    r.resultAbort = resultAbort;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    r.resultAbort = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里，会对该 <code>flags</code> 做一个判断，看是否过滤不处理该广播；</p>
<p><br></p>
<ul>
<li><strong>FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT</strong>：设置该标志位后，当在开机完成之前发送该广播，只有已经被注册的接收者（静态）会被调用；如果是粘性广播，仍然会被系统保留下来，即使没有接收者被调用；如果设置了 <code>FLAG_RECEIVER_REGISTERED_ONLY</code> 标志位，该标志位无效！</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Intent <span class="title">verifyBroadcastLocked</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">    ... ... ... ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】mProcessesReady 表示系统进程是否准备好！</span></span><br><span class="line">    <span class="keyword">if</span> (!mProcessesReady) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((flags&amp;Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// This will be turned into a FLAG_RECEIVER_REGISTERED_ONLY later on if needed.</span></span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((flags&amp;Intent.FLAG_RECEIVER_REGISTERED_ONLY) == <span class="number">0</span>) &#123;</span><br><span class="line">            Slog.e(TAG, <span class="string">"Attempt to launch receivers of broadcast intent "</span> + intent</span><br><span class="line">                    + <span class="string">" before boot completion"</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Cannot broadcast before boot completed"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> intent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，如果在系统进程没有准备好时，如果广播设置了 <code>FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT</code>，但如果此时没有设置 <code>FLAG_RECEIVER_REGISTERED_ONLY</code> 标签，那会报出异常。</p>
<p><br></p>
<ul>
<li><strong>FLAG_RECEIVER_BOOT_UPGRADE</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><br></p>
<ul>
<li><strong>FLAG_RECEIVER_INCLUDE_BACKGROUND</strong>：如果设置了该标签，该广播将<strong>始终发送</strong>给后台（缓存或不运行）应用程序的静态接收者；</li>
</ul>
<p><br></p>
<ul>
<li><strong>FLAG_RECEIVER_EXCLUDE_BACKGROUND</strong>：如果设置了该标签，该广播将<strong>始终不会发送</strong>给后台（缓存或不运行）应用程序的静态接收者，但是如果发送者显示指定了接收者的组件名或者包名，那么后台接收者仍然可以接收到该广播！！</li>
</ul>
<p>这两个标签的处理如下，这里的 <code>info</code> 是静态接收者的数据对象！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!skip) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】判断是否允许后台启动！</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> allowed = mService.checkAllowBackgroundLocked(</span><br><span class="line">            info.activityInfo.applicationInfo.uid, info.activityInfo.packageName, -<span class="number">1</span>,</span><br><span class="line">            <span class="keyword">false</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (allowed != ActivityManager.APP_START_MODE_NORMAL) &#123;</span><br><span class="line">        <span class="comment">//【2】如果是禁止启动，就跳过该应用程序，但 checkAllowBackgroundLocked 不会返回该值；</span></span><br><span class="line">        <span class="keyword">if</span> (allowed == ActivityManager.APP_START_MODE_DISABLED) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Background execution disabled: receiving "</span></span><br><span class="line">                    + r.intent + <span class="string">" to "</span></span><br><span class="line">                    + component.flattenToShortString());</span><br><span class="line"></span><br><span class="line">            skip = <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【3】如果是延迟启动，那其属于一个后台的接收者，那就要判断下标志位；</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (((r.intent.getFlags()&amp;Intent.FLAG_RECEIVER_EXCLUDE_BACKGROUND) != <span class="number">0</span>)</span><br><span class="line">                || (r.intent.getComponent() == <span class="keyword">null</span></span><br><span class="line">                    &amp;&amp; r.intent.getPackage() == <span class="keyword">null</span></span><br><span class="line">                    &amp;&amp; ((r.intent.getFlags()</span><br><span class="line">                            &amp; Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND) == <span class="number">0</span>))) &#123;</span><br><span class="line"></span><br><span class="line">            Slog.w(TAG, <span class="string">"Background execution not allowed: receiving "</span></span><br><span class="line">                    + r.intent + <span class="string">" to "</span></span><br><span class="line">                    + component.flattenToShortString());</span><br><span class="line"></span><br><span class="line">            skip = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Android 系统在发送广播时会判断是否会跳过一些接收者！如果 <code>checkAllowBackgroundLocked</code> 返回值，返回值为 <code>ActivityManager.APP_START_MODE_DELAYED</code>，表示接收者是需要后台启动的！</p>
<p>这种情况下：</p>
<ul>
<li>如果设置了 <code>FLAG_RECEIVER_EXCLUDE_BACKGROUND</code> 标签，那就会逃过该后台的静态接收者；</li>
<li>如果没设置 <code>FLAG_RECEIVER_INCLUDE_BACKGROUND</code> 标签，且没有设置 <code>Component</code> 或者 <code>Package</code>，那就会跳过该后台的静态接收者；</li>
</ul>
<p><br></p>
<p>对于标志位的分析，我们就简单的提一下，详细的分析，大家可以去看 <code>sendBroadcast</code> 过程！！</p>
<h2 id="1-3-广播的发送方法"><a href="#1-3-广播的发送方法" class="headerlink" title="1.3 广播的发送方法"></a>1.3 广播的发送方法</h2><p>对于广播的发送，很简单，有很多的方法，来发送不同类型的广播：</p>
<ul>
<li><p>普通广播：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>有序广播：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>粘性广播：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>粘性有序广播：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="2-接收者的使用"><a href="#2-接收者的使用" class="headerlink" title="2 接收者的使用"></a>2 接收者的使用</h1><p>广播接收者分为 <code>2</code> 种，静态接收者，动态接收者：</p>
<ul>
<li>动态注册的接收者不是常驻型，也就是说广播跟随 <code>Activity</code> 的生命周期。注意在 <code>Activity</code> 结束前，移除广播接收器。</li>
<li>静态注册的接收者不是常驻型，也就是说当应用程序关闭后，如果有信息广播来，程序也会被系统调用自动运行。</li>
</ul>
<p>下面我们来看看他们的使用方法：</p>
<h2 id="2-1-静态注册的接收者"><a href="#2-1-静态注册的接收者" class="headerlink" title="2.1 静态注册的接收者"></a>2.1 静态注册的接收者</h2><p>静态接收者需要单独存在于一个 <code>.java</code> 文件：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstallResultReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (intent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            OppoLog.i (TAG, <span class="string">"ota intent is null!"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>并且在 <code>AndroidManifest.xml</code> 需要说明该组件的存在：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;receiver</span><br><span class="line">    android:name=<span class="string">".install.InstallResultReceiver"</span></span><br><span class="line">    android:exported=<span class="string">"true"</span>&gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name=<span class="string">"coolqi.intent.action.package_install_success"</span> /&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/receiver&gt;</span><br></pre></td></tr></table></figure>
<p><code>AndroidManifest.xml</code> 可以对接收者配置很多的属性，这里列举几个比较重要的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">android:name=<span class="string">".install.InstallResultReceiver"</span></span><br><span class="line">android:singleUser=<span class="string">"true"</span></span><br><span class="line">android:process=<span class="string">"com.demo.coolqi"</span></span><br><span class="line">android:enabled=<span class="string">"true"</span></span><br><span class="line">android:permission=<span class="string">"coolqi.send.package_install_success"</span></span><br><span class="line">android:exported=<span class="string">"true"</span>&gt;</span><br></pre></td></tr></table></figure>
<p>解释说明下：</p>
<ul>
<li><strong>name</strong>：接收者的全名；</li>
<li><strong>singleUser</strong>：该接收者是否在所有；</li>
<li><strong>process</strong>：该接收者所在的进程名；</li>
<li><strong>enabled</strong>：该接收者是否为单用户模式，如果为 <code>true</code>，所有用户使用的 <code>BroadcastReceiver</code> 是同一个；</li>
<li><strong>permission</strong>：该接收者指定发送者应具有的权限；</li>
<li><strong>exported</strong>：该接收者是否对其他应用暴露；</li>
</ul>
<p>初次之外：<code>intent-filter</code> 也可以设置一些属性，这里列举一些重要的属性：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:priority=<span class="string">""</span></span><br></pre></td></tr></table></figure></p>
<p>解释说明下：</p>
<ul>
<li><strong>priority</strong>：表示接收者的优先级，对于有序发送的广播，接收者优先级越高，越先接受到广播；</li>
</ul>
<p>关于优先级对于广播接受的影响，我们后面会谈到；</p>
<h2 id="2-2-动态注册的接收者"><a href="#2-2-动态注册的接收者" class="headerlink" title="2.2 动态注册的接收者"></a>2.2 动态注册的接收者</h2><p>动态接收者不能单独存在于一个独立的 <code>.java</code> 文件中，他需要最为其他类的内部类来定义，它依附于其他的类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class InstallResultReceiver extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    private InstallResultReceiver resultReceiver;</span><br><span class="line">    </span><br><span class="line">    class InstallResultReceiver extends BroadcastReceiver&#123;</span><br><span class="line">  </span><br><span class="line">        @Override</span><br><span class="line">        public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line">     </span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要在代码中实时注册：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IntentFilter filter = new IntentFilter();</span><br><span class="line">filter.addAction(&quot;coolqi.intent.action.package_install_success&quot;);</span><br><span class="line">reReceiver = new InstallResultReceiver();</span><br><span class="line"></span><br><span class="line">registerReceiver(reReceiver, filter);</span><br></pre></td></tr></table></figure>
<p>同时在不需要该接收者时，需要动态取消注册：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unregisterReceiver(reReceiver);</span><br></pre></td></tr></table></figure>
<p>对于动态注册的接收者，也可以设置他的优先级：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filter.setPriority(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<h1 id="3-广播的发送和处理"><a href="#3-广播的发送和处理" class="headerlink" title="3 广播的发送和处理"></a>3 广播的发送和处理</h1><p>接下来，总结一下，广播的发送和处理流程！</p>
<h2 id="3-1-接收者的收集流程"><a href="#3-1-接收者的收集流程" class="headerlink" title="3.1 接收者的收集流程"></a>3.1 接收者的收集流程</h2><p>我们先通过一张图来看看广播接收者的收集流程：</p>
<p><img src="http://static.zybuluo.com/Coolqi/pmg9s76kvyeuzoggcthzf7i8/%E5%B9%BF%E6%92%AD%E7%9A%84%E5%8F%91%E9%80%81%E6%B5%81%E7%A8%8B.png" alt="广播的发送流程.png-84kB"></p>
<p>我们可以看到，发送过程中，首先会发送目标为动态注册的接收者的普通广播，发送方式是并发！</p>
<p>接下来会收集静态接收者和动态接收者，注意如果是普通广播，这里只收集静态注册的接收者，然后根据优先级对接收者进行排序，排序的算法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (it &lt; NT &amp;&amp; ir &lt; NR) &#123;</span><br><span class="line">    <span class="keyword">if</span> (curt == <span class="keyword">null</span>) &#123;</span><br><span class="line">        curt = (ResolveInfo)receivers.get(it); <span class="comment">// 静态</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (curr == <span class="keyword">null</span>) &#123;</span><br><span class="line">        curr = registeredReceivers.get(ir); <span class="comment">// 动态</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (curr.getPriority() &gt;= curt.priority) &#123;</span><br><span class="line">        receivers.add(it, curr);</span><br><span class="line">        ir++;</span><br><span class="line">        curr = <span class="keyword">null</span>;</span><br><span class="line">        it++;</span><br><span class="line">        NT++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        it++;</span><br><span class="line">        curt = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中：<code>NT</code> 是静态接收者的数量， <code>NR</code> 是动态注册的接收者的数量!</p>
<p>对于普通广播，由于 <code>NR</code> 是 0，目标接收者只有静态接收者，所以这里是不会进行优先级排序的；</p>
<p>对于有序广播，由于其既存在动态接收者，又存在静态接收者，所以这会进行优先级排序，排序的方式如下：</p>
<ul>
<li>如果动态接收者的优先级 <code>Priority</code> 大于等于静态接收者的优先级，动态接收者排在前面；</li>
<li>否则，静态接收者在前！</li>
</ul>
<p>通过上面，我们可以看出：</p>
<ul>
<li>对于普通广播，动态接收者是要比静态接收者先接受到广播的，无视优先级！</li>
<li>对于有序广播，则是按照优先级来处理！</li>
</ul>
<h2 id="3-2-广播发送流程"><a href="#3-2-广播发送流程" class="headerlink" title="3.2 广播发送流程"></a>3.2 广播发送流程</h2><p>接下来，我们来分析下广播的发送过程！</p>
<p>在发送的过程中，我们需要注意一些细节问题：</p>
<ul>
<li>发送的广播 <code>Intent</code> 会被强制添加 <code>Intent.FLAG_EXCLUDE_STOPPED_PACKAGES</code>，禁止广播发送给被强制停止的接收者！该标志位是从 <code>Android 3.1</code> 开始新增了：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAG_EXCLUDE_STOPPED_PACKAGES = <span class="number">0x00000010</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAG_INCLUDE_STOPPED_PACKAGES = <span class="number">0x00000020</span>;</span><br></pre></td></tr></table></figure>
<p>下面我来解释一下：</p>
<ul>
<li><code>FLAG_EXCLUDE_STOPPED_PACKAGES</code>：如果设置了该标志位，该 <code>Intent</code> 将不会匹配那些被强制停止的应用中的组件，如果不设置该标志位，默认是会匹配被强制停止的应用的组件的！</li>
<li><code>FLAG_INCLUDE_STOPPED_PACKAGES</code>：：如果设置了该标志位，该 <code>Intent</code> 将会匹配那些被强制停止的应用中的组件，如果不设置 <code>FLAG_EXCLUDE_STOPPED_PACKAGES</code> 标志位，将会默认设置该标志位，如果两个标志位都被设置了，该标志位才生效！</li>
</ul>
<p>对于系统广播，一般是无法更改标志位的，当然，系统开发者除外；对于应用的自定义的广播，可以设置 <code>FLAG_INCLUDE_STOPPED_PACKAGES</code>，使其能够发送给被停止的接收者！</p>
<p>这里简单提一下，有 <code>2</code> 种情况，应用会处于停止状态：</p>
<ul>
<li>应用第一次安装并且没有被启动过；</li>
<li>用户在应用管理中强制停止了该应用；</li>
</ul>
<p>在收集完接收者后，就会创建对应的广播，封装接收者列表，然后，将广播添加到指定队列的列表中，触发发送，我们来简单的回顾下；</p>
<p><img src="http://static.zybuluo.com/Coolqi/evfvxiy8cvrflkg1jzq2tk5m/%E6%94%B6%E9%9B%86%E6%8E%A5%E6%94%B6%E8%80%85%E5%9B%BE%E7%A4%BA.png" alt="收集接收者图示.png-71.7kB"></p>
<p>广播分发的调用链如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">queue.scheduleBroadcastsLocked(); -&gt; send BROADCAST_INTENT_MSG -&gt; processNextBroadcast();</span><br></pre></td></tr></table></figure></p>
<p>我们用一张图来直观的看一下:</p>
<p><img src="http://static.zybuluo.com/Coolqi/7qk2sd0r3ldxvj9w7elmn6ps/%E5%B9%BF%E6%92%AD%E7%9A%84%E5%8F%91%E9%80%81%E6%B5%81%E7%A8%8B2.png" alt="广播的发送流程2.png-65.3kB"></p>
<p>可以看到，每次分发，都会率先的处理 <code>BroadcastQueue</code> 队列中的并发集合 <code>mParallelBroadcasts</code>  中的所有广播：目标为动态接收者的普通广播，直到 <code>mParallelBroadcasts</code> 为空！</p>
<p>然后，接着是，处理那些正在等待目标进程启动的广播 <code>mPendingBroadcast</code>，如果目标进程没有启动完成或者没有死亡，那就不能继续发送广播，因为需要的等待进程启动后处理该广播！</p>
<p>接着是，处理有序列表 <code>mOrderedBroadcasts</code> 中的广播，首先会遍历 <code>mOrderedBroadcasts</code>，移除那些没有接收者 / 接收者都已经接收完成 / 被终止 / 超时的广播，定位到下一次需要发送的广播，进行分发；</p>
<blockquote>
<p>这里要重点说一下：mOrderedBroadcasts 中的广播有 2 中：一种是目标是静态接收者的普通广播；另一种是有序广播，这二种广播都采用的是有序的发送方式；</p>
</blockquote>
<h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h1></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Coolqi.Li</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://coolqi.top/2016/08/13/BroadcastReceiver篇 7 - BroadcastReceiver 广播机制总结/">https://coolqi.top/2016/08/13/BroadcastReceiver篇 7 - BroadcastReceiver 广播机制总结/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://coolqi.top">Coolqi`s Blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/BroadcastReceiver广播接收者/">BroadcastReceiver广播接收者</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="/img/zfb.jpg"><div class="post-qr-code__desc">支付宝打赏</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="/img/wechat.jpg"><div class="post-qr-code__desc">微信打赏</div></div></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2016/09/21/Serivce 篇 7 - Service restart 流程分析/"><i class="fa fa-chevron-left">  </i><span>Serivce 篇 7 - Service restart 流程分析</span></a></div><div class="next-post pull-right"><a href="/2016/08/11/Serivce 篇 6 - startForeground 和 stopForeground 分析/"><span>Serivce 篇 6 - startForeground 和 stopForeground 分析</span><i class="fa fa-chevron-right"></i></a></div></nav><div class="post-adv"><a href="https://www.vultr.com/?ref=7231808"><img src="https://www.vultr.com/media/banner_1.png" width="728" height="90"></a></div><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '2cd8921819db714376b8',
  clientSecret: '94b82090448833d5295bc0d210f9f0719b2f124d',
  repo: 'single-li.github.io',
  owner: 'single-li',
  admin: 'single-li',
  id: decodeURI(location.pathname),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2015 - 2019 By Coolqi.Li</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://coolqi.top/">blog</a>!</div><div class="busuanzi"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.6"></script><script src="/js/fancybox.js?version=1.5.6"></script><script src="/js/sidebar.js?version=1.5.6"></script><script src="/js/copy.js?version=1.5.6"></script><script src="/js/fireworks.js?version=1.5.6"></script><script src="/js/transition.js?version=1.5.6"></script><script src="/js/scroll.js?version=1.5.6"></script><script src="/js/head.js?version=1.5.6"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="/js/search/local-search.js"></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"live2d-widget-model-hijiki"},"display":{"position":"right","width":110,"height":220},"mobile":{"show":false},"log":false});</script></body></html>