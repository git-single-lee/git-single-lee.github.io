<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="BroadcastReceiver篇 2 - registerReceiver 动态注册流程分析"><meta name="keywords" content="BroadcastReceiver广播接收者"><meta name="author" content="Coolqi.Li,undefined"><meta name="copyright" content="Coolqi.Li"><title>BroadcastReceiver篇 2 - registerReceiver 动态注册流程分析 | Coolqi`s Blog</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.5.6"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css?version=1.5.6"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#0-综述"><span class="toc-text">0 综述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-应用进程"><span class="toc-text">1 应用进程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-ContextWapper-registerReceiver"><span class="toc-text">1.1 ContextWapper.registerReceiver</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-ContextImpl-registerReceiver"><span class="toc-text">1.2 ContextImpl.registerReceiver</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-ContextImpl-registerReceiverInternal-核心入口"><span class="toc-text">1.3 ContextImpl.registerReceiverInternal - 核心入口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-1-LoadedApk-getReceiverDispatcher"><span class="toc-text">1.3.1 LoadedApk.getReceiverDispatcher</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-2-new-LoadedApk-ReceiverDispatcher"><span class="toc-text">1.3.2 new LoadedApk.ReceiverDispatcher</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-2-1-new-ReceiverDispatcher-InnerReceiver"><span class="toc-text">1.3.2.1 new ReceiverDispatcher.InnerReceiver</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-ActivityManagerP-registerReceiver"><span class="toc-text">1.4 ActivityManagerP.registerReceiver</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-系统进程"><span class="toc-text">2 系统进程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-ActivityManagerS-registerReceiver"><span class="toc-text">2.1 ActivityManagerS.registerReceiver</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-ActivityManagerS-getRecordForAppLocked"><span class="toc-text">2.1.1 ActivityManagerS.getRecordForAppLocked</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-IntentFilter-match"><span class="toc-text">2.1.2 IntentFilter.match</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-3-ActivityManagerS-broadcastQueueForIntent"><span class="toc-text">2.1.3 ActivityManagerS.broadcastQueueForIntent</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-4-new-BroadcastRecord"><span class="toc-text">2.1.4 new BroadcastRecord</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-5-BroadcastQueue-enqueueParallelBroadcastLocked"><span class="toc-text">2.1.5 BroadcastQueue.enqueueParallelBroadcastLocked</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-6-BroadcastQueue-scheduleBroadcastsLocked"><span class="toc-text">2.1.6 BroadcastQueue.scheduleBroadcastsLocked</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-BroadcastQueue-scheduleBroadcastsLocked"><span class="toc-text">2.2 BroadcastQueue.scheduleBroadcastsLocked</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-BroadcastQueue-BroadcastHandler"><span class="toc-text">2.3 BroadcastQueue.BroadcastHandler</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-总结"><span class="toc-text">3 总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-数据结构分析"><span class="toc-text">3.1 数据结构分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1-BroadcastRecevier"><span class="toc-text">3.1.1 BroadcastRecevier</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2-mStickyBroadcasts"><span class="toc-text">3.1.2 mStickyBroadcasts</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-3-mRegisteredReceivers"><span class="toc-text">3.1.3 mRegisteredReceivers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-4-ReceiverList"><span class="toc-text">3.1.4 ReceiverList</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-5-BroadcastFilter"><span class="toc-text">3.1.5 BroadcastFilter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-6-mReceiverResolver"><span class="toc-text">3.1.6 mReceiverResolver</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-7-BroadcastQueue"><span class="toc-text">3.1.7 BroadcastQueue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-8-BroadcastRecord"><span class="toc-text">3.1.8 BroadcastRecord</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-结构关系图"><span class="toc-text">3.2 结构关系图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-注册者进程关系图"><span class="toc-text">3.2.1 注册者进程关系图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-系统进程关系图"><span class="toc-text">3.2.2 系统进程关系图</span></a></li></ol></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Coolqi.Li</div><div class="author-info__description text-center">“你好，我是李帅奇，Android 系统工程师，MineCraft 忠实玩家，设计和绘画爱好者，缺妹纸晚期患者，熬夜星人。”</div><div class="follow-button"><a href="https://github.com/li-coolqi">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">59</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">13</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">17</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="https://molunerfinn.com">Molunerfinn</a><a class="author-info-links__name text-center" href="https://piegg.cn">PiEgg</a><a class="author-info-links__name text-center" href="https://piegg.cn">Elody</a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Coolqi`s Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/about">About</a></span></div><div id="post-info"><div id="post-title">BroadcastReceiver篇 2 - registerReceiver 动态注册流程分析</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2016-05-01</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/AndroidFramework源码分析/">AndroidFramework源码分析</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/AndroidFramework源码分析/BroadcastReceiver广播接收者/">BroadcastReceiver广播接收者</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">6k</span><span class="post-meta__separator">|</span><span>阅读时长: 26 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>[toc]</p>
<p>基于 Android 7.1.1 源码，分析 BroadcastReceiver <strong>动态注册</strong> 的过程，转载请说明出处！</p>
<h1 id="0-综述"><a href="#0-综述" class="headerlink" title="0 综述"></a>0 综述</h1><p>BroadcastReceiver 动态注册，就是应用程序在运行过程中，调用 registerReceiver 方法注册：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Intent <span class="title">registerReceiver</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    BroadcastReceiver receiver, IntentFilter filter)</span>；</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Intent <span class="title">registerReceiver</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    BroadcastReceiver receiver, IntentFilter filter,</span></span></span><br><span class="line"><span class="function"><span class="params">    String broadcastPermission, Handler scheduler)</span>；</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Intent <span class="title">registerReceiverAsUser</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    BroadcastReceiver receiver, UserHandle user, IntentFilter filter,</span></span></span><br><span class="line"><span class="function"><span class="params">    String broadcastPermission, Handler scheduler)</span>；</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到，动态注册广播接收者者时，我们需要创建一个 IntentFilter 过滤器对象，我们还可以指定广播发送者的权限，除此之外，我们还可以通过传入 Handler 来指定 onReceive 方法执行的线程（默认是主线程）。</p>
<p>当应用不再需要这个广播接收者后，需要动态取消注册：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unregisterReceiver</span><span class="params">(BroadcastReceiver receiver)</span></span>;</span><br></pre></td></tr></table></figure>
<p>下面，我们来进入源码，分析动态注册的流程！</p>
<h1 id="1-应用进程"><a href="#1-应用进程" class="headerlink" title="1 应用进程"></a>1 应用进程</h1><h2 id="1-1-ContextWapper-registerReceiver"><a href="#1-1-ContextWapper-registerReceiver" class="headerlink" title="1.1 ContextWapper.registerReceiver"></a>1.1 ContextWapper.registerReceiver</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Intent <span class="title">registerReceiver</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    BroadcastReceiver receiver, IntentFilter filter)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mBase.registerReceiver(receiver, filter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// broadcastPermission 用来指定发送者需要的权限！</span></span><br><span class="line"><span class="comment">// scheduler 用来指定 onReceive 方法执行的线程！</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Intent <span class="title">registerReceiver</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    BroadcastReceiver receiver, IntentFilter filter,</span></span></span><br><span class="line"><span class="function"><span class="params">    String broadcastPermission, Handler scheduler)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mBase.registerReceiver(receiver, filter, broadcastPermission,</span><br><span class="line">            scheduler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Intent <span class="title">registerReceiverAsUser</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    BroadcastReceiver receiver, UserHandle user, IntentFilter filter,</span></span></span><br><span class="line"><span class="function"><span class="params">    String broadcastPermission, Handler scheduler)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mBase.registerReceiverAsUser(receiver, user, filter, broadcastPermission,</span><br><span class="line">            scheduler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 mBase 是 ContextImpl 对象！</p>
<h2 id="1-2-ContextImpl-registerReceiver"><a href="#1-2-ContextImpl-registerReceiver" class="headerlink" title="1.2 ContextImpl.registerReceiver"></a>1.2 ContextImpl.registerReceiver</h2><p>进入 ContextImpl 继续看：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Intent <span class="title">registerReceiver</span><span class="params">(BroadcastReceiver receiver, IntentFilter filter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> registerReceiver(receiver, filter, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Intent <span class="title">registerReceiver</span><span class="params">(BroadcastReceiver receiver, IntentFilter filter,</span></span></span><br><span class="line"><span class="function"><span class="params">        String broadcastPermission, Handler scheduler)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> registerReceiverInternal(receiver, getUserId(),</span><br><span class="line">            filter, broadcastPermission, scheduler, getOuterContext());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Intent <span class="title">registerReceiverAsUser</span><span class="params">(BroadcastReceiver receiver, UserHandle user,</span></span></span><br><span class="line"><span class="function"><span class="params">        IntentFilter filter, String broadcastPermission, Handler scheduler)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> registerReceiverInternal(receiver, user.getIdentifier(),</span><br><span class="line">            filter, broadcastPermission, scheduler, getOuterContext());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到，虽然是不同的注册方法，最后都调用了 registerReceiverInternal 方法！getOuterContext() 方法用于获得注册时的上下文运行环境！也就是代表注册时所属的组件！！</p>
<h2 id="1-3-ContextImpl-registerReceiverInternal-核心入口"><a href="#1-3-ContextImpl-registerReceiverInternal-核心入口" class="headerlink" title="1.3 ContextImpl.registerReceiverInternal - 核心入口"></a>1.3 ContextImpl.registerReceiverInternal - 核心入口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Intent <span class="title">registerReceiverInternal</span><span class="params">(BroadcastReceiver receiver, <span class="keyword">int</span> userId,</span></span></span><br><span class="line"><span class="function"><span class="params">        IntentFilter filter, String broadcastPermission,</span></span></span><br><span class="line"><span class="function"><span class="params">        Handler scheduler, Context context)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    IIntentReceiver rd = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (receiver != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//【1】mPackageInfo 是 LoadedApk 对象，每个进程都有一个！</span></span><br><span class="line">        <span class="keyword">if</span> (mPackageInfo != <span class="keyword">null</span> &amp;&amp; context != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (scheduler == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果传入的 Handler 为 null，就设置 scheduler 为所在进程的主线程 Handler!</span></span><br><span class="line">                scheduler = mMainThread.getHandler();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//【*1.3.1】获得 BroadcastReceiver 对应的 IIntentReceiver 对象！</span></span><br><span class="line">            rd = mPackageInfo.getReceiverDispatcher(</span><br><span class="line">                receiver, context, scheduler,</span><br><span class="line">                mMainThread.getInstrumentation(), <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (scheduler == <span class="keyword">null</span>) &#123;</span><br><span class="line">                scheduler = mMainThread.getHandler();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//【*1.3.2】创建一个 ReceiverDispatcher 对象！</span></span><br><span class="line">            rd = <span class="keyword">new</span> LoadedApk.ReceiverDispatcher(</span><br><span class="line">                    receiver, context, scheduler, <span class="keyword">null</span>, <span class="keyword">true</span>).getIIntentReceiver();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【*1.4】进入系统进程，继续注册！</span></span><br><span class="line">        <span class="keyword">final</span> Intent intent = ActivityManagerNative.getDefault().registerReceiver(</span><br><span class="line">                mMainThread.getApplicationThread(), mBasePackageName,</span><br><span class="line">                rd, filter, broadcastPermission, userId);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (intent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            intent.setExtrasClassLoader(getClassLoader());</span><br><span class="line">            intent.prepareToEnterProcess();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> intent;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>IIntentReceiver 类实例 rd 用来在应用进程和系统进程中进行 Binder 通信！</p>
<p>Handler 类对象 scheduler 用来设置接受到广播后 onReceive 执行的线程，如果传入 null，默认就在主线程！</p>
<p>这里涉及到一个 mPackageInfo，他是 LoadedApk 类的实例。每一个进程在创建时，都会有一个 LoadedApk 对象。用来分装一个应用程序的信息！</p>
<p>我们去 LoadedApk 目录去看看：</p>
<h3 id="1-3-1-LoadedApk-getReceiverDispatcher"><a href="#1-3-1-LoadedApk-getReceiverDispatcher" class="headerlink" title="1.3.1 LoadedApk.getReceiverDispatcher"></a>1.3.1 LoadedApk.getReceiverDispatcher</h3><p>这里的 boolean registered 为 true：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">getReceiverDispatcher</span><span class="params">(BroadcastReceiver r,</span></span></span><br><span class="line"><span class="function"><span class="params">        Context context, Handler handler,</span></span></span><br><span class="line"><span class="function"><span class="params">        Instrumentation instrumentation, <span class="keyword">boolean</span> registered)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mReceivers) &#123;</span><br><span class="line">        <span class="comment">//【1】尝试获得对应的 ReceiverDispatcher，如果没有就重新创建！</span></span><br><span class="line">        LoadedApk.ReceiverDispatcher rd = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        ArrayMap&lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&gt; map = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (registered) &#123;</span><br><span class="line">            map = mReceivers.get(context);</span><br><span class="line">            <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">                rd = map.get(r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【*1.3.2】第一次注册，创建全新的 ReceiverDispatcher 对象！</span></span><br><span class="line">        <span class="keyword">if</span> (rd == <span class="keyword">null</span>) &#123;</span><br><span class="line">            rd = <span class="keyword">new</span> ReceiverDispatcher(r, context, handler,</span><br><span class="line">                    instrumentation, registered);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (registered) &#123;</span><br><span class="line">                <span class="keyword">if</span> (map == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    map = <span class="keyword">new</span> ArrayMap&lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&gt;();</span><br><span class="line">                    mReceivers.put(context, map);</span><br><span class="line">                &#125;</span><br><span class="line">                map.put(r, rd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//【2】校验一下 context 和 handler 是否和之前注册的一样，不一样会抛出异常！</span></span><br><span class="line">            rd.validate(context, handler);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        rd.mForgotten = <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【3】返回内部的 InnerReceiver 对象！</span></span><br><span class="line">        <span class="keyword">return</span> rd.getIIntentReceiver();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>LoadedApk 有一个 ArrayMap 集合 mReceivers：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ArrayMap&lt;Context, ArrayMap&lt;BroadcastReceiver, ReceiverDispatcher&gt;&gt; mReceivers</span><br><span class="line">    = <span class="keyword">new</span> ArrayMap&lt;Context, ArrayMap&lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&gt;&gt;();</span><br></pre></td></tr></table></figure></p>
<p>用来保存当前进程下，每个上下文运行环境 Context 中，对应的 BroadcastReceiver 和 ReceiverDispatcher 的映射关系！</p>
<h3 id="1-3-2-new-LoadedApk-ReceiverDispatcher"><a href="#1-3-2-new-LoadedApk-ReceiverDispatcher" class="headerlink" title="1.3.2 new LoadedApk.ReceiverDispatcher"></a>1.3.2 new LoadedApk.ReceiverDispatcher</h3><p>我们再去看看 ReceiverDispatcher 对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ReceiverDispatcher(BroadcastReceiver receiver, Context context,</span><br><span class="line">        Handler activityThread, Instrumentation instrumentation,</span><br><span class="line">        <span class="keyword">boolean</span> registered) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (activityThread == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Handler must not be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【*1.3.2.1】创建了一个 InnerReceiver 对象，用于 Binder 通信！</span></span><br><span class="line">    mIIntentReceiver = <span class="keyword">new</span> InnerReceiver(<span class="keyword">this</span>, !registered);</span><br><span class="line">    mReceiver = receiver;</span><br><span class="line">    mContext = context;</span><br><span class="line"></span><br><span class="line">    mActivityThread = activityThread;</span><br><span class="line">    mInstrumentation = instrumentation;</span><br><span class="line">    mRegistered = registered;</span><br><span class="line">    mLocation = <span class="keyword">new</span> IntentReceiverLeaked(<span class="keyword">null</span>);</span><br><span class="line">    mLocation.fillInStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 IntentReceiverLeaked，我们不过多分析，很简单！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">IntentReceiverLeaked</span> <span class="keyword">extends</span> <span class="title">AndroidRuntimeException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IntentReceiverLeaked</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ReceiverDispatcher 用于保存 BroadcastReceiver 和 InnerReceiver 映射关系，我们继续看：</p>
<h4 id="1-3-2-1-new-ReceiverDispatcher-InnerReceiver"><a href="#1-3-2-1-new-ReceiverDispatcher-InnerReceiver" class="headerlink" title="1.3.2.1 new ReceiverDispatcher.InnerReceiver"></a>1.3.2.1 new ReceiverDispatcher.InnerReceiver</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerReceiver</span> <span class="keyword">extends</span> <span class="title">IIntentReceiver</span>.<span class="title">Stub</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> WeakReference&lt;LoadedApk.ReceiverDispatcher&gt; mDispatcher;</span><br><span class="line">    <span class="keyword">final</span> LoadedApk.ReceiverDispatcher mStrongRef;</span><br><span class="line"></span><br><span class="line">    InnerReceiver(LoadedApk.ReceiverDispatcher rd, <span class="keyword">boolean</span> strong) &#123;</span><br><span class="line">        <span class="comment">//【1】创建了一个 ReceiverDispatcher 的弱引用！</span></span><br><span class="line">        mDispatcher = <span class="keyword">new</span> WeakReference&lt;LoadedApk.ReceiverDispatcher&gt;(rd);</span><br><span class="line">        <span class="comment">//【2】这里 strong 为 false，所以 mStrongRef 为 null；</span></span><br><span class="line">        mStrongRef = strong ? rd : <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performReceive</span><span class="params">(Intent intent, <span class="keyword">int</span> resultCode, String data,</span></span></span><br><span class="line"><span class="function"><span class="params">            Bundle extras, <span class="keyword">boolean</span> ordered, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> sendingUser)</span> </span>&#123;</span><br><span class="line">        ... ... ... ... <span class="comment">// 用于处理广播的接收！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到 InnerReceiver 继承了 IIntentReceiver.Stub，他是作为 Binder 通信的服务端，其实，这种架构，我们在 Service 的创建和启动中，也同样看到过！！ </p>
<h2 id="1-4-ActivityManagerP-registerReceiver"><a href="#1-4-ActivityManagerP-registerReceiver" class="headerlink" title="1.4 ActivityManagerP.registerReceiver"></a>1.4 ActivityManagerP.registerReceiver</h2><p>接着调用 AMP 代理对象的 registerReceiver 方法，进入系统进程，注册 BroadcastReceiver！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Intent <span class="title">registerReceiver</span><span class="params">(IApplicationThread caller, String packageName,</span></span></span><br><span class="line"><span class="function"><span class="params">        IIntentReceiver receiver,</span></span></span><br><span class="line"><span class="function"><span class="params">        IntentFilter filter, String perm, <span class="keyword">int</span> userId)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    Parcel data = Parcel.obtain();</span><br><span class="line">    Parcel reply = Parcel.obtain();</span><br><span class="line">    data.writeInterfaceToken(IActivityManager.descriptor);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】处理 ApplicationThread 对象！</span></span><br><span class="line">    data.writeStrongBinder(caller != <span class="keyword">null</span> ? caller.asBinder() : <span class="keyword">null</span>);</span><br><span class="line">    data.writeString(packageName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】处理 IIntentReceiver 对象！</span></span><br><span class="line">    data.writeStrongBinder(receiver != <span class="keyword">null</span> ? receiver.asBinder() : <span class="keyword">null</span>);</span><br><span class="line">    filter.writeToParcel(data, <span class="number">0</span>);</span><br><span class="line">    data.writeString(perm);</span><br><span class="line">    data.writeInt(userId);</span><br><span class="line"></span><br><span class="line">    mRemote.transact(REGISTER_RECEIVER_TRANSACTION, data, reply, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    reply.readException();</span><br><span class="line">    Intent intent = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> haveIntent = reply.readInt();</span><br><span class="line">    <span class="keyword">if</span> (haveIntent != <span class="number">0</span>) &#123;</span><br><span class="line">        intent = Intent.CREATOR.createFromParcel(reply);</span><br><span class="line">    &#125;</span><br><span class="line">    reply.recycle();</span><br><span class="line">    data.recycle();</span><br><span class="line">    <span class="keyword">return</span> intent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面，进入系统进程！</p>
<h1 id="2-系统进程"><a href="#2-系统进程" class="headerlink" title="2 系统进程"></a>2 系统进程</h1><p>首先，进入 ActivityManagerN.onTransact 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    ... ... ...</span><br><span class="line">    <span class="keyword">case</span> REGISTER_RECEIVER_TRANSACTION:</span><br><span class="line">    &#123;</span><br><span class="line">        data.enforceInterface(IActivityManager.descriptor);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【1】获得 ApplicationThreadProxy 对象！</span></span><br><span class="line">        IBinder b = data.readStrongBinder();</span><br><span class="line">        IApplicationThread app =</span><br><span class="line">            b != <span class="keyword">null</span> ? ApplicationThreadNative.asInterface(b) : <span class="keyword">null</span>;</span><br><span class="line">            </span><br><span class="line">        String packageName = data.readString();</span><br><span class="line">        b = data.readStrongBinder();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【2】获得 IIntentReceiver.proxy 对象！</span></span><br><span class="line">        IIntentReceiver rec</span><br><span class="line">            = b != <span class="keyword">null</span> ? IIntentReceiver.Stub.asInterface(b) : <span class="keyword">null</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">//【3】获得 IntentFilter 对象！</span></span><br><span class="line">        IntentFilter filter = IntentFilter.CREATOR.createFromParcel(data);</span><br><span class="line">        String perm = data.readString();</span><br><span class="line">        <span class="keyword">int</span> userId = data.readInt();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【*2.1】继续调用 AMS.registerReceiver 方法，注册广播接收者！</span></span><br><span class="line">        Intent intent = registerReceiver(app, packageName, rec, filter, perm, userId);</span><br><span class="line"></span><br><span class="line">        reply.writeNoException();</span><br><span class="line">        <span class="keyword">if</span> (intent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            reply.writeInt(<span class="number">1</span>);</span><br><span class="line">            intent.writeToParcel(reply, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            reply.writeInt(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    ... ... ...    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-1-ActivityManagerS-registerReceiver"><a href="#2-1-ActivityManagerS-registerReceiver" class="headerlink" title="2.1 ActivityManagerS.registerReceiver"></a>2.1 ActivityManagerS.registerReceiver</h2><p>参数分析：</p>
<ul>
<li><strong>IApplicationThread caller</strong>：注册操作所属的应用进程的 ApplicationThreadProxy 对象</li>
<li><strong>String callerPackage</strong>：注册者所属的应用程序包名；</li>
<li><strong>IIntentReceiver receiver</strong>：IIntentReceiver.Proxy 对象，映射注册者进程中的 InnerReceiver 对象；</li>
<li><strong>IntentFilter filter</strong>：Intent 过滤器；</li>
<li><strong>String permission</strong>：需要的权限！</li>
<li><strong>int userId</strong>：当前设备用户 id</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Intent <span class="title">registerReceiver</span><span class="params">(IApplicationThread caller, String callerPackage,</span></span></span><br><span class="line"><span class="function"><span class="params">        IIntentReceiver receiver, IntentFilter filter, String permission, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    enforceNotIsolatedCaller(<span class="string">"registerReceiver"</span>);</span><br><span class="line">    <span class="comment">//【1】用来保存能够处理的粘性广播列表！</span></span><br><span class="line">    ArrayList&lt;Intent&gt; stickyIntents = <span class="keyword">null</span>;</span><br><span class="line">    ProcessRecord callerApp = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> callingUid;</span><br><span class="line">    <span class="keyword">int</span> callingPid;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (caller != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//【*2.1.1】获得注册者进程对应的 ProcessRecord 对象！</span></span><br><span class="line">            <span class="comment">// 如果注册者进程为 null，抛出异常！</span></span><br><span class="line">            callerApp = getRecordForAppLocked(caller);</span><br><span class="line">            <span class="keyword">if</span> (callerApp == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(</span><br><span class="line">                        <span class="string">"Unable to find app for caller "</span> + caller</span><br><span class="line">                        + <span class="string">" (pid="</span> + Binder.getCallingPid()</span><br><span class="line">                        + <span class="string">") when registering receiver "</span> + receiver);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//【2】如果注册者进程的 uid 不是系统 uid，并且注册者包名不在注册者进程的列表中</span></span><br><span class="line">            <span class="comment">// 且注册者包名不是 “android” 抛出异常！</span></span><br><span class="line">            <span class="keyword">if</span> (callerApp.info.uid != Process.SYSTEM_UID &amp;&amp;</span><br><span class="line">                    !callerApp.pkgList.containsKey(callerPackage) &amp;&amp;</span><br><span class="line">                    !<span class="string">"android"</span>.equals(callerPackage)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"Given caller package "</span> + callerPackage</span><br><span class="line">                        + <span class="string">" is not running in process "</span> + callerApp);</span><br><span class="line">            &#125;</span><br><span class="line">            callingUid = callerApp.info.uid;</span><br><span class="line">            callingPid = callerApp.pid;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            callerPackage = <span class="keyword">null</span>;</span><br><span class="line">            callingUid = Binder.getCallingUid();</span><br><span class="line">            callingPid = Binder.getCallingPid();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        userId = mUserController.handleIncomingUser(callingPid, callingUid, userId, <span class="keyword">true</span>,</span><br><span class="line">                ALLOW_FULL_ONLY, <span class="string">"registerReceiver"</span>, callerPackage);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【2】通过解析 IntentFilter 获得 BroadcastReceiver 设置的 action 列表！</span></span><br><span class="line">        Iterator&lt;String&gt; actions = filter.actionsIterator();</span><br><span class="line">        <span class="keyword">if</span> (actions == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ArrayList&lt;String&gt; noAction = <span class="keyword">new</span> ArrayList&lt;String&gt;(<span class="number">1</span>);</span><br><span class="line">            noAction.add(<span class="keyword">null</span>);</span><br><span class="line">            actions = noAction.iterator();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 收集所有设备用户；</span></span><br><span class="line">        <span class="keyword">int</span>[] userIds = &#123; UserHandle.USER_ALL, UserHandle.getUserId(callingUid) &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【3】遍历广播接收者的 actions 列表，找到能够和 action 匹配的粘性广播，添加到 stickyIntents 集合中！</span></span><br><span class="line">        <span class="keyword">while</span> (actions.hasNext()) &#123;</span><br><span class="line">            String action = actions.next();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> id : userIds) &#123;</span><br><span class="line">                <span class="comment">//【3.1】获得每个设备用户下的“粘性”广播！</span></span><br><span class="line">                ArrayMap&lt;String, ArrayList&lt;Intent&gt;&gt; stickies = mStickyBroadcasts.get(id);</span><br><span class="line">                <span class="keyword">if</span> (stickies != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    ArrayList&lt;Intent&gt; intents = stickies.get(action);</span><br><span class="line">                    <span class="keyword">if</span> (intents != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (stickyIntents == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            stickyIntents = <span class="keyword">new</span> ArrayList&lt;Intent&gt;();</span><br><span class="line">                        &#125;</span><br><span class="line">                        stickyIntents.addAll(intents);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【4】因为 Intent 出了设置 action 这个属性之外，还会设置其他的一些属性！</span></span><br><span class="line">    <span class="comment">// 这里是查找完全匹配的“粘性”广播，添加到 allSticky 集合中！</span></span><br><span class="line">    ArrayList&lt;Intent&gt; allSticky = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (stickyIntents != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> ContentResolver resolver = mContext.getContentResolver();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, N = stickyIntents.size(); i &lt; N; i++) &#123;</span><br><span class="line">            Intent intent = stickyIntents.get(i);</span><br><span class="line">            <span class="keyword">if</span> (filter.match(resolver, intent, <span class="keyword">true</span>, TAG) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (allSticky == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    allSticky = <span class="keyword">new</span> ArrayList&lt;Intent&gt;();</span><br><span class="line">                &#125;</span><br><span class="line">                allSticky.add(intent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【5】我们会将第一个完全匹配的粘性广播发给接收者，如果动态注册的接收者为 null 的话，立刻返回！</span></span><br><span class="line">    Intent sticky = allSticky != <span class="keyword">null</span> ? allSticky.get(<span class="number">0</span>) : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, <span class="string">"Register receiver "</span> + filter + <span class="string">": "</span> + sticky);</span><br><span class="line">    <span class="keyword">if</span> (receiver == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> sticky;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (callerApp != <span class="keyword">null</span> &amp;&amp; (callerApp.thread == <span class="keyword">null</span></span><br><span class="line">                || callerApp.thread.asBinder() != caller.asBinder())) &#123;</span><br><span class="line">            <span class="comment">//【6】如果注册者进程死亡了，就退出！</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【7】尝试获得广播接收者在系统进程中的 ReceiverList 对象，如果为 null，说明没有注册！ </span></span><br><span class="line">        ReceiverList rl = mRegisteredReceivers.get(receiver.asBinder());</span><br><span class="line">        <span class="keyword">if</span> (rl == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【*3.1.4】创建一个全新的 ReceiverList 对象，封装该动态注册的广播接收者！</span></span><br><span class="line">            rl = <span class="keyword">new</span> ReceiverList(<span class="keyword">this</span>, callerApp, callingPid, callingUid,</span><br><span class="line">                    userId, receiver);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//【*5.2】如果 rl.app 不为 null，说明注册者进程已经启动，就将  ReceiverList 对象添加</span></span><br><span class="line">            <span class="comment">// 到注册者的进程的 receivers 集合中，对于动态注册，显然进入这个分支！</span></span><br><span class="line">            <span class="keyword">if</span> (rl.app != <span class="keyword">null</span>) &#123;</span><br><span class="line">                rl.app.receivers.add(rl);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果 rl.app 为 bull，这可能是一种异常状态！！直接 linkToDeath 进行 Binder 监听！</span></span><br><span class="line">                    receiver.asBinder().linkToDeath(rl, <span class="number">0</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                    <span class="keyword">return</span> sticky;</span><br><span class="line">                &#125;</span><br><span class="line">                rl.linkedToDeath = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//【6】将 InnerReceiver.proxy 和 ReceiverList 的映射关系保存到 mRegisteredReceivers 中！</span></span><br><span class="line">            <span class="comment">// 表示该广播接收者已经被注册！</span></span><br><span class="line">            mRegisteredReceivers.put(receiver.asBinder(), rl);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rl.uid != callingUid) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    <span class="string">"Receiver requested to register for uid "</span> + callingUid</span><br><span class="line">                    + <span class="string">" was previously registered for uid "</span> + rl.uid);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rl.pid != callingPid) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    <span class="string">"Receiver requested to register for pid "</span> + callingPid</span><br><span class="line">                    + <span class="string">" was previously registered for pid "</span> + rl.pid);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rl.userId != userId) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    <span class="string">"Receiver requested to register for user "</span> + userId</span><br><span class="line">                    + <span class="string">" was previously registered for user "</span> + rl.userId);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【7】创建 BroadcastFilter 对象 bf，用来封装广播接收者的 IntentFilter 对象！</span></span><br><span class="line">        BroadcastFilter bf = <span class="keyword">new</span> BroadcastFilter(filter, rl, callerPackage,</span><br><span class="line">                permission, callingUid, userId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 BroadcastFilter 对象添加到 ReceiverList 列表中！</span></span><br><span class="line">        rl.add(bf);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!bf.debugCheck()) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"==&gt; For Dynamic broadcast"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【8】将创建的广播过滤器 BroadcastFilter 保存到 mReceiverResolver 中，用于查询使用！</span></span><br><span class="line">        mReceiverResolver.addFilter(bf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【9】如果 allSticky 不为 null，说明有能匹配该广播过滤器的 “粘性广播”！</span></span><br><span class="line">        <span class="comment">// 接着就是要处理粘性广播的分发了！</span></span><br><span class="line">        <span class="keyword">if</span> (allSticky != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//【9.1】将该动态注册的广播接收者添加到 ArrayList 中！</span></span><br><span class="line">            <span class="comment">// 准备将该粘性广播发送给接收者！</span></span><br><span class="line">            ArrayList receivers = <span class="keyword">new</span> ArrayList();</span><br><span class="line">            receivers.add(bf);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> stickyCount = allSticky.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stickyCount; i++) &#123;</span><br><span class="line">                Intent intent = allSticky.get(i);</span><br><span class="line">                <span class="comment">//【9.2】根据 Intent 是否设置 Intent.FLAG_RECEIVER_FOREGROUND 标志位，</span></span><br><span class="line">                <span class="comment">// 选择前台或者后台广播队列！</span></span><br><span class="line">                BroadcastQueue queue = broadcastQueueForIntent(intent);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//【9.3】创建 BroadcastRecord 对象！！</span></span><br><span class="line">                BroadcastRecord r = <span class="keyword">new</span> BroadcastRecord(queue, intent, <span class="keyword">null</span>,</span><br><span class="line">                        <span class="keyword">null</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, AppOpsManager.OP_NONE, <span class="keyword">null</span>, receivers,</span><br><span class="line">                        <span class="keyword">null</span>, <span class="number">0</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//【9.4】将粘性广播加入到广播队列的并发广播集合中！！</span></span><br><span class="line">                queue.enqueueParallelBroadcastLocked(r);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//【2.3】处理广播队列中的已有的广播！！</span></span><br><span class="line">                queue.scheduleBroadcastsLocked();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sticky;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面我们来分析下这个方法中的一些重要步骤：</p>
<h3 id="2-1-1-ActivityManagerS-getRecordForAppLocked"><a href="#2-1-1-ActivityManagerS-getRecordForAppLocked" class="headerlink" title="2.1.1 ActivityManagerS.getRecordForAppLocked"></a>2.1.1 ActivityManagerS.getRecordForAppLocked</h3><p>获得注册者进程的 ProcessRecord 对象，传入参数：</p>
<ul>
<li><strong>IApplicationThread thread</strong>：注册者进程在系统进程中的 ApplicationThreadProxy 对象！</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ProcessRecord <span class="title">getRecordForAppLocked</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        IApplicationThread thread)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (thread == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得进程 ProcessRecord 在 mLruProcesses 中的下标！</span></span><br><span class="line">    <span class="keyword">int</span> appIndex = getLRURecordIndexForAppLocked(thread);</span><br><span class="line">    <span class="keyword">return</span> appIndex &gt;= <span class="number">0</span> ? mLruProcesses.get(appIndex) : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里调用了 getLRURecordIndexForAppLocked 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getLRURecordIndexForAppLocked</span><span class="params">(IApplicationThread thread)</span> </span>&#123;</span><br><span class="line">    IBinder threadBinder = thread.asBinder();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find the application record.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=mLruProcesses.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">        ProcessRecord rec = mLruProcesses.get(i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到正在运行，并且 IApplicationThread 对象可以匹配的进程！</span></span><br><span class="line">        <span class="keyword">if</span> (rec.thread != <span class="keyword">null</span> &amp;&amp; rec.thread.asBinder() == threadBinder) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>mLruProcesses 是一个 ArrayList 集合，用来保存正在运行中的应用程序进程，这里我们先不看！</p>
<h3 id="2-1-2-IntentFilter-match"><a href="#2-1-2-IntentFilter-match" class="headerlink" title="2.1.2 IntentFilter.match"></a>2.1.2 IntentFilter.match</h3><p>主要代码段：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (filter.match(resolver, intent, <span class="keyword">true</span>, TAG) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (allSticky == <span class="keyword">null</span>) &#123;</span><br><span class="line">        allSticky = <span class="keyword">new</span> ArrayList&lt;Intent&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    allSticky.add(intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当前要注册的广播接收者只能接收到能够和 IntentFilter 匹配的广播，所以对于“粘性广播”，我们还需要再进行一次匹配操作，找到能够匹配 IntentFilter 的粘性广播，保存到 allSticky 列表中，我们来看看匹配过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">match</span><span class="params">(ContentResolver resolver, Intent intent,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> resolve, String logTag)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String type = resolve ? intent.resolveType(resolver) : intent.getType();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> match(intent.getAction(), type, intent.getScheme(),</span><br><span class="line">                 intent.getData(), intent.getCategories(), logTag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-1-3-ActivityManagerS-broadcastQueueForIntent"><a href="#2-1-3-ActivityManagerS-broadcastQueueForIntent" class="headerlink" title="2.1.3 ActivityManagerS.broadcastQueueForIntent"></a>2.1.3 ActivityManagerS.broadcastQueueForIntent</h3><p>该方法的作用是为广播选择合适的队列：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BroadcastQueue <span class="title">broadcastQueueForIntent</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isFg = (intent.getFlags() &amp; Intent.FLAG_RECEIVER_FOREGROUND) != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG_BROADCAST_BACKGROUND) Slog.i(TAG_BROADCAST,</span><br><span class="line">            <span class="string">"Broadcast intent "</span> + intent + <span class="string">" on "</span></span><br><span class="line">            + (isFg ? <span class="string">"foreground"</span> : <span class="string">"background"</span>) + <span class="string">" queue"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (isFg) ? mFgBroadcastQueue : mBgBroadcastQueue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果 Intent 设置了 Intent.FLAG_RECEIVER_FOREGROUND 标志位，那该广播就是一个前台广播，应该被加入 mFgBroadcastQueue 队列；否则，这是一个后台广播，就应该被添加到 mBgBroadcastQueue 队列中；</p>
<h3 id="2-1-4-new-BroadcastRecord"><a href="#2-1-4-new-BroadcastRecord" class="headerlink" title="2.1.4 new BroadcastRecord"></a>2.1.4 new BroadcastRecord</h3><p>创建广播管理对象 BroadcastRecord，参数传递：</p>
<ul>
<li><strong>BroadcastQueue _queue</strong>：表示广播所在的队列，传入 queue</li>
<li><strong>Intent _intent</strong>：传入 intent</li>
<li><strong>ProcessRecord _callerApp</strong>：传入 null</li>
<li><strong>String _callerPackage</strong>：传入 null</li>
<li><strong>int _callingPid</strong>：传入 -1</li>
<li><strong>int _callingUid</strong>：传入 -1</li>
<li><strong>String _resolvedType</strong>：传入 null</li>
<li><strong>String[] _requiredPermissions</strong>：传入 null</li>
<li><strong>int _appOp</strong>：传入 AppOpsManager.OP_NONE</li>
<li><strong>BroadcastOptions _options</strong>：传入 null</li>
<li><strong>List _receivers</strong>：传入 receivers，这里是</li>
<li><strong>IIntentReceiver _resultTo</strong>：传入 null</li>
<li><strong>int _resultCode</strong>：传入 0</li>
<li><strong>String _resultData</strong>：传入 null</li>
<li><strong>Bundle _resultExtras</strong>：传入 null</li>
<li><strong>boolean _serialized</strong>：传入 false</li>
<li><strong>boolean _sticky</strong>：传入 true</li>
<li><strong>boolean _initialSticky</strong>：传入 true</li>
<li><strong>int _userId</strong>：传入 -1</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">BroadcastRecord(BroadcastQueue _queue,</span><br><span class="line">        Intent _intent, ProcessRecord _callerApp, String _callerPackage,</span><br><span class="line">        <span class="keyword">int</span> _callingPid, <span class="keyword">int</span> _callingUid, String _resolvedType, String[] _requiredPermissions,</span><br><span class="line">        <span class="keyword">int</span> _appOp, BroadcastOptions _options, List _receivers, IIntentReceiver _resultTo,</span><br><span class="line">        <span class="keyword">int</span> _resultCode, String _resultData, Bundle _resultExtras, <span class="keyword">boolean</span> _serialized,</span><br><span class="line">        <span class="keyword">boolean</span> _sticky, <span class="keyword">boolean</span> _initialSticky,</span><br><span class="line">        <span class="keyword">int</span> _userId) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果广播对应的 Intent 为 null，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (_intent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Can't construct with a null intent"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    queue = _queue;  <span class="comment">// 广播所属的广播队列，有前台和后台之分；</span></span><br><span class="line">    intent = _intent; <span class="comment">// 广播 Intent</span></span><br><span class="line">    targetComp = _intent.getComponent(); <span class="comment">// 广播的目标组件，也就是目标 BroadcastReceiver</span></span><br><span class="line"></span><br><span class="line">    callerApp = _callerApp; <span class="comment">// 发送者所在的进程</span></span><br><span class="line">    callerPackage = _callerPackage; <span class="comment">// 发送者所属的包名</span></span><br><span class="line">    callingPid = _callingPid; <span class="comment">// 发送者的进程 pid</span></span><br><span class="line">    callingUid = _callingUid; <span class="comment">// 发送者进程的 uid</span></span><br><span class="line"></span><br><span class="line">    resolvedType = _resolvedType;</span><br><span class="line">    requiredPermissions = _requiredPermissions; <span class="comment">// 发送该广播需要的权限</span></span><br><span class="line">    appOp = _appOp;</span><br><span class="line">    options = _options;</span><br><span class="line"></span><br><span class="line">    receivers = _receivers; <span class="comment">//</span></span><br><span class="line">    delivery = <span class="keyword">new</span> <span class="keyword">int</span>[_receivers != <span class="keyword">null</span> ? _receivers.size() : <span class="number">0</span>]; <span class="comment">// 该广播分发给每个接收者的次数</span></span><br><span class="line"></span><br><span class="line">    resultTo = _resultTo;</span><br><span class="line">    resultCode = _resultCode;</span><br><span class="line">    resultData = _resultData;</span><br><span class="line">    resultExtras = _resultExtras;</span><br><span class="line">    ordered = _serialized;</span><br><span class="line">    sticky = _sticky;</span><br><span class="line">    initialSticky = _initialSticky;</span><br><span class="line">    userId = _userId;</span><br><span class="line">    nextReceiver = <span class="number">0</span>;</span><br><span class="line">    state = IDLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里是对“粘性”广播创建对应的 BroadcastRecord 管理对象！</p>
<h3 id="2-1-5-BroadcastQueue-enqueueParallelBroadcastLocked"><a href="#2-1-5-BroadcastQueue-enqueueParallelBroadcastLocked" class="headerlink" title="2.1.5 BroadcastQueue.enqueueParallelBroadcastLocked"></a>2.1.5 BroadcastQueue.enqueueParallelBroadcastLocked</h3><p>将“粘性”广播 BroadcastRecord 添加到 BroadcastQueue 对象内部的 mParallelBroadcasts 列表中，并初始化 r.enqueueClockTime 为当前系统时间，表示广播进入队列的时间；<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueueParallelBroadcastLocked</span><span class="params">(BroadcastRecord r)</span> </span>&#123;</span><br><span class="line">    mParallelBroadcasts.add(r);</span><br><span class="line">    r.enqueueClockTime = System.currentTimeMillis();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出，粘性广播属于并发的广播！</p>
<h3 id="2-1-6-BroadcastQueue-scheduleBroadcastsLocked"><a href="#2-1-6-BroadcastQueue-scheduleBroadcastsLocked" class="headerlink" title="2.1.6 BroadcastQueue.scheduleBroadcastsLocked"></a>2.1.6 BroadcastQueue.scheduleBroadcastsLocked</h3><p>开始处理广播，mBroadcastsScheduled 表示是否开始广播处理任务！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleBroadcastsLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, <span class="string">"Schedule broadcasts ["</span></span><br><span class="line">            + mQueueName + <span class="string">"]: current="</span></span><br><span class="line">            + mBroadcastsScheduled);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mBroadcastsScheduled) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【1】发送 BROADCAST_INTENT_MSG 消息！</span></span><br><span class="line">    mHandler.sendMessage(mHandler.obtainMessage(BROADCAST_INTENT_MSG, <span class="keyword">this</span>));</span><br><span class="line">    mBroadcastsScheduled = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>收集了粘性广播，把粘性广播添加到了指定的广播队列中，然后就是要处理广播了！mHandler 是 BroadcastHandler 对象，这里是向 BroadcastHandler 发送 BROADCAST_INTENT_MSG 消息，开始分发广播！！</p>
<h2 id="2-2-BroadcastQueue-scheduleBroadcastsLocked"><a href="#2-2-BroadcastQueue-scheduleBroadcastsLocked" class="headerlink" title="2.2 BroadcastQueue.scheduleBroadcastsLocked"></a>2.2 BroadcastQueue.scheduleBroadcastsLocked</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleBroadcastsLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, <span class="string">"Schedule broadcasts ["</span></span><br><span class="line">            + mQueueName + <span class="string">"]: current="</span></span><br><span class="line">            + mBroadcastsScheduled);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mBroadcastsScheduled) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【1】触发广播的分发！</span></span><br><span class="line">    mHandler.sendMessage(mHandler.obtainMessage(BROADCAST_INTENT_MSG, <span class="keyword">this</span>));</span><br><span class="line">    mBroadcastsScheduled = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-3-BroadcastQueue-BroadcastHandler"><a href="#2-3-BroadcastQueue-BroadcastHandler" class="headerlink" title="2.3 BroadcastQueue.BroadcastHandler"></a>2.3 BroadcastQueue.BroadcastHandler</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BroadcastHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BroadcastHandler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(looper, <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">case</span> BROADCAST_INTENT_MSG: &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(</span><br><span class="line">                        TAG_BROADCAST, <span class="string">"Received BROADCAST_INTENT_MSG"</span>);</span><br><span class="line">                <span class="comment">//【1】接收到 BROADCAST_INTENT_MSG 消息，开始分发广播！</span></span><br><span class="line">                processNextBroadcast(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">case</span> BROADCAST_TIMEOUT_MSG: &#123;</span><br><span class="line">                <span class="comment">//【2】广播处理超时</span></span><br><span class="line">                <span class="keyword">synchronized</span> (mService) &#123;</span><br><span class="line">                    broadcastTimeoutLocked(<span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">case</span> SCHEDULE_TEMP_WHITELIST_MSG: &#123;</span><br><span class="line">                <span class="comment">//【3】添加 doze 模式白名单，这个在 doze 模式篇中会讲解！！</span></span><br><span class="line">                DeviceIdleController.LocalService dic = mService.mLocalDeviceIdleController;</span><br><span class="line">                <span class="keyword">if</span> (dic != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    dic.addPowerSaveTempWhitelistAppDirect(UserHandle.getAppId(msg.arg1),</span><br><span class="line">                            msg.arg2, <span class="keyword">true</span>, (String)msg.obj);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着，调用 processNextBroadcast 方法，分发队列中的广播，分发的具体流程，我们会在 sendBroadcast 流程分析那篇博文中详细解析，这里先不看！</p>
<h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h1><h2 id="3-1-数据结构分析"><a href="#3-1-数据结构分析" class="headerlink" title="3.1 数据结构分析"></a>3.1 数据结构分析</h2><p>以上过程涉及到了一些重要的数据结构！</p>
<h3 id="3-1-1-BroadcastRecevier"><a href="#3-1-1-BroadcastRecevier" class="headerlink" title="3.1.1 BroadcastRecevier"></a>3.1.1 <strong>BroadcastRecevier</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BroadcastReceiver</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> PendingResult mPendingResult;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BroadcastReceiver 是一个抽象类，我们在开发时，需要继承 BroadcastReceiver 来实现自己的广播接收者！</p>
<h3 id="3-1-2-mStickyBroadcasts"><a href="#3-1-2-mStickyBroadcasts" class="headerlink" title="3.1.2 mStickyBroadcasts"></a>3.1.2 <strong>mStickyBroadcasts</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> SparseArray&lt;ArrayMap&lt;String, ArrayList&lt;Intent&gt;&gt;&gt; mStickyBroadcasts =</span><br><span class="line">        <span class="keyword">new</span> SparseArray&lt;ArrayMap&lt;String, ArrayList&lt;Intent&gt;&gt;&gt;();</span><br></pre></td></tr></table></figure>
<p>mStickyBroadcasts 用来保存每个设备用户下活跃的粘性广播！</p>
<p>这里来解释下粘性广播，粘性广播是可以发送给以后注册的接受者的广播，意思是<strong>系统会将前面的粘性广播保存在 AMS 中，一旦注册了能够接受对应粘性广播的 BroadcastReceiver，在注册结束后，BroadcastReceiver 会立即收到粘性广播</strong>！</p>
<p>mStickyBroadcasts 是一个稀疏数组，数组下标为设备用户ID：userId，对应的数组元素是设备用户 ID 下所有活跃的粘性广播：<code>ArrayMap&lt;String, ArrayList&lt;Intent&gt;&gt;</code>；</p>
<p><code>ArrayMap&lt;String, ArrayList&lt;Intent&gt;&gt;</code>  的 key 是粘性广播 Intent 的 action，value 是一个 ArrayList：是所有设置了同一个 action 的粘性广播 Intent；</p>
<h3 id="3-1-3-mRegisteredReceivers"><a href="#3-1-3-mRegisteredReceivers" class="headerlink" title="3.1.3 mRegisteredReceivers"></a>3.1.3 <strong>mRegisteredReceivers</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> HashMap&lt;IBinder, ReceiverList&gt; mRegisteredReceivers = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>用来保存动态注册的广播接收者，是一个 HashMap，key 是广播接收者的 IInnerReceiver 对象，value 是 ReceiverList 对象，是一个 ArrayList 集合，用来封装该广播接收者的信息！</p>
<h3 id="3-1-4-ReceiverList"><a href="#3-1-4-ReceiverList" class="headerlink" title="3.1.4 ReceiverList"></a>3.1.4 <strong>ReceiverList</strong></h3><p>ReceiverList 用于封装每一个动态创建</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiverList</span> <span class="keyword">extends</span> <span class="title">ArrayList</span>&lt;<span class="title">BroadcastFilter</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">IBinder</span>.<span class="title">DeathRecipient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ActivityManagerService owner; <span class="comment">// AMS 对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> IIntentReceiver receiver; <span class="comment">// 广播接收者的 InnerReceiver.Proxy 对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> ProcessRecord app; <span class="comment">// 注册者所在的进程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> pid; <span class="comment">// 注册者的进程 pid</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> uid; <span class="comment">// 注册者的进程 uid</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> userId; <span class="comment">// 注册者所在的设备用户 id</span></span><br><span class="line"></span><br><span class="line">    BroadcastRecord curBroadcast = <span class="keyword">null</span>; <span class="comment">// 接收者当前正在处理的广播</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> linkedToDeath = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    String stringName;</span><br><span class="line">    </span><br><span class="line">    ReceiverList(ActivityManagerService _owner, ProcessRecord _app,</span><br><span class="line">            <span class="keyword">int</span> _pid, <span class="keyword">int</span> _uid, <span class="keyword">int</span> _userId, IIntentReceiver _receiver) &#123;</span><br><span class="line">        owner = _owner;</span><br><span class="line">        receiver = _receiver;</span><br><span class="line">        app = _app;</span><br><span class="line">        pid = _pid;</span><br><span class="line">        uid = _uid;</span><br><span class="line">        userId = _userId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ReceiverList 继承了 ArrayList<broadcastfilter>，所以它本质上就是一个 ArrayList 集合！</broadcastfilter></p>
<h3 id="3-1-5-BroadcastFilter"><a href="#3-1-5-BroadcastFilter" class="headerlink" title="3.1.5 BroadcastFilter"></a>3.1.5 <strong>BroadcastFilter</strong></h3><p>BroadcastFilter 表示的动态设定的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BroadcastFilter</span> <span class="keyword">extends</span> <span class="title">IntentFilter</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Back-pointer to the list this filter is in.</span></span><br><span class="line">    <span class="keyword">final</span> ReceiverList receiverList; <span class="comment">// BroadcastFilter 所属的 receiverList 列表；</span></span><br><span class="line">    <span class="keyword">final</span> String packageName; <span class="comment">// 注册者的包名；</span></span><br><span class="line">    <span class="keyword">final</span> String requiredPermission; <span class="comment">// 广播需要的权限</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> owningUid; <span class="comment">// 注册者的 uid</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> owningUserId; <span class="comment">// 注册者所属的 UserId</span></span><br><span class="line"></span><br><span class="line">    BroadcastFilter(IntentFilter _filter, ReceiverList _receiverList,</span><br><span class="line">            String _packageName, String _requiredPermission, <span class="keyword">int</span> _owningUid, <span class="keyword">int</span> _userId) &#123;</span><br><span class="line">        <span class="keyword">super</span>(_filter);</span><br><span class="line">        receiverList = _receiverList;</span><br><span class="line">        packageName = _packageName;</span><br><span class="line">        requiredPermission = _requiredPermission;</span><br><span class="line">        owningUid = _owningUid;</span><br><span class="line">        owningUserId = _userId;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BroadcastFilter 继承了 IntentFilter，其本身是一个 IntentFilter 扩展类，出了有 IntentFilter 的属性和方法之外，他还封装了一些其他的属性，我们可以把 BroadcastFilter 理解为注册广播是传入的 IntentFilter！</p>
<h3 id="3-1-6-mReceiverResolver"><a href="#3-1-6-mReceiverResolver" class="headerlink" title="3.1.6 mReceiverResolver"></a>3.1.6 <strong>mReceiverResolver</strong></h3><p>mReceiverResolver 是模板类 IntentResolver 的子类，用于解析 Intent 对象！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> IntentResolver&lt;BroadcastFilter, BroadcastFilter&gt; mReceiverResolver</span><br><span class="line">        = <span class="keyword">new</span> IntentResolver&lt;BroadcastFilter, BroadcastFilter&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">allowFilterResult</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            BroadcastFilter filter, List&lt;BroadcastFilter&gt; dest)</span> </span>&#123;</span><br><span class="line">        IBinder target = filter.receiverList.receiver.asBinder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = dest.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dest.get(i).receiverList.receiver.asBinder() == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> BroadcastFilter <span class="title">newResult</span><span class="params">(BroadcastFilter filter, <span class="keyword">int</span> match, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (userId == UserHandle.USER_ALL || filter.owningUserId == UserHandle.USER_ALL</span><br><span class="line">                || userId == filter.owningUserId) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.newResult(filter, match, userId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> BroadcastFilter[] newArray(<span class="keyword">int</span> size) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BroadcastFilter[size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isPackageForFilter</span><span class="params">(String packageName, BroadcastFilter filter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> packageName.equals(filter.packageName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>mReceiverResolver 持有所有动态注册的广播接受者的 BroadcastFilter 对象，也就是 IntentFilter，当广播没有设置组件信息时，会通过 mReceiverResolver 查询接收者的信息！</p>
<h3 id="3-1-7-BroadcastQueue"><a href="#3-1-7-BroadcastQueue" class="headerlink" title="3.1.7 BroadcastQueue"></a>3.1.7 <strong>BroadcastQueue</strong></h3><p>BroadcastQueue 表示的是广播队列，任何一个广播都需要被添加到这个队列才能被分发！Android 系统提供了两个队列：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BroadcastQueue mFgBroadcastQueue;</span><br><span class="line">BroadcastQueue mBgBroadcastQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> BroadcastQueue[] mBroadcastQueues = <span class="keyword">new</span> BroadcastQueue[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 广播接收者运行超时时间</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BROADCAST_FG_TIMEOUT = <span class="number">10</span>*<span class="number">1000</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BROADCAST_BG_TIMEOUT = <span class="number">60</span>*<span class="number">1000</span>;</span><br></pre></td></tr></table></figure></p>
<p>他们是在 AMS 的启动时候初始化的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mFgBroadcastQueue = <span class="keyword">new</span> BroadcastQueue(<span class="keyword">this</span>, mHandler,</span><br><span class="line">        <span class="string">"foreground"</span>, BROADCAST_FG_TIMEOUT, <span class="keyword">false</span>);</span><br><span class="line">mBgBroadcastQueue = <span class="keyword">new</span> BroadcastQueue(<span class="keyword">this</span>, mHandler,</span><br><span class="line">        <span class="string">"background"</span>, BROADCAST_BG_TIMEOUT, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">mBroadcastQueues[<span class="number">0</span>] = mFgBroadcastQueue;</span><br><span class="line">mBroadcastQueues[<span class="number">1</span>] = mBgBroadcastQueue;</span><br></pre></td></tr></table></figure></p>
<p>一个是前台队列，一个是后台队列！一个广播会根据是否设置了 Intent.FLAG_RECEIVER_FOREGROUND 标志位，会被放到 mFgBroadcastQueue 或者 mBgBroadcastQueue 队列中进行分发，我们去看看 BroadcastQueue 类的一些重要的成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BroadcastQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_BROADCAST_HISTORY = ActivityManager.isLowRamDeviceStatic() ? <span class="number">10</span> : <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_BROADCAST_SUMMARY_HISTORY</span><br><span class="line">            = ActivityManager.isLowRamDeviceStatic() ? <span class="number">25</span> : <span class="number">300</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ActivityManagerService mService;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> String mQueueName; <span class="comment">// 队列的名称</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> mTimeoutPeriod;  <span class="comment">// 广播接收者运行超时时间</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> mDelayBehindServices; <span class="comment">// 是否延迟发送广播，后台队列才会为 true！</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> ArrayList&lt;BroadcastRecord&gt; mParallelBroadcasts = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// 并行广播列表</span></span><br><span class="line">    <span class="keyword">final</span> ArrayList&lt;BroadcastRecord&gt; mOrderedBroadcasts = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// 有序广播列表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列中广播的历史记录，用于 debugging！</span></span><br><span class="line">    <span class="keyword">final</span> BroadcastRecord[] mBroadcastHistory = <span class="keyword">new</span> BroadcastRecord[MAX_BROADCAST_HISTORY];</span><br><span class="line">    <span class="keyword">int</span> mHistoryNext = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Intent[] mBroadcastSummaryHistory = <span class="keyword">new</span> Intent[MAX_BROADCAST_SUMMARY_HISTORY];</span><br><span class="line">    <span class="keyword">int</span> mSummaryHistoryNext = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用于记录所有广播的操作时间！</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span>[] mSummaryHistoryEnqueueTime = <span class="keyword">new</span>  <span class="keyword">long</span>[MAX_BROADCAST_SUMMARY_HISTORY];</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span>[] mSummaryHistoryDispatchTime = <span class="keyword">new</span>  <span class="keyword">long</span>[MAX_BROADCAST_SUMMARY_HISTORY];</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span>[] mSummaryHistoryFinishTime = <span class="keyword">new</span>  <span class="keyword">long</span>[MAX_BROADCAST_SUMMARY_HISTORY];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> mBroadcastsScheduled = <span class="keyword">false</span>; <span class="comment">// 分发广播时（BROADCAST_INTENT_MSG），该变量会被置为 true！</span></span><br><span class="line">    <span class="keyword">boolean</span> mPendingBroadcastTimeoutMessage; <span class="comment">// 广播处理超时（BROADCAST_TIMEOUT_MSG），该变量会被置为 true！</span></span><br><span class="line"></span><br><span class="line">    BroadcastRecord mPendingBroadcast = <span class="keyword">null</span>; <span class="comment">// 等待目标进程启动的挂起广播</span></span><br><span class="line">    <span class="keyword">int</span> mPendingBroadcastRecvIndex; <span class="comment">// 等待目标进程启动的挂起广播的目标接收者的下标</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> BroadcastHandler mHandler; <span class="comment">// 用于在系统进程中处理发送广播和广播超时的操作！</span></span><br><span class="line"></span><br><span class="line">    BroadcastQueue(ActivityManagerService service, Handler handler,</span><br><span class="line">            String name, <span class="keyword">long</span> timeoutPeriod, <span class="keyword">boolean</span> allowDelayBehindServices) &#123;</span><br><span class="line">        mService = service;</span><br><span class="line">        mHandler = <span class="keyword">new</span> BroadcastHandler(handler.getLooper());</span><br><span class="line">        mQueueName = name;</span><br><span class="line">        mTimeoutPeriod = timeoutPeriod;</span><br><span class="line">        mDelayBehindServices = allowDelayBehindServices;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ... ... ... ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BroadcastQueue 里面还有很多的方法，用于处理广播的分发，超时等等，这个我们后面再看！！</p>
<h3 id="3-1-8-BroadcastRecord"><a href="#3-1-8-BroadcastRecord" class="headerlink" title="3.1.8 BroadcastRecord"></a>3.1.8 <strong>BroadcastRecord</strong></h3><p>在应用端，广播的表现形式是一个个 Intent 对象，但是在系统进程中，AMS 会将 Intent 封装成 BroadcastRecord 对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BroadcastRecord</span> <span class="keyword">extends</span> <span class="title">Binder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Intent intent;    <span class="comment">// 广播对应的 Intent</span></span><br><span class="line">    <span class="keyword">final</span> ComponentName targetComp; <span class="comment">// Intent 设置的组件</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> ProcessRecord callerApp; <span class="comment">// 发送该广播的进程</span></span><br><span class="line">    <span class="keyword">final</span> String callerPackage; <span class="comment">// 发送该广播的 package</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> callingPid;   <span class="comment">// 发送该广播的进程 pid</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> callingUid;   <span class="comment">// 发送该广播的进程 uid</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> ordered;  <span class="comment">// 该广播是否是有序广播</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> sticky;   <span class="comment">// 该广播是否是粘性广播</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> initialSticky; <span class="comment">// initial broadcast from register to sticky?</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> userId;       <span class="comment">// 广播所属的设备用户 id</span></span><br><span class="line">    <span class="keyword">final</span> String resolvedType; <span class="comment">// the resolved data type</span></span><br><span class="line">    <span class="keyword">final</span> String[] requiredPermissions; <span class="comment">// 发送改变广播需要的权限</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> appOp;        <span class="comment">// 和该广播相关联的应用操作</span></span><br><span class="line">    <span class="keyword">final</span> BroadcastOptions options; <span class="comment">// 发送者提供广播参数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> List receivers;   <span class="comment">// 该广播的目标接收者列表，动态接收者为 BroadcastFilter，静态接收者为 ResolveInfo；</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span>[] delivery;   <span class="comment">// 该广播对于每个广播接收者的分发状态</span></span><br><span class="line">    IIntentReceiver resultTo; <span class="comment">// 用来接收发送广播的结果</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> enqueueClockTime;  <span class="comment">// 该广播加入队列的时间！</span></span><br><span class="line">    <span class="keyword">long</span> dispatchTime;      <span class="comment">// 该广播开始分发的时间（uptimeMillis）</span></span><br><span class="line">    <span class="keyword">long</span> dispatchClockTime; <span class="comment">// 该广播开始分发的时间（currentTimeMillis）</span></span><br><span class="line">    <span class="keyword">long</span> receiverTime;      <span class="comment">// 接收者接收该广播的时间，用于计算超时</span></span><br><span class="line">    <span class="keyword">long</span> finishTime;        <span class="comment">// 该广播完成分发的时间（uptimeMillis）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> resultCode;         <span class="comment">// current result code value.</span></span><br><span class="line">    String resultData;      <span class="comment">// current result data value.</span></span><br><span class="line">    Bundle resultExtras;    <span class="comment">// current result extra data values.</span></span><br><span class="line">    <span class="keyword">boolean</span> resultAbort;    <span class="comment">// current result abortBroadcast value.</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> nextReceiver;       <span class="comment">// 下一个广播的序号</span></span><br><span class="line">    IBinder receiver;       <span class="comment">// 当前接收者的 Binder 实体，用于跨进程通信</span></span><br><span class="line">    <span class="keyword">int</span> state;              <span class="comment">// 广播的状态！</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> anrCount;           <span class="comment">// ANR 的次数；</span></span><br><span class="line">    <span class="keyword">int</span> manifestCount;      <span class="comment">// 目标静态接收者的个数；</span></span><br><span class="line">    <span class="keyword">int</span> manifestSkipCount;  <span class="comment">// 跳过的静态接收者个数；</span></span><br><span class="line">    BroadcastQueue queue;   <span class="comment">// 该广播所属的队列；</span></span><br><span class="line"></span><br><span class="line">    BroadcastFilter curFilter; <span class="comment">// 目标动态接收者！</span></span><br><span class="line"></span><br><span class="line">    ProcessRecord curApp;       <span class="comment">// 接受该广播的广播接收者所在进程！</span></span><br><span class="line">    ComponentName curComponent; <span class="comment">// 接受该广播的广播接收者的组件名！</span></span><br><span class="line">    ActivityInfo curReceiver;   <span class="comment">// 接受该广播的静态广播接收者的信息对象！</span></span><br><span class="line">    </span><br><span class="line">    ... ... ... ...</span><br><span class="line">       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-2-结构关系图"><a href="#3-2-结构关系图" class="headerlink" title="3.2 结构关系图"></a>3.2 结构关系图</h2><p>结构关系图我们从 2 个方面来说明！</p>
<h3 id="3-2-1-注册者进程关系图"><a href="#3-2-1-注册者进程关系图" class="headerlink" title="3.2.1 注册者进程关系图"></a>3.2.1 注册者进程关系图</h3><p>处理广播的类是 BroadcastReceiver，InnerReceiver 用于实现注册者进程和系统进程的跨进程通信，ReceiverDispatcher 实现了二者的低耦合，用于管理二者的映射关系！</p>
<p>系统进程通过 InnerReceiver.Proxy 代理对象，通过 Binder 通信将广播传递给注册者进程的 BroadcastReceiver！performReceive 方法最终会创建一个 Args 对象，用于拉起 BroadcastReceiver 的 onReceive 方法！</p>
<h3 id="3-2-2-系统进程关系图"><a href="#3-2-2-系统进程关系图" class="headerlink" title="3.2.2 系统进程关系图"></a>3.2.2 系统进程关系图</h3><p><img src="http://static.zybuluo.com/Coolqi/4u0xiwyi1qg1dx6c55776vyb/%E5%B9%BF%E6%92%AD%E6%8E%A5%E6%94%B6%E8%80%85%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C%E7%B3%BB%E7%BB%9F%E8%BF%9B%E7%A8%8B%E5%85%B3%E7%B3%BB%E5%9B%BE.png" alt="广播接收者动态注册系统进程关系图.png-318.2kB"></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Coolqi.Li</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2016/05/01/BroadcastReceiver篇 2 - registerReceiver 动态注册流程分析/">http://yoursite.com/2016/05/01/BroadcastReceiver篇 2 - registerReceiver 动态注册流程分析/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com">Coolqi`s Blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/BroadcastReceiver广播接收者/">BroadcastReceiver广播接收者</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="/img/zfb.jpg"><div class="post-qr-code__desc">支付宝打赏</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="/img/wechat.jpg"><div class="post-qr-code__desc">微信打赏</div></div></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2016/05/04/BroadcastReceiver篇 3 - unregisterReceiver 和 TimeOut 流程分析/"><i class="fa fa-chevron-left">  </i><span>BroadcastReceiver篇 3 - unregisterReceiver 和 TimeOut 流程分析</span></a></div><div class="next-post pull-right"><a href="/2016/04/29/JobScheduler第 8 篇 - JobInfo JobStatus 和 JobParameters/"><span>JobScheduler第 8 篇 - JobInfo JobStatus 和 JobParameters</span><i class="fa fa-chevron-right"></i></a></div></nav><div class="post-adv"><a href="https://www.vultr.com/?ref=7231808"><img src="https://www.vultr.com/media/banner_1.png" width="728" height="90"></a></div></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2015 - 2018 By Coolqi.Li</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://molunerfinn.com">blog</a>!</div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.6"></script><script src="/js/fancybox.js?version=1.5.6"></script><script src="/js/sidebar.js?version=1.5.6"></script><script src="/js/copy.js?version=1.5.6"></script><script src="/js/fireworks.js?version=1.5.6"></script><script src="/js/transition.js?version=1.5.6"></script><script src="/js/scroll.js?version=1.5.6"></script><script src="/js/head.js?version=1.5.6"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="/js/search/local-search.js"></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>