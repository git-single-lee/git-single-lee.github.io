<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="BroadcastReceiver篇 3 - unregisterReceiver 和 TimeOut 流程分析"><meta name="keywords" content="BroadcastReceiver广播接收者"><meta name="author" content="Coolqi.Li"><meta name="copyright" content="Coolqi.Li"><title>BroadcastReceiver篇 3 - unregisterReceiver 和 TimeOut 流程分析 | Coolqi`s Blog</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://unpkg.com"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitment/style/default.min.css"><script src="https://cdn.jsdelivr.net/npm/gitment/dist/gitment.browser.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?b7acef5306e54116ad8a99e8b753a92d";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#0-综述"><span class="toc-text">0 综述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-应用进程"><span class="toc-text">1 应用进程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-ContextWrapper-unregisterReceiver"><span class="toc-text">1.1 ContextWrapper.unregisterReceiver</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-ContextImpl-unregisterReceiver"><span class="toc-text">1.2 ContextImpl.unregisterReceiver</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1-LoadedApk-forgetReceiverDispatcher"><span class="toc-text">1.2.1 LoadedApk.forgetReceiverDispatcher</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-2-ActivityManagerProxy-unregisterReceiver"><span class="toc-text">1.2.2 ActivityManagerProxy.unregisterReceiver</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-系统进程"><span class="toc-text">2 系统进程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-ActivityManagerS-unregisterReceiver"><span class="toc-text">2.1 ActivityManagerS.unregisterReceiver</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-BroadcastQueue-getMatchingOrderedReceiver"><span class="toc-text">2.1.1 BroadcastQueue.getMatchingOrderedReceiver</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-BroadcastQueue-finishReceiverLocked"><span class="toc-text">2.1.2 BroadcastQueue.finishReceiverLocked</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-3-ActivityManagerS-removeReceiverLocked"><span class="toc-text">2.1.3 ActivityManagerS.removeReceiverLocked</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-TimeOut-流程分析"><span class="toc-text">3 TimeOut 流程分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-设置超时"><span class="toc-text">3.1 设置超时</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1-BroadcastQueue-processNextBroadcast"><span class="toc-text">3.1.1 BroadcastQueue.processNextBroadcast</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2-BroadcastQueue-setBroadcastTimeoutLocked"><span class="toc-text">3.1.2 BroadcastQueue.setBroadcastTimeoutLocked</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-3-BroadcastHandler-handleMessage-BROADCAST-TIMEOUT-MSG"><span class="toc-text">3.1.3 BroadcastHandler.handleMessage[BROADCAST_TIMEOUT_MSG]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-4-BroadcastQueue-broadcastTimeoutLocked"><span class="toc-text">3.1.4 BroadcastQueue.broadcastTimeoutLocked</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-5-new-AppNotResponding"><span class="toc-text">3.1.5 new AppNotResponding</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-取消超时"><span class="toc-text">3.2 取消超时</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-BroadcastQueue-cancelBroadcastTimeoutLocked"><span class="toc-text">3.2.1 BroadcastQueue.cancelBroadcastTimeoutLocked</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-总结"><span class="toc-text">4 总结</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.jpg"></div><div class="author-info__name text-center">Coolqi.Li</div><div class="author-info__description text-center">“Hi，我是李帅奇，Android 开发工程师，熬夜星人，一个努力赚钱，积极向上的好人。微信公众号：CoolOriLans (酷奇源语)”</div><div class="follow-button"><a href="https://github.com/git-single-lee">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">90</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">23</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">30</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">coolqi 和他的朋友们</div><a class="author-info-links__name text-center" href="https://developer.android.google.cn/">AndroidDeveloper</a><a class="author-info-links__name text-center" href="http://www.android-studio.org/">AndroidStudio</a><a class="author-info-links__name text-center" href="https://www.jianshu.com/u/123a20a96441">个人简书</a><a class="author-info-links__name text-center" href="https://weibo.com/coolqiLi">个人微博</a><a class="author-info-links__name text-center" href="https://www.jianshu.com/u/fd0b722ce11f">小二哥的 Android 站</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/img/blog-bg.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Coolqi`s Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/about">About</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">BroadcastReceiver篇 3 - unregisterReceiver 和 TimeOut 流程分析</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2016-05-04</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/AndroidFramework源码分析/">AndroidFramework源码分析</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/AndroidFramework源码分析/BroadcastReceiver广播接收者/">BroadcastReceiver广播接收者</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">3.6k</span><span class="post-meta__separator">|</span><span>阅读时长: 16 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>[toc]</p>
<p>基于 Android 7.1.1 源码，分析 BroadcastReceiver <strong>动态注册</strong> 的过程，转载请说明出处！</p>
<h1 id="0-综述"><a href="#0-综述" class="headerlink" title="0 综述"></a>0 综述</h1><p>BroadcastReceiver 动态注册后，需要动态取消注册：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unregisterReceiver</span><span class="params">(BroadcastReceiver receiver)</span></span>;</span><br></pre></td></tr></table></figure>
<p>下面，我们来进入源码，分析 <code>unregisterReceiver</code> 的流程！</p>
<h1 id="1-应用进程"><a href="#1-应用进程" class="headerlink" title="1 应用进程"></a>1 应用进程</h1><p>我们先去应用进程来看下：</p>
<h2 id="1-1-ContextWrapper-unregisterReceiver"><a href="#1-1-ContextWrapper-unregisterReceiver" class="headerlink" title="1.1 ContextWrapper.unregisterReceiver"></a>1.1 ContextWrapper.unregisterReceiver</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unregisterReceiver</span><span class="params">(BroadcastReceiver receiver)</span> </span>&#123;</span><br><span class="line">    mBase.unregisterReceiver(receiver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 <code>mBase</code> 为 <code>ContextImpl</code> 实例！</p>
<h2 id="1-2-ContextImpl-unregisterReceiver"><a href="#1-2-ContextImpl-unregisterReceiver" class="headerlink" title="1.2 ContextImpl.unregisterReceiver"></a>1.2 ContextImpl.unregisterReceiver</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unregisterReceiver</span><span class="params">(BroadcastReceiver receiver)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mPackageInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//【*1.2.1】获得接收者对应的 InnerReceiver 对象！</span></span><br><span class="line">        IIntentReceiver rd = mPackageInfo.forgetReceiverDispatcher(</span><br><span class="line">                getOuterContext(), receiver);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【*1.2.2】进入系统进程，取消动态接收者的注册！</span></span><br><span class="line">            <span class="comment">// 这是同步调用！</span></span><br><span class="line">            ActivityManagerNative.getDefault().unregisterReceiver(rd);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Not supported in system context"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mPackageInfo 是 LoadedApk 实例，用来保存应用程序的加载信息，每一个进程都会有一个！</p>
<p>这里我们来分析下：</p>
<h3 id="1-2-1-LoadedApk-forgetReceiverDispatcher"><a href="#1-2-1-LoadedApk-forgetReceiverDispatcher" class="headerlink" title="1.2.1 LoadedApk.forgetReceiverDispatcher"></a>1.2.1 LoadedApk.forgetReceiverDispatcher</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IIntentReceiver <span class="title">forgetReceiverDispatcher</span><span class="params">(Context context,</span></span></span><br><span class="line"><span class="function"><span class="params">        BroadcastReceiver r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mReceivers) &#123;</span><br><span class="line">        <span class="comment">//【1】首先，获得当前设备用户下，动态注册的所有接收者的 map 表！</span></span><br><span class="line">        ArrayMap&lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&gt; map = mReceivers.get(context);</span><br><span class="line">        LoadedApk.ReceiverDispatcher rd = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//【1.2】获得该接收者对应的 ReceiverDispatcher 对象！</span></span><br><span class="line">            rd = map.get(r);</span><br><span class="line">            <span class="keyword">if</span> (rd != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//【1.3】从 map 表中移除该 rd 对象！</span></span><br><span class="line">                map.remove(r);</span><br><span class="line">                <span class="keyword">if</span> (map.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                    mReceivers.remove(context);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//【1.4】只有设置了 debug 模式，才会进入！</span></span><br><span class="line">                <span class="keyword">if</span> (r.getDebugUnregister()) &#123;</span><br><span class="line">                    ArrayMap&lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&gt; holder</span><br><span class="line">                            = mUnregisteredReceivers.get(context);</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//【1.5】会将该接触注册的接收者添加到 mUnregisteredReceivers 集合中！</span></span><br><span class="line">                    <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        holder = <span class="keyword">new</span> ArrayMap&lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&gt;();</span><br><span class="line">                        mUnregisteredReceivers.put(context, holder);</span><br><span class="line">                    &#125;</span><br><span class="line">                    RuntimeException ex = <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                            <span class="string">"Originally unregistered here:"</span>);</span><br><span class="line">                    ex.fillInStackTrace();</span><br><span class="line">                    rd.setUnregisterLocation(ex);</span><br><span class="line">                    holder.put(r, rd);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//【1.6】设置 ReceiverDispatcher 对象的 mForgotten 值为 true！</span></span><br><span class="line">                rd.mForgotten = <span class="keyword">true</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//【1.7】返回内部的 InnerReceiver 对象！</span></span><br><span class="line">                <span class="keyword">return</span> rd.getIIntentReceiver();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【2】每个动态注册的接收者都只能被 unregisteredReceivers 一次，不然会抛出异常！</span></span><br><span class="line">        ArrayMap&lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&gt; holder</span><br><span class="line">                = mUnregisteredReceivers.get(context);</span><br><span class="line">        <span class="keyword">if</span> (holder != <span class="keyword">null</span>) &#123;</span><br><span class="line">            rd = holder.get(r);</span><br><span class="line">            <span class="keyword">if</span> (rd != <span class="keyword">null</span>) &#123;</span><br><span class="line">                RuntimeException ex = rd.getUnregisterLocation();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                        <span class="string">"Unregistering Receiver "</span> + r</span><br><span class="line">                        + <span class="string">" that was already unregistered"</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (context == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unbinding Receiver "</span> + r</span><br><span class="line">                    + <span class="string">" from Context that is no longer in use: "</span> + context);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Receiver not registered: "</span> + r);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法的主要作用是：</p>
<ul>
<li>删除 ReceiverDispatcher 对象；</li>
<li>返回接收者对应的 InnerReceiver 对象；</li>
</ul>
<p>继续来看：</p>
<h3 id="1-2-2-ActivityManagerProxy-unregisterReceiver"><a href="#1-2-2-ActivityManagerProxy-unregisterReceiver" class="headerlink" title="1.2.2 ActivityManagerProxy.unregisterReceiver"></a>1.2.2 ActivityManagerProxy.unregisterReceiver</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unregisterReceiver</span><span class="params">(IIntentReceiver receiver)</span> <span class="keyword">throws</span> RemoteException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Parcel data = Parcel.obtain();</span><br><span class="line">    Parcel reply = Parcel.obtain();</span><br><span class="line">    data.writeInterfaceToken(IActivityManager.descriptor);</span><br><span class="line">    data.writeStrongBinder(receiver.asBinder());</span><br><span class="line">    <span class="comment">//【1】Binder 通信：UNREGISTER_RECEIVER_TRANSACTION</span></span><br><span class="line">    mRemote.transact(UNREGISTER_RECEIVER_TRANSACTION, data, reply, <span class="number">0</span>);</span><br><span class="line">    reply.readException();</span><br><span class="line">    data.recycle();</span><br><span class="line">    reply.recycle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面会进入系统进程，我们直接去看！</p>
<h1 id="2-系统进程"><a href="#2-系统进程" class="headerlink" title="2 系统进程"></a>2 系统进程</h1><p>首先会进入 ActivityManagerN 中去：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> UNREGISTER_RECEIVER_TRANSACTION:</span><br><span class="line">&#123;</span><br><span class="line">    data.enforceInterface(IActivityManager.descriptor);</span><br><span class="line">    IBinder b = data.readStrongBinder();</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【1】这里将客户端的 InnerReceiver 转为了服务端的 IIntentReceiver.Proxy 对象！</span></span><br><span class="line">    IIntentReceiver rec = IIntentReceiver.Stub.asInterface(b);</span><br><span class="line">    <span class="comment">//【2】继续调用 unregisterReceiver，解除注册！</span></span><br><span class="line">    unregisterReceiver(rec);</span><br><span class="line">    reply.writeNoException();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>进入 ActivityManagerS 中去！</p>
<h2 id="2-1-ActivityManagerS-unregisterReceiver"><a href="#2-1-ActivityManagerS-unregisterReceiver" class="headerlink" title="2.1 ActivityManagerS.unregisterReceiver"></a>2.1 ActivityManagerS.unregisterReceiver</h2><p>这里的 receiver 是接收者在系统进程中的 Binder 对象！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unregisterReceiver</span><span class="params">(IIntentReceiver receiver)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, <span class="string">"Unregister receiver: "</span> + receiver);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> doTrim = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">//【1】获得对应的 ReceiverList 过滤器对象！</span></span><br><span class="line">            ReceiverList rl = mRegisteredReceivers.get(receiver.asBinder());</span><br><span class="line">            <span class="keyword">if</span> (rl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//【2.1.1】判断接收者是否在处理有序发送的广播，如果在处理广播，就要立刻结束处理！</span></span><br><span class="line">                <span class="keyword">final</span> BroadcastRecord r = rl.curBroadcast;</span><br><span class="line">                <span class="keyword">if</span> (r != <span class="keyword">null</span> &amp;&amp; r == r.queue.getMatchingOrderedReceiver(r)) &#123;</span><br><span class="line">                    <span class="comment">//【×2.1.2】立刻结束广播处理！</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">boolean</span> doNext = r.queue.finishReceiverLocked(</span><br><span class="line">                            r, r.resultCode, r.resultData, r.resultExtras,</span><br><span class="line">                            r.resultAbort, <span class="keyword">false</span>);</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//【2】继续分发广播！</span></span><br><span class="line">                    <span class="keyword">if</span> (doNext) &#123;</span><br><span class="line">                        doTrim = <span class="keyword">true</span>;</span><br><span class="line">                        r.queue.processNextBroadcast(<span class="keyword">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (rl.app != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    rl.app.receivers.remove(rl);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//【×2.1.3】移除该广播接收者！</span></span><br><span class="line">                removeReceiverLocked(rl);</span><br><span class="line">                <span class="comment">//【5】如果绑定了死亡监听，就取消绑定！</span></span><br><span class="line">                <span class="keyword">if</span> (rl.linkedToDeath) &#123;</span><br><span class="line">                    rl.linkedToDeath = <span class="keyword">false</span>;</span><br><span class="line">                    rl.receiver.asBinder().unlinkToDeath(rl, <span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【6】回收资源！</span></span><br><span class="line">        <span class="keyword">if</span> (doTrim) &#123;</span><br><span class="line">            trimApplications();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码主要作用：</p>
<ul>
<li>如果当前接收者正在处理有序发送的广播，那就立刻结束处理；</li>
<li>对于有序发送的广播，继续分发广播；</li>
<li>移除当前接收者，同时解除绑定；</li>
</ul>
<p>我们继续分析细节！</p>
<h3 id="2-1-1-BroadcastQueue-getMatchingOrderedReceiver"><a href="#2-1-1-BroadcastQueue-getMatchingOrderedReceiver" class="headerlink" title="2.1.1 BroadcastQueue.getMatchingOrderedReceiver"></a>2.1.1 BroadcastQueue.getMatchingOrderedReceiver</h3><p>该方法用来判断当前是否有有序分发的广播发送给当前的广播！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BroadcastRecord <span class="title">getMatchingOrderedReceiver</span><span class="params">(IBinder receiver)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mOrderedBroadcasts.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> BroadcastRecord r = mOrderedBroadcasts.get(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (r != <span class="keyword">null</span> &amp;&amp; r.receiver == receiver) &#123;</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>判断依据很简单：当有序发送的广播指定了某个动态接收者时，其 <code>r.receiver</code> 会保存接收者对应的 <code>IIntentReceiver.Proxy</code> 对象！</p>
<h3 id="2-1-2-BroadcastQueue-finishReceiverLocked"><a href="#2-1-2-BroadcastQueue-finishReceiverLocked" class="headerlink" title="2.1.2 BroadcastQueue.finishReceiverLocked"></a>2.1.2 BroadcastQueue.finishReceiverLocked</h3><p>立刻结束广播的处理，注意：这里的 <code>waitForServices</code> 传入的是 <code>false</code>，结果表示是否 finish 完成！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">finishReceiverLocked</span><span class="params">(BroadcastRecord r, <span class="keyword">int</span> resultCode,</span></span></span><br><span class="line"><span class="function"><span class="params">        String resultData, Bundle resultExtras, <span class="keyword">boolean</span> resultAbort, <span class="keyword">boolean</span> waitForServices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> state = r.state;</span><br><span class="line">    <span class="keyword">final</span> ActivityInfo receiver = r.curReceiver;</span><br><span class="line">    <span class="comment">//【1】初始化广播的状态为 BroadcastRecord.IDLE！</span></span><br><span class="line">    r.state = BroadcastRecord.IDLE;</span><br><span class="line">    <span class="keyword">if</span> (state == BroadcastRecord.IDLE) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"finishReceiver ["</span> + mQueueName + <span class="string">"] called but state is IDLE"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【2】清空广播的当前目标接收者 Binder 实体！</span></span><br><span class="line">    r.receiver = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//【3】清空广播的 Intent 组件信息！</span></span><br><span class="line">    r.intent.setComponent(<span class="keyword">null</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【4】清空广播目标进程的 curReceiver！</span></span><br><span class="line">    <span class="keyword">if</span> (r.curApp != <span class="keyword">null</span> &amp;&amp; r.curApp.curReceiver == r) &#123;</span><br><span class="line">        r.curApp.curReceiver = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【5】清空广播目标 filter 所在的接收者处理的当前广播；</span></span><br><span class="line">    <span class="keyword">if</span> (r.curFilter != <span class="keyword">null</span>) &#123;</span><br><span class="line">        r.curFilter.receiverList.curBroadcast = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    r.curFilter = <span class="keyword">null</span>;</span><br><span class="line">    r.curReceiver = <span class="keyword">null</span>;</span><br><span class="line">    r.curApp = <span class="keyword">null</span>;</span><br><span class="line">    mPendingBroadcast = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//【6】保存了和返回的结果码等信息；</span></span><br><span class="line">    r.resultCode = resultCode;</span><br><span class="line">    r.resultData = resultData;</span><br><span class="line">    r.resultExtras = resultExtras;</span><br><span class="line">    <span class="comment">//【7】是否忽视结果；</span></span><br><span class="line">    <span class="keyword">if</span> (resultAbort &amp;&amp; (r.intent.getFlags()&amp;Intent.FLAG_RECEIVER_NO_ABORT) == <span class="number">0</span>) &#123;</span><br><span class="line">        r.resultAbort = resultAbort;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        r.resultAbort = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【8】因为 waitForServices 不进入该分支！</span></span><br><span class="line">    <span class="keyword">if</span> (waitForServices &amp;&amp; r.curComponent != <span class="keyword">null</span> &amp;&amp; r.queue.mDelayBehindServices</span><br><span class="line">            &amp;&amp; r.queue.mOrderedBroadcasts.size() &gt; <span class="number">0</span></span><br><span class="line">            &amp;&amp; r.queue.mOrderedBroadcasts.get(<span class="number">0</span>) == r) &#123;</span><br><span class="line">        ActivityInfo nextReceiver;</span><br><span class="line">        <span class="keyword">if</span> (r.nextReceiver &lt; r.receivers.size()) &#123;</span><br><span class="line">            Object obj = r.receivers.get(r.nextReceiver);</span><br><span class="line">            nextReceiver = (obj <span class="keyword">instanceof</span> ActivityInfo) ? (ActivityInfo)obj : <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nextReceiver = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (receiver == <span class="keyword">null</span> || nextReceiver == <span class="keyword">null</span></span><br><span class="line">                || receiver.applicationInfo.uid != nextReceiver.applicationInfo.uid</span><br><span class="line">                || !receiver.processName.equals(nextReceiver.processName)) &#123;</span><br><span class="line">            <span class="comment">//【8.1】延迟结束该广播的本次分发！</span></span><br><span class="line">            <span class="keyword">if</span> (mService.mServices.hasBackgroundServices(r.userId)) &#123;</span><br><span class="line">                Slog.i(TAG, <span class="string">"Delay finish: "</span> + r.curComponent.flattenToShortString());</span><br><span class="line">                r.state = BroadcastRecord.WAITING_SERVICES;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r.curComponent = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【9】判断广播的状态！</span></span><br><span class="line">    <span class="keyword">return</span> state == BroadcastRecord.APP_RECEIVE</span><br><span class="line">            || state == BroadcastRecord.CALL_DONE_RECEIVE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个过程主要有以下的目的：</p>
<ul>
<li>初始化广播的属性，为下次分发做准备；</li>
<li>然后根据广播的状态，判断是否需要继续分发；</li>
</ul>
<p>对于有序发送广播，如果其目标接收者为动态注册，那么广播的状态为 <code>BroadcastRecord.CALL_DONE_RECEIVE</code>, 这里就会返回 true!</p>
<p>这里在 sendBroadcast 流程中有讲，这里就不再细说了！</p>
<h3 id="2-1-3-ActivityManagerS-removeReceiverLocked"><a href="#2-1-3-ActivityManagerS-removeReceiverLocked" class="headerlink" title="2.1.3 ActivityManagerS.removeReceiverLocked"></a>2.1.3 ActivityManagerS.removeReceiverLocked</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeReceiverLocked</span><span class="params">(ReceiverList rl)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】从动态注册的接收者列表中移除该接收者！</span></span><br><span class="line">    mRegisteredReceivers.remove(rl.receiver.asBinder());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = rl.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">//【2】移除该接收者的 filter！</span></span><br><span class="line">        mReceiverResolver.removeFilter(rl.get(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法逻辑很简单；</p>
<ul>
<li>从 <strong>mRegisteredReceivers</strong> 中删除该动态注册的接收者；</li>
<li>从 <strong>mReceiverResolver</strong> 中删除该动态注册的接收者对应的过滤器对象；</li>
</ul>
<h1 id="3-TimeOut-流程分析"><a href="#3-TimeOut-流程分析" class="headerlink" title="3 TimeOut 流程分析"></a>3 TimeOut 流程分析</h1><p>下面我们来看看广播的超时处理！</p>
<h2 id="3-1-设置超时"><a href="#3-1-设置超时" class="headerlink" title="3.1 设置超时"></a>3.1 设置超时</h2><p>对于有序发送的广播（注意：不是有序广播），是会设置超时处理，防止一个接收者的处理超时，导致其他接收者无法接收到广播。设置超时的地方是在 <code>processNextBroadcast</code> 方法中：</p>
<h3 id="3-1-1-BroadcastQueue-processNextBroadcast"><a href="#3-1-1-BroadcastQueue-processNextBroadcast" class="headerlink" title="3.1.1 BroadcastQueue.processNextBroadcast"></a>3.1.1 BroadcastQueue.processNextBroadcast</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">r.receiverTime = SystemClock.uptimeMillis();</span><br><span class="line"><span class="keyword">if</span> (recIdx == <span class="number">0</span>) &#123;</span><br><span class="line">    r.dispatchTime = r.receiverTime;</span><br><span class="line">    r.dispatchClockTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, <span class="string">"Processing ordered broadcast ["</span></span><br><span class="line">            + mQueueName + <span class="string">"] "</span> + r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!mPendingBroadcastTimeoutMessage) &#123;</span><br><span class="line">    <span class="comment">//【1】计算超时时间点，时间为 r.receiverTime 加上 mTimeoutPeriod！</span></span><br><span class="line">    <span class="keyword">long</span> timeoutTime = r.receiverTime + mTimeoutPeriod;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,</span><br><span class="line">            <span class="string">"Submitting BROADCAST_TIMEOUT_MSG ["</span></span><br><span class="line">            + mQueueName + <span class="string">"] for "</span> + r + <span class="string">" at "</span> + timeoutTime);</span><br><span class="line">            </span><br><span class="line">    <span class="comment">//【×3.1.2】设置超时任务！</span></span><br><span class="line">    setBroadcastTimeoutLocked(timeoutTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次在有序发送广播给接收者的时候，会设置 <code>r.receiverTime</code> 的值，超时是基于这个值来计算的！</p>
<p><code>mPendingBroadcastTimeoutMessage</code> 表示当前是否有超时的消息被处理，默认是为 false！</p>
<p><code>timeoutTime</code> 是超时任务的触发时间点，系统会该时间点发送 <code>BROADCAST_TIMEOUT_MSG</code>消息，系统进程主线程会处理该消息！</p>
<p><code>mTimeoutPeriod</code> 表示超时周期，是一段时间间隔！前台队列和后台队列的 <code>mTimeoutPeriod</code> 是不一样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mFgBroadcastQueue = <span class="keyword">new</span> BroadcastQueue(<span class="keyword">this</span>, mHandler,</span><br><span class="line">        <span class="string">"foreground"</span>, BROADCAST_FG_TIMEOUT, <span class="keyword">false</span>);</span><br><span class="line">mBgBroadcastQueue = <span class="keyword">new</span> BroadcastQueue(<span class="keyword">this</span>, mHandler,</span><br><span class="line">        <span class="string">"background"</span>, BROADCAST_BG_TIMEOUT, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>
<p>对于<strong>前台队列</strong>，超时周期为 10 s：<code>static final int BROADCAST_FG_TIMEOUT = 10*1000;</code></p>
<p>对于<strong>后台队列</strong>，超时周期为 60 s：<code>static final int BROADCAST_BG_TIMEOUT = 60*1000;</code></p>
<h3 id="3-1-2-BroadcastQueue-setBroadcastTimeoutLocked"><a href="#3-1-2-BroadcastQueue-setBroadcastTimeoutLocked" class="headerlink" title="3.1.2 BroadcastQueue.setBroadcastTimeoutLocked"></a>3.1.2 BroadcastQueue.setBroadcastTimeoutLocked</h3><p>设置超时消息！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setBroadcastTimeoutLocked</span><span class="params">(<span class="keyword">long</span> timeoutTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mPendingBroadcastTimeoutMessage) &#123;</span><br><span class="line">        Message msg = mHandler.obtainMessage(BROADCAST_TIMEOUT_MSG, <span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//【1】发送消息！</span></span><br><span class="line">        mHandler.sendMessageAtTime(msg, timeoutTime);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【2】将 mPendingBroadcastTimeoutMessage 置为 true！</span></span><br><span class="line">        mPendingBroadcastTimeoutMessage = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>超时时间点到了后，会发送 <code>BROADCAST_TIMEOUT_MSG</code> 消息给系统进程主线程的 Handler 处理！</p>
<h3 id="3-1-3-BroadcastHandler-handleMessage-BROADCAST-TIMEOUT-MSG"><a href="#3-1-3-BroadcastHandler-handleMessage-BROADCAST-TIMEOUT-MSG" class="headerlink" title="3.1.3 BroadcastHandler.handleMessage[BROADCAST_TIMEOUT_MSG]"></a>3.1.3 BroadcastHandler.handleMessage[BROADCAST_TIMEOUT_MSG]</h3><p>这里只列举重点的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">     <span class="keyword">case</span> BROADCAST_TIMEOUT_MSG: &#123;</span><br><span class="line">         <span class="keyword">synchronized</span> (mService) &#123;</span><br><span class="line">             <span class="comment">//【×3.1.4】处理广播超时！</span></span><br><span class="line">             broadcastTimeoutLocked(<span class="keyword">true</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">break</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-1-4-BroadcastQueue-broadcastTimeoutLocked"><a href="#3-1-4-BroadcastQueue-broadcastTimeoutLocked" class="headerlink" title="3.1.4 BroadcastQueue.broadcastTimeoutLocked"></a>3.1.4 BroadcastQueue.broadcastTimeoutLocked</h3><p>执行超时任务的处理，此时 fromMsg 为 true，因为是通过 BroadcastHandler 触发的超时处理！！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">broadcastTimeoutLocked</span><span class="params">(<span class="keyword">boolean</span> fromMsg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fromMsg) &#123;</span><br><span class="line">        mPendingBroadcastTimeoutMessage = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【1】有序发送的广播队列为空，不处理，返回！</span></span><br><span class="line">    <span class="keyword">if</span> (mOrderedBroadcasts.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】获得超时的广播，因为每次发送的时候，都是从 mOrderedBroadcasts 的 0 index 处获取广播！</span></span><br><span class="line">    BroadcastRecord r = mOrderedBroadcasts.get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fromMsg) &#123;</span><br><span class="line">        <span class="comment">//【2.1】如果系统正在进行 odex 优化，就延迟超时任务的处理，并返回！</span></span><br><span class="line">        <span class="keyword">if</span> (mService.mDidDexOpt) &#123;</span><br><span class="line">            mService.mDidDexOpt = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【×3.1.2】这里延长了 time out 的时间！</span></span><br><span class="line">            <span class="keyword">long</span> timeoutTime = SystemClock.uptimeMillis() + mTimeoutPeriod;</span><br><span class="line">            setBroadcastTimeoutLocked(timeoutTime);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【2.2】系统进程没有准备好，返回！</span></span><br><span class="line">        <span class="keyword">if</span> (!mService.mProcessesReady) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【2.3】如果当前时间没到超时时间点，说明没有超时，再次重置任务，返回！</span></span><br><span class="line">        <span class="keyword">long</span> timeoutTime = r.receiverTime + mTimeoutPeriod;</span><br><span class="line">        <span class="keyword">if</span> (timeoutTime &gt; now) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,</span><br><span class="line">                    <span class="string">"Premature timeout ["</span></span><br><span class="line">                    + mQueueName + <span class="string">"] @ "</span> + now + <span class="string">": resetting BROADCAST_TIMEOUT_MSG for "</span></span><br><span class="line">                    + timeoutTime);</span><br><span class="line">            <span class="comment">//【×3.1.2】重新设置超时时间点！</span></span><br><span class="line">            setBroadcastTimeoutLocked(timeoutTime);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BroadcastRecord br = mOrderedBroadcasts.get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【3】判断广播的状态，如果此时是 WAITING_SERVICES，说明当前的接收者已经处理完毕，</span></span><br><span class="line">    <span class="comment">// 但是需要等待目标进程后台服务启动后，才能发送给下一个接收者！</span></span><br><span class="line">    <span class="keyword">if</span> (br.state == BroadcastRecord.WAITING_SERVICES) &#123;</span><br><span class="line"></span><br><span class="line">        Slog.i(TAG, <span class="string">"Waited long enough for: "</span> + (br.curComponent != <span class="keyword">null</span></span><br><span class="line">                ? br.curComponent.flattenToShortString() : <span class="string">"(null)"</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【3.1】如果此时触发了该广播的超时任务，就直接初始化广播属性，发送给下一个接收者，然后返回！</span></span><br><span class="line">        br.curComponent = <span class="keyword">null</span>;</span><br><span class="line">        br.state = BroadcastRecord.IDLE;</span><br><span class="line">        <span class="comment">//【3.2】继续分发！</span></span><br><span class="line">        processNextBroadcast(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Slog.w(TAG, <span class="string">"Timeout of broadcast "</span> + r + <span class="string">" - receiver="</span> + r. receiver</span><br><span class="line">            + <span class="string">", started "</span> + (now - r.receiverTime) + <span class="string">"ms ago"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【4】广播的接收时间设置为当前！</span></span><br><span class="line">    r.receiverTime = now;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【5】广播的 ANR 次数加 1；</span></span><br><span class="line">    r.anrCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Current receiver has passed its expiration date.</span></span><br><span class="line">    <span class="keyword">if</span> (r.nextReceiver &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"Timeout on receiver with nextReceiver &lt;= 0"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ProcessRecord app = <span class="keyword">null</span>;</span><br><span class="line">    String anrMessage = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【7】设置广播的当前接收者的分发状态为 BroadcastRecord.DELIVERY_TIMEOUT，表示分发超时！</span></span><br><span class="line">    Object curReceiver = r.receivers.get(r.nextReceiver-<span class="number">1</span>);</span><br><span class="line">    r.delivery[r.nextReceiver-<span class="number">1</span>] = BroadcastRecord.DELIVERY_TIMEOUT;</span><br><span class="line"></span><br><span class="line">    Slog.w(TAG, <span class="string">"Receiver during timeout: "</span> + curReceiver);</span><br><span class="line"></span><br><span class="line">    logBroadcastReceiverDiscardLocked(r);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【8】获得广播接收者所在的进程！</span></span><br><span class="line">    <span class="keyword">if</span> (curReceiver <span class="keyword">instanceof</span> BroadcastFilter) &#123;</span><br><span class="line">        BroadcastFilter bf = (BroadcastFilter)curReceiver;</span><br><span class="line">        <span class="keyword">if</span> (bf.receiverList.pid != <span class="number">0</span></span><br><span class="line">                &amp;&amp; bf.receiverList.pid != ActivityManagerService.MY_PID) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (mService.mPidsSelfLocked) &#123;</span><br><span class="line">                app = mService.mPidsSelfLocked.get(</span><br><span class="line">                        bf.receiverList.pid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        app = r.curApp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【9】广播处理超时后，会导致 ANR 的问题，这里是设置 ANR 的信息！</span></span><br><span class="line">    <span class="keyword">if</span> (app != <span class="keyword">null</span>) &#123;</span><br><span class="line">        anrMessage = <span class="string">"Broadcast of "</span> + r.intent.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【10】如果正在进程启动的广播！</span></span><br><span class="line">    <span class="keyword">if</span> (mPendingBroadcast == r) &#123;</span><br><span class="line">        mPendingBroadcast = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【11】结束当前的接收者；</span></span><br><span class="line">    finishReceiverLocked(r, r.resultCode, r.resultData,</span><br><span class="line">            r.resultExtras, r.resultAbort, <span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">//【12】将广播发送给下一个接收者；</span></span><br><span class="line">    scheduleBroadcastsLocked();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (anrMessage != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//【×3.1.5】发送 ANR 消息！</span></span><br><span class="line">        mHandler.post(<span class="keyword">new</span> AppNotResponding(app, anrMessage));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个函数的逻辑梳理如下：</p>
<ul>
<li><strong>1</strong> 如果有序列表集合 <code>mOrderedBroadcasts</code> 为空，不做任何处理，直接返回；</li>
<li><strong>2</strong> 如果系统正在进行 <code>odex</code> 优化，就延迟超时任务的处理，并返回；</li>
<li><strong>3</strong> 系统进程没有准备好，不做任何处理，直接返回；</li>
<li><strong>4</strong> 如果超时处理提前触发了，就重置超时处理，并返回；</li>
<li><strong>5</strong> 如果当前广播的状态是 <code>BroadcastRecord.WAITING_SERVICES</code>，说明当前接受者已经处理完毕了，但是该广播在等待后台服务的启动，那就初始化广播属性，直接发送给下一个接受者，返回！</li>
</ul>
<p>如果以上条件不满足，那么该广播处理超时会导致 <code>ANR</code> 的问题：</p>
<ul>
<li>设置当前接收者的分发状态为：<code>BroadcastRecord.DELIVERY_TIMEOUT</code></li>
<li>获得下一个广播接收者进程 <code>ProcessRecord</code></li>
<li>结束当前的接收者 <code>finishReceiverLocked</code>；</li>
<li>将广播发送给下一个接收者 <code>scheduleBroadcastsLocked</code>;</li>
</ul>
<p>最后，就是很关键的一步了：</p>
<ul>
<li>创建一个 <code>Runable</code>，主线程会执行该任务，抛出 <code>ANR</code> 异常！</li>
</ul>
<h3 id="3-1-5-new-AppNotResponding"><a href="#3-1-5-new-AppNotResponding" class="headerlink" title="3.1.5 new AppNotResponding"></a>3.1.5 new AppNotResponding</h3><p><code>AppNotResponding</code> 继承了 <code>Runnable</code>，我们来看看它的 <code>run</code> 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AppNotResponding</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ProcessRecord mApp;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String mAnnotation;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AppNotResponding</span><span class="params">(ProcessRecord app, String annotation)</span> </span>&#123;</span><br><span class="line">        mApp = app;</span><br><span class="line">        mAnnotation = annotation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mService.mAppErrors.appNotResponding(mApp, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>, mAnnotation);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>系统进程的主线程会执行该 <code>Runable</code>，<code>AppNotResponding</code> 会调用 <code>mAppErrors.appNotResponding</code> 方法处理接收者进程的 <code>ANR</code>!</p>
<p>这里我简单的提一下，<code>AppErrors</code> 是 <code>ActivityManagerService</code> 专门用来处理系统和应用的 <code>ANR</code> 和 <code>Crash</code> 的类！</p>
<p>后面会写一篇文章来详细分析其处理的过程，这里就不先不细说了！！</p>
<h2 id="3-2-取消超时"><a href="#3-2-取消超时" class="headerlink" title="3.2 取消超时"></a>3.2 取消超时</h2><p>当有序发送的广播及时处理后，我们会取消超时消息，我们回到 processNextBroadcast 方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">processNextBroadcast</span><span class="params">(<span class="keyword">boolean</span> fromMsg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(mService) &#123;</span><br><span class="line">        ... ... ...</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mOrderedBroadcasts.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                mService.scheduleAppGcsLocked();</span><br><span class="line">                <span class="keyword">if</span> (looped) &#123;</span><br><span class="line">                    mService.updateOomAdjLocked();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            r = mOrderedBroadcasts.get(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">boolean</span> forceReceive = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            ... ... ... ...</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//【1】当有序发送的广播发送完成或者被终止的时候，会 remove 掉该超时消息！</span></span><br><span class="line">            <span class="keyword">if</span> (r.receivers == <span class="keyword">null</span> || r.nextReceiver &gt;= numReceivers</span><br><span class="line">                    || r.resultAbort || forceReceive) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (r.resultTo != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.i(TAG_BROADCAST,</span><br><span class="line">                                <span class="string">"Finishing broadcast ["</span> + mQueueName + <span class="string">"] "</span></span><br><span class="line">                                + r.intent.getAction() + <span class="string">" app="</span> + r.callerApp);</span><br><span class="line">                        performReceiveLocked(r.callerApp, r.resultTo,</span><br><span class="line">                            <span class="keyword">new</span> Intent(r.intent), r.resultCode,</span><br><span class="line">                            r.resultData, r.resultExtras, <span class="keyword">false</span>, <span class="keyword">false</span>, r.userId);</span><br><span class="line">                        r.resultTo = <span class="keyword">null</span>;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                        r.resultTo = <span class="keyword">null</span>;</span><br><span class="line">                        Slog.w(TAG, <span class="string">"Failure ["</span></span><br><span class="line">                                + mQueueName + <span class="string">"] sending broadcast result of "</span></span><br><span class="line">                                + r.intent, e);</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//【3.2.1】移除超时消息！</span></span><br><span class="line">                cancelBroadcastTimeoutLocked();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST,</span><br><span class="line">                        <span class="string">"Finished with ordered broadcast "</span> + r);</span><br><span class="line"></span><br><span class="line">                addBroadcastToHistoryLocked(r);</span><br><span class="line">                <span class="keyword">if</span> (r.intent.getComponent() == <span class="keyword">null</span> &amp;&amp; r.intent.getPackage() == <span class="keyword">null</span></span><br><span class="line">                        &amp;&amp; (r.intent.getFlags()&amp;Intent.FLAG_RECEIVER_REGISTERED_ONLY) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// This was an implicit broadcast... let's record it for posterity.</span></span><br><span class="line">                    mService.addBroadcastStatLocked(r.intent.getAction(), r.callerPackage,</span><br><span class="line">                            r.manifestCount, r.manifestSkipCount, r.finishTime-r.dispatchTime);</span><br><span class="line">                &#125;</span><br><span class="line">                mOrderedBroadcasts.remove(<span class="number">0</span>);</span><br><span class="line">                r = <span class="keyword">null</span>;</span><br><span class="line">                looped = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (r == <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<p>这里可以看到，只有在广播发送完成或者被终止的时候，才会移除消息！</p>
<p>因为每次有序发送广播的时候，都会重新设置超时消息，具体的逻辑见：processNextBroadcast 方法！</p>
<h3 id="3-2-1-BroadcastQueue-cancelBroadcastTimeoutLocked"><a href="#3-2-1-BroadcastQueue-cancelBroadcastTimeoutLocked" class="headerlink" title="3.2.1 BroadcastQueue.cancelBroadcastTimeoutLocked"></a>3.2.1 BroadcastQueue.cancelBroadcastTimeoutLocked</h3><p>取消广播超时消息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">cancelBroadcastTimeoutLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mPendingBroadcastTimeoutMessage) &#123;</span><br><span class="line">        mHandler.removeMessages(BROADCAST_TIMEOUT_MSG, <span class="keyword">this</span>);</span><br><span class="line">        mPendingBroadcastTimeoutMessage = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h1><p>关于 <code>unregisterReceiver</code> 和 <code>TimeOut</code> 超时处理的逻辑就分析到这里！</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Coolqi.Li</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lishuaiqi.top/2016/05/04/BroadcastReceiver3-unregisterReceiverAndTimeOut/">https://lishuaiqi.top/2016/05/04/BroadcastReceiver3-unregisterReceiverAndTimeOut/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lishuaiqi.top">Coolqi`s Blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/BroadcastReceiver广播接收者/">BroadcastReceiver广播接收者</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="/img/zfb.jpg"><div class="post-qr-code__desc">支付宝打赏</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="/img/wechat.jpg"><div class="post-qr-code__desc">微信打赏</div></div></div><div class="social-share pull-right"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2016/05/08/BroadcastReceiver4-staticRegisterReceiver/"><i class="fa fa-chevron-left">  </i><span>BroadcastReceiver篇 4 - BroadcastReceiver 静态注册</span></a></div><div class="next-post pull-right"><a href="/2016/05/01/BroadcastReceiver2-dynamicRegisterReceiver/"><span>BroadcastReceiver篇 2 - registerReceiver 动态注册流程分析</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitment-container"></div><script>var gitment = new Gitment({
  id: md5(decodeURI(location.pathname)),
  owner: '',
  repo: '',
  oauth: {
    client_id: '7b4efbcd7027d15749d6',
    client_secret: '14b5d7e8580ee29f7aeca733a25c000795967448'
  }
})
gitment.render('gitment-container')</script></div></div><footer class="footer-bg" style="background-image: url(/img/blog-bg.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2015 - 2022 By Coolqi.Li</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://lishuaiqi.top/">blog</a>!</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>