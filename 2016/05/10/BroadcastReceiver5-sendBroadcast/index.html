<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="BroadcastReceiver篇 5 - sendBroadcast 流程分析"><meta name="keywords" content="BroadcastReceiver广播接收者"><meta name="author" content="Coolqi.Li"><meta name="copyright" content="Coolqi.Li"><title>BroadcastReceiver篇 5 - sendBroadcast 流程分析 | Coolqi`s Blog</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://unpkg.com"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitment/style/default.min.css"><script src="https://cdn.jsdelivr.net/npm/gitment/dist/gitment.browser.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?b7acef5306e54116ad8a99e8b753a92d";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#0-综述"><span class="toc-text">0 综述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-发送者进程"><span class="toc-text">1 发送者进程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-ContextWapper-sendBroadcast"><span class="toc-text">1.1 ContextWapper.sendBroadcast</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-ContextImpl-sendBroadcast"><span class="toc-text">1.2 ContextImpl.sendBroadcast</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-ActivityManagerProxy-broadcastIntent"><span class="toc-text">1.3 ActivityManagerProxy.broadcastIntent</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-系统进程"><span class="toc-text">2 系统进程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-AMService-broadcastIntent"><span class="toc-text">2.1 AMService.broadcastIntent</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-AMService-broadcastIntentLocked"><span class="toc-text">2.2 AMService.broadcastIntentLocked</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-AMService-collectReceiverComponents"><span class="toc-text">2.2.1 AMService.collectReceiverComponents</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-PackageManagerS-isProtectedBroadcast"><span class="toc-text">2.2.2 PackageManagerS.isProtectedBroadcast</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-广播的分发处理"><span class="toc-text">2.3 广播的分发处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-ActivityManagerS-broadcastQueueForIntent"><span class="toc-text">2.3.1 ActivityManagerS.broadcastQueueForIntent</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-new-BroadcastRecord"><span class="toc-text">2.3.2 new BroadcastRecord</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-3-BroadcastQueue-replaceXXXXX"><span class="toc-text">2.3.3 BroadcastQueue.replaceXXXXX</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-4-BroadcastQueue-enqueueOrderedBroadcastLocked"><span class="toc-text">2.3.4 BroadcastQueue.enqueueOrderedBroadcastLocked</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-5-BroadcastQueue-scheduleBroadcastsLocked"><span class="toc-text">2.3.5 BroadcastQueue.scheduleBroadcastsLocked</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-BroadcastHandler-handleMessage"><span class="toc-text">2.4 BroadcastHandler.handleMessage</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-BroadcastQueue-processNextBroadcast"><span class="toc-text">2.5 BroadcastQueue.processNextBroadcast</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-1-发送给动态注册的接收者"><span class="toc-text">2.5.1 发送给动态注册的接收者</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-1-1-BroadcastQueue-deliverToRegisteredReceiverLocked"><span class="toc-text">2.5.1.1 BroadcastQueue.deliverToRegisteredReceiverLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-1-2-BroadcastQueue-addBroadcastToHistoryLocked"><span class="toc-text">2.5.1.2 BroadcastQueue.addBroadcastToHistoryLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-1-3-BroadcastQueue-performReceiveLocked"><span class="toc-text">2.5.1.3 BroadcastQueue.performReceiveLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-1-4-ApplicationThreadP-scheduleRegisteredReceiver"><span class="toc-text">2.5.1.4 ApplicationThreadP.scheduleRegisteredReceiver</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-2-发送给静态注册的接收者"><span class="toc-text">2.5.2 发送给静态注册的接收者</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-2-1-进程已启动"><span class="toc-text">2.5.2.1 进程已启动</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-5-2-1-1-BroadcastQueue-processCurBroadcastLocked"><span class="toc-text">2.5.2.1.1 BroadcastQueue.processCurBroadcastLocked</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-5-2-1-2-ApplicationThreadP-processCurBroadcastLocked"><span class="toc-text">2.5.2.1.2 ApplicationThreadP.processCurBroadcastLocked</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-5-2-2-进程未启动"><span class="toc-text">2.5.2.2 进程未启动</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-5-2-2-1-ActivityManagerService-attachApplicationLocked"><span class="toc-text">2.5.2.2.1 ActivityManagerService.attachApplicationLocked</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#2-5-2-2-1-1-ActivityManagerS-isPendingBroadcastProcessLocked"><span class="toc-text">2.5.2.2.1.1 ActivityManagerS.isPendingBroadcastProcessLocked</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-5-2-2-1-2-ActivityManagerS-sendPendingBroadcastsLocked"><span class="toc-text">2.5.2.2.1.2 ActivityManagerS.sendPendingBroadcastsLocked</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-5-2-2-1-3-BroadcastQueue-sendPendingBroadcastsLocked"><span class="toc-text">2.5.2.2.1.3 BroadcastQueue.sendPendingBroadcastsLocked</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-接收者进程"><span class="toc-text">3 接收者进程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-动态接收者进程"><span class="toc-text">3.1 动态接收者进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1-ApplicationThread-scheduleRegisteredReceiver"><span class="toc-text">3.1.1 ApplicationThread.scheduleRegisteredReceiver</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2-InnerReceiver-performReceive"><span class="toc-text">3.1.2 InnerReceiver.performReceive</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-3-ReceiverDispatcher-performReceive"><span class="toc-text">3.1.3 ReceiverDispatcher.performReceive</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-3-1-new-Args"><span class="toc-text">3.1.3.1 new Args</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-4-Args-run"><span class="toc-text">3.1.4 Args.run</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-静态接收者进程"><span class="toc-text">3.2 静态接收者进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-ApplicationThread-scheduleReceiver"><span class="toc-text">3.2.1 ApplicationThread.scheduleReceiver</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-1-new-ReceiverData"><span class="toc-text">3.2.1.1 new ReceiverData</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-H-handleMessage"><span class="toc-text">3.2.2 H.handleMessage</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-3-ActivityThread-handleReceiver"><span class="toc-text">3.2.3 ActivityThread.handleReceiver</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-PendingResult"><span class="toc-text">3.3 PendingResult</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-1-PendingResult-finish"><span class="toc-text">3.3.1 PendingResult.finish</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-2-PendingResult-sendFinished"><span class="toc-text">3.3.2 PendingResult.sendFinished</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-系统进程"><span class="toc-text">4 系统进程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-ActivityManagerS-finishReceiver"><span class="toc-text">4.1 ActivityManagerS.finishReceiver</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-1-BroadcastQueue-getMatchingOrderedReceiver"><span class="toc-text">4.1.1 BroadcastQueue.getMatchingOrderedReceiver</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-2-BroadcastQueue-finishReceiverLocked"><span class="toc-text">4.1.2 BroadcastQueue.finishReceiverLocked</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-总结"><span class="toc-text">5 总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-广播的处理流程"><span class="toc-text">5.1 广播的处理流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-1-普通广播的处理流程"><span class="toc-text">5.1.1 普通广播的处理流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-2-有序广播的处理流程"><span class="toc-text">5.1.2 有序广播的处理流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-3-粘性广播的处理流程"><span class="toc-text">5.1.3 粘性广播的处理流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-广播的状态周期"><span class="toc-text">5.2 广播的状态周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-接收者的分发状态"><span class="toc-text">5.3 接收者的分发状态</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.jpg"></div><div class="author-info__name text-center">Coolqi.Li</div><div class="author-info__description text-center">“Hi，我是李帅奇，Android 开发工程师，熬夜星人，一个努力赚钱，积极向上的好人。”</div><div class="follow-button"><a href="https://github.com/single-li">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">88</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">21</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">26</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">；coolqi 和他的朋友们</div><a class="author-info-links__name text-center" href="https://developer.android.google.cn/">AndroidDeveloper</a><a class="author-info-links__name text-center" href="http://www.android-studio.org/">AndroidStudio</a><a class="author-info-links__name text-center" href="https://www.jianshu.com/u/123a20a96441">个人简书</a><a class="author-info-links__name text-center" href="https://weibo.com/coolqiLi">个人微博</a><a class="author-info-links__name text-center" href="https://www.jianshu.com/u/fd0b722ce11f">小二哥的 Android 站</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/img/blog-bg.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Coolqi`s Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/about">About</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">BroadcastReceiver篇 5 - sendBroadcast 流程分析</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2016-05-10</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/AndroidFramework源码分析/">AndroidFramework源码分析</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/AndroidFramework源码分析/BroadcastReceiver广播接收者/">BroadcastReceiver广播接收者</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">22.1k</span><span class="post-meta__separator">|</span><span>阅读时长: 96 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>[toc]</p>
<p>本文基于 Android 7.1.1，分析发送广播的流程，转载请说明出处！</p>
<p>写本文的目的：</p>
<ul>
<li>了解广播发送的流程；</li>
<li>了解 AMS 对广播接收者组件的管理；</li>
<li>记录自己的研究和分析；</li>
</ul>
<h1 id="0-综述"><a href="#0-综述" class="headerlink" title="0 综述"></a>0 综述</h1><p>在 Android 系统中，有如下种类的广播，他们的发送方式各不一样，我们先来简单的了解一下：</p>
<p><strong>1. 普通广播</strong></p>
<p>发送普通广播的方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sendBroadcast(...)</span><br><span class="line">sendBroadcastMultiplePermissions(...)</span><br><span class="line">sendBroadcastAsUser(...)</span><br></pre></td></tr></table></figure></p>
<p>普通广播的发送参数 serialized 为 <code>false</code>，<code>sticky</code> 也为 <code>false</code>，表示普通广播既不是粘性的，也不是无序的；</p>
<p>对于普通广播，<code>AMS</code> 会针对其接收者的类型做不同的处理：</p>
<ul>
<li>对于动态注册的广播接收者，<code>AMS</code> 会遍历对应的目标接收者集合，依次发送广播；</li>
<li>对于静态注册的广播接收者，<code>AMS</code> 在发送普通广播时，会按照有序的方式来进行分发；</li>
</ul>
<p>由此可见，对于普通广播来说，动态注册的广播接收者会先接收到广播！</p>
<p><br></p>
<p><strong>2. 有序广播</strong></p>
<p>发送有序广播的方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sendOrderedBroadcast(...)</span><br><span class="line">sendOrderedBroadcastAsUser(...)</span><br></pre></td></tr></table></figure></p>
<p>有序广播的发送参数 <code>serialized</code> 为 <code>true</code>，<code>sticky</code> 为 <code>false</code>；</p>
<p>对于有序广播，AMS 会收集能够匹配的静态注册和动态注册的广播接收者，按照优先级们，依次有序的发送广播！</p>
<p>AMS 收到上一个 <code>BroadcastReceiver</code> 处理完毕的消息返回后，才会将广播发送给下一个 <code>BroadcastReceiver</code>；其中，任意一个 <code>BroadcastReceiver</code>，都可以中止后续的广播分发流程；同时，上一个 <code>BroadcastReceiver</code> 可以将额外的信息添加到广播中。</p>
<p>对于发送给静态注册的广播接收者的普通广播，<code>AMS</code> 是将其按照发送有序广播的方式来进行发送的，因为静态注册的接收者由于其注册方式的特殊性，其所在进程可能没有被启动，所以如果采用并发的方式发送，那么系统需要在同一时间启动大量的进程，这显然不是合理的设计！</p>
<p><br></p>
<p><strong>3. 粘性广播</strong></p>
<p>发送粘性广播的方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sendStickyBroadcast(...)</span><br><span class="line">sendStickyBroadcastAsUser(...)</span><br></pre></td></tr></table></figure></p>
<p>粘性广播的发送参数 <code>serialized</code> 为 <code>false</code>，<code>sticky</code> 为 <code>true</code>；</p>
<p>粘性广播的特性是系统会保存这个广播，当系统中又新注册了一个广播接收者时，该接收者会立刻接收到这个广播，粘性广播默认属于普通广播！</p>
<p><br></p>
<p><strong>4. 粘性有序广播</strong></p>
<p>发送粘性有序广播的方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sendStickyOrderedBroadcast(...)</span><br></pre></td></tr></table></figure></p>
<p>粘性广播的发送参数 <code>serialized</code> 为 <code>true</code>，<code>sticky</code> 为 <code>true</code>；</p>
<p>粘性有序广播本质上属于有序广播，只不过其具有 “粘性”！</p>
<p><br></p>
<p>本篇文章，会主要分析下广播的发送和处理过程：</p>
<h1 id="1-发送者进程"><a href="#1-发送者进程" class="headerlink" title="1 发送者进程"></a>1 发送者进程</h1><h2 id="1-1-ContextWapper-sendBroadcast"><a href="#1-1-ContextWapper-sendBroadcast" class="headerlink" title="1.1 ContextWapper.sendBroadcast"></a>1.1 ContextWapper.sendBroadcast</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendBroadcast</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1.2】继续调用</span></span><br><span class="line">    mBase.sendBroadcast(intent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">... ... ... ...</span><br></pre></td></tr></table></figure>
<p>这里的 <code>mBase</code> 对象是 <code>ContextImpl</code> 实例，其他的方法的调用方式也是一样的！</p>
<h2 id="1-2-ContextImpl-sendBroadcast"><a href="#1-2-ContextImpl-sendBroadcast" class="headerlink" title="1.2 ContextImpl.sendBroadcast"></a>1.2 ContextImpl.sendBroadcast</h2><p>进入 <code>ContextImpl</code>，我们看看不同的 <code>send</code> 方法都做了什么操作：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendBroadcast</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">    warnIfCallingFromSystemProcess();</span><br><span class="line">    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        intent.prepareToLeaveProcess(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//【1.3】开始发送广播！</span></span><br><span class="line">        ActivityManagerNative.getDefault().broadcastIntent(</span><br><span class="line">                mMainThread.getApplicationThread(), intent, resolvedType, <span class="keyword">null</span>,</span><br><span class="line">                Activity.RESULT_OK, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, AppOpsManager.OP_NONE, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">false</span>,</span><br><span class="line">                getUserId());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，这里最终调用了 <code>AMS</code> 的 <code>broadcastIntent</code> 方法！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** &#123;<span class="doctag">@hide</span>&#125; */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getUserId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mUser.getIdentifier();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getUserId 方法用来获得进程所在的设备用户 <code>id</code>，一般我们在应用程序进程中，只能获得当前的设备用户 <code>id</code>，这个 <code>id</code> 是进程启动时获得的！</p>
<h2 id="1-3-ActivityManagerProxy-broadcastIntent"><a href="#1-3-ActivityManagerProxy-broadcastIntent" class="headerlink" title="1.3 ActivityManagerProxy.broadcastIntent"></a>1.3 ActivityManagerProxy.broadcastIntent</h2><p>我们来看一下，发送普通广播的参数传递：</p>
<ul>
<li><code>IApplicationThread caller</code>：发送者进程的 <code>ApplicationThread</code> 对象，用于跨进程通信！</li>
<li><code>Intent intent</code>：广播 <code>Intent</code></li>
<li><code>String resolvedType</code>：</li>
<li><code>IIntentReceiver resultTo</code>：广播发送后的结果反馈对象，这里传入 <code>null</code>！</li>
<li><code>int resultCode</code>：广播发送后的结果反馈码，这里传入 <code>Activity.RESULT_OK</code>！</li>
<li><code>String resultData</code>： 广播发送后的结果反馈数据，这里传入 <code>null</code>！</li>
<li><code>Bundle map</code>：传入 null；</li>
<li><code>String[] requiredPermissions</code>：广播接受者需要的权限，传入 <code>null</code> 或者指定的权限数组！</li>
<li><code>int appOp</code>：发送广播相关的应用操作，传入 <code>AppOpsManager.OP_NONE</code> 或者指定的操作！</li>
<li><code>Bundle options</code>：广播携带的参数信息，传入 <code>null</code> 或者指定的 <code>Bundle</code> 对象！</li>
<li><code>boolean serialized</code>：广播是否是序列化的，普通的广播传入 <code>false</code>；</li>
<li><code>boolean sticky</code>： 广播是否是粘性的，传入 <code>false</code>；</li>
<li><code>int userId</code>：当前的设备用户 <code>id</code>；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">broadcastIntent</span><span class="params">(IApplicationThread caller,</span></span></span><br><span class="line"><span class="function"><span class="params">        Intent intent, String resolvedType, IIntentReceiver resultTo,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> resultCode, String resultData, Bundle map,</span></span></span><br><span class="line"><span class="function"><span class="params">        String[] requiredPermissions, <span class="keyword">int</span> appOp, Bundle options, <span class="keyword">boolean</span> serialized,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> userId)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    Parcel data = Parcel.obtain();</span><br><span class="line">    Parcel reply = Parcel.obtain();</span><br><span class="line">    data.writeInterfaceToken(IActivityManager.descriptor);</span><br><span class="line">    data.writeStrongBinder(caller != <span class="keyword">null</span> ? caller.asBinder() : <span class="keyword">null</span>);</span><br><span class="line">    intent.writeToParcel(data, <span class="number">0</span>);</span><br><span class="line">    data.writeString(resolvedType);</span><br><span class="line">    data.writeStrongBinder(resultTo != <span class="keyword">null</span> ? resultTo.asBinder() : <span class="keyword">null</span>);</span><br><span class="line">    data.writeInt(resultCode);</span><br><span class="line">    data.writeString(resultData);</span><br><span class="line">    data.writeBundle(map);</span><br><span class="line">    data.writeStringArray(requiredPermissions);</span><br><span class="line">    data.writeInt(appOp);</span><br><span class="line">    data.writeBundle(options);</span><br><span class="line">    data.writeInt(serialized ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    data.writeInt(sticky ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    data.writeInt(userId);</span><br><span class="line">    <span class="comment">//【1】BROADCAST_INTENT_TRANSACTION binder 消息！</span></span><br><span class="line">    mRemote.transact(BROADCAST_INTENT_TRANSACTION, data, reply, <span class="number">0</span>);</span><br><span class="line">    reply.readException();</span><br><span class="line">    <span class="keyword">int</span> res = reply.readInt();</span><br><span class="line">    reply.recycle();</span><br><span class="line">    data.recycle();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面，就是进入系统进程！</p>
<h1 id="2-系统进程"><a href="#2-系统进程" class="headerlink" title="2 系统进程"></a>2 系统进程</h1><p>首先，进入 <code>ActivityManagerNative</code> 中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (code) &#123;</span><br><span class="line">    <span class="keyword">case</span> BROADCAST_INTENT_TRANSACTION:</span><br><span class="line">    &#123;</span><br><span class="line">        data.enforceInterface(IActivityManager.descriptor);</span><br><span class="line">        IBinder b = data.readStrongBinder();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【1】获得代理对象 ApplicationThreadProxy！</span></span><br><span class="line">        IApplicationThread app =</span><br><span class="line">            b != <span class="keyword">null</span> ? ApplicationThreadNative.asInterface(b) : <span class="keyword">null</span>;</span><br><span class="line">        Intent intent = Intent.CREATOR.createFromParcel(data);</span><br><span class="line">        String resolvedType = data.readString();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【2】显然这里的 resultTo = null;</span></span><br><span class="line">        b = data.readStrongBinder();</span><br><span class="line">        IIntentReceiver resultTo =</span><br><span class="line">            b != <span class="keyword">null</span> ? IIntentReceiver.Stub.asInterface(b) : <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【3】得到 Activity.RESULT_OK</span></span><br><span class="line">        <span class="keyword">int</span> resultCode = data.readInt();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【4】均为 null！</span></span><br><span class="line">        String resultData = data.readString();</span><br><span class="line">        Bundle resultExtras = data.readBundle();</span><br><span class="line">        String[] perms = data.readStringArray();</span><br><span class="line">        <span class="keyword">int</span> appOp = data.readInt();</span><br><span class="line">        Bundle options = data.readBundle();</span><br><span class="line">        <span class="keyword">boolean</span> serialized = data.readInt() != <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> sticky = data.readInt() != <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> userId = data.readInt();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【2.1】调用 AMS 的 broadcastIntent 方法继续发送广播！</span></span><br><span class="line">        <span class="keyword">int</span> res = broadcastIntent(app, intent, resolvedType, resultTo,</span><br><span class="line">                resultCode, resultData, resultExtras, perms, appOp,</span><br><span class="line">                options, serialized, sticky, userId);</span><br><span class="line"></span><br><span class="line">        reply.writeNoException();</span><br><span class="line">        reply.writeInt(res);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们进入 <code>AMS</code> 的方法中去看看：</p>
<h2 id="2-1-AMService-broadcastIntent"><a href="#2-1-AMService-broadcastIntent" class="headerlink" title="2.1 AMService.broadcastIntent"></a>2.1 AMService.broadcastIntent</h2><p>这里的参数和之前保持一致，不用多说！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">broadcastIntent</span><span class="params">(IApplicationThread caller,</span></span></span><br><span class="line"><span class="function"><span class="params">        Intent intent, String resolvedType, IIntentReceiver resultTo,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> resultCode, String resultData, Bundle resultExtras,</span></span></span><br><span class="line"><span class="function"><span class="params">        String[] requiredPermissions, <span class="keyword">int</span> appOp, Bundle bOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> serialized, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先判断进程是否隔离！ </span></span><br><span class="line">    enforceNotIsolatedCaller(<span class="string">"broadcastIntent"</span>);</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        intent = verifyBroadcastLocked(intent);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【1】获得发送者所在进程！</span></span><br><span class="line">        <span class="keyword">final</span> ProcessRecord callerApp = getRecordForAppLocked(caller);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> callingPid = Binder.getCallingPid();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> callingUid = Binder.getCallingUid();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【×2.2】调用 broadcastIntentLocked 方法继续处理广播的分发！</span></span><br><span class="line">        <span class="keyword">int</span> res = broadcastIntentLocked(callerApp,</span><br><span class="line">                callerApp != <span class="keyword">null</span> ? callerApp.info.packageName : <span class="keyword">null</span>,</span><br><span class="line">                intent, resolvedType, resultTo, resultCode, resultData, resultExtras,</span><br><span class="line">                requiredPermissions, appOp, bOptions, serialized, sticky,</span><br><span class="line">                callingPid, callingUid, userId);</span><br><span class="line"></span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-AMService-broadcastIntentLocked"><a href="#2-2-AMService-broadcastIntentLocked" class="headerlink" title="2.2 AMService.broadcastIntentLocked"></a>2.2 AMService.broadcastIntentLocked</h2><p>这里我们再来看看参数传递：</p>
<ul>
<li><strong><code>ProcessRecord callerApp</code></strong>：发送者所在的进程对象</li>
<li><strong><code>String callerPackage</code></strong>：发送者所在的应用包名</li>
<li><strong><code>Intent intent</code></strong>：广播 <code>Intent</code></li>
<li><strong><code>String resolvedType</code></strong>：</li>
<li><strong><code>IIntentReceiver resultTo</code></strong>： 广播发送后的结果反馈对象；</li>
<li><strong><code>int resultCode</code></strong>：广播发送后的结果反馈码，这里传入 <code>Activity.RESULT_OK</code>；</li>
<li><strong><code>String resultData</code></strong>：广播发送后的结果反馈数据，这里传入 <code>null</code>；</li>
<li><strong><code>Bundle resultExtras</code></strong>： 传入 <code>null</code>；</li>
<li><strong><code>String[] requiredPermissions</code></strong>： 广播接受者需要的权限，传入 <code>null</code> 或者指定的权限数组；</li>
<li><strong><code>int appOp</code></strong>：发送广播相关的应用操作，传入 <code>AppOpsManager.OP_NONE</code> 或者指定的操作；</li>
<li><strong><code>Bundle bOptions</code></strong>：广播携带的参数信息，传入 <code>null</code> 或者指定的 <code>Bundle</code> 对象；</li>
<li><strong><code>boolean ordered</code></strong>：广播是否是有序广播还是普通广播；</li>
<li><strong><code>boolean sticky</code></strong>：广播是否是粘性的；</li>
<li><strong><code>int callingPid</code></strong>：发送者所在进程的 <code>pid</code>；</li>
<li><strong><code>int callingUid</code></strong>：发送者所在进程的 <code>uid</code>；</li>
<li><strong><code>int userId</code></strong>：目标设备用户 <code>id</code>；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">broadcastIntentLocked</span><span class="params">(ProcessRecord callerApp,</span></span></span><br><span class="line"><span class="function"><span class="params">        String callerPackage, Intent intent, String resolvedType,</span></span></span><br><span class="line"><span class="function"><span class="params">        IIntentReceiver resultTo, <span class="keyword">int</span> resultCode, String resultData,</span></span></span><br><span class="line"><span class="function"><span class="params">        Bundle resultExtras, String[] requiredPermissions, <span class="keyword">int</span> appOp, Bundle bOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> ordered, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> callingPid, <span class="keyword">int</span> callingUid, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    intent = <span class="keyword">new</span> Intent(intent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】给 intent 添加 Intent.FLAG_EXCLUDE_STOPPED_PACKAGES 标志位！</span></span><br><span class="line">    <span class="comment">// 禁止广播发送给被强制停止的应用！</span></span><br><span class="line">    intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】如果系统还没有完成启动，并且广播没有设置 FLAG_RECEIVER_BOOT_UPGRADE 标志位！</span></span><br><span class="line">    <span class="comment">// 那就给广播 Intent 添加 Intent.FLAG_RECEIVER_REGISTERED_ONLY 标志位</span></span><br><span class="line">    <span class="comment">// 这样，该广播就不会发送给静态注册的广播接收者了，也就不会拉起其所在的进程！</span></span><br><span class="line">    <span class="keyword">if</span> (!mProcessesReady &amp;&amp; (intent.getFlags()&amp;Intent.FLAG_RECEIVER_BOOT_UPGRADE) == <span class="number">0</span>) &#123;</span><br><span class="line">        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST,</span><br><span class="line">            (sticky ? <span class="string">"Broadcast sticky: "</span>: <span class="string">"Broadcast: "</span>) + intent</span><br><span class="line">            + <span class="string">" ordered="</span> + ordered + <span class="string">" userid="</span> + userId);</span><br><span class="line">    <span class="keyword">if</span> ((resultTo != <span class="keyword">null</span>) &amp;&amp; !ordered) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"Broadcast "</span> + intent + <span class="string">" not ordered but result callback requested!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    userId = mUserController.handleIncomingUser(callingPid, callingUid, userId, <span class="keyword">true</span>,</span><br><span class="line">            ALLOW_NON_FULL, <span class="string">"broadcast"</span>, callerPackage);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【3】判断接受该广播的设备用户是否运行，如果没有运行，就停止发送广播！</span></span><br><span class="line">    <span class="keyword">if</span> (userId != UserHandle.USER_ALL &amp;&amp; !mUserController.isUserRunningLocked(userId, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((callingUid != Process.SYSTEM_UID</span><br><span class="line">                || (intent.getFlags() &amp; Intent.FLAG_RECEIVER_BOOT_UPGRADE) == <span class="number">0</span>)</span><br><span class="line">                &amp;&amp; !Intent.ACTION_SHUTDOWN.equals(intent.getAction())) &#123;</span><br><span class="line"></span><br><span class="line">            Slog.w(TAG, <span class="string">"Skipping broadcast of "</span> + intent</span><br><span class="line">                    + <span class="string">": user "</span> + userId + <span class="string">" is stopped"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> ActivityManager.BROADCAST_FAILED_USER_STOPPED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【4】如果广播带有附加参数，用于修改 doze 临时白名单，那么就要校验是否有</span></span><br><span class="line">    <span class="comment">// CHANGE_DEVICE_IDLE_TEMP_WHITELIST 权限！</span></span><br><span class="line">    BroadcastOptions brOptions = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (bOptions != <span class="keyword">null</span>) &#123;</span><br><span class="line">        brOptions = <span class="keyword">new</span> BroadcastOptions(bOptions);</span><br><span class="line">        <span class="keyword">if</span> (brOptions.getTemporaryAppWhitelistDuration() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (checkComponentPermission(</span><br><span class="line">                    android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST,</span><br><span class="line">                    Binder.getCallingPid(), Binder.getCallingUid(), -<span class="number">1</span>, <span class="keyword">true</span>)</span><br><span class="line">                    != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">                String msg = <span class="string">"Permission Denial: "</span> + intent.getAction()</span><br><span class="line">                        + <span class="string">" broadcast from "</span> + callerPackage + <span class="string">" (pid="</span> + callingPid</span><br><span class="line">                        + <span class="string">", uid="</span> + callingUid + <span class="string">")"</span></span><br><span class="line">                        + <span class="string">" requires "</span></span><br><span class="line">                        + android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST;</span><br><span class="line">                Slog.w(TAG, msg);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【5】判断该广播是否是被保护的广播，被保护的广播只能由系统发送！</span></span><br><span class="line">    <span class="keyword">final</span> String action = intent.getAction();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isProtectedBroadcast;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//【×2.2.2】判断是否是保护广播！</span></span><br><span class="line">        isProtectedBroadcast = AppGlobals.getPackageManager().isProtectedBroadcast(action);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line"></span><br><span class="line">        Slog.w(TAG, <span class="string">"Remote exception"</span>, e);</span><br><span class="line">        <span class="keyword">return</span> ActivityManager.BROADCAST_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【6】判断发送者进程是否是系统进程；</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isCallerSystem;</span><br><span class="line">    <span class="keyword">switch</span> (UserHandle.getAppId(callingUid)) &#123;</span><br><span class="line">        <span class="keyword">case</span> Process.ROOT_UID:</span><br><span class="line">        <span class="keyword">case</span> Process.SYSTEM_UID:</span><br><span class="line">        <span class="keyword">case</span> Process.PHONE_UID:</span><br><span class="line">        <span class="keyword">case</span> Process.BLUETOOTH_UID:</span><br><span class="line">        <span class="keyword">case</span> Process.NFC_UID:</span><br><span class="line">            isCallerSystem = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            isCallerSystem = (callerApp != <span class="keyword">null</span>) &amp;&amp; callerApp.persistent;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【7】安全校验，禁止非系统的 app 发送受保护的广播！</span></span><br><span class="line">    <span class="keyword">if</span> (!isCallerSystem) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isProtectedBroadcast) &#123;</span><br><span class="line">            <span class="comment">//【7.1】如果应用是非系统应用，但是广播是受保护的，那就抛出异常！</span></span><br><span class="line">            String msg = <span class="string">"Permission Denial: not allowed to send broadcast "</span></span><br><span class="line">                    + action + <span class="string">" from pid="</span></span><br><span class="line">                    + callingPid + <span class="string">", uid="</span> + callingUid;</span><br><span class="line">            Slog.w(TAG, msg);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(msg);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(action)</span><br><span class="line">                || AppWidgetManager.ACTION_APPWIDGET_UPDATE.equals(action)) &#123;</span><br><span class="line">            <span class="comment">//【7.2】如果不是受保护的广播，那么会对一些特殊广播做限制，只能发送给应用自身！</span></span><br><span class="line">            <span class="keyword">if</span> (callerPackage == <span class="keyword">null</span>) &#123;</span><br><span class="line">                String msg = <span class="string">"Permission Denial: not allowed to send broadcast "</span></span><br><span class="line">                        + action + <span class="string">" from unknown caller."</span>;</span><br><span class="line">                Slog.w(TAG, msg);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(msg);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (intent.getComponent() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果指定了组件名，那么会校验下组件所属的包名是否和发送者一样！</span></span><br><span class="line">                <span class="keyword">if</span> (!intent.getComponent().getPackageName().equals(</span><br><span class="line">                        callerPackage)) &#123;</span><br><span class="line">                    String msg = <span class="string">"Permission Denial: not allowed to send broadcast "</span></span><br><span class="line">                            + action + <span class="string">" to "</span></span><br><span class="line">                            + intent.getComponent().getPackageName() + <span class="string">" from "</span></span><br><span class="line">                            + callerPackage;</span><br><span class="line">                    Slog.w(TAG, msg);</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 设置包名，限制目标包为自身！</span></span><br><span class="line">                intent.setPackage(callerPackage);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【8】针对一些特殊 action 的广播进行处理，比如 uid 被移除，package 相关的广播，外置应用是否可用！</span></span><br><span class="line">    <span class="keyword">if</span> (action != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">            <span class="keyword">case</span> Intent.ACTION_UID_REMOVED:</span><br><span class="line">            <span class="keyword">case</span> Intent.ACTION_PACKAGE_REMOVED:</span><br><span class="line">            <span class="keyword">case</span> Intent.ACTION_PACKAGE_CHANGED:</span><br><span class="line">            <span class="keyword">case</span> Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:</span><br><span class="line">            <span class="keyword">case</span> Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:</span><br><span class="line">            <span class="keyword">case</span> Intent.ACTION_PACKAGES_SUSPENDED:</span><br><span class="line">            <span class="keyword">case</span> Intent.ACTION_PACKAGES_UNSUSPENDED:</span><br><span class="line">                <span class="comment">//【8.1】首先判断发送者是否有 android.Manifest.permission.BROADCAST_PACKAGE_REMOVED 权限！</span></span><br><span class="line">                <span class="comment">// 没有的话，抛出异常！</span></span><br><span class="line">                <span class="keyword">if</span> (checkComponentPermission(</span><br><span class="line">                        android.Manifest.permission.BROADCAST_PACKAGE_REMOVED,</span><br><span class="line">                        callingPid, callingUid, -<span class="number">1</span>, <span class="keyword">true</span>)</span><br><span class="line">                        != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">                    String msg = <span class="string">"Permission Denial: "</span> + intent.getAction()</span><br><span class="line">                            + <span class="string">" broadcast from "</span> + callerPackage + <span class="string">" (pid="</span> + callingPid</span><br><span class="line">                            + <span class="string">", uid="</span> + callingUid + <span class="string">")"</span></span><br><span class="line">                            + <span class="string">" requires "</span></span><br><span class="line">                            + android.Manifest.permission.BROADCAST_PACKAGE_REMOVED;</span><br><span class="line">                    Slog.w(TAG, msg);</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(msg);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">                    <span class="keyword">case</span> Intent.ACTION_UID_REMOVED:</span><br><span class="line">                        <span class="comment">//【8.2】如果是 Intent.ACTION_UID_REMOVED，就从 mBatteryStatsService </span></span><br><span class="line">                        <span class="comment">// 和 mAppOpsService 中移除这个 uid 的信息！</span></span><br><span class="line">                        <span class="keyword">final</span> Bundle intentExtras = intent.getExtras();</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">int</span> uid = intentExtras != <span class="keyword">null</span></span><br><span class="line">                                ? intentExtras.getInt(Intent.EXTRA_UID) : -<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">if</span> (uid &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            mBatteryStatsService.removeUid(uid);</span><br><span class="line">                            mAppOpsService.uidRemoved(uid);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:</span><br><span class="line">                        <span class="comment">//【8.3】如果是扩展应用不可用的广播，那就清楚该应用的相关数据！</span></span><br><span class="line">                        String list[] =</span><br><span class="line">                                intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (list != <span class="keyword">null</span> &amp;&amp; list.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">                                forceStopPackageLocked(list[i], -<span class="number">1</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">true</span>,</span><br><span class="line">                                        <span class="keyword">false</span>, <span class="keyword">false</span>, userId, <span class="string">"storage unmount"</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                            mRecentTasks.cleanupLocked(UserHandle.USER_ALL);</span><br><span class="line">                            sendPackageBroadcastLocked(</span><br><span class="line">                                    IApplicationThread.EXTERNAL_STORAGE_UNAVAILABLE, list,</span><br><span class="line">                                    userId);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:</span><br><span class="line">                        <span class="comment">//【8.4】如果是扩展应用可用的广播，那就只清楚最近任务中的数据！</span></span><br><span class="line">                        mRecentTasks.cleanupLocked(UserHandle.USER_ALL);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> Intent.ACTION_PACKAGE_REMOVED:</span><br><span class="line">                    <span class="keyword">case</span> Intent.ACTION_PACKAGE_CHANGED:</span><br><span class="line">                        <span class="comment">//【8.5】如果是 package 移除或改变的广播，进入这里！！</span></span><br><span class="line">                        <span class="comment">// CHANGED 广播一般是在某个组件 enabled or disabled 的时候！</span></span><br><span class="line">                        Uri data = intent.getData();</span><br><span class="line">                        String ssp;</span><br><span class="line">                        <span class="keyword">if</span> (data != <span class="keyword">null</span> &amp;&amp; (ssp=data.getSchemeSpecificPart()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="comment">//【8.5.1】判断是否是覆盖安装，卸载！</span></span><br><span class="line">                            <span class="keyword">boolean</span> removed = Intent.ACTION_PACKAGE_REMOVED.equals(action);</span><br><span class="line">                            <span class="keyword">final</span> <span class="keyword">boolean</span> replacing =</span><br><span class="line">                                    intent.getBooleanExtra(Intent.EXTRA_REPLACING, <span class="keyword">false</span>);</span><br><span class="line">                            <span class="keyword">final</span> <span class="keyword">boolean</span> killProcess =</span><br><span class="line">                                    !intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 这里的 fullUninstall 表示是否完全卸载，卸载掉覆盖安装的 apk，replacing 为 true！</span></span><br><span class="line">                            <span class="keyword">final</span> <span class="keyword">boolean</span> fullUninstall = removed &amp;&amp; !replacing;</span><br><span class="line">                            <span class="comment">//【8.5.2】应用包被移除了，进入该分支！</span></span><br><span class="line">                            <span class="keyword">if</span> (removed) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (killProcess) &#123;</span><br><span class="line">                                    <span class="comment">//【8.5.2.1】杀掉进程！</span></span><br><span class="line">                                    forceStopPackageLocked(ssp, UserHandle.getAppId(</span><br><span class="line">                                            intent.getIntExtra(Intent.EXTRA_UID, -<span class="number">1</span>)),</span><br><span class="line">                                            <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, fullUninstall, userId,</span><br><span class="line">                                            removed ? <span class="string">"pkg removed"</span> : <span class="string">"pkg changed"</span>);</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">final</span> <span class="keyword">int</span> cmd = killProcess</span><br><span class="line">                                        ? IApplicationThread.PACKAGE_REMOVED</span><br><span class="line">                                        : IApplicationThread.PACKAGE_REMOVED_DONT_KILL;</span><br><span class="line"></span><br><span class="line">                                sendPackageBroadcastLocked(cmd,</span><br><span class="line">                                        <span class="keyword">new</span> String[] &#123;ssp&#125;, userId);</span><br><span class="line">                                <span class="comment">//【8.5.2.2】如果是卸载应用的话，移除该应用的所有信息：包括 uid 信息，uri 权限信息</span></span><br><span class="line">                                <span class="comment">// 最近任务，以及电池使用信息！</span></span><br><span class="line">                                <span class="keyword">if</span> (fullUninstall) &#123;</span><br><span class="line">                                    mAppOpsService.packageRemoved(</span><br><span class="line">                                            intent.getIntExtra(Intent.EXTRA_UID, -<span class="number">1</span>), ssp);</span><br><span class="line">                                    removeUriPermissionsForPackageLocked(ssp, userId, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">                                    removeTasksByPackageNameLocked(ssp, userId);</span><br><span class="line"></span><br><span class="line">                                    <span class="keyword">if</span> (mUnsupportedDisplaySizeDialog != <span class="keyword">null</span> &amp;&amp; ssp.equals(</span><br><span class="line">                                            mUnsupportedDisplaySizeDialog.getPackageName())) &#123;</span><br><span class="line">                                        mUnsupportedDisplaySizeDialog.dismiss();</span><br><span class="line">                                        mUnsupportedDisplaySizeDialog = <span class="keyword">null</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    mCompatModePackages.handlePackageUninstalledLocked(ssp);</span><br><span class="line">                                    mBatteryStatsService.notePackageUninstalled(ssp);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="comment">//【8.5.3】应用包没有被移除，进入该分支，如果需要是杀掉进程，那就执行 kill 操作！</span></span><br><span class="line">                                <span class="keyword">if</span> (killProcess) &#123;</span><br><span class="line">                                    killPackageProcessesLocked(ssp, UserHandle.getAppId(</span><br><span class="line">                                            intent.getIntExtra(Intent.EXTRA_UID, -<span class="number">1</span>)),</span><br><span class="line">                                            userId, ProcessList.INVALID_ADJ,</span><br><span class="line">                                            <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="string">"change "</span> + ssp);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="comment">//【8.5.4】清除掉 disable 的包组件！</span></span><br><span class="line">                                cleanupDisabledPackageComponentsLocked(ssp, userId, killProcess,</span><br><span class="line">                                        intent.getStringArrayExtra(</span><br><span class="line">                                                Intent.EXTRA_CHANGED_COMPONENT_NAME_LIST));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> Intent.ACTION_PACKAGES_SUSPENDED:</span><br><span class="line">                    <span class="keyword">case</span> Intent.ACTION_PACKAGES_UNSUSPENDED:</span><br><span class="line">                        <span class="comment">//【8.6】如果是 SUSPENDED 或 UNSUSPENDED 的广播，进入这里！！</span></span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">boolean</span> suspended = Intent.ACTION_PACKAGES_SUSPENDED.equals(</span><br><span class="line">                                intent.getAction());</span><br><span class="line">                        <span class="keyword">final</span> String[] packageNames = intent.getStringArrayExtra(</span><br><span class="line">                                Intent.EXTRA_CHANGED_PACKAGE_LIST);</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">int</span> userHandle = intent.getIntExtra(</span><br><span class="line">                                Intent.EXTRA_USER_HANDLE, UserHandle.USER_NULL);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">synchronized</span>(ActivityManagerService.<span class="keyword">this</span>) &#123;</span><br><span class="line">                            mRecentTasks.onPackagesSuspendedChanged(</span><br><span class="line">                                    packageNames, suspended, userHandle);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> Intent.ACTION_PACKAGE_REPLACED:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//【8.7】如果是 REPLACED （覆盖安装的时候）的广播，进入这里！！</span></span><br><span class="line">                <span class="keyword">final</span> Uri data = intent.getData();</span><br><span class="line">                <span class="keyword">final</span> String ssp;</span><br><span class="line">                <span class="keyword">if</span> (data != <span class="keyword">null</span> &amp;&amp; (ssp = data.getSchemeSpecificPart()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">final</span> ApplicationInfo aInfo =</span><br><span class="line">                            getPackageManagerInternalLocked().getApplicationInfo(</span><br><span class="line">                                    ssp,</span><br><span class="line">                                    userId);</span><br><span class="line">                    <span class="keyword">if</span> (aInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        Slog.w(TAG, <span class="string">"Dropping ACTION_PACKAGE_REPLACED for non-existent pkg:"</span></span><br><span class="line">                                + <span class="string">" ssp="</span> + ssp + <span class="string">" data="</span> + data);</span><br><span class="line">                        <span class="keyword">return</span> ActivityManager.BROADCAST_SUCCESS;</span><br><span class="line">                    &#125;</span><br><span class="line">                    mStackSupervisor.updateActivityApplicationInfoLocked(aInfo);</span><br><span class="line">                    sendPackageBroadcastLocked(IApplicationThread.PACKAGE_REPLACED,</span><br><span class="line">                            <span class="keyword">new</span> String[] &#123;ssp&#125;, userId);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> Intent.ACTION_PACKAGE_ADDED:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//【8.8】如果是 ADDED （全新安装的时候）的广播，进入这里！！</span></span><br><span class="line">                Uri data = intent.getData();</span><br><span class="line">                String ssp;</span><br><span class="line">                <span class="keyword">if</span> (data != <span class="keyword">null</span> &amp;&amp; (ssp = data.getSchemeSpecificPart()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">boolean</span> replacing =</span><br><span class="line">                            intent.getBooleanExtra(Intent.EXTRA_REPLACING, <span class="keyword">false</span>);</span><br><span class="line">                    mCompatModePackages.handlePackageAddedLocked(ssp, replacing);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        ApplicationInfo ai = AppGlobals.getPackageManager().</span><br><span class="line">                                getApplicationInfo(ssp, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                        mBatteryStatsService.notePackageInstalled(ssp,</span><br><span class="line">                                ai != <span class="keyword">null</span> ? ai.versionCode : <span class="number">0</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> Intent.ACTION_PACKAGE_DATA_CLEARED:</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//【8.9】如果是 PACKAGE_DATA_CLEARED （清楚数据）的广播，进入这里！！</span></span><br><span class="line">                Uri data = intent.getData();</span><br><span class="line">                String ssp;</span><br><span class="line">                <span class="keyword">if</span> (data != <span class="keyword">null</span> &amp;&amp; (ssp = data.getSchemeSpecificPart()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// Hide the "unsupported display" dialog if necessary.</span></span><br><span class="line">                    <span class="keyword">if</span> (mUnsupportedDisplaySizeDialog != <span class="keyword">null</span> &amp;&amp; ssp.equals(</span><br><span class="line">                            mUnsupportedDisplaySizeDialog.getPackageName())) &#123;</span><br><span class="line">                        mUnsupportedDisplaySizeDialog.dismiss();</span><br><span class="line">                        mUnsupportedDisplaySizeDialog = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    mCompatModePackages.handlePackageDataClearedLocked(ssp);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> Intent.ACTION_TIMEZONE_CHANGED:</span><br><span class="line">                <span class="comment">// If this is the time zone changed action, queue up a message that will reset</span></span><br><span class="line">                <span class="comment">// the timezone of all currently running processes. This message will get</span></span><br><span class="line">                <span class="comment">// queued up before the broadcast happens.</span></span><br><span class="line">                mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> Intent.ACTION_TIME_CHANGED:</span><br><span class="line">                <span class="comment">// If the user set the time, let all running processes know.</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> is24Hour =</span><br><span class="line">                        intent.getBooleanExtra(Intent.EXTRA_TIME_PREF_24_HOUR_FORMAT, <span class="keyword">false</span>) ? <span class="number">1</span></span><br><span class="line">                                : <span class="number">0</span>;</span><br><span class="line">                mHandler.sendMessage(mHandler.obtainMessage(UPDATE_TIME, is24Hour, <span class="number">0</span>));</span><br><span class="line">                BatteryStatsImpl stats = mBatteryStatsService.getActiveStatistics();</span><br><span class="line">                <span class="keyword">synchronized</span> (stats) &#123;</span><br><span class="line">                    stats.noteCurrentTimeChangedLocked();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> Intent.ACTION_CLEAR_DNS_CACHE:</span><br><span class="line">                mHandler.sendEmptyMessage(CLEAR_DNS_CACHE_MSG);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> Proxy.PROXY_CHANGE_ACTION:</span><br><span class="line">                ProxyInfo proxy = intent.getParcelableExtra(Proxy.EXTRA_PROXY_INFO);</span><br><span class="line">                mHandler.sendMessage(mHandler.obtainMessage(UPDATE_HTTP_PROXY_MSG, proxy));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> android.hardware.Camera.ACTION_NEW_PICTURE:</span><br><span class="line">            <span class="keyword">case</span> android.hardware.Camera.ACTION_NEW_VIDEO:</span><br><span class="line">                <span class="comment">// These broadcasts are no longer allowed by the system, since they can</span></span><br><span class="line">                <span class="comment">// cause significant thrashing at a crictical point (using the camera).</span></span><br><span class="line">                <span class="comment">// Apps should use JobScehduler to monitor for media provider changes.</span></span><br><span class="line">                Slog.w(TAG, action + <span class="string">" no longer allowed; dropping from "</span></span><br><span class="line">                        + UserHandle.formatUid(callingUid));</span><br><span class="line">                <span class="keyword">if</span> (resultTo != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">final</span> BroadcastQueue queue = broadcastQueueForIntent(intent);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        queue.performReceiveLocked(callerApp, resultTo, intent,</span><br><span class="line">                                Activity.RESULT_CANCELED, <span class="keyword">null</span>, <span class="keyword">null</span>,</span><br><span class="line">                                <span class="keyword">false</span>, <span class="keyword">false</span>, userId);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                        Slog.w(TAG, <span class="string">"Failure ["</span></span><br><span class="line">                                + queue.mQueueName + <span class="string">"] sending broadcast result of "</span></span><br><span class="line">                                + intent, e);</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Lie; we don't want to crash the app.</span></span><br><span class="line">                <span class="keyword">return</span> ActivityManager.BROADCAST_SUCCESS;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【9】如果 sticky 为 true，表示该广播为粘性广播，那就要收集到指定的集合中！</span></span><br><span class="line">    <span class="keyword">if</span> (sticky) &#123;</span><br><span class="line">        <span class="comment">//【9.1】权限校验，发送粘性广播必须配置 android.Manifest.permission.BROADCAST_STICKY 权限！</span></span><br><span class="line">        <span class="comment">// 否则会抛出异常！</span></span><br><span class="line">        <span class="keyword">if</span> (checkPermission(android.Manifest.permission.BROADCAST_STICKY,</span><br><span class="line">                callingPid, callingUid) != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">            String msg = <span class="string">"Permission Denial: broadcastIntent() requesting a sticky broadcast from pid="</span></span><br><span class="line">                    + callingPid + <span class="string">", uid="</span> + callingUid</span><br><span class="line">                    + <span class="string">" requires "</span> + android.Manifest.permission.BROADCAST_STICKY;</span><br><span class="line"></span><br><span class="line">            Slog.w(TAG, msg);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【9.2】对于粘性广播，不能强制广播接收者应具有的权限！</span></span><br><span class="line">        <span class="keyword">if</span> (requiredPermissions != <span class="keyword">null</span> &amp;&amp; requiredPermissions.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Can't broadcast sticky intent "</span> + intent</span><br><span class="line">                    + <span class="string">" and enforce permissions "</span> + Arrays.toString(requiredPermissions));</span><br><span class="line">            <span class="keyword">return</span> ActivityManager.BROADCAST_STICKY_CANT_HAVE_PERMISSION;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【9.3】如果粘性广播设置具体的组件，抛出异常！</span></span><br><span class="line">        <span class="keyword">if</span> (intent.getComponent() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(</span><br><span class="line">                    <span class="string">"Sticky broadcasts can't target a specific component"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【9.4】如果我们的目标设备用户 id 不是 UserHandle.USER_ALL</span></span><br><span class="line">        <span class="comment">// 那就要判断是否已经有一个相同的全局粘性广播，如果有，产生冲突，抛出异常！</span></span><br><span class="line">        <span class="keyword">if</span> (userId != UserHandle.USER_ALL) &#123;</span><br><span class="line">            ArrayMap&lt;String, ArrayList&lt;Intent&gt;&gt; stickies = mStickyBroadcasts.get(</span><br><span class="line">                    UserHandle.USER_ALL);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (stickies != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ArrayList&lt;Intent&gt; list = stickies.get(intent.getAction());</span><br><span class="line">                <span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> N = list.size();</span><br><span class="line">                    <span class="keyword">int</span> i;</span><br><span class="line">                    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (intent.filterEquals(list.get(i))) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                                    <span class="string">"Sticky broadcast "</span> + intent + <span class="string">" for user "</span></span><br><span class="line">                                    + userId + <span class="string">" conflicts with existing global broadcast"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【9.5】将该粘性广播 Intent 添加到设备用户 userId 对应的广播列表中！</span></span><br><span class="line">        <span class="comment">// 如果之前已经添加过，就取代之前的相同粘性广播！</span></span><br><span class="line">        ArrayMap&lt;String, ArrayList&lt;Intent&gt;&gt; stickies = mStickyBroadcasts.get(userId);</span><br><span class="line">        <span class="keyword">if</span> (stickies == <span class="keyword">null</span>) &#123;</span><br><span class="line">            stickies = <span class="keyword">new</span> ArrayMap&lt;&gt;();</span><br><span class="line">            mStickyBroadcasts.put(userId, stickies);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Intent&gt; list = stickies.get(intent.getAction());</span><br><span class="line">        <span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;</span><br><span class="line">            list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            stickies.put(intent.getAction(), list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> stickiesCount = list.size();</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; stickiesCount; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (intent.filterEquals(list.get(i))) &#123;</span><br><span class="line">                <span class="comment">//【9.5.1】如果有重复，就取代旧的粘性广播！</span></span><br><span class="line">                list.set(i, <span class="keyword">new</span> Intent(intent));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【9.5.2】没有重复，就将这个广播添加到该粘性广播列表中！</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= stickiesCount) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> Intent(intent));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【10】根据传入的设备用户 id，获得广播的目标设备用户数组！</span></span><br><span class="line">    <span class="keyword">int</span>[] users;</span><br><span class="line">    <span class="keyword">if</span> (userId == UserHandle.USER_ALL) &#123;</span><br><span class="line">        <span class="comment">// 如果 userId 为 UserHandle.USER_ALL，说明这个广播要发送给所有的设备用户，</span></span><br><span class="line">        <span class="comment">// 就调用 getStartedUserArrayLocked 方法获得当前被启动的所有的设备用户数组！</span></span><br><span class="line">        users = mUserController.getStartedUserArrayLocked();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 userId 不为 UserHandle.USER_ALL，说明这个广播是发送给指定的设备用户的！</span></span><br><span class="line">        users = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;userId&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【11】收集能够接收和处理该广播的广播接收者！</span></span><br><span class="line">    <span class="comment">// receivers 保存静态注册的广播接受者，registeredReceivers 保存动态注册的广播接收者！</span></span><br><span class="line">    List receivers = <span class="keyword">null</span>;</span><br><span class="line">    List&lt;BroadcastFilter&gt; registeredReceivers = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断 Intent 是否设置了 Intent.FLAG_RECEIVER_REGISTERED_ONLY 标志位，如果设置了该标志位</span></span><br><span class="line">    <span class="comment">// 那么，静态注册的广播接收者无法接受这个广播！</span></span><br><span class="line">    <span class="keyword">if</span> ((intent.getFlags()&amp;Intent.FLAG_RECEIVER_REGISTERED_ONLY) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//【×2.2.1】收集系统中匹配该广播的静态注册的广播接收者！</span></span><br><span class="line">        receivers = collectReceiverComponents(intent, resolvedType, callingUid, users);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【12】如果广播 Intent 没有设置组件信息，那就从 mReceiverResolver 中进行匹配动态注册的接收者！</span></span><br><span class="line">    <span class="comment">// mReceiverResolver 用来保存动态注册的广播接收者信息，这个我们在前面讲过！</span></span><br><span class="line">    <span class="keyword">if</span> (intent.getComponent() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (userId == UserHandle.USER_ALL &amp;&amp; callingUid == Process.SHELL_UID) &#123;</span><br><span class="line">            <span class="comment">// 遍历每一个设备用户！</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; users.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mUserController.hasUserRestriction(</span><br><span class="line">                        UserManager.DISALLOW_DEBUGGING_FEATURES, users[i])) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                List&lt;BroadcastFilter&gt; registeredReceiversForUser =</span><br><span class="line">                        mReceiverResolver.queryIntent(intent,</span><br><span class="line">                                resolvedType, <span class="keyword">false</span>, users[i]);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (registeredReceivers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    registeredReceivers = registeredReceiversForUser;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (registeredReceiversForUser != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    registeredReceivers.addAll(registeredReceiversForUser);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            registeredReceivers = mReceiverResolver.queryIntent(intent,</span><br><span class="line">                    resolvedType, <span class="keyword">false</span>, userId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【13】判断 intent 是否设置了 FLAG_RECEIVER_REPLACE_PENDING 标志位，如果设置了。</span></span><br><span class="line">    <span class="comment">// 那么新的 intent 会取代前面正在处于等待状态的 intent；</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> replacePending =</span><br><span class="line">            (intent.getFlags() &amp; Intent.FLAG_RECEIVER_REPLACE_PENDING) != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, <span class="string">"Enqueing broadcast: "</span> + intent.getAction()</span><br><span class="line">            + <span class="string">" replacePending="</span> + replacePending);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> NR = registeredReceivers != <span class="keyword">null</span> ? registeredReceivers.size() : <span class="number">0</span>; <span class="comment">// 动态接受者的广播！</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【14】如果该广播是普通广播，并且存在匹配的动态注册的接收器，将广播添加到队列的并行集合中！</span></span><br><span class="line">    <span class="keyword">if</span> (!ordered &amp;&amp; NR &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isCallerSystem) &#123;</span><br><span class="line">            checkBroadcastFromSystem(intent, callerApp, callerPackage, callingUid,</span><br><span class="line">                    isProtectedBroadcast, registeredReceivers);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【×2.3.1】根据 Intent 是否设置了 Intent.FLAG_RECEIVER_FOREGROUND 标志位，选择指定的前台队列或者后台队列！</span></span><br><span class="line">        <span class="keyword">final</span> BroadcastQueue queue = broadcastQueueForIntent(intent);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【×2.3.2】创建广播对应的 BroadcastRecord 对象，发送给动态注册的广播接收者 registeredReceivers！</span></span><br><span class="line">        BroadcastRecord r = <span class="keyword">new</span> BroadcastRecord(queue, intent, callerApp,</span><br><span class="line">                callerPackage, callingPid, callingUid, resolvedType, requiredPermissions,</span><br><span class="line">                appOp, brOptions, registeredReceivers, resultTo, resultCode, resultData,</span><br><span class="line">                resultExtras, ordered, sticky, <span class="keyword">false</span>, userId);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, <span class="string">"Enqueueing parallel broadcast "</span> + r);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【×2.3.3】如果在队列的 mParallelBroadcasts 集合中能够找到相同的无序广播，就取代之前的旧的无序广播！</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> replaced = replacePending &amp;&amp; queue.replaceParallelBroadcastLocked(r);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!replaced) &#123;</span><br><span class="line">            <span class="comment">//【×2.3.4】将该广播添加到队列的并行集合 mParallelBroadcasts 中！</span></span><br><span class="line">            queue.enqueueParallelBroadcastLocked(r);</span><br><span class="line">            <span class="comment">//【×2.3.5】启动队列的广播分发任务！</span></span><br><span class="line">            queue.scheduleBroadcastsLocked();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【14.1】将动态注册的广播接收者集合 registeredReceivers 清空！</span></span><br><span class="line">        registeredReceivers = <span class="keyword">null</span>;</span><br><span class="line">        NR = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【15】将查询到的广播接收者合并到一个列表中！</span></span><br><span class="line">    <span class="keyword">int</span> ir = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果收集到静态注册的广播接收者，才会进入该分支！</span></span><br><span class="line">    <span class="comment">// 对于普通广播来说，动态注册的广播接收者在前面已经处理完了，这只剩下了静态注册的广播接收者了！</span></span><br><span class="line">    <span class="comment">// 对于有序广播来说，静态和动态的广播接收者都还没有处理！</span></span><br><span class="line">    <span class="keyword">if</span> (receivers != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//【15.1】这里对一些特殊的 action 做了一些处理，目的是防止刚安装的应用包通过静态接收这些广播实现自启动！</span></span><br><span class="line">        <span class="comment">// 首先收集这些这些广播中携带的 packageName！</span></span><br><span class="line">        String skipPackages[] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction())</span><br><span class="line">                || Intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction())</span><br><span class="line">                || Intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) &#123;</span><br><span class="line">            Uri data = intent.getData();</span><br><span class="line">            <span class="keyword">if</span> (data != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//【15.1.1】上面的广播会携带 Scheme 属性，表示包名，这里会收集到 skipPackages 中！</span></span><br><span class="line">                String pkgName = data.getSchemeSpecificPart();</span><br><span class="line">                <span class="keyword">if</span> (pkgName != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    skipPackages = <span class="keyword">new</span> String[] &#123; pkgName &#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) &#123;</span><br><span class="line">            skipPackages = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【15.2】从静态注册的广播接收者中删除属于这些 package 的广播接收者，防止应用自启动！</span></span><br><span class="line">        <span class="keyword">if</span> (skipPackages != <span class="keyword">null</span> &amp;&amp; (skipPackages.length &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String skipPackage : skipPackages) &#123;</span><br><span class="line">                <span class="keyword">if</span> (skipPackage != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> NT = receivers.size();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> it=<span class="number">0</span>; it&lt;NT; it++) &#123;</span><br><span class="line">                        ResolveInfo curt = (ResolveInfo)receivers.get(it);</span><br><span class="line">                        <span class="keyword">if</span> (curt.activityInfo.packageName.equals(skipPackage)) &#123;</span><br><span class="line">                            receivers.remove(it);</span><br><span class="line">                            it--;</span><br><span class="line">                            NT--;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> NT = receivers != <span class="keyword">null</span> ? receivers.size() : <span class="number">0</span>; <span class="comment">// 静态接收者的数量！</span></span><br><span class="line">        <span class="keyword">int</span> it = <span class="number">0</span>;</span><br><span class="line">        ResolveInfo curt = <span class="keyword">null</span>;</span><br><span class="line">        BroadcastFilter curr = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【15.3】注意，这里的 while 循环的目的是将所有的广播接收者合并到同一个集合中！</span></span><br><span class="line">        <span class="comment">// 如果是有序广播，这里会进入 while 循环，将 registeredReceivers 中的动态广播接收者，</span></span><br><span class="line">        <span class="comment">// 根据优先级合并到静态注册的广播接收者集合 receivers 中！</span></span><br><span class="line">        <span class="comment">// 对于普通广播，动态注册的广播接收者在前面已经处理完了，所以只剩下静态注册的接收者，所以不会进入循环！</span></span><br><span class="line">        <span class="keyword">while</span> (it &lt; NT &amp;&amp; nr &lt; NR) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curt == <span class="keyword">null</span>) &#123;</span><br><span class="line">                curt = (ResolveInfo)receivers.get(it);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (curr == <span class="keyword">null</span>) &#123;</span><br><span class="line">                curr = registeredReceivers.get(ir);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (curr.getPriority() &gt;= curt.priority) &#123; <span class="comment">// 按照优先级！</span></span><br><span class="line">                receivers.add(it, curr);</span><br><span class="line">                ir++;</span><br><span class="line">                curr = <span class="keyword">null</span>;</span><br><span class="line">                it++;</span><br><span class="line">                NT++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                it++;</span><br><span class="line">                curt = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (ir &lt; NR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (receivers == <span class="keyword">null</span>) &#123;</span><br><span class="line">            receivers = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【15.3】将剩余的动态接收者收集进来。当然如果没有静态接收者</span></span><br><span class="line">        <span class="comment">// 这里就只收集动态接收者；</span></span><br><span class="line">        receivers.add(registeredReceivers.get(ir));</span><br><span class="line">        ir++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【16】如果是系统调用，那么这里会做广播检查；</span></span><br><span class="line">    <span class="keyword">if</span> (isCallerSystem) &#123;</span><br><span class="line">        checkBroadcastFromSystem(intent, callerApp, callerPackage, callingUid,</span><br><span class="line">                isProtectedBroadcast, receivers);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【17】最后，将广播分发给已经合并到同一个集合中的广播接收者！</span></span><br><span class="line">    <span class="comment">// 如果没有收集到任何的广播接收者，且这个广播是一个隐式广播，那就把这个广播的状态记录下来！</span></span><br><span class="line">    <span class="keyword">if</span> ((receivers != <span class="keyword">null</span> &amp;&amp; receivers.size() &gt; <span class="number">0</span>)</span><br><span class="line">            || resultTo != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里的逻辑和上面的类似，不多说了！</span></span><br><span class="line">        <span class="comment">// 注意这里的 ordered，对于目标为静态接收者的普通广播，为 false，对于有序广播，则为 true；</span></span><br><span class="line">        <span class="comment">//【×2.3.1】选择合适的队列！</span></span><br><span class="line">        BroadcastQueue queue = broadcastQueueForIntent(intent);</span><br><span class="line">        <span class="comment">//【×2.3.2】创建广播对象！</span></span><br><span class="line">        BroadcastRecord r = <span class="keyword">new</span> BroadcastRecord(queue, intent, callerApp,</span><br><span class="line">                callerPackage, callingPid, callingUid, resolvedType,</span><br><span class="line">                requiredPermissions, appOp, brOptions, receivers, resultTo, resultCode,</span><br><span class="line">                resultData, resultExtras, ordered, sticky, <span class="keyword">false</span>, userId);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, <span class="string">"Enqueueing ordered broadcast "</span> + r</span><br><span class="line">                + <span class="string">": prev had "</span> + queue.mOrderedBroadcasts.size());</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.i(TAG_BROADCAST,</span><br><span class="line">                <span class="string">"Enqueueing broadcast "</span> + r.intent.getAction());</span><br><span class="line">        <span class="comment">//【×2.3.3】判读是否要取代已经存在的广播；</span></span><br><span class="line">        <span class="keyword">boolean</span> replaced = replacePending &amp;&amp; queue.replaceOrderedBroadcastLocked(r);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!replaced) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【×2.3.4】将广播添加到有序列表中！</span></span><br><span class="line">            queue.enqueueOrderedBroadcastLocked(r);</span><br><span class="line">            <span class="comment">//【×2.3.5】触发广播分发！</span></span><br><span class="line">            queue.scheduleBroadcastsLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (intent.getComponent() == <span class="keyword">null</span> &amp;&amp; intent.getPackage() == <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; (intent.getFlags()&amp;Intent.FLAG_RECEIVER_REGISTERED_ONLY) == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将广播的状态记录下来！</span></span><br><span class="line">            addBroadcastStatLocked(intent.getAction(), callerPackage, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ActivityManager.BROADCAST_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来总结一下，这个方法方法流程：</p>
<ul>
<li><p><strong>1.</strong> 给 intent 添加 <code>Intent.FLAG_EXCLUDE_STOPPED_PACKAGES</code> 标志位，禁止广播发送给被强制停止的应用！</p>
<ul>
<li><strong>1.1</strong> 如果系统没有启动完成，就给广播添加 <code>Intent.FLAG_RECEIVER_REGISTERED_ONLY</code> 标志位，禁止启动静态广播接收者！<br><br></li>
</ul>
</li>
<li><p><strong>2.</strong> 针对一些特殊 <code>action</code> 的广播进行处理，比如 <code>uid</code> 被移除，<code>package</code> 相关的广播等等！<br><br></p>
</li>
<li><p><strong>3.</strong> 如果是粘性广播，就需要将广播收集到 <code>mStickyBroadcasts</code> 集合中！</p>
<ul>
<li><strong>3.1</strong> 权限校验：发送粘性广播必须配置 <code>android.Manifest.permission.BROADCAST_STICKY</code> 权限！</li>
<li><strong>3.2</strong> 对于粘性广播，不能强制广播接收者应具有的权限！</li>
<li><strong>3.3</strong> 如果有相同的全局粘性广播，会产生冲突！<br><br></li>
</ul>
</li>
<li><p><strong>4.</strong> 收集能够匹配当前广播的广播接收者：</p>
<ul>
<li><strong>4.1</strong> 尝试收集能够匹配当前广播的静态注册的广播接收者（如果 <code>intent</code> 设置了 <code>Intent.FLAG_RECEIVER_REGISTERED_ONLY</code>，不收集）</li>
<li><strong>4.2</strong> 收集能够匹配当前广播动态注册的广播接收者<ul>
<li><strong>4.2.1</strong> 如果广播没有设置组件信息，那就从 <code>mReceiverResolver</code> 对象中收集动态广播接收者！<br><br>    </li>
</ul>
</li>
</ul>
</li>
<li><p><strong>5.</strong> 如果广播是普通广播，且存在匹配的动态注册的广播接收者 <code>registeredReceivers</code>！</p>
<ul>
<li><strong>5.1</strong> 创建对应的 <code>BroadcastRecord(registeredReceivers)</code> 对象，这里的 <code>BroadcastRecord.receivers</code> 都是动态注册的广播接收者！</li>
<li><strong>5.2</strong> 并添加到指定的队列（前台后台由 <code>Intent.FLAG_RECEIVER_FOREGROUND</code> 决定）的无序并行集合 <code>mParallelBroadcasts</code> 中！</li>
<li><strong>5.3</strong> 触发广播发送任务，清空 <code>registeredReceivers</code>！<br><br></li>
</ul>
</li>
<li><p><strong>6.</strong> 将收集到的静态广播接收者 <code>receivers</code> 和动态广播接收者 <code>registeredReceivers</code> 合并到同一个列表 <code>receivers</code> 中，只有在收集到静态注册的广播接收者才会合并！</p>
<ul>
<li><strong>6.1</strong> 这首先会针对一些特殊 <code>action</code> 做了处理，防止应用自启动！</li>
<li><strong>6.2</strong> 对于普通广播，到这里就只剩下静态广播接收者了，无需合并；<pre><code>对于有序广播，到这里静态广播接收者和动态广播接收者都没有处理，那就按照优先级，将二者合并到静态广播接收者 receivers 中！
</code></pre><br>   </li>
</ul>
</li>
<li><p><strong>7.</strong> 处理 <code>6</code> 中获得的合并广播接收者集合！</p>
<ul>
<li><strong>7.1</strong> 创建对应的 <code>BroadcastRecord(receivers)</code> 对象，注意这里的 <code>BroadcastRecord.receivers</code> 可能只有静态广播接收者，可能静态动态都有！</li>
<li><strong>7.2</strong> 并添加到指定的队列（前台后台由 <code>Intent.FLAG_RECEIVER_FOREGROUND</code> 决定）的无序并行集合 <code>mParallelBroadcasts</code> / 有序集合 <code>mOrderedBroadcasts</code> 中！</li>
<li><strong>7.3</strong> 触发广播发送任务；<br><br>   </li>
</ul>
</li>
</ul>
<p>接下来，我们来看看这个方法中的一些细节：</p>
<h3 id="2-2-1-AMService-collectReceiverComponents"><a href="#2-2-1-AMService-collectReceiverComponents" class="headerlink" title="2.2.1 AMService.collectReceiverComponents"></a>2.2.1 AMService.collectReceiverComponents</h3><p><code>collectReceiverComponents</code> 方法用来收集指定设备用户下的静态注册的广播接收者：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;ResolveInfo&gt; <span class="title">collectReceiverComponents</span><span class="params">(Intent intent, String resolvedType,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> callingUid, <span class="keyword">int</span>[] users)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pmFlags = STOCK_PM_FLAGS | MATCH_DEBUG_TRIAGED_MISSING;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 用来保存查询结果！</span></span><br><span class="line">    List&lt;ResolveInfo&gt; receivers = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用来保存在所有设备用户下都只有一个实例的广播接收者！</span></span><br><span class="line">        HashSet&lt;ComponentName&gt; singleUserReceivers = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> scannedFirstReceivers = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> user : users) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Skip users that have Shell restrictions, with exception of always permitted</span></span><br><span class="line">            <span class="comment">// Shell broadcasts</span></span><br><span class="line">            <span class="keyword">if</span> (callingUid == Process.SHELL_UID</span><br><span class="line">                    &amp;&amp; mUserController.hasUserRestriction(</span><br><span class="line">                            UserManager.DISALLOW_DEBUGGING_FEATURES, user)</span><br><span class="line">                    &amp;&amp; !isPermittedShellBroadcast(intent)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 查询指定设备用户下的静态广播接收者！</span></span><br><span class="line">            List&lt;ResolveInfo&gt; newReceivers = AppGlobals.getPackageManager()</span><br><span class="line">                    .queryIntentReceivers(intent, resolvedType, pmFlags, user).getList();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果不是系统用户，那就要检测该设备用户下的所有静态广播接收者，</span></span><br><span class="line">            <span class="comment">// 过滤掉设置了 systemUserOnly 属性的接收者！</span></span><br><span class="line">            <span class="keyword">if</span> (user != UserHandle.USER_SYSTEM &amp;&amp; newReceivers != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;newReceivers.size(); i++) &#123;</span><br><span class="line">                    ResolveInfo ri = newReceivers.get(i);</span><br><span class="line">                    <span class="keyword">if</span> ((ri.activityInfo.flags&amp;ActivityInfo.FLAG_SYSTEM_USER_ONLY) != <span class="number">0</span>) &#123;</span><br><span class="line">                        newReceivers.remove(i);</span><br><span class="line">                        i--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (newReceivers != <span class="keyword">null</span> &amp;&amp; newReceivers.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                newReceivers = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 保存查询结果，查询第一个设备用户下的广播接收者进入该分支！</span></span><br><span class="line">            <span class="keyword">if</span> (receivers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                receivers = newReceivers;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (newReceivers != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 后续设备用户下的查询会进入该分支！</span></span><br><span class="line">                <span class="keyword">if</span> (!scannedFirstReceivers) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 收集那些在所有的设备用户下都只有一个实例的广播接收者！</span></span><br><span class="line">                    scannedFirstReceivers = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;receivers.size(); i++) &#123;</span><br><span class="line">                        ResolveInfo ri = receivers.get(i);</span><br><span class="line">                        <span class="keyword">if</span> ((ri.activityInfo.flags&amp;ActivityInfo.FLAG_SINGLE_USER) != <span class="number">0</span>) &#123;</span><br><span class="line">                            ComponentName cn = <span class="keyword">new</span> ComponentName(</span><br><span class="line">                                    ri.activityInfo.packageName, ri.activityInfo.name);</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (singleUserReceivers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                singleUserReceivers = <span class="keyword">new</span> HashSet&lt;ComponentName&gt;();</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            singleUserReceivers.add(cn);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;newReceivers.size(); i++) &#123;</span><br><span class="line">                    ResolveInfo ri = newReceivers.get(i);</span><br><span class="line">                    <span class="keyword">if</span> ((ri.activityInfo.flags&amp;ActivityInfo.FLAG_SINGLE_USER) != <span class="number">0</span>) &#123;</span><br><span class="line">                        ComponentName cn = <span class="keyword">new</span> ComponentName(</span><br><span class="line">                                ri.activityInfo.packageName, ri.activityInfo.name);</span><br><span class="line">                        <span class="keyword">if</span> (singleUserReceivers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            singleUserReceivers = <span class="keyword">new</span> HashSet&lt;ComponentName&gt;();</span><br><span class="line">                        &#125;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 这里保证了在所有的设备用户下都只有一个实例的广播接收者只会被添加一次！</span></span><br><span class="line">                        <span class="keyword">if</span> (!singleUserReceivers.contains(cn)) &#123;</span><br><span class="line">                            singleUserReceivers.add(cn);</span><br><span class="line">                            receivers.add(ri);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        receivers.add(ri);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">        <span class="comment">// pm is in same process, this will never happen.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> receivers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里要注意：</p>
<p>如果我们在 <code>AndroidManifest.xml</code> 中给静态广播接收者设置了 <code>android:singleUser=&quot;true&quot;</code> 属性的话，那么他对应的 <code>ActivityInfo.flags</code> 会被设置 <code>ActivityInfo.FLAG_SINGLE_USER</code> 位，这样该接收者在所有的设备用户下都只会有一个实例！</p>
<p>具体的关于静态广播接收者的查询过程，请去看另一篇文章!</p>
<h3 id="2-2-2-PackageManagerS-isProtectedBroadcast"><a href="#2-2-2-PackageManagerS-isProtectedBroadcast" class="headerlink" title="2.2.2 PackageManagerS.isProtectedBroadcast"></a>2.2.2 PackageManagerS.isProtectedBroadcast</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isProtectedBroadcast</span><span class="params">(String actionName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mPackages) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mProtectedBroadcasts.contains(actionName)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (actionName != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> remove these terrible hacks</span></span><br><span class="line">            <span class="keyword">if</span> (actionName.startsWith(<span class="string">"android.net.netmon.lingerExpired"</span>)</span><br><span class="line">                    || actionName.startsWith(<span class="string">"com.android.server.sip.SipWakeupTimer"</span>)</span><br><span class="line">                    || actionName.startsWith(<span class="string">"com.android.internal.telephony.data-reconnect"</span>)</span><br><span class="line">                    || actionName.startsWith(<span class="string">"android.net.netmon.launchCaptivePortalApp"</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看看如何判断一个广播是否是受保护的广播：</p>
<ul>
<li>该广播在 <code>mProtectedBroadcasts</code> 列表中；</li>
<li>该广播是指定的一些广播；</li>
</ul>
<p>二者满足任何一个条件就行了！</p>
<p>其中 mProtectedBroadcasts 是在 PMS 里面对 protected-broadcast 类型的标签进行解析得到的，这里我们不细看！</p>
<h2 id="2-3-广播的分发处理"><a href="#2-3-广播的分发处理" class="headerlink" title="2.3 广播的分发处理"></a>2.3 广播的分发处理</h2><p>接下来，我们去看看广播队列是如何处理其内部的广播分发的，我们先回到 ActivityManagerS 中去！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">... ... ...</span><br><span class="line">            BroadcastQueue queue = broadcastQueueForIntent(intent);</span><br><span class="line"></span><br><span class="line">            BroadcastRecord r = <span class="keyword">new</span> BroadcastRecord(queue, intent, callerApp,</span><br><span class="line">                    callerPackage, callingPid, callingUid, resolvedType,</span><br><span class="line">                    requiredPermissions, appOp, brOptions, receivers, resultTo, resultCode,</span><br><span class="line">                    resultData, resultExtras, ordered, sticky, <span class="keyword">false</span>, userId);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, <span class="string">"Enqueueing ordered broadcast "</span> + r</span><br><span class="line">                    + <span class="string">": prev had "</span> + queue.mOrderedBroadcasts.size());</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.i(TAG_BROADCAST,</span><br><span class="line">                    <span class="string">"Enqueueing broadcast "</span> + r.intent.getAction());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> replaced = replacePending &amp;&amp; queue.replaceOrderedBroadcastLocked(r);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!replaced) &#123;</span><br><span class="line">                queue.enqueueOrderedBroadcastLocked(r);</span><br><span class="line">                queue.scheduleBroadcastsLocked();</span><br><span class="line">            &#125;</span><br><span class="line">... ... ...</span><br></pre></td></tr></table></figure></p>
<p>这里是分发广播的核心代码段，我们一个一个来分析！</p>
<h3 id="2-3-1-ActivityManagerS-broadcastQueueForIntent"><a href="#2-3-1-ActivityManagerS-broadcastQueueForIntent" class="headerlink" title="2.3.1 ActivityManagerS.broadcastQueueForIntent"></a>2.3.1 ActivityManagerS.broadcastQueueForIntent</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BroadcastQueue <span class="title">broadcastQueueForIntent</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isFg = (intent.getFlags() &amp; Intent.FLAG_RECEIVER_FOREGROUND) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_BROADCAST_BACKGROUND) Slog.i(TAG_BROADCAST,</span><br><span class="line">            <span class="string">"Broadcast intent "</span> + intent + <span class="string">" on "</span></span><br><span class="line">            + (isFg ? <span class="string">"foreground"</span> : <span class="string">"background"</span>) + <span class="string">" queue"</span>);</span><br><span class="line">    <span class="keyword">return</span> (isFg) ? mFgBroadcastQueue : mBgBroadcastQueue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用于判断将这个 <code>Intent</code> 插入哪个队列，插入的依据是 <code>Intent</code> 是否设置了 <code>Intent.FLAG_RECEIVER_FOREGROUND</code> 标志位！</p>
<p>这里我们可以看到 <code>ActivityManagerS</code> 通过 2 个队列来管理内部的广播：</p>
<ul>
<li><code>mFgBroadcastQueue</code>：前台广播队列；</li>
<li><code>mBgBroadcastQueue</code>：后台广播队列；</li>
</ul>
<h3 id="2-3-2-new-BroadcastRecord"><a href="#2-3-2-new-BroadcastRecord" class="headerlink" title="2.3.2 new BroadcastRecord"></a>2.3.2 new BroadcastRecord</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">BroadcastRecord(BroadcastQueue _queue,</span><br><span class="line">        Intent _intent, ProcessRecord _callerApp, String _callerPackage,</span><br><span class="line">        <span class="keyword">int</span> _callingPid, <span class="keyword">int</span> _callingUid, String _resolvedType, String[] _requiredPermissions,</span><br><span class="line">        <span class="keyword">int</span> _appOp, BroadcastOptions _options, List _receivers, IIntentReceiver _resultTo,</span><br><span class="line">        <span class="keyword">int</span> _resultCode, String _resultData, Bundle _resultExtras, <span class="keyword">boolean</span> _serialized,</span><br><span class="line">        <span class="keyword">boolean</span> _sticky, <span class="keyword">boolean</span> _initialSticky,</span><br><span class="line">        <span class="keyword">int</span> _userId) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_intent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Can't construct with a null intent"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    queue = _queue; <span class="comment">// 该广播位于的广播队列</span></span><br><span class="line">    intent = _intent; <span class="comment">// 广播的 Intent</span></span><br><span class="line">    targetComp = _intent.getComponent(); <span class="comment">// 广播的目标组件</span></span><br><span class="line">    callerApp = _callerApp; <span class="comment">// 发送者的进程对象</span></span><br><span class="line">    callerPackage = _callerPackage; <span class="comment">// 发送者的包名</span></span><br><span class="line">    callingPid = _callingPid; <span class="comment">// 发送者的 pid</span></span><br><span class="line">    callingUid = _callingUid; <span class="comment">// 发送者的 uid</span></span><br><span class="line">    resolvedType = _resolvedType;</span><br><span class="line">    requiredPermissions = _requiredPermissions; <span class="comment">// 广播接收者需要具备的权限！</span></span><br><span class="line">    appOp = _appOp;</span><br><span class="line">    options = _options;</span><br><span class="line">    receivers = _receivers; <span class="comment">// 广播接收者集合，包含静态广播接收者和动态广播接收者</span></span><br><span class="line">    delivery = <span class="keyword">new</span> <span class="keyword">int</span>[_receivers != <span class="keyword">null</span> ? _receivers.size() : <span class="number">0</span>]; <span class="comment">// 广播的分发情况！</span></span><br><span class="line"></span><br><span class="line">    resultTo = _resultTo;</span><br><span class="line">    resultCode = _resultCode;</span><br><span class="line">    resultData = _resultData;</span><br><span class="line">    resultExtras = _resultExtras;</span><br><span class="line"></span><br><span class="line">    ordered = _serialized; <span class="comment">// 该广播是有序广播吗？</span></span><br><span class="line">    sticky = _sticky; <span class="comment">// 该广播是粘性广播吗？</span></span><br><span class="line">    initialSticky = _initialSticky; </span><br><span class="line">    userId = _userId; <span class="comment">// 广播的目标设备用户</span></span><br><span class="line">    nextReceiver = <span class="number">0</span>; <span class="comment">// 下一个要接受该广播的接收者序号！</span></span><br><span class="line">    state = IDLE; <span class="comment">// 广播的状态！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些属性其实很简单！</p>
<h3 id="2-3-3-BroadcastQueue-replaceXXXXX"><a href="#2-3-3-BroadcastQueue-replaceXXXXX" class="headerlink" title="2.3.3 BroadcastQueue.replaceXXXXX"></a>2.3.3 BroadcastQueue.replaceXXXXX</h3><p>替换掉 BroadcastQueue 中 mParallelBroadcasts 已有的正在等待分发的 intent：</p>
<ul>
<li>replace ParallelBroadcast</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">replaceParallelBroadcastLocked</span><span class="params">(BroadcastRecord r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mParallelBroadcasts.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">final</span> Intent curIntent = mParallelBroadcasts.get(i).intent;</span><br><span class="line">        <span class="comment">//【1】匹配 filter，如果有匹配的 intent，替换掉！</span></span><br><span class="line">        <span class="keyword">if</span> (r.intent.filterEquals(curIntent)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,</span><br><span class="line">                    <span class="string">"***** DROPPING PARALLEL ["</span></span><br><span class="line">            + mQueueName + <span class="string">"]: "</span> + r.intent);</span><br><span class="line">            mParallelBroadcasts.set(i, r);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，如下操作：</p>
<ul>
<li><strong>replace Ordered Broadcast</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">replaceOrderedBroadcastLocked</span><span class="params">(BroadcastRecord r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mOrderedBroadcasts.size() - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">//【1】匹配 filter，如果有匹配的 intent，替换掉！</span></span><br><span class="line">        <span class="keyword">if</span> (r.intent.filterEquals(mOrderedBroadcasts.get(i).intent)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,</span><br><span class="line">                    <span class="string">"***** DROPPING ORDERED ["</span></span><br><span class="line">                    + mQueueName + <span class="string">"]: "</span> + r.intent);</span><br><span class="line">            mOrderedBroadcasts.set(i, r);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不多说了！</p>
<h3 id="2-3-4-BroadcastQueue-enqueueOrderedBroadcastLocked"><a href="#2-3-4-BroadcastQueue-enqueueOrderedBroadcastLocked" class="headerlink" title="2.3.4 BroadcastQueue.enqueueOrderedBroadcastLocked"></a>2.3.4 BroadcastQueue.enqueueOrderedBroadcastLocked</h3><p>这里是将广播添加到广播队列的并行集合或者是有序集合中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueueParallelBroadcastLocked</span><span class="params">(BroadcastRecord r)</span> </span>&#123;</span><br><span class="line">    mParallelBroadcasts.add(r);</span><br><span class="line">    r.enqueueClockTime = System.currentTimeMillis();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueueOrderedBroadcastLocked</span><span class="params">(BroadcastRecord r)</span> </span>&#123;</span><br><span class="line">    mOrderedBroadcasts.add(r);</span><br><span class="line">    r.enqueueClockTime = System.currentTimeMillis();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过前面的分析，我们可以看出：</p>
<ul>
<li>对于普通广播来说<ul>
<li>先会被添加到 <code>mParallelBroadcasts</code> 中，<code>BroadcastRecord.receivers</code> 为动态注册的广播接收者集合，采用并发的发送方式；</li>
<li>再被添加到 <code>mOrderedBroadcasts</code> 中，<code>BroadcastRecord.receivers</code> 为静态注册的广播接收者集合，采用有序的发送方式；</li>
</ul>
</li>
</ul>
<p><br></p>
<ul>
<li>对于有序广播来说：<ul>
<li>会被直接添加到 <code>mOrderedBroadcasts</code> 中， <code>BroadcastRecord.receivers</code> 为静态注册和动态注册的广播接收者集合，按照优先级排序，采用有序的发送方式；</li>
</ul>
</li>
</ul>
<p><br></p>
<h3 id="2-3-5-BroadcastQueue-scheduleBroadcastsLocked"><a href="#2-3-5-BroadcastQueue-scheduleBroadcastsLocked" class="headerlink" title="2.3.5 BroadcastQueue.scheduleBroadcastsLocked"></a>2.3.5 BroadcastQueue.scheduleBroadcastsLocked</h3><p>接下来，就是触发广播的分发调度！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleBroadcastsLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, <span class="string">"Schedule broadcasts ["</span></span><br><span class="line">            + mQueueName + <span class="string">"]: current="</span></span><br><span class="line">            + mBroadcastsScheduled);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mBroadcastsScheduled) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【×2.4】发送 `BROADCAST_INTENT_MSG` 消息！</span></span><br><span class="line">    mHandler.sendMessage(mHandler.obtainMessage(BROADCAST_INTENT_MSG, <span class="keyword">this</span>));</span><br><span class="line">    mBroadcastsScheduled = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面就进入了 BroadcastHandler 中！</p>
<h2 id="2-4-BroadcastHandler-handleMessage"><a href="#2-4-BroadcastHandler-handleMessage" class="headerlink" title="2.4 BroadcastHandler.handleMessage"></a>2.4 BroadcastHandler.handleMessage</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BroadcastHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BroadcastHandler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(looper, <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="comment">//【1】处理 BROADCAST_INTENT_MSG 消息！</span></span><br><span class="line">            <span class="keyword">case</span> BROADCAST_INTENT_MSG: &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(</span><br><span class="line">                        TAG_BROADCAST, <span class="string">"Received BROADCAST_INTENT_MSG"</span>);</span><br><span class="line">                <span class="comment">//【×2.5】进行广播分发，参数传入 true；</span></span><br><span class="line">                processNextBroadcast(<span class="keyword">true</span>);</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> BROADCAST_TIMEOUT_MSG: &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (mService) &#123;</span><br><span class="line">                    broadcastTimeoutLocked(<span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> SCHEDULE_TEMP_WHITELIST_MSG: &#123;</span><br><span class="line">                DeviceIdleController.LocalService dic = mService.mLocalDeviceIdleController;</span><br><span class="line">                <span class="keyword">if</span> (dic != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    dic.addPowerSaveTempWhitelistAppDirect(UserHandle.getAppId(msg.arg1),</span><br><span class="line">                            msg.arg2, <span class="keyword">true</span>, (String)msg.obj);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>收到 <code>BROADCAST_INTENT_MSG</code> 消息后，调用 <code>processNextBroadcast</code> 方法，执行广播分发！</p>
<h2 id="2-5-BroadcastQueue-processNextBroadcast"><a href="#2-5-BroadcastQueue-processNextBroadcast" class="headerlink" title="2.5 BroadcastQueue.processNextBroadcast"></a>2.5 BroadcastQueue.processNextBroadcast</h2><p>processNextBroadcast 方法比较长，需要我们仔细分析，参数传递：</p>
<ul>
<li><strong>boolean fromMsg</strong>：传入 true，表示触发是来自消息调用！</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">processNextBroadcast</span><span class="params">(<span class="keyword">boolean</span> fromMsg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(mService) &#123;</span><br><span class="line">        BroadcastRecord r;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, <span class="string">"processNextBroadcast ["</span></span><br><span class="line">                + mQueueName + <span class="string">"]: "</span></span><br><span class="line">                + mParallelBroadcasts.size() + <span class="string">" broadcasts, "</span></span><br><span class="line">                + mOrderedBroadcasts.size() + <span class="string">" ordered broadcasts"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【1】更新 cpu 的状态信息！</span></span><br><span class="line">        mService.updateCpuStats();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fromMsg) &#123;</span><br><span class="line">            <span class="comment">//【2】如果 fromMsg 为 true，会将 mBroadcastsScheduled 置为 false；</span></span><br><span class="line">            <span class="comment">// 这样之前又可以继续发送消息触发分发了！</span></span><br><span class="line">            mBroadcastsScheduled = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【3】立刻分发 mParallelBroadcasts 集合中的普通广播！</span></span><br><span class="line">        <span class="comment">// 根据前面的分析，普通广播会先被加入到 mParallelBroadcasts 中并且目标接收者是动态注册的广播接受者！</span></span><br><span class="line">        <span class="keyword">while</span> (mParallelBroadcasts.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            r = mParallelBroadcasts.remove(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//【3.1】更新普通广播的分发时间！</span></span><br><span class="line">            r.dispatchTime = SystemClock.uptimeMillis();</span><br><span class="line">            r.dispatchClockTime = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> N = r.receivers.size();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, <span class="string">"Processing parallel broadcast ["</span></span><br><span class="line">                    + mQueueName + <span class="string">"] "</span> + r);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">                Object target = r.receivers.get(i);</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_BROADCAST)  Slog.v(TAG_BROADCAST,</span><br><span class="line">                        <span class="string">"Delivering non-ordered on ["</span> + mQueueName + <span class="string">"] to registered "</span></span><br><span class="line">                        + target + <span class="string">": "</span> + r);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//【×2.5.1.1】将该普通广播分发给动态注册的每个接收者！</span></span><br><span class="line">                deliverToRegisteredReceiverLocked(r, (BroadcastFilter)target, <span class="keyword">false</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//【×2.5.1.2】分发成功后，将该普通广播添加到历史集合中！</span></span><br><span class="line">            addBroadcastToHistoryLocked(r);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, <span class="string">"Done with parallel broadcast ["</span></span><br><span class="line">                    + mQueueName + <span class="string">"] "</span> + r);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【4】处理正在等待目标进程启动的广播，如果 mPendingBroadcast 不为 null，说明该广播仍然未处理！</span></span><br><span class="line">        <span class="keyword">if</span> (mPendingBroadcast != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST,</span><br><span class="line">                    <span class="string">"processNextBroadcast ["</span> + mQueueName + <span class="string">"]: waiting for "</span></span><br><span class="line">                    + mPendingBroadcast.curApp);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> isDead;</span><br><span class="line">            <span class="keyword">synchronized</span> (mService.mPidsSelfLocked) &#123;</span><br><span class="line">                <span class="comment">//【4.1】获得目标进程的 ProcessRecord 对象！</span></span><br><span class="line">                ProcessRecord proc = mService.mPidsSelfLocked.get(mPendingBroadcast.curApp.pid);</span><br><span class="line">                isDead = proc == <span class="keyword">null</span> || proc.crashing;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//【4.2】如果目标进程没有死亡，就继续的等待，return！</span></span><br><span class="line">            <span class="keyword">if</span> (!isDead) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"pending app  ["</span></span><br><span class="line">                        + mQueueName + <span class="string">"]"</span> + mPendingBroadcast.curApp</span><br><span class="line">                        + <span class="string">" died before responding to broadcast"</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//【4.3】目标进程死亡，将 mPendingBroadcast 初始化为 null！</span></span><br><span class="line">                mPendingBroadcast.state = BroadcastRecord.IDLE;</span><br><span class="line">                mPendingBroadcast.nextReceiver = mPendingBroadcastRecvIndex;</span><br><span class="line">                mPendingBroadcast = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> looped = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【5】 while 循环用于移除 mOrderedBroadcasts 列表中的无需发送的广播，并找到下一个需要发送的广播！</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">//【5.1】如果 mOrderedBroadcasts 的广播已经处理完了，就直接返回！</span></span><br><span class="line">            <span class="keyword">if</span> (mOrderedBroadcasts.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                mService.scheduleAppGcsLocked();</span><br><span class="line">                <span class="keyword">if</span> (looped) &#123;</span><br><span class="line">                    <span class="comment">//【5.1.1】更新系统 oomAdj 的值！</span></span><br><span class="line">                    mService.updateOomAdjLocked();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//【5.2】获得有序队列中的第一个要分发的广播！</span></span><br><span class="line">            r = mOrderedBroadcasts.get(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">boolean</span> forceReceive = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> numReceivers = (r.receivers != <span class="keyword">null</span>) ? r.receivers.size() : <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> (mService.mProcessesReady &amp;&amp; r.dispatchTime &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//【5.3】判断是否广播超时，超时则调用 broadcastTimeoutLocked(false) 强行结束广播；</span></span><br><span class="line">                <span class="comment">// 并设置 forceReceive 为 true，设置广播状态 r.state 为 BroadcastRecord.IDLE！  </span></span><br><span class="line">                <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">                <span class="keyword">if</span> ((numReceivers &gt; <span class="number">0</span>) &amp;&amp;</span><br><span class="line">                        (now &gt; r.dispatchTime + (<span class="number">2</span>*mTimeoutPeriod*numReceivers))) &#123;</span><br><span class="line"></span><br><span class="line">                    Slog.w(TAG, <span class="string">"Hung broadcast ["</span></span><br><span class="line">                            + mQueueName + <span class="string">"] discarded after timeout failure:"</span></span><br><span class="line">                            + <span class="string">" now="</span> + now</span><br><span class="line">                            + <span class="string">" dispatchTime="</span> + r.dispatchTime</span><br><span class="line">                            + <span class="string">" startTime="</span> + r.receiverTime</span><br><span class="line">                            + <span class="string">" intent="</span> + r.intent</span><br><span class="line">                            + <span class="string">" numReceivers="</span> + numReceivers</span><br><span class="line">                            + <span class="string">" nextReceiver="</span> + r.nextReceiver</span><br><span class="line">                            + <span class="string">" state="</span> + r.state);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//【5.4】处理广播超时</span></span><br><span class="line">                    broadcastTimeoutLocked(<span class="keyword">false</span>); </span><br><span class="line">                    <span class="comment">//【5.5】广播超时了，所以我们视其为接收，forceReceive 为 true；</span></span><br><span class="line">                    forceReceive = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="comment">//【5.6】更新广播的状态为 idle；</span></span><br><span class="line">                    r.state = BroadcastRecord.IDLE;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【5.7】判断广播的状态是否是 BroadcastRecord.IDLE，对于 mOrderedBroadcasts 集合中的广播来说，</span></span><br><span class="line">            <span class="comment">// 只有广播的状态为 BroadcastRecord.IDLE 时才能继续下一次的分发，这里就直接返回了！！</span></span><br><span class="line">            <span class="keyword">if</span> (r.state != BroadcastRecord.IDLE) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.d(TAG_BROADCAST,</span><br><span class="line">                        <span class="string">"processNextBroadcast("</span></span><br><span class="line">                        + mQueueName + <span class="string">") called when not idle (state="</span></span><br><span class="line">                        + r.state + <span class="string">")"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//【5.8】如果该广播没有接收者，或者该广播的所有接收者都接收到了广播（nextReceiver 大于接收者数）</span></span><br><span class="line">            <span class="comment">// 或者该广播被终止继续传递（有序广播特性），或者该广播超时了被视为强制接收了，进入该分支；</span></span><br><span class="line">            <span class="keyword">if</span> (r.receivers == <span class="keyword">null</span> || r.nextReceiver &gt;= numReceivers</span><br><span class="line">                    || r.resultAbort || forceReceive) &#123;</span><br><span class="line">                    </span><br><span class="line">                <span class="keyword">if</span> (r.resultTo != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.i(TAG_BROADCAST,</span><br><span class="line">                                <span class="string">"Finishing broadcast ["</span> + mQueueName + <span class="string">"] "</span></span><br><span class="line">                                + r.intent.getAction() + <span class="string">" app="</span> + r.callerApp);</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">//【×2.5.1.3】如果该广播的 r.resultTo 不为 null，resultTo 也是一个广播接收者，</span></span><br><span class="line">                        <span class="comment">// 那就调用 performReceiveLocked() 将该广播发送给 resultTo！</span></span><br><span class="line">                        performReceiveLocked(r.callerApp, r.resultTo,</span><br><span class="line">                            <span class="keyword">new</span> Intent(r.intent), r.resultCode,</span><br><span class="line">                            r.resultData, r.resultExtras, <span class="keyword">false</span>, <span class="keyword">false</span>, r.userId);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//【5.8.1】将广播的 r.resultTo 置为 null；</span></span><br><span class="line">                        r.resultTo = <span class="keyword">null</span>;</span><br><span class="line">                        </span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                        r.resultTo = <span class="keyword">null</span>;</span><br><span class="line">                        Slog.w(TAG, <span class="string">"Failure ["</span></span><br><span class="line">                                + mQueueName + <span class="string">"] sending broadcast result of "</span></span><br><span class="line">                                + r.intent, e);</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, <span class="string">"Cancelling BROADCAST_TIMEOUT_MSG"</span>);</span><br><span class="line">                <span class="comment">//【5.8.2】取消广播超时的消息！</span></span><br><span class="line">                cancelBroadcastTimeoutLocked();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST,</span><br><span class="line">                        <span class="string">"Finished with ordered broadcast "</span> + r);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//【×2.5.1.2】将广播添加到历史集合中！</span></span><br><span class="line">                addBroadcastToHistoryLocked(r);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//【5.8.3】如果该广播是一个隐式广播，将该广播添加到 mCurBroadcastStats 中记录下来！</span></span><br><span class="line">                <span class="keyword">if</span> (r.intent.getComponent() == <span class="keyword">null</span> &amp;&amp; r.intent.getPackage() == <span class="keyword">null</span></span><br><span class="line">                        &amp;&amp; (r.intent.getFlags()&amp;Intent.FLAG_RECEIVER_REGISTERED_ONLY) == <span class="number">0</span>) &#123;</span><br><span class="line">                    mService.addBroadcastStatLocked(r.intent.getAction(), r.callerPackage,</span><br><span class="line">                            r.manifestCount, r.manifestSkipCount, r.finishTime-r.dispatchTime);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//【5.8.4】从 mOrderedBroadcasts 中移除该广播！</span></span><br><span class="line">                mOrderedBroadcasts.remove(<span class="number">0</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//【5.8.5】将 r 设为 null，进行下一次循环！</span></span><br><span class="line">                r = <span class="keyword">null</span>;</span><br><span class="line">                looped = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (r == <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【6】分发 mOrderedBroadcasts 集合中的广播，通过前面的分析 mOrderedBroadcasts 会存储 2 种类型的广播</span></span><br><span class="line">        <span class="comment">// 普通广播，接收者为静态注册的；有序广播，接收者为的动态和静态注册的合并；</span></span><br><span class="line">        <span class="comment">// 首先，计算广播的下一个接收者的序号。同时，增加目标接收者计数！！ </span></span><br><span class="line">        <span class="keyword">int</span> recIdx = r.nextReceiver++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【7】初始化该广播的接收时间，该时间会不断更新！！</span></span><br><span class="line">        r.receiverTime = SystemClock.uptimeMillis();</span><br><span class="line">        <span class="comment">//【8】如果是第一个接收者，就记录广播的开始分发时间；</span></span><br><span class="line">        <span class="keyword">if</span> (recIdx == <span class="number">0</span>) &#123;</span><br><span class="line">            r.dispatchTime = r.receiverTime;</span><br><span class="line">            r.dispatchClockTime = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, <span class="string">"Processing ordered broadcast ["</span></span><br><span class="line">                    + mQueueName + <span class="string">"] "</span> + r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【9】如果没有设置广播超时消息，那就设置超时消息！</span></span><br><span class="line">        <span class="keyword">if</span> (!mPendingBroadcastTimeoutMessage) &#123;</span><br><span class="line">            <span class="keyword">long</span> timeoutTime = r.receiverTime + mTimeoutPeriod;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,</span><br><span class="line">                    <span class="string">"Submitting BROADCAST_TIMEOUT_MSG ["</span></span><br><span class="line">                    + mQueueName + <span class="string">"] for "</span> + r + <span class="string">" at "</span> + timeoutTime);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//【9.1】设置广播处理的超时时间为 10s</span></span><br><span class="line">            <span class="comment">// 这里会将 mPendingBroadcastTimeoutMessage 设置为 true；</span></span><br><span class="line">            setBroadcastTimeoutLocked(timeoutTime);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【10】获得广播的额外数据；</span></span><br><span class="line">        <span class="keyword">final</span> BroadcastOptions brOptions = r.options;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【11】获得广播的下一个接收者；</span></span><br><span class="line">        <span class="keyword">final</span> Object nextReceiver = r.receivers.get(recIdx);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【12】如果下一个广播接收者是动态注册的广播接收者！（这里只可能是有序广播）</span></span><br><span class="line">        <span class="keyword">if</span> (nextReceiver <span class="keyword">instanceof</span> BroadcastFilter) &#123;</span><br><span class="line">            BroadcastFilter filter = (BroadcastFilter)nextReceiver;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (DEBUG_BROADCAST)  Slog.v(TAG_BROADCAST,</span><br><span class="line">                    <span class="string">"Delivering ordered ["</span></span><br><span class="line">                    + mQueueName + <span class="string">"] to registered "</span></span><br><span class="line">                    + filter + <span class="string">": "</span> + r);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//【×2.5.1.1】将该有序广播分发给动态注册的广播接收者，该方法中会进一步过滤！！</span></span><br><span class="line">            deliverToRegisteredReceiverLocked(r, filter, r.ordered, recIdx);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【12.1】当所有的接收者都接收到了广播时，那么 r.receiver 为 null；</span></span><br><span class="line">            <span class="comment">// 或者说该广播是普通广播，那么这里会继续下一次分发！</span></span><br><span class="line">            <span class="keyword">if</span> (r.receiver == <span class="keyword">null</span> || !r.ordered) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, <span class="string">"Quick finishing ["</span></span><br><span class="line">                        + mQueueName + <span class="string">"]: ordered="</span></span><br><span class="line">                        + r.ordered + <span class="string">" receiver="</span> + r.receiver);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//【12.2】将广播的状态设置为 idle；</span></span><br><span class="line">                r.state = BroadcastRecord.IDLE;</span><br><span class="line">                <span class="comment">//【×2.3.5】重新发送BROADCAST_INTENT_MSG，触发下一次发送广播的流程！</span></span><br><span class="line">                scheduleBroadcastsLocked();</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果广播没有分发完成，并且是有序广播，并且其携带了额外数据，为了防止其在 doze 模式下</span></span><br><span class="line">                <span class="comment">// 能够收到广播，所以如果额外数据中指定了 temp duration，那么会将其加入到 doze 临时白名单中；</span></span><br><span class="line">                <span class="keyword">if</span> (brOptions != <span class="keyword">null</span> &amp;&amp; brOptions.getTemporaryAppWhitelistDuration() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    scheduleTempWhitelistLocked(filter.owningUid,</span><br><span class="line">                            brOptions.getTemporaryAppWhitelistDuration(), r);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//【12.3】这里直接 return 掉，因为对于有序广播而言，</span></span><br><span class="line">            <span class="comment">// 已经通知了一个 BroadcastReceiver，需要等待其处理结果，因此返回！</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【13】如果下一个广播接收者是静态注册的广播接收者（对于有序/普通广播）</span></span><br><span class="line">        ResolveInfo info =</span><br><span class="line">            (ResolveInfo)nextReceiver;</span><br><span class="line">        ComponentName component = <span class="keyword">new</span> ComponentName(</span><br><span class="line">                info.activityInfo.applicationInfo.packageName,</span><br><span class="line">                info.activityInfo.name);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【14】判断是否跳过该静态接收者！</span></span><br><span class="line">        <span class="keyword">boolean</span> skip = <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【15】如果 sdk 不匹配，跳过该接收者！</span></span><br><span class="line">        <span class="keyword">if</span> (brOptions != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                (info.activityInfo.applicationInfo.targetSdkVersion</span><br><span class="line">                        &lt; brOptions.getMinManifestReceiverApiLevel() ||</span><br><span class="line">                info.activityInfo.applicationInfo.targetSdkVersion</span><br><span class="line">                        &gt; brOptions.getMaxManifestReceiverApiLevel())) &#123;</span><br><span class="line">            skip = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【16】检查广播发送者是否具有接收者要求的权限！</span></span><br><span class="line">        <span class="keyword">int</span> perm = mService.checkComponentPermission(info.activityInfo.permission,</span><br><span class="line">                r.callingPid, r.callingUid, info.activityInfo.applicationInfo.uid,</span><br><span class="line">                info.activityInfo.exported);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!skip &amp;&amp; perm != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">            <span class="comment">//【16.1】如果发送者不被授予该权限，那就跳过该接收者！</span></span><br><span class="line">            <span class="keyword">if</span> (!info.activityInfo.exported) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Permission Denial: broadcasting "</span></span><br><span class="line">                        + r.intent.toString()</span><br><span class="line">                        + <span class="string">" from "</span> + r.callerPackage + <span class="string">" (pid="</span> + r.callingPid</span><br><span class="line">                        + <span class="string">", uid="</span> + r.callingUid + <span class="string">")"</span></span><br><span class="line">                        + <span class="string">" is not exported from uid "</span> + info.activityInfo.applicationInfo.uid</span><br><span class="line">                        + <span class="string">" due to receiver "</span> + component.flattenToShortString());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Permission Denial: broadcasting "</span></span><br><span class="line">                        + r.intent.toString()</span><br><span class="line">                        + <span class="string">" from "</span> + r.callerPackage + <span class="string">" (pid="</span> + r.callingPid</span><br><span class="line">                        + <span class="string">", uid="</span> + r.callingUid + <span class="string">")"</span></span><br><span class="line">                        + <span class="string">" requires "</span> + info.activityInfo.permission</span><br><span class="line">                        + <span class="string">" due to receiver "</span> + component.flattenToShortString());</span><br><span class="line">            &#125;</span><br><span class="line">            skip = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!skip &amp;&amp; info.activityInfo.permission != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//【16.2】权限校验通过，那就要判断发送者是否能执行接收者指定的权限对应的操作！</span></span><br><span class="line">            <span class="comment">// 一般情况下，如果有权限有对应的 op，那么权限在授予的情况下，也会授予 op！</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> opCode = AppOpsManager.permissionToOpCode(info.activityInfo.permission);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (opCode != AppOpsManager.OP_NONE</span><br><span class="line">                    &amp;&amp; mService.mAppOpsService.noteOperation(opCode, r.callingUid,</span><br><span class="line">                            r.callerPackage) != AppOpsManager.MODE_ALLOWED) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Appop Denial: broadcasting "</span></span><br><span class="line">                        + r.intent.toString()</span><br><span class="line">                        + <span class="string">" from "</span> + r.callerPackage + <span class="string">" (pid="</span></span><br><span class="line">                        + r.callingPid + <span class="string">", uid="</span> + r.callingUid + <span class="string">")"</span></span><br><span class="line">                        + <span class="string">" requires appop "</span> + AppOpsManager.permissionToOp(</span><br><span class="line">                                info.activityInfo.permission)</span><br><span class="line">                        + <span class="string">" due to registered receiver "</span></span><br><span class="line">                        + component.flattenToShortString());</span><br><span class="line">                skip = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【17】如果接收者不是 system uid 的，而广播发送者指定了权限，那就要校验接收者是否具有该权限！</span></span><br><span class="line">        <span class="keyword">if</span> (!skip &amp;&amp; info.activityInfo.applicationInfo.uid != Process.SYSTEM_UID &amp;&amp;</span><br><span class="line">            r.requiredPermissions != <span class="keyword">null</span> &amp;&amp; r.requiredPermissions.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r.requiredPermissions.length; i++) &#123;</span><br><span class="line">                String requiredPermission = r.requiredPermissions[i];</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    perm = AppGlobals.getPackageManager().</span><br><span class="line">                            checkPermission(requiredPermission,</span><br><span class="line">                                    info.activityInfo.applicationInfo.packageName,</span><br><span class="line">                                    UserHandle.getUserId(info.activityInfo.applicationInfo.uid));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                    perm = PackageManager.PERMISSION_DENIED;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//【17.1】接收者不具有该权限，跳过该接收者！</span></span><br><span class="line">                <span class="keyword">if</span> (perm != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">                    Slog.w(TAG, <span class="string">"Permission Denial: receiving "</span></span><br><span class="line">                            + r.intent + <span class="string">" to "</span></span><br><span class="line">                            + component.flattenToShortString()</span><br><span class="line">                            + <span class="string">" requires "</span> + requiredPermission</span><br><span class="line">                            + <span class="string">" due to sender "</span> + r.callerPackage</span><br><span class="line">                            + <span class="string">" (uid "</span> + r.callingUid + <span class="string">")"</span>);</span><br><span class="line">                    skip = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//【17.2】判断接收者是否能执行发送者指定的权限所对应的操作！</span></span><br><span class="line">                <span class="keyword">int</span> appOp = AppOpsManager.permissionToOpCode(requiredPermission);</span><br><span class="line">                <span class="keyword">if</span> (appOp != AppOpsManager.OP_NONE &amp;&amp; appOp != r.appOp</span><br><span class="line">                        &amp;&amp; mService.mAppOpsService.noteOperation(appOp,</span><br><span class="line">                        info.activityInfo.applicationInfo.uid, info.activityInfo.packageName)</span><br><span class="line">                        != AppOpsManager.MODE_ALLOWED) &#123;</span><br><span class="line">                    Slog.w(TAG, <span class="string">"Appop Denial: receiving "</span></span><br><span class="line">                            + r.intent + <span class="string">" to "</span></span><br><span class="line">                            + component.flattenToShortString()</span><br><span class="line">                            + <span class="string">" requires appop "</span> + AppOpsManager.permissionToOp(</span><br><span class="line">                            requiredPermission)</span><br><span class="line">                            + <span class="string">" due to sender "</span> + r.callerPackage</span><br><span class="line">                            + <span class="string">" (uid "</span> + r.callingUid + <span class="string">")"</span>);</span><br><span class="line">                    skip = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【18】如果广播无需权限，只需要执行某个 op 的话，这里会判断是否有 op 权限！</span></span><br><span class="line">        <span class="keyword">if</span> (!skip &amp;&amp; r.appOp != AppOpsManager.OP_NONE</span><br><span class="line">                &amp;&amp; mService.mAppOpsService.noteOperation(r.appOp,</span><br><span class="line">                info.activityInfo.applicationInfo.uid, info.activityInfo.packageName)</span><br><span class="line">                != AppOpsManager.MODE_ALLOWED) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Appop Denial: receiving "</span></span><br><span class="line">                    + r.intent + <span class="string">" to "</span></span><br><span class="line">                    + component.flattenToShortString()</span><br><span class="line">                    + <span class="string">" requires appop "</span> + AppOpsManager.opToName(r.appOp)</span><br><span class="line">                    + <span class="string">" due to sender "</span> + r.callerPackage</span><br><span class="line">                    + <span class="string">" (uid "</span> + r.callingUid + <span class="string">")"</span>);</span><br><span class="line">            skip = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【19】判断 Intent 是否满足 AMS 的 IntentFirewall 防火墙要求，不满足，跳过！</span></span><br><span class="line">        <span class="keyword">if</span> (!skip) &#123;</span><br><span class="line">            skip = !mService.mIntentFirewall.checkBroadcast(r.intent, r.callingUid,</span><br><span class="line">                    r.callingPid, r.resolvedType, info.activityInfo.applicationInfo.uid);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【20】判断该接收者是否是单例！</span></span><br><span class="line">        <span class="keyword">boolean</span> isSingleton = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            isSingleton = mService.isSingleton(info.activityInfo.processName,</span><br><span class="line">                    info.activityInfo.applicationInfo,</span><br><span class="line">                    info.activityInfo.name, info.activityInfo.flags);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SecurityException e) &#123;</span><br><span class="line">            Slog.w(TAG, e.getMessage());</span><br><span class="line">            skip = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【20.1】如果接收者是单例模式，那就要校验接收者是否有</span></span><br><span class="line">        <span class="comment">// android.Manifest.permission.INTERACT_ACROSS_USERS 权限，如果没有，跳过该接收者！</span></span><br><span class="line">        <span class="keyword">if</span> ((info.activityInfo.flags&amp;ActivityInfo.FLAG_SINGLE_USER) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ActivityManager.checkUidPermission(</span><br><span class="line">                    android.Manifest.permission.INTERACT_ACROSS_USERS,</span><br><span class="line">                    info.activityInfo.applicationInfo.uid)</span><br><span class="line">                            != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Permission Denial: Receiver "</span> + component.flattenToShortString()</span><br><span class="line">                        + <span class="string">" requests FLAG_SINGLE_USER, but app does not hold "</span></span><br><span class="line">                        + android.Manifest.permission.INTERACT_ACROSS_USERS);</span><br><span class="line">                skip = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【21】记录处理的静态接收者数量！</span></span><br><span class="line">        <span class="keyword">if</span> (!skip) &#123;</span><br><span class="line">            r.manifestCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r.manifestSkipCount++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【22】如果接收者所在进程 crash 了，跳过该接收者！</span></span><br><span class="line">        <span class="keyword">if</span> (r.curApp != <span class="keyword">null</span> &amp;&amp; r.curApp.crashing) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Skipping deliver ordered ["</span> + mQueueName + <span class="string">"] "</span> + r</span><br><span class="line">                    + <span class="string">" to "</span> + r.curApp + <span class="string">": process crashing"</span>);</span><br><span class="line">            skip = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【23】判断该静态接收者所在的 package 是否可用，不可用就跳过！</span></span><br><span class="line">        <span class="keyword">if</span> (!skip) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> isAvailable = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                isAvailable = AppGlobals.getPackageManager().isPackageAvailable(</span><br><span class="line">                        info.activityInfo.packageName,</span><br><span class="line">                        UserHandle.getUserId(info.activityInfo.applicationInfo.uid));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Exception getting recipient info for "</span></span><br><span class="line">                        + info.activityInfo.packageName, e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!isAvailable) &#123; <span class="comment">// 不可用，跳过！</span></span><br><span class="line">                <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,</span><br><span class="line">                        <span class="string">"Skipping delivery to "</span> + info.activityInfo.packageName + <span class="string">" / "</span></span><br><span class="line">                        + info.activityInfo.applicationInfo.uid</span><br><span class="line">                        + <span class="string">" : package no longer available"</span>);</span><br><span class="line">                skip = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【24】如果在任何组件运行时都要重新校验权限，那就执权限校验，校验失败，跳过！</span></span><br><span class="line">        <span class="keyword">if</span> (Build.PERMISSIONS_REVIEW_REQUIRED &amp;&amp; !skip) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!requestStartTargetPermissionsReviewIfNeededLocked(r,</span><br><span class="line">                    info.activityInfo.packageName, UserHandle.getUserId(</span><br><span class="line">                            info.activityInfo.applicationInfo.uid))) &#123;</span><br><span class="line">                skip = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> receiverUid = info.activityInfo.applicationInfo.uid;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【25】如果发送者不是系统进程，且接收者是单例，并且本次调用是有效的</span></span><br><span class="line">        <span class="comment">// 那就始终返回默认设备用户下的接收者对象，保持单例有效性！</span></span><br><span class="line">        <span class="keyword">if</span> (r.callingUid != Process.SYSTEM_UID &amp;&amp; isSingleton</span><br><span class="line">                &amp;&amp; mService.isValidSingletonCall(r.callingUid, receiverUid)) &#123;</span><br><span class="line">            info.activityInfo = mService.getActivityInfoForUser(info.activityInfo, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【26】获得目标广播接收者的进程名；</span></span><br><span class="line">        String targetProcess = info.activityInfo.processName;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【27】获得目标广播接收者所在进程的 ProcessRecord 对象！</span></span><br><span class="line">        ProcessRecord app = mService.getProcessRecordLocked(targetProcess,</span><br><span class="line">                info.activityInfo.applicationInfo.uid, <span class="keyword">false</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (!skip) &#123;</span><br><span class="line">            <span class="comment">//【28】判断该静态接收者所在进程是否允许后台启动或者在后台接受广播，不允许就跳过！</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> allowed = mService.checkAllowBackgroundLocked(</span><br><span class="line">                    info.activityInfo.applicationInfo.uid, info.activityInfo.packageName, -<span class="number">1</span>,</span><br><span class="line">                    <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (allowed != ActivityManager.APP_START_MODE_NORMAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (allowed == ActivityManager.APP_START_MODE_DISABLED) &#123;</span><br><span class="line">                    Slog.w(TAG, <span class="string">"Background execution disabled: receiving "</span></span><br><span class="line">                            + r.intent + <span class="string">" to "</span></span><br><span class="line">                            + component.flattenToShortString());</span><br><span class="line">                    skip = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (((r.intent.getFlags()&amp;Intent.FLAG_RECEIVER_EXCLUDE_BACKGROUND) != <span class="number">0</span>)</span><br><span class="line">                        || (r.intent.getComponent() == <span class="keyword">null</span></span><br><span class="line">                            &amp;&amp; r.intent.getPackage() == <span class="keyword">null</span></span><br><span class="line">                            &amp;&amp; ((r.intent.getFlags()</span><br><span class="line">                                    &amp; Intent.FLAG_RECEIVER_INCLUDE_BACKGROUND) == <span class="number">0</span>))) &#123;</span><br><span class="line">                    <span class="comment">//【28.1】这里针对 intent 的属性做了判断：</span></span><br><span class="line">                    <span class="comment">// 如果 intent 设置了 FLAG_RECEIVER_EXCLUDE_BACKGROUND，那就不能发给后台接收者；</span></span><br><span class="line">                    <span class="comment">// 如果是没有设置 FLAG_RECEIVER_INCLUDE_BACKGROUND 的隐式广播，那么也不能发给后台接收者；</span></span><br><span class="line">                    Slog.w(TAG, <span class="string">"Background execution not allowed: receiving "</span></span><br><span class="line">                            + r.intent + <span class="string">" to "</span></span><br><span class="line">                            + component.flattenToShortString());</span><br><span class="line"></span><br><span class="line">                    skip = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【29】如果 skip 的值为 true，说明要跳过当前的静态接收者，继续下次广播分发！！</span></span><br><span class="line">        <span class="keyword">if</span> (skip) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_BROADCAST)  Slog.v(TAG_BROADCAST,</span><br><span class="line">                    <span class="string">"Skipping delivery of ordered ["</span> + mQueueName + <span class="string">"] "</span></span><br><span class="line">                    + r + <span class="string">" for whatever reason"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【29.1】设置序号为 recIdx 的接收者的分发状态为 BroadcastRecord.DELIVERY_SKIPPED 跳过！</span></span><br><span class="line">            r.delivery[recIdx] = BroadcastRecord.DELIVERY_SKIPPED;</span><br><span class="line">            r.receiver = <span class="keyword">null</span>;</span><br><span class="line">            r.curFilter = <span class="keyword">null</span>;</span><br><span class="line">            r.state = BroadcastRecord.IDLE;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【×2.3.5】继续下次广播分发，结束方法！</span></span><br><span class="line">            scheduleBroadcastsLocked();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【30】如果该静态接收者不会跳过，那就设置其属性，准备发送广播！</span></span><br><span class="line">        r.delivery[recIdx] = BroadcastRecord.DELIVERY_DELIVERED;</span><br><span class="line">        r.state = BroadcastRecord.APP_RECEIVE; <span class="comment">// 广播状态；</span></span><br><span class="line">        r.curComponent = component;</span><br><span class="line">        r.curReceiver = info.activityInfo;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DEBUG_MU &amp;&amp; r.callingUid &gt; UserHandle.PER_USER_RANGE) &#123;</span><br><span class="line">            Slog.v(TAG_MU, <span class="string">"Updated broadcast record activity info for secondary user, "</span></span><br><span class="line">                    + info.activityInfo + <span class="string">", callingUid = "</span> + r.callingUid + <span class="string">", uid = "</span></span><br><span class="line">                    + info.activityInfo.applicationInfo.uid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【31】如果额外参数指定了 doze 白名单参数，那么就设置临时白名单；</span></span><br><span class="line">        <span class="keyword">if</span> (brOptions != <span class="keyword">null</span> &amp;&amp; brOptions.getTemporaryAppWhitelistDuration() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            scheduleTempWhitelistLocked(receiverUid,</span><br><span class="line">                    brOptions.getTemporaryAppWhitelistDuration(), r);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【32】设置接收者所在的包 stoped 状态为 false！</span></span><br><span class="line">            AppGlobals.getPackageManager().setPackageStoppedState(</span><br><span class="line">                    r.curComponent.getPackageName(), <span class="keyword">false</span>, UserHandle.getUserId(r.callingUid));</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Failed trying to unstop package "</span></span><br><span class="line">                    + r.curComponent.getPackageName() + <span class="string">": "</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【33】如果静态广播接收者所在的进程已经启动，那就要直接发送广播！</span></span><br><span class="line">        <span class="keyword">if</span> (app != <span class="keyword">null</span> &amp;&amp; app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                app.addPackage(info.activityInfo.packageName,</span><br><span class="line">                        info.activityInfo.applicationInfo.versionCode, mService.mProcessStats);</span><br><span class="line">                        </span><br><span class="line">                <span class="comment">//【×2.5.2.1.1】发送广播，并等待结果返回！</span></span><br><span class="line">                processCurBroadcastLocked(r, app);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Exception when sending broadcast to "</span></span><br><span class="line">                      + r.curComponent, e);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">                Slog.wtf(TAG, <span class="string">"Failed sending broadcast to "</span></span><br><span class="line">                        + r.curComponent + <span class="string">" with "</span> + r.intent, e);</span><br><span class="line"></span><br><span class="line">                logBroadcastReceiverDiscardLocked(r);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//【×4.1.2】发送失败，结束本次发送！</span></span><br><span class="line">                finishReceiverLocked(r, r.resultCode, r.resultData,</span><br><span class="line">                        r.resultExtras, r.resultAbort, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//【×2.3.5】继续发送后续的广播！</span></span><br><span class="line">                scheduleBroadcastsLocked();</span><br><span class="line">                r.state = BroadcastRecord.IDLE; <span class="comment">// 设置状态！</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DEBUG_BROADCAST)  Slog.v(TAG_BROADCAST,</span><br><span class="line">                <span class="string">"Need to start app ["</span></span><br><span class="line">                + mQueueName + <span class="string">"] "</span> + targetProcess + <span class="string">" for broadcast "</span> + r);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【34】如果静态广播接收者所在的进程没有启动，那就要先启动其所在进程！</span></span><br><span class="line">        <span class="keyword">if</span> ((r.curApp=mService.startProcessLocked(targetProcess,</span><br><span class="line">                info.activityInfo.applicationInfo, <span class="keyword">true</span>,</span><br><span class="line">                r.intent.getFlags() | Intent.FLAG_FROM_BACKGROUND,</span><br><span class="line">                <span class="string">"broadcast"</span>, r.curComponent,</span><br><span class="line">                (r.intent.getFlags()&amp;Intent.FLAG_RECEIVER_BOOT_UPGRADE) != <span class="number">0</span>, <span class="keyword">false</span>, <span class="keyword">false</span>))</span><br><span class="line">                        == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">            Slog.w(TAG, <span class="string">"Unable to launch app "</span></span><br><span class="line">                    + info.activityInfo.applicationInfo.packageName + <span class="string">"/"</span></span><br><span class="line">                    + info.activityInfo.applicationInfo.uid + <span class="string">" for broadcast "</span></span><br><span class="line">                    + r.intent + <span class="string">": process is bad"</span>);</span><br><span class="line">            </span><br><span class="line">            logBroadcastReceiverDiscardLocked(r);</span><br><span class="line">            <span class="comment">//【×4.1.2】目标进程启动失败，结束本次发送！</span></span><br><span class="line">            finishReceiverLocked(r, r.resultCode, r.resultData,</span><br><span class="line">                    r.resultExtras, r.resultAbort, <span class="keyword">false</span>);</span><br><span class="line">                    </span><br><span class="line">            <span class="comment">//【×2.3.5】继续发送后续的广播！</span></span><br><span class="line">            scheduleBroadcastsLocked();</span><br><span class="line">            r.state = BroadcastRecord.IDLE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【35】将当前的广播保存到 mPendingBroadcast 中，表示正在等待目标进程启动的广播！</span></span><br><span class="line">        mPendingBroadcast = r;</span><br><span class="line">        <span class="comment">// 广播的目标接收者的序号！</span></span><br><span class="line">        mPendingBroadcastRecvIndex = recIdx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法的逻辑很长，我们来总结一下他的业务流程：</p>
<ul>
<li>1 立刻分发 <code>mParallelBroadcasts</code> 集合中的目标为动态接收者的普通广播，方式方式为并行！<ul>
<li>1.1 调用【<code>deliverToRegisteredReceiverLocked</code>】发送广播！</li>
</ul>
</li>
</ul>
<p><br></p>
<ul>
<li>2 处理正在等待目标进程启动的广播 <code>mPendingBroadcast</code>，<code>mPendingBroadcast</code> 是有序的发送方式！<ul>
<li>2.1 如果进程没有启动成功，就等待进程启动后处理改广播，<code>return</code>；</li>
</ul>
</li>
</ul>
<p><br></p>
<ul>
<li>3 移除 <code>mOrderedBroadcasts</code> 列表中的无需发送的广播，并找到下一个需要发送的广播，<code>mOrderedBroadcasts</code> 集合中的所有广播都是有序发送！<ul>
<li>3.1 如果某个广播超时了，就强行结束广播，并设置广播的状态为 <code>BroadcastRecord.IDLE</code>;</li>
<li>3.2 如果某个广播的状态不是 <code>BroadcastRecord.IDLE</code>，说明上一个接收者没有结束广播处理，<code>return</code>；</li>
<li>3.3 如果某个广播没有接收者，或者已经分发给了所有的目标接受者，或者被终止传递，或者广播超时了，那就移除该广播！<br>  如果指定了 <code>r.resultTo</code>，那还需要将该广播发送给 <code>resultTo</code> 接受者！ </li>
</ul>
</li>
</ul>
<p><br></p>
<ul>
<li><p>4 有序分发 <code>mOrderedBroadcasts</code> 的广播，根据下一个接收者的不同，做不同的处理！</p>
<ul>
<li>4.1 如果是动态接收者，调用【<code>deliverToRegisteredReceiverLocked</code>】发送广播，然后等待处理结果，<code>return</code>！</li>
<li><p>4.2 如果是静态接收者，先要判断是否 skip 该接收者；</p>
<ul>
<li><p>4.2.1 跳过的触发条件：</p>
<pre><code>- sdk 不匹配，跳过；
- 发送者不具有接收者要求的权限，跳过；
- 接收者不具有发送者要求的权限，跳过；
- 广播不满足 `AMS` 的 `IntentFirewall` 防火墙要求，跳过；
- 接收者是单例，但是没有申明 `android.Manifest.permission.INTERACT_ACROSS_USERS`，跳过；
- 接收者所在进程 `crash` 了，跳过；
- 接收者所在 `package` 不可用，跳过；
- 接收者所在进程不允许后台启动，跳过；

&lt;/br&gt;
</code></pre></li>
<li><p>4.2.2 如果需要跳过该接受者，执行 <code>scheduleBroadcastsLocked</code>，进行下一次广播分发；</p>
<pre><code>- `r.delivery[recIdx] = BroadcastRecord.DELIVERY_SKIPPED`;
- `r.receiver = null`;
- `r.curFilter = null`;
- `r.state = BroadcastRecord.IDLE`;

&lt;/br&gt;
</code></pre></li>
<li><p>4.2.3 如果不跳过，就执行发送操作，这里需要判断静态接收者的进程是否启动；</p>
<pre><code>- 4.2.3.1 静态广播接收者所在的进程已经启动，调用【`processCurBroadcastLocked`】 发送广播，并等待结果，`return`；
- 4.2.3.2 静态广播接收者所在的进程没有启动，调用 `startProcessLocked` 启动进程：
        - 启动成功，将当前广播保存到 `mPendingBroadcast` 中，等待处理！
        - 启动失败，那就 执行 `scheduleBroadcastsLocked`，进行下一次广播分发；
</code></pre></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><br></p>
<p>梳理后，整个方法的业务逻辑很清楚了，下面我们来关注一些细节：</p>
<h3 id="2-5-1-发送给动态注册的接收者"><a href="#2-5-1-发送给动态注册的接收者" class="headerlink" title="2.5.1 发送给动态注册的接收者"></a>2.5.1 发送给动态注册的接收者</h3><h4 id="2-5-1-1-BroadcastQueue-deliverToRegisteredReceiverLocked"><a href="#2-5-1-1-BroadcastQueue-deliverToRegisteredReceiverLocked" class="headerlink" title="2.5.1.1 BroadcastQueue.deliverToRegisteredReceiverLocked"></a>2.5.1.1 BroadcastQueue.deliverToRegisteredReceiverLocked</h4><p>对于目标是动态接收者的普通广播（<code>ordered</code> 为 <code>false</code>），和目标是动态接收者的有序广播（<code>ordered</code> 为 <code>true</code>），都是通过 <code>deliverToRegisteredReceiverLocked</code> 直接发送的！</p>
<p>下面，我们来看看如何给动态注册的接收者发送广播！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deliverToRegisteredReceiverLocked</span><span class="params">(BroadcastRecord r,</span></span></span><br><span class="line"><span class="function"><span class="params">        BroadcastFilter filter, <span class="keyword">boolean</span> ordered, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】判断是否跳过这个接收者，这个和前面的流程很类似！</span></span><br><span class="line">    <span class="keyword">boolean</span> skip = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【2】首先是权限校验，校验发送者是否有接收者定义的权限，没有，跳过该接收者！</span></span><br><span class="line">    <span class="comment">// 权限如果是授予的，那还要再校验下 appOps！</span></span><br><span class="line">    <span class="keyword">if</span> (filter.requiredPermission != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> perm = mService.checkComponentPermission(filter.requiredPermission,</span><br><span class="line">                r.callingPid, r.callingUid, -<span class="number">1</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (perm != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Permission Denial: broadcasting "</span></span><br><span class="line">                    + r.intent.toString()</span><br><span class="line">                    + <span class="string">" from "</span> + r.callerPackage + <span class="string">" (pid="</span></span><br><span class="line">                    + r.callingPid + <span class="string">", uid="</span> + r.callingUid + <span class="string">")"</span></span><br><span class="line">                    + <span class="string">" requires "</span> + filter.requiredPermission</span><br><span class="line">                    + <span class="string">" due to registered receiver "</span> + filter);</span><br><span class="line">            skip = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> opCode = AppOpsManager.permissionToOpCode(filter.requiredPermission);</span><br><span class="line">            <span class="keyword">if</span> (opCode != AppOpsManager.OP_NONE</span><br><span class="line">                    &amp;&amp; mService.mAppOpsService.noteOperation(opCode, r.callingUid,</span><br><span class="line">                            r.callerPackage) != AppOpsManager.MODE_ALLOWED) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Appop Denial: broadcasting "</span></span><br><span class="line">                        + r.intent.toString()</span><br><span class="line">                        + <span class="string">" from "</span> + r.callerPackage + <span class="string">" (pid="</span></span><br><span class="line">                        + r.callingPid + <span class="string">", uid="</span> + r.callingUid + <span class="string">")"</span></span><br><span class="line">                        + <span class="string">" requires appop "</span> + AppOpsManager.permissionToOp(</span><br><span class="line">                                filter.requiredPermission)</span><br><span class="line">                        + <span class="string">" due to registered receiver "</span> + filter);</span><br><span class="line">                skip = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【3】校验接收者者是否有发送者定义的权限，没有，跳过该接收者！</span></span><br><span class="line">    <span class="comment">// 权限如果是授予的，那还要再校验下 appOps！</span></span><br><span class="line">    <span class="keyword">if</span> (!skip &amp;&amp; r.requiredPermissions != <span class="keyword">null</span> &amp;&amp; r.requiredPermissions.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r.requiredPermissions.length; i++) &#123;</span><br><span class="line">            String requiredPermission = r.requiredPermissions[i];</span><br><span class="line">            <span class="keyword">int</span> perm = mService.checkComponentPermission(requiredPermission,</span><br><span class="line">                    filter.receiverList.pid, filter.receiverList.uid, -<span class="number">1</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (perm != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Permission Denial: receiving "</span></span><br><span class="line">                        + r.intent.toString()</span><br><span class="line">                        + <span class="string">" to "</span> + filter.receiverList.app</span><br><span class="line">                        + <span class="string">" (pid="</span> + filter.receiverList.pid</span><br><span class="line">                        + <span class="string">", uid="</span> + filter.receiverList.uid + <span class="string">")"</span></span><br><span class="line">                        + <span class="string">" requires "</span> + requiredPermission</span><br><span class="line">                        + <span class="string">" due to sender "</span> + r.callerPackage</span><br><span class="line">                        + <span class="string">" (uid "</span> + r.callingUid + <span class="string">")"</span>);</span><br><span class="line"></span><br><span class="line">                skip = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> appOp = AppOpsManager.permissionToOpCode(requiredPermission);</span><br><span class="line">            <span class="keyword">if</span> (appOp != AppOpsManager.OP_NONE &amp;&amp; appOp != r.appOp</span><br><span class="line">                    &amp;&amp; mService.mAppOpsService.noteOperation(appOp,</span><br><span class="line">                    filter.receiverList.uid, filter.packageName)</span><br><span class="line">                    != AppOpsManager.MODE_ALLOWED) &#123;</span><br><span class="line"></span><br><span class="line">                Slog.w(TAG, <span class="string">"Appop Denial: receiving "</span></span><br><span class="line">                        + r.intent.toString()</span><br><span class="line">                        + <span class="string">" to "</span> + filter.receiverList.app</span><br><span class="line">                        + <span class="string">" (pid="</span> + filter.receiverList.pid</span><br><span class="line">                        + <span class="string">", uid="</span> + filter.receiverList.uid + <span class="string">")"</span></span><br><span class="line">                        + <span class="string">" requires appop "</span> + AppOpsManager.permissionToOp(</span><br><span class="line">                        requiredPermission)</span><br><span class="line">                        + <span class="string">" due to sender "</span> + r.callerPackage</span><br><span class="line">                        + <span class="string">" (uid "</span> + r.callingUid + <span class="string">")"</span>);</span><br><span class="line"></span><br><span class="line">                skip = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【4】校验接收者权限，这里跟踪下代码，由于传入的权限为 null，方法里面只针对 uid 做了判断</span></span><br><span class="line">    <span class="comment">// 看是不是 root 或者 system，是不是隔离进程 uid；</span></span><br><span class="line">    <span class="keyword">if</span> (!skip &amp;&amp; (r.requiredPermissions == <span class="keyword">null</span> || r.requiredPermissions.length == <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">int</span> perm = mService.checkComponentPermission(<span class="keyword">null</span>,</span><br><span class="line">                filter.receiverList.pid, filter.receiverList.uid, -<span class="number">1</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (perm != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Permission Denial: security check failed when receiving "</span></span><br><span class="line">                    + r.intent.toString()</span><br><span class="line">                    + <span class="string">" to "</span> + filter.receiverList.app</span><br><span class="line">                    + <span class="string">" (pid="</span> + filter.receiverList.pid</span><br><span class="line">                    + <span class="string">", uid="</span> + filter.receiverList.uid + <span class="string">")"</span></span><br><span class="line">                    + <span class="string">" due to sender "</span> + r.callerPackage</span><br><span class="line">                    + <span class="string">" (uid "</span> + r.callingUid + <span class="string">")"</span>);</span><br><span class="line">            skip = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【5】校验 ops！</span></span><br><span class="line">    <span class="keyword">if</span> (!skip &amp;&amp; r.appOp != AppOpsManager.OP_NONE</span><br><span class="line">            &amp;&amp; mService.mAppOpsService.noteOperation(r.appOp,</span><br><span class="line">            filter.receiverList.uid, filter.packageName)</span><br><span class="line">            != AppOpsManager.MODE_ALLOWED) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"Appop Denial: receiving "</span></span><br><span class="line">                + r.intent.toString()</span><br><span class="line">                + <span class="string">" to "</span> + filter.receiverList.app</span><br><span class="line">                + <span class="string">" (pid="</span> + filter.receiverList.pid</span><br><span class="line">                + <span class="string">", uid="</span> + filter.receiverList.uid + <span class="string">")"</span></span><br><span class="line">                + <span class="string">" requires appop "</span> + AppOpsManager.opToName(r.appOp)</span><br><span class="line">                + <span class="string">" due to sender "</span> + r.callerPackage</span><br><span class="line">                + <span class="string">" (uid "</span> + r.callingUid + <span class="string">")"</span>);</span><br><span class="line">        skip = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【6】判断是否允许后台发送广播，不允许就跳过！</span></span><br><span class="line">    <span class="keyword">if</span> (!skip) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> allowed = mService.checkAllowBackgroundLocked(filter.receiverList.uid,</span><br><span class="line">                filter.packageName, -<span class="number">1</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (allowed == ActivityManager.APP_START_MODE_DISABLED) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Background execution not allowed: receiving "</span></span><br><span class="line">                    + r.intent</span><br><span class="line">                    + <span class="string">" to "</span> + filter.receiverList.app</span><br><span class="line">                    + <span class="string">" (pid="</span> + filter.receiverList.pid</span><br><span class="line">                    + <span class="string">", uid="</span> + filter.receiverList.uid + <span class="string">")"</span>);</span><br><span class="line">            skip = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【7】广播不通过防火墙校验，跳过该接收者！</span></span><br><span class="line">    <span class="keyword">if</span> (!mService.mIntentFirewall.checkBroadcast(r.intent, r.callingUid,</span><br><span class="line">            r.callingPid, r.resolvedType, filter.receiverList.uid)) &#123;</span><br><span class="line">        skip = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【8】接收者所在进程 crash 了，就跳过接收者！</span></span><br><span class="line">    <span class="keyword">if</span> (!skip &amp;&amp; (filter.receiverList.app == <span class="keyword">null</span> || filter.receiverList.app.crashing)) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"Skipping deliver ["</span> + mQueueName + <span class="string">"] "</span> + r</span><br><span class="line">                + <span class="string">" to "</span> + filter.receiverList + <span class="string">": process crashing"</span>);</span><br><span class="line">        skip = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【9】如果跳过该接收者，那就设置该接收者为 DELIVERY_SKIPPED；</span></span><br><span class="line">    <span class="keyword">if</span> (skip) &#123;</span><br><span class="line">        r.delivery[index] = BroadcastRecord.DELIVERY_SKIPPED;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【10】如果需要 review 权限，那就拉起 review！</span></span><br><span class="line">    <span class="keyword">if</span> (Build.PERMISSIONS_REVIEW_REQUIRED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!requestStartTargetPermissionsReviewIfNeededLocked(r, filter.packageName,</span><br><span class="line">                filter.owningUserId)) &#123;</span><br><span class="line">            r.delivery[index] = BroadcastRecord.DELIVERY_SKIPPED;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【11】开始发送广播！</span></span><br><span class="line">    r.delivery[index] = BroadcastRecord.DELIVERY_DELIVERED;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【12】如果是有序广播，下面的分支！！</span></span><br><span class="line">    <span class="keyword">if</span> (ordered) &#123;</span><br><span class="line">        <span class="comment">//【12.1】设置广播的目标接收者 IIntentReceier.Proxy 对象，用于挂进程拉起 onReceive 方法！</span></span><br><span class="line">        r.receiver = filter.receiverList.receiver.asBinder();</span><br><span class="line">        <span class="comment">//【12.2】设置一系列相互引用；</span></span><br><span class="line">        r.curFilter = filter;</span><br><span class="line">        filter.receiverList.curBroadcast = r;</span><br><span class="line">        <span class="comment">//【12.2】设置广播状态；</span></span><br><span class="line">        r.state = BroadcastRecord.CALL_IN_RECEIVE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【12.3】如果接收者所在进程已经启动！</span></span><br><span class="line">        <span class="keyword">if</span> (filter.receiverList.app != <span class="keyword">null</span>) &#123;</span><br><span class="line">            r.curApp = filter.receiverList.app;</span><br><span class="line">            filter.receiverList.app.curReceiver = r;</span><br><span class="line">            mService.updateOomAdjLocked(r.curApp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_BROADCAST_LIGHT) Slog.i(TAG_BROADCAST,</span><br><span class="line">                <span class="string">"Delivering to "</span> + filter + <span class="string">" : "</span> + r);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (filter.receiverList.app != <span class="keyword">null</span> &amp;&amp; filter.receiverList.app.inFullBackup) &#123;</span><br><span class="line">            <span class="comment">//【13】如果接收者的进程正在进行数据的备份和还原操作，那就跳过当前接收者！</span></span><br><span class="line">            <span class="comment">// 发送给下一个接收者，先 finishReceiverLocked，再 scheduleBroadcastsLocked！！</span></span><br><span class="line">            <span class="keyword">if</span> (ordered) &#123;</span><br><span class="line">                skipReceiverLocked(r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//【×2.5.1.3】发送广播，one way 异步传输，无需等待返回！</span></span><br><span class="line">            performReceiveLocked(filter.receiverList.app, filter.receiverList.receiver,</span><br><span class="line">                    <span class="keyword">new</span> Intent(r.intent), r.resultCode, r.resultData,</span><br><span class="line">                    r.resultExtras, r.ordered, r.initialSticky, r.userId);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【14】如果是有序广播，将广播状态置为 CALL_DONE_RECEIVE 已经接受！</span></span><br><span class="line">        <span class="keyword">if</span> (ordered) &#123;</span><br><span class="line">            <span class="comment">//【14.1】修改广播状态为 CALL_DONE_RECEIVE！</span></span><br><span class="line">            r.state = BroadcastRecord.CALL_DONE_RECEIVE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"Failure sending broadcast "</span> + r.intent, e);</span><br><span class="line">        <span class="keyword">if</span> (ordered) &#123;</span><br><span class="line">            r.receiver = <span class="keyword">null</span>;</span><br><span class="line">            r.curFilter = <span class="keyword">null</span>;</span><br><span class="line">            filter.receiverList.curBroadcast = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (filter.receiverList.app != <span class="keyword">null</span>) &#123;</span><br><span class="line">                filter.receiverList.app.curReceiver = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>整个方法的逻辑很简单！</p>
<h4 id="2-5-1-2-BroadcastQueue-addBroadcastToHistoryLocked"><a href="#2-5-1-2-BroadcastQueue-addBroadcastToHistoryLocked" class="headerlink" title="2.5.1.2 BroadcastQueue.addBroadcastToHistoryLocked"></a>2.5.1.2 BroadcastQueue.addBroadcastToHistoryLocked</h4><p>将分发的广播加入历史集合中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addBroadcastToHistoryLocked</span><span class="params">(BroadcastRecord r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r.callingUid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// This was from a registerReceiver() call; ignore it.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    r.finishTime = SystemClock.uptimeMillis();</span><br><span class="line"></span><br><span class="line">    mBroadcastHistory[mHistoryNext] = r;</span><br><span class="line">    mHistoryNext = ringAdvance(mHistoryNext, <span class="number">1</span>, MAX_BROADCAST_HISTORY);</span><br><span class="line"></span><br><span class="line">    mBroadcastSummaryHistory[mSummaryHistoryNext] = r.intent;</span><br><span class="line">    mSummaryHistoryEnqueueTime[mSummaryHistoryNext] = r.enqueueClockTime;</span><br><span class="line">    mSummaryHistoryDispatchTime[mSummaryHistoryNext] = r.dispatchClockTime;</span><br><span class="line">    mSummaryHistoryFinishTime[mSummaryHistoryNext] = System.currentTimeMillis();</span><br><span class="line">    mSummaryHistoryNext = ringAdvance(mSummaryHistoryNext, <span class="number">1</span>, MAX_BROADCAST_SUMMARY_HISTORY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-5-1-3-BroadcastQueue-performReceiveLocked"><a href="#2-5-1-3-BroadcastQueue-performReceiveLocked" class="headerlink" title="2.5.1.3 BroadcastQueue.performReceiveLocked"></a>2.5.1.3 BroadcastQueue.performReceiveLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">performReceiveLocked</span><span class="params">(ProcessRecord app, IIntentReceiver receiver,</span></span></span><br><span class="line"><span class="function"><span class="params">        Intent intent, <span class="keyword">int</span> resultCode, String data, Bundle extras,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> ordered, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> sendingUser)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (app != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//【×2.5.1.4】one-way 通过 Binder 通信，进入接收者所在的进程！</span></span><br><span class="line">                app.thread.scheduleRegisteredReceiver(receiver, intent, resultCode,</span><br><span class="line">                        data, extras, ordered, sticky, sendingUser, app.repProcState);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (mService) &#123;</span><br><span class="line">                    Slog.w(TAG, <span class="string">"Can't deliver broadcast to "</span> + app.processName</span><br><span class="line">                            + <span class="string">" (pid "</span> + app.pid + <span class="string">"). Crashing it."</span>);</span><br><span class="line">                    app.scheduleCrash(<span class="string">"can't deliver broadcast"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RemoteException(<span class="string">"app.thread must not be null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//【1】如果进程 app 为 null，这里会直接通过 binder 拉起相应方法！</span></span><br><span class="line">        receiver.performReceive(intent, resultCode, data, extras, ordered,</span><br><span class="line">                sticky, sendingUser);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里会调用 <code>ApplicationThreadProxy</code> 对象的 <code>scheduleRegisteredReceiver</code>！</p>
<p>这里就要进入接收者所在的进程了！</p>
<h4 id="2-5-1-4-ApplicationThreadP-scheduleRegisteredReceiver"><a href="#2-5-1-4-ApplicationThreadP-scheduleRegisteredReceiver" class="headerlink" title="2.5.1.4 ApplicationThreadP.scheduleRegisteredReceiver"></a>2.5.1.4 ApplicationThreadP.scheduleRegisteredReceiver</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleRegisteredReceiver</span><span class="params">(IIntentReceiver receiver, Intent intent,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> resultCode, String dataStr, Bundle extras, <span class="keyword">boolean</span> ordered,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> sendingUser, <span class="keyword">int</span> processState)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    Parcel data = Parcel.obtain();</span><br><span class="line">    data.writeInterfaceToken(IApplicationThread.descriptor);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里的 receiver 是动态注册的接收者在 AMS 中的 IIntentReceiver.Proxy 对象！</span></span><br><span class="line">    data.writeStrongBinder(receiver.asBinder());</span><br><span class="line">    intent.writeToParcel(data, <span class="number">0</span>);</span><br><span class="line">    data.writeInt(resultCode);</span><br><span class="line">    data.writeString(dataStr);</span><br><span class="line">    data.writeBundle(extras);</span><br><span class="line">    data.writeInt(ordered ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    data.writeInt(sticky ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    data.writeInt(sendingUser);</span><br><span class="line">    data.writeInt(processState);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Binder 通信：SCHEDULE_REGISTERED_RECEIVER_TRANSACTION</span></span><br><span class="line">    <span class="comment">// 这里是 FLAG_ONEWAY，异步传输，无需等待返回！</span></span><br><span class="line">    mRemote.transact(SCHEDULE_REGISTERED_RECEIVER_TRANSACTION, data, <span class="keyword">null</span>,</span><br><span class="line">            IBinder.FLAG_ONEWAY);</span><br><span class="line">    data.recycle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来就会进入接收者所在进程！</p>
<h3 id="2-5-2-发送给静态注册的接收者"><a href="#2-5-2-发送给静态注册的接收者" class="headerlink" title="2.5.2 发送给静态注册的接收者"></a>2.5.2 发送给静态注册的接收者</h3><p>对于静态注册的广播接收者（有序广播/普通广播），因为他的进程未必已经被启动，所以要分情况！</p>
<h4 id="2-5-2-1-进程已启动"><a href="#2-5-2-1-进程已启动" class="headerlink" title="2.5.2.1 进程已启动"></a>2.5.2.1 进程已启动</h4><p>如果接收者所在的进程被启动了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Is this receiver's application already running?</span></span><br><span class="line"> <span class="keyword">if</span> (app != <span class="keyword">null</span> &amp;&amp; app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         app.addPackage(info.activityInfo.packageName,</span><br><span class="line">                 info.activityInfo.applicationInfo.versionCode, mService.mProcessStats);</span><br><span class="line">         </span><br><span class="line">         <span class="comment">//【×2.5.2.1.1】那就调用 processCurBroadcastLocked 处理广播发送！</span></span><br><span class="line">         processCurBroadcastLocked(r, app);</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        </span><br><span class="line">     &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        </span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>我们继续看：</p>
<h5 id="2-5-2-1-1-BroadcastQueue-processCurBroadcastLocked"><a href="#2-5-2-1-1-BroadcastQueue-processCurBroadcastLocked" class="headerlink" title="2.5.2.1.1 BroadcastQueue.processCurBroadcastLocked"></a>2.5.2.1.1 BroadcastQueue.processCurBroadcastLocked</h5><p>发送当前的广播！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">processCurBroadcastLocked</span><span class="params">(BroadcastRecord r,</span></span></span><br><span class="line"><span class="function"><span class="params">        ProcessRecord app)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_BROADCAST)  Slog.v(TAG_BROADCAST,</span><br><span class="line">            <span class="string">"Process cur broadcast "</span> + r + <span class="string">" for app "</span> + app);</span><br><span class="line">    <span class="keyword">if</span> (app.thread == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RemoteException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】进程如果在进行备份还原操作，跳过该静态接收者！</span></span><br><span class="line">    <span class="keyword">if</span> (app.inFullBackup) &#123;</span><br><span class="line">        skipReceiverLocked(r);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【2】将广播的 r.receiver 设置为接收者进程的 ApplicationThreadProxy 对象！</span></span><br><span class="line">    r.receiver = app.thread.asBinder();</span><br><span class="line">    r.curApp = app;</span><br><span class="line">    app.curReceiver = r;</span><br><span class="line"></span><br><span class="line">    app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_RECEIVER);</span><br><span class="line">    mService.updateLruProcessLocked(app, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">    mService.updateOomAdjLocked();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【3】设置组件信息，由于前面 r.receiver 设置的是 ApplicationThreadProxy，</span></span><br><span class="line">    <span class="comment">// 所以为了拉起接收者，这里必须设置组件名！</span></span><br><span class="line">    r.intent.setComponent(r.curComponent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST,</span><br><span class="line">                <span class="string">"Delivering to component "</span> + r.curComponent</span><br><span class="line">                + <span class="string">": "</span> + r);</span><br><span class="line"></span><br><span class="line">        mService.notifyPackageUse(r.intent.getComponent().getPackageName(),</span><br><span class="line">                                  PackageManager.NOTIFY_PACKAGE_USE_BROADCAST_RECEIVER);</span><br><span class="line">                                  </span><br><span class="line">        <span class="comment">//【×3.2.1】通过 Binder 通信，进入应用进程，拉起接收者的 onReceive 方法！</span></span><br><span class="line">        <span class="comment">// one ways！</span></span><br><span class="line">        app.thread.scheduleReceiver(<span class="keyword">new</span> Intent(r.intent), r.curReceiver,</span><br><span class="line">                mService.compatibilityInfoForPackageLocked(r.curReceiver.applicationInfo),</span><br><span class="line">                r.resultCode, r.resultData, r.resultExtras, r.ordered, r.userId,</span><br><span class="line">                app.repProcState);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DEBUG_BROADCAST)  Slog.v(TAG_BROADCAST,</span><br><span class="line">                <span class="string">"Process cur broadcast "</span> + r + <span class="string">" DELIVERED for app "</span> + app);</span><br><span class="line"></span><br><span class="line">        started = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_BROADCAST)  Slog.v(TAG_BROADCAST,</span><br><span class="line">                    <span class="string">"Process cur broadcast "</span> + r + <span class="string">": NOT STARTED!"</span>);</span><br><span class="line">            r.receiver = <span class="keyword">null</span>;</span><br><span class="line">            r.curApp = <span class="keyword">null</span>;</span><br><span class="line">            app.curReceiver = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就会进入接收者所在的进程，我们后面再看！</p>
<h5 id="2-5-2-1-2-ApplicationThreadP-processCurBroadcastLocked"><a href="#2-5-2-1-2-ApplicationThreadP-processCurBroadcastLocked" class="headerlink" title="2.5.2.1.2 ApplicationThreadP.processCurBroadcastLocked"></a>2.5.2.1.2 ApplicationThreadP.processCurBroadcastLocked</h5><p>发送当前的广播！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleReceiver</span><span class="params">(Intent intent, ActivityInfo info,</span></span></span><br><span class="line"><span class="function"><span class="params">        CompatibilityInfo compatInfo, <span class="keyword">int</span> resultCode, String resultData,</span></span></span><br><span class="line"><span class="function"><span class="params">        Bundle map, <span class="keyword">boolean</span> sync, <span class="keyword">int</span> sendingUser, <span class="keyword">int</span> processState)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    Parcel data = Parcel.obtain();</span><br><span class="line">    data.writeInterfaceToken(IApplicationThread.descriptor);</span><br><span class="line">    intent.writeToParcel(data, <span class="number">0</span>);</span><br><span class="line">    info.writeToParcel(data, <span class="number">0</span>);</span><br><span class="line">    compatInfo.writeToParcel(data, <span class="number">0</span>);</span><br><span class="line">    data.writeInt(resultCode);</span><br><span class="line">    data.writeString(resultData);</span><br><span class="line">    data.writeBundle(map);</span><br><span class="line">    data.writeInt(sync ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    data.writeInt(sendingUser);</span><br><span class="line">    data.writeInt(processState);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【1】发送 SCHEDULE_RECEIVER_TRANSACTION 消息，one way！！</span></span><br><span class="line">    mRemote.transact(SCHEDULE_RECEIVER_TRANSACTION, data, <span class="keyword">null</span>,</span><br><span class="line">            IBinder.FLAG_ONEWAY);</span><br><span class="line">    data.recycle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面就进入了应用进程：</p>
<h4 id="2-5-2-2-进程未启动"><a href="#2-5-2-2-进程未启动" class="headerlink" title="2.5.2.2 进程未启动"></a>2.5.2.2 进程未启动</h4><p>对于进程没有启动这种情况，我们需要主动的拉起接收者所在的进程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((r.curApp=mService.startProcessLocked(targetProcess,</span><br><span class="line">        info.activityInfo.applicationInfo, <span class="keyword">true</span>,</span><br><span class="line">        r.intent.getFlags() | Intent.FLAG_FROM_BACKGROUND,</span><br><span class="line">        <span class="string">"broadcast"</span>, r.curComponent,</span><br><span class="line">        (r.intent.getFlags()&amp;Intent.FLAG_RECEIVER_BOOT_UPGRADE) != <span class="number">0</span>, <span class="keyword">false</span>, <span class="keyword">false</span>))</span><br><span class="line">                == <span class="keyword">null</span>) &#123;</span><br><span class="line">    ... ... ... ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//【1】将广播保存到 mPendingBroadcast 中！</span></span><br><span class="line">mPendingBroadcast = r;</span><br><span class="line">mPendingBroadcastRecvIndex = recIdx;</span><br></pre></td></tr></table></figure>
<p>对于进程的启动，我们这里不详细的介绍，请看其他的博文，这里我就直接上结果：</p>
<h5 id="2-5-2-2-1-ActivityManagerService-attachApplicationLocked"><a href="#2-5-2-2-1-ActivityManagerService-attachApplicationLocked" class="headerlink" title="2.5.2.2.1 ActivityManagerService.attachApplicationLocked"></a>2.5.2.2.1 ActivityManagerService.attachApplicationLocked</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">attachApplicationLocked</span><span class="params">(IApplicationThread thread,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> pid)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    ... ... ... ...</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【×2.5.2.2.1.1 】判读是否有等待该进程启动的广播</span></span><br><span class="line">    <span class="keyword">if</span> (!badApp &amp;&amp; isPendingBroadcastProcessLocked(pid)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【×2.5.2.2.1.2】发送广播！</span></span><br><span class="line">            didSomething |= sendPendingBroadcastsLocked(app);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// If the app died trying to launch the receiver we declare it 'bad'</span></span><br><span class="line">            Slog.wtf(TAG, <span class="string">"Exception thrown dispatching broadcasts in "</span> + app, e);</span><br><span class="line">            badApp = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ... ... ... ...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们继续来看：</p>
<h6 id="2-5-2-2-1-1-ActivityManagerS-isPendingBroadcastProcessLocked"><a href="#2-5-2-2-1-1-ActivityManagerS-isPendingBroadcastProcessLocked" class="headerlink" title="2.5.2.2.1.1 ActivityManagerS.isPendingBroadcastProcessLocked"></a>2.5.2.2.1.1 ActivityManagerS.isPendingBroadcastProcessLocked</h6><p>进程启动后，会判断该进程中是否有有需要分发的广播：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isPendingBroadcastProcessLocked</span><span class="params">(<span class="keyword">int</span> pid)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【×2.5.2.2.1.2】判读是否有等待该进程启动的广播</span></span><br><span class="line">    <span class="keyword">return</span> mFgBroadcastQueue.isPendingBroadcastProcessLocked(pid)</span><br><span class="line">            || mBgBroadcastQueue.isPendingBroadcastProcessLocked(pid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其实判断的依据很简单：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPendingBroadcastProcessLocked</span><span class="params">(<span class="keyword">int</span> pid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mPendingBroadcast != <span class="keyword">null</span> &amp;&amp; mPendingBroadcast.curApp.pid == pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果 <code>BroadcastQueue</code> 内部的 <code>mPendingBroadcast</code> 不为 <code>null</code>，且 <code>mPendingBroadcast.curApp.pid</code> 等于当前进程的 <code>pid</code>，就说明有目标为该进程的广播！</p>
<h6 id="2-5-2-2-1-2-ActivityManagerS-sendPendingBroadcastsLocked"><a href="#2-5-2-2-1-2-ActivityManagerS-sendPendingBroadcastsLocked" class="headerlink" title="2.5.2.2.1.2 ActivityManagerS.sendPendingBroadcastsLocked"></a>2.5.2.2.1.2 ActivityManagerS.sendPendingBroadcastsLocked</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">sendPendingBroadcastsLocked</span><span class="params">(ProcessRecord app)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> didSomething = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】遍历前台和后台广播队列！</span></span><br><span class="line">    <span class="keyword">for</span> (BroadcastQueue queue : mBroadcastQueues) &#123;</span><br><span class="line">        <span class="comment">//【×2.5.2.2.1.3】发送 pending broadcast！！</span></span><br><span class="line">        didSomething |= queue.sendPendingBroadcastsLocked(app);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> didSomething;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面我们去 <code>BroadcastQueue</code> 中去看看！</p>
<h6 id="2-5-2-2-1-3-BroadcastQueue-sendPendingBroadcastsLocked"><a href="#2-5-2-2-1-3-BroadcastQueue-sendPendingBroadcastsLocked" class="headerlink" title="2.5.2.2.1.3 BroadcastQueue.sendPendingBroadcastsLocked"></a>2.5.2.2.1.3 BroadcastQueue.sendPendingBroadcastsLocked</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendPendingBroadcastsLocked</span><span class="params">(ProcessRecord app)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> didSomething = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【1】将 mPendingBroadcast 赋给 br！</span></span><br><span class="line">    <span class="keyword">final</span> BroadcastRecord br = mPendingBroadcast;</span><br><span class="line">    <span class="keyword">if</span> (br != <span class="keyword">null</span> &amp;&amp; br.curApp.pid == app.pid) &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//【1】校验进程是否匹配！</span></span><br><span class="line">        <span class="keyword">if</span> (br.curApp != app) &#123;</span><br><span class="line">            Slog.e(TAG, <span class="string">"App mismatch when sending pending broadcast to "</span></span><br><span class="line">                    + app.processName + <span class="string">", intended target is "</span> + br.curApp.processName);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//【2】将 mPendingBroadcast 赋值为 null；</span></span><br><span class="line">            mPendingBroadcast = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【×2.5.2.1.1】发送广播！</span></span><br><span class="line">            processCurBroadcastLocked(br, app);</span><br><span class="line">            didSomething = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Exception in new application when starting receiver "</span></span><br><span class="line">                    + br.curComponent.flattenToShortString(), e);</span><br><span class="line"></span><br><span class="line">            logBroadcastReceiverDiscardLocked(br);</span><br><span class="line">            finishReceiverLocked(br, br.resultCode, br.resultData,</span><br><span class="line">                    br.resultExtras, br.resultAbort, <span class="keyword">false</span>);</span><br><span class="line">            scheduleBroadcastsLocked();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// We need to reset the state if we failed to start the receiver.</span></span><br><span class="line">            br.state = BroadcastRecord.IDLE;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> didSomething;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 <code>processCurBroadcastLocked</code> 又回到了进程已启动的发送流程了！！</p>
<h1 id="3-接收者进程"><a href="#3-接收者进程" class="headerlink" title="3 接收者进程"></a>3 接收者进程</h1><p>这里我们按照广播接收者的不同来分别看看：</p>
<h2 id="3-1-动态接收者进程"><a href="#3-1-动态接收者进程" class="headerlink" title="3.1 动态接收者进程"></a>3.1 动态接收者进程</h2><p>发送给动态注册的接收者有 <code>2</code> 种广播，首先会进入 <code>ApplicationThreadN</code> 中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> SCHEDULE_REGISTERED_RECEIVER_TRANSACTION: &#123;</span><br><span class="line">    data.enforceInterface(IApplicationThread.descriptor);</span><br><span class="line">    </span><br><span class="line">    IIntentReceiver receiver = IIntentReceiver.Stub.asInterface(</span><br><span class="line">            data.readStrongBinder());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里是将 IIntentReceiver Binder 对象转为 InnerReceiver 对象！</span></span><br><span class="line">    Intent intent = Intent.CREATOR.createFromParcel(data);</span><br><span class="line">    <span class="keyword">int</span> resultCode = data.readInt();</span><br><span class="line">    String dataStr = data.readString();</span><br><span class="line">    Bundle extras = data.readBundle();</span><br><span class="line">    <span class="keyword">boolean</span> ordered = data.readInt() != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> sticky = data.readInt() != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sendingUser = data.readInt();</span><br><span class="line">    <span class="keyword">int</span> processState = data.readInt();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【1】进入 ApplicationThread，调用 scheduleRegisteredReceiver 方法！</span></span><br><span class="line">    scheduleRegisteredReceiver(receiver, intent,</span><br><span class="line">            resultCode, dataStr, extras, ordered, sticky, sendingUser, processState);</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-1-1-ApplicationThread-scheduleRegisteredReceiver"><a href="#3-1-1-ApplicationThread-scheduleRegisteredReceiver" class="headerlink" title="3.1.1 ApplicationThread.scheduleRegisteredReceiver"></a>3.1.1 ApplicationThread.scheduleRegisteredReceiver</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleRegisteredReceiver</span><span class="params">(IIntentReceiver receiver, Intent intent,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> resultCode, String dataStr, Bundle extras, <span class="keyword">boolean</span> ordered,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> sendingUser, <span class="keyword">int</span> processState)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    updateProcessState(processState, <span class="keyword">false</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【×3.1.2】进入 InnerReceiver！</span></span><br><span class="line">    receiver.performReceive(intent, resultCode, dataStr, extras, ordered,</span><br><span class="line">            sticky, sendingUser);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-1-2-InnerReceiver-performReceive"><a href="#3-1-2-InnerReceiver-performReceive" class="headerlink" title="3.1.2 InnerReceiver.performReceive"></a>3.1.2 InnerReceiver.performReceive</h3><p>继续看：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performReceive</span><span class="params">(Intent intent, <span class="keyword">int</span> resultCode, String data,</span></span></span><br><span class="line"><span class="function"><span class="params">        Bundle extras, <span class="keyword">boolean</span> ordered, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> sendingUser)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> LoadedApk.ReceiverDispatcher rd;</span><br><span class="line">    <span class="keyword">if</span> (intent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Log.wtf(TAG, <span class="string">"Null intent received"</span>);</span><br><span class="line">        rd = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//【1】如果广播不为 null，就获得对应的 ReceiverDispatcher 对象，用于分发广播！</span></span><br><span class="line">        rd = mDispatcher.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ActivityThread.DEBUG_BROADCAST) &#123;</span><br><span class="line">        <span class="keyword">int</span> seq = intent.getIntExtra(<span class="string">"seq"</span>, -<span class="number">1</span>);</span><br><span class="line">        Slog.i(ActivityThread.TAG, <span class="string">"Receiving broadcast "</span> + intent.getAction()</span><br><span class="line">                + <span class="string">" seq="</span> + seq + <span class="string">" to "</span> + (rd != <span class="keyword">null</span> ? rd.mReceiver : <span class="keyword">null</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rd != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//【×3.1.3】调用 ReceiverDispatcher 的 performReceive 方法，分发广播！</span></span><br><span class="line">        rd.performReceive(intent, resultCode, data, extras,</span><br><span class="line">                ordered, sticky, sendingUser);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//【3】如果 rd 为 null，那就调用 AMS 的方法，立刻结束广播的发送！</span></span><br><span class="line">        <span class="keyword">if</span> (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG,</span><br><span class="line">                <span class="string">"Finishing broadcast to unregistered receiver"</span>);</span><br><span class="line">        IActivityManager mgr = ActivityManagerNative.getDefault();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (extras != <span class="keyword">null</span>) &#123;</span><br><span class="line">                extras.setAllowFds(<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//【4】调用了 ams 的 finish receiver 方法，这个方法我们在取消注册的时候会看！</span></span><br><span class="line">            mgr.finishReceiver(<span class="keyword">this</span>, resultCode, data, extras, <span class="keyword">false</span>, intent.getFlags());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-1-3-ReceiverDispatcher-performReceive"><a href="#3-1-3-ReceiverDispatcher-performReceive" class="headerlink" title="3.1.3 ReceiverDispatcher.performReceive"></a>3.1.3 ReceiverDispatcher.performReceive</h3><p>接着，进入 <code>ReceiverDispatcher</code>，我们都知道 <code>ReceiverDispatcher</code> 保存了 <code>BroadcastReceiver</code> 和 <code>InnerReceiver</code> 的映射关系：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performReceive</span><span class="params">(Intent intent, <span class="keyword">int</span> resultCode, String data,</span></span></span><br><span class="line"><span class="function"><span class="params">        Bundle extras, <span class="keyword">boolean</span> ordered, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> sendingUser)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【*3.1.3.1】创建了一个 Args 对象，用于封装广播参数信息！Args 继承了 Runnable 对象!</span></span><br><span class="line">    <span class="keyword">final</span> Args args = <span class="keyword">new</span> Args(intent, resultCode, data, extras, ordered,</span><br><span class="line">            sticky, sendingUser);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (intent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Log.wtf(TAG, <span class="string">"Null intent received"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ActivityThread.DEBUG_BROADCAST) &#123;</span><br><span class="line">            <span class="keyword">int</span> seq = intent.getIntExtra(<span class="string">"seq"</span>, -<span class="number">1</span>);</span><br><span class="line">            Slog.i(ActivityThread.TAG, <span class="string">"Enqueueing broadcast "</span> + intent.getAction()</span><br><span class="line">                    + <span class="string">" seq="</span> + seq + <span class="string">" to "</span> + mReceiver);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【×3.1.4】调用 mActivityThread.post 执行 Args 任务！post 如果返回 false，说明任务执行失败！</span></span><br><span class="line">    <span class="keyword">if</span> (intent == <span class="keyword">null</span> || !mActivityThread.post(args)) &#123;</span><br><span class="line">        <span class="comment">//【1】任务执行失败，如果该广播是通过有序的方式发送的，还要通知系统，广播已经分发完成！</span></span><br><span class="line">        <span class="comment">// 然后系统就会进行下一个广播的有序分发！</span></span><br><span class="line">        <span class="keyword">if</span> (mRegistered &amp;&amp; ordered) &#123;</span><br><span class="line">            IActivityManager mgr = ActivityManagerNative.getDefault();</span><br><span class="line">            <span class="keyword">if</span> (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG,</span><br><span class="line">                    <span class="string">"Finishing sync broadcast to "</span> + mReceiver);</span><br><span class="line">            <span class="comment">//【×3.3.2】调用了 args 父类 PendingResult 的 sendFinished 方法！</span></span><br><span class="line">            args.sendFinished(mgr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里我们回顾一下，采用有序的分发方式的广播有 <code>2</code> 种类型：</p>
<ul>
<li>目标是静态注册的接收者的普通广播；</li>
<li>另外一种是目标是静态或者动态注册的接收者的有序广播；</li>
</ul>
<p>这里的 <code>ordered</code> 如果是普通广播，那么为 <code>false</code>，如果是有序广播，那么为 <code>true</code>！</p>
<h4 id="3-1-3-1-new-Args"><a href="#3-1-3-1-new-Args" class="headerlink" title="3.1.3.1 new Args"></a>3.1.3.1 new Args</h4><p>创建了一个 Args 对象，其继承了 PendingResult：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Args</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span>.<span class="title">PendingResult</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Intent mCurIntent;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> mOrdered;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mDispatched;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Args</span><span class="params">(Intent intent, <span class="keyword">int</span> resultCode, String resultData, Bundle resultExtras,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> ordered, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> sendingUser)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【1】这里的 mIIntentReceiver 是 ReceiverDispatcher 的内部变量：InnerReceiver！</span></span><br><span class="line">        <span class="comment">// 显然，对于动态注册的接收者，mType 等于 TYPE_REGISTERED 或者 TYPE_UNREGISTERED；</span></span><br><span class="line">        <span class="keyword">super</span>(resultCode, resultData, resultExtras,</span><br><span class="line">                mRegistered ? TYPE_REGISTERED : TYPE_UNREGISTERED, ordered,</span><br><span class="line">                sticky, mIIntentReceiver.asBinder(), sendingUser, intent.getFlags());</span><br><span class="line"></span><br><span class="line">        mCurIntent = intent;</span><br><span class="line">        mOrdered = ordered;</span><br><span class="line">    &#125;</span><br><span class="line">    ... ... ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 <code>mRegistered</code> 是应用在动态注册接收者时，创建 <code>ReceiverDispatcher</code> 时设置为 <code>true</code> 的，这里显然为 <code>true</code>！</p>
<h3 id="3-1-4-Args-run"><a href="#3-1-4-Args-run" class="headerlink" title="3.1.4 Args.run"></a>3.1.4 Args.run</h3><p><code>mActivityThread.post</code> 方法，会在主线程执行任务 <code>Args</code>，下面我们来看看 <code>Args.run</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> BroadcastReceiver receiver = mReceiver;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> ordered = mOrdered; <span class="comment">// 是否有序！</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (ActivityThread.DEBUG_BROADCAST) &#123;</span><br><span class="line">        <span class="keyword">int</span> seq = mCurIntent.getIntExtra(<span class="string">"seq"</span>, -<span class="number">1</span>);</span><br><span class="line">        Slog.i(ActivityThread.TAG, <span class="string">"Dispatching broadcast "</span> + mCurIntent.getAction()</span><br><span class="line">                + <span class="string">" seq="</span> + seq + <span class="string">" to "</span> + mReceiver);</span><br><span class="line">        Slog.i(ActivityThread.TAG, <span class="string">"  mRegistered="</span> + mRegistered</span><br><span class="line">                + <span class="string">" mOrderedHint="</span> + ordered);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> IActivityManager mgr = ActivityManagerNative.getDefault();</span><br><span class="line">    <span class="keyword">final</span> Intent intent = mCurIntent;</span><br><span class="line">    <span class="keyword">if</span> (intent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Log.wtf(TAG, <span class="string">"Null intent being dispatched, mDispatched="</span> + mDispatched);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mCurIntent = <span class="keyword">null</span>;</span><br><span class="line">    mDispatched = <span class="keyword">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【1】如果动态注册的接收者为 null，或者广播为 null，或者已经通过 unregisterReceiver</span></span><br><span class="line">    <span class="comment">// 方法动态取消注册了接收者，并且如果是有序广播，就要通知系统，继续下一次分发！</span></span><br><span class="line">    <span class="keyword">if</span> (receiver == <span class="keyword">null</span> || intent == <span class="keyword">null</span> || mForgotten) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mRegistered &amp;&amp; ordered) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG,</span><br><span class="line">                    <span class="string">"Finishing null broadcast to "</span> + mReceiver);</span><br><span class="line">            <span class="comment">//【×3.3.2】调用了 args 父类 PendingResult 的 sendFinished 方法！</span></span><br><span class="line">            sendFinished(mgr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"broadcastReceiveReg"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//【2】通过反射的方式，拉起 onReceive 方法！</span></span><br><span class="line">        ClassLoader cl =  mReceiver.getClass().getClassLoader();</span><br><span class="line">        intent.setExtrasClassLoader(cl);</span><br><span class="line">        intent.prepareToEnterProcess();</span><br><span class="line">        setExtrasClassLoader(cl);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【3】设置 PendingResult 属性</span></span><br><span class="line">        receiver.setPendingResult(<span class="keyword">this</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【4】拉起 onReceive 方法！</span></span><br><span class="line">        receiver.onReceive(mContext, intent);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mRegistered &amp;&amp; ordered) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG,</span><br><span class="line">                    <span class="string">"Finishing failed broadcast to "</span> + mReceiver);</span><br><span class="line">            <span class="comment">//【×3.3.2】这里出现了异常，如果是有序广播，需要通知系统！</span></span><br><span class="line">            <span class="comment">// 调用了 args 父类 PendingResult 的 sendFinished 方法！</span></span><br><span class="line">            sendFinished(mgr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mInstrumentation == <span class="keyword">null</span> ||</span><br><span class="line">                !mInstrumentation.onException(mReceiver, e)) &#123;</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Error receiving broadcast "</span> + intent</span><br><span class="line">                + <span class="string">" in "</span> + mReceiver, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【3】显然，这里不为 null，调用 finish 结束广播！</span></span><br><span class="line">    <span class="keyword">if</span> (receiver.getPendingResult() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//【×3.3.1】调用了父类的 finish 方法！</span></span><br><span class="line">        finish();</span><br><span class="line">    &#125;</span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>mForgotten</code> 属性是在 <code>unregisterReceiver</code> 的时候被置为 <code>true</code> 的，这里终于进入了 <code>BroadcastReceiver</code> 的 <code>onReceive</code> 方法！</p>
<h2 id="3-2-静态接收者进程"><a href="#3-2-静态接收者进程" class="headerlink" title="3.2 静态接收者进程"></a>3.2 静态接收者进程</h2><p>发送给静态注册的接收者也有 <code>2</code> 种广播，首先会进入 <code>ApplicationThreadN</code> 中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> SCHEDULE_RECEIVER_TRANSACTION:</span><br><span class="line">&#123;</span><br><span class="line">    data.enforceInterface(IApplicationThread.descriptor);</span><br><span class="line">    Intent intent = Intent.CREATOR.createFromParcel(data);</span><br><span class="line">    ActivityInfo info = ActivityInfo.CREATOR.createFromParcel(data);</span><br><span class="line">    CompatibilityInfo compatInfo = CompatibilityInfo.CREATOR.createFromParcel(data);</span><br><span class="line">    <span class="keyword">int</span> resultCode = data.readInt();</span><br><span class="line">    String resultData = data.readString();</span><br><span class="line">    Bundle resultExtras = data.readBundle();</span><br><span class="line">    <span class="keyword">boolean</span> sync = data.readInt() != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sendingUser = data.readInt();</span><br><span class="line">    <span class="keyword">int</span> processState = data.readInt();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【1】进入 ApplicationThread 的 scheduleReceiver 方法！</span></span><br><span class="line">    scheduleReceiver(intent, info, compatInfo, resultCode, resultData,</span><br><span class="line">            resultExtras, sync, sendingUser, processState);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-1-ApplicationThread-scheduleReceiver"><a href="#3-2-1-ApplicationThread-scheduleReceiver" class="headerlink" title="3.2.1 ApplicationThread.scheduleReceiver"></a>3.2.1 ApplicationThread.scheduleReceiver</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleReceiver</span><span class="params">(Intent intent, ActivityInfo info,</span></span></span><br><span class="line"><span class="function"><span class="params">        CompatibilityInfo compatInfo, <span class="keyword">int</span> resultCode, String data, Bundle extras,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> sync, <span class="keyword">int</span> sendingUser, <span class="keyword">int</span> processState)</span> </span>&#123;</span><br><span class="line">    updateProcessState(processState, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【×3.2.1.1】创建了一个 ReceiverData 对象！</span></span><br><span class="line">    <span class="comment">// mAppThread 是当前进程的 ApplicationThread 对象，是一个 Binder 对象！</span></span><br><span class="line">    ReceiverData r = <span class="keyword">new</span> ReceiverData(intent, resultCode, data, extras,</span><br><span class="line">            sync, <span class="keyword">false</span>, mAppThread.asBinder(), sendingUser);</span><br><span class="line">    r.info = info;</span><br><span class="line">    r.compatInfo = compatInfo;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【×3.2.2】发送 H.RECEIVER 给主线程！</span></span><br><span class="line">    sendMessage(H.RECEIVER, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里创建了一个 <code>ReceiverData</code> 对象，用来封装接收者的数据信息！</p>
<h4 id="3-2-1-1-new-ReceiverData"><a href="#3-2-1-1-new-ReceiverData" class="headerlink" title="3.2.1.1 new ReceiverData"></a>3.2.1.1 new ReceiverData</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiverData</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span>.<span class="title">PendingResult</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReceiverData</span><span class="params">(Intent intent, <span class="keyword">int</span> resultCode, String resultData, Bundle resultExtras,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">boolean</span> ordered, <span class="keyword">boolean</span> sticky, IBinder token, <span class="keyword">int</span> sendingUser)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这个地方，传入的是 TYPE_COMPONENT，即 mType 是 TYPE_COMPONENT！</span></span><br><span class="line">        <span class="keyword">super</span>(resultCode, resultData, resultExtras, TYPE_COMPONENT, ordered, sticky,</span><br><span class="line">                token, sendingUser, intent.getFlags());</span><br><span class="line">        <span class="keyword">this</span>.intent = intent;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 广播 Intent 对象！</span></span><br><span class="line">    Intent intent;</span><br><span class="line">    <span class="comment">// 接收者的信息 ActivityInfo 对象！</span></span><br><span class="line">    ActivityInfo info;</span><br><span class="line">    CompatibilityInfo compatInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ReceiverData</code> 继承了 <code>BroadcastReceiver.PendingResult</code> 对象，用来封装静态接收者的数据信息！</p>
<p>这里就和 Args 类似了！</p>
<h3 id="3-2-2-H-handleMessage"><a href="#3-2-2-H-handleMessage" class="headerlink" title="3.2.2 H.handleMessage"></a>3.2.2 H.handleMessage</h3><p>我们去看看主线程 Handler H 是如何处理 H.RECEIVER 消息的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">H</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_MESSAGES) Slog.v(TAG, <span class="string">"&gt;&gt;&gt; handling: "</span> + codeToString(msg.what));</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="keyword">case</span> RECEIVER:</span><br><span class="line">                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"broadcastReceiveComp"</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//【×3.2.3】调用 handleReceiver 处理广播！</span></span><br><span class="line">                handleReceiver((ReceiverData)msg.obj);</span><br><span class="line"></span><br><span class="line">                maybeSnapshot();</span><br><span class="line">                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-3-ActivityThread-handleReceiver"><a href="#3-2-3-ActivityThread-handleReceiver" class="headerlink" title="3.2.3 ActivityThread.handleReceiver"></a>3.2.3 ActivityThread.handleReceiver</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleReceiver</span><span class="params">(ReceiverData data)</span> </span>&#123;</span><br><span class="line">    unscheduleGcIdler();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】获得组件名，用于反射！</span></span><br><span class="line">    String component = data.intent.getComponent().getClassName();</span><br><span class="line"></span><br><span class="line">    LoadedApk packageInfo = getPackageInfoNoCheck(</span><br><span class="line">            data.info.applicationInfo, data.compatInfo);</span><br><span class="line"></span><br><span class="line">    IActivityManager mgr = ActivityManagerNative.getDefault();</span><br><span class="line"> </span><br><span class="line">    BroadcastReceiver receiver;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【2】通过反射获得 BroadcastReceiver 对象的实例！</span></span><br><span class="line">        java.lang.ClassLoader cl = packageInfo.getClassLoader();</span><br><span class="line">        data.intent.setExtrasClassLoader(cl);</span><br><span class="line">        data.intent.prepareToEnterProcess();</span><br><span class="line">        data.setExtrasClassLoader(cl);</span><br><span class="line">        receiver = (BroadcastReceiver)cl.loadClass(component).newInstance();</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.i(TAG,</span><br><span class="line">                <span class="string">"Finishing failed broadcast to "</span> + data.intent.getComponent());</span><br><span class="line">        data.sendFinished(mgr);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">            <span class="string">"Unable to instantiate receiver "</span> + component</span><br><span class="line">            + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//【3】获得 Application 的上下文运行环境！</span></span><br><span class="line">        Application app = packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (localLOGV) Slog.v(</span><br><span class="line">            TAG, <span class="string">"Performing receive of "</span> + data.intent</span><br><span class="line">            + <span class="string">": app="</span> + app</span><br><span class="line">            + <span class="string">", appName="</span> + app.getPackageName()</span><br><span class="line">            + <span class="string">", pkg="</span> + packageInfo.getPackageName()</span><br><span class="line">            + <span class="string">", comp="</span> + data.intent.getComponent().toShortString()</span><br><span class="line">            + <span class="string">", dir="</span> + packageInfo.getAppDir());</span><br><span class="line"></span><br><span class="line">        ContextImpl context = (ContextImpl)app.getBaseContext();</span><br><span class="line">        sCurrentBroadcastIntent.set(data.intent);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【4】设置接收者的 PendingResult 属性！</span></span><br><span class="line">        receiver.setPendingResult(data);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【5】拉起广播接收者的 onReceive 方法！！</span></span><br><span class="line">        receiver.onReceive(context.getReceiverRestrictedContext(),</span><br><span class="line">                data.intent);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.i(TAG,</span><br><span class="line">                <span class="string">"Finishing failed broadcast to "</span> + data.intent.getComponent());</span><br><span class="line">        <span class="comment">//【×3.3.2】异常情况直接返回！     </span></span><br><span class="line">        data.sendFinished(mgr);</span><br><span class="line">        <span class="keyword">if</span> (!mInstrumentation.onException(receiver, e)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Unable to start receiver "</span> + component</span><br><span class="line">                + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        sCurrentBroadcastIntent.set(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【6】调用 ReceiverData 的 finish 函数，通知 AMS 广播处理完成！</span></span><br><span class="line">    <span class="keyword">if</span> (receiver.getPendingResult() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//【×3.3.1】实际上调用了 PendingResult 的 finish 方法！</span></span><br><span class="line">        data.finish();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面，我们进入到 <code>ReceiverData</code> 中去！！</p>
<h2 id="3-3-PendingResult"><a href="#3-3-PendingResult" class="headerlink" title="3.3 PendingResult"></a>3.3 PendingResult</h2><h3 id="3-3-1-PendingResult-finish"><a href="#3-3-1-PendingResult-finish" class="headerlink" title="3.3.1 PendingResult.finish"></a>3.3.1 PendingResult.finish</h3><p>接着，调用 <code>PendingResult .finish</code> 结束广播的分发，通知系统继续广播的分发！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">finish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果 mType 为 TYPE_COMPONENT，静态接收者，进入 IF 分支！</span></span><br><span class="line">    <span class="keyword">if</span> (mType == TYPE_COMPONENT) &#123;</span><br><span class="line">        <span class="keyword">final</span> IActivityManager mgr = ActivityManagerNative.getDefault();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 若主线程的 QueuedWork 中有事情还未处理完，则必须让事情做完后，才通知 AMS 结果！</span></span><br><span class="line">        <span class="keyword">if</span> (QueuedWork.hasPendingWork()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建一个任务，通过 singleThreadExecutor 单线程依次执行！</span></span><br><span class="line">            QueuedWork.singleThreadExecutor().execute( <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG,</span><br><span class="line">                            <span class="string">"Finishing broadcast after work to component "</span> + mToken);</span><br><span class="line">                    sendFinished(mgr);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG,</span><br><span class="line">                    <span class="string">"Finishing broadcast to component "</span> + mToken);</span><br><span class="line">                    </span><br><span class="line">                    </span><br><span class="line">            <span class="comment">//【×3.3.2】如果主线程无等待处理的事件，直接通知 AMS 结果！</span></span><br><span class="line">            sendFinished(mgr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mOrderedHint &amp;&amp; mType != TYPE_UNREGISTERED) &#123;</span><br><span class="line">        <span class="comment">//【1】如果 mType 为 TYPE_REGISTERED : TYPE_UNREGISTERED，动态接收者，</span></span><br><span class="line">        <span class="comment">// 所以会进入 ELSE IF， mOrderedHint 为 true，表示为有序广播，此时我们需要通知系统！！</span></span><br><span class="line">        <span class="keyword">if</span> (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG,</span><br><span class="line">                <span class="string">"Finishing broadcast to "</span> + mToken);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> IActivityManager mgr = ActivityManagerNative.getDefault();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【×3.3.2】发送结果！</span></span><br><span class="line">        sendFinished(mgr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>mOrderedHint</code> 是创建 <code>Args</code> 时赋值初始化的，他是父类 <code>PendingResult</code> 的成员变量，表示该广播是否是有序的！</p>
<h3 id="3-3-2-PendingResult-sendFinished"><a href="#3-3-2-PendingResult-sendFinished" class="headerlink" title="3.3.2 PendingResult.sendFinished"></a>3.3.2 PendingResult.sendFinished</h3><p>无论是 <code>Args</code>，还是 <code>ReceiverData</code> 他们都继承了 <code>PendingResult</code> 类，<code>sendFinished</code> 的实现是在 <code>PendingResult</code> 类中！</p>
<p>通过上面的方法可以看到，静态接收者由于都是有序分发，所以都要回调通知；但是动态接收者，只有广播是有序广播，才会回调通知系统，普通广播是不需要回调系统的！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendFinished</span><span class="params">(IActivityManager am)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">//【1】判断是否已经 finish 过，会抛出异常！</span></span><br><span class="line">        <span class="keyword">if</span> (mFinished) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Broadcast already finished"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mFinished = <span class="keyword">true</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (mResultExtras != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mResultExtras.setAllowFds(<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//【1】有序发送的广播，mOrderedHint 为 true，进入该分支！</span></span><br><span class="line">            <span class="comment">// mAbortBroadcast 表示是否终止该广播的继续分发！</span></span><br><span class="line">            <span class="comment">// mOrderedHint 表示该广播是否是有序发送的！</span></span><br><span class="line">            <span class="keyword">if</span> (mOrderedHint) &#123;</span><br><span class="line">                am.finishReceiver(mToken, mResultCode, mResultData, mResultExtras,</span><br><span class="line">                        mAbortBroadcast, mFlags);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 普通广播但是是发送给静态接收者的，也会回调系统！</span></span><br><span class="line">                am.finishReceiver(mToken, <span class="number">0</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>, mFlags);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 <code>mToken</code> 要注意一下：</p>
<ul>
<li>如果是动态注册的接收者，<code>mToken</code> 是 <code>InnerReceiver</code> 对象；</li>
<li>如果是静态注册的接收者，<code>mToken</code> 是 <code>ApplicationThread</code> 对象；</li>
</ul>
<p>这里的 <code>mAbortBroadcast</code> 表示是否终止该广播的继续分发，对于有序发送的广播来说，当一个接收者接收到了该广播，可以通过以下方式来设置是否终止该广播的继续传递：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">abortBroadcast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    checkSynchronousHint();</span><br><span class="line">    mPendingResult.mAbortBroadcast = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以及：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public final void clearAbortBroadcast() &#123;</span><br><span class="line">    if (mPendingResult != null) &#123;</span><br><span class="line">        mPendingResult.mAbortBroadcast = false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面就会进入系统进程！</p>
<h1 id="4-系统进程"><a href="#4-系统进程" class="headerlink" title="4 系统进程"></a>4 系统进程</h1><p>通过前面的分析，我们知道以下 2 种广播是通过有序的方式发送的：</p>
<ul>
<li>目标是静态接收者的普通广播；</li>
<li>有序广播；</li>
</ul>
<p>下面我们来看看有序发送的广播的后事处理：</p>
<h2 id="4-1-ActivityManagerS-finishReceiver"><a href="#4-1-ActivityManagerS-finishReceiver" class="headerlink" title="4.1 ActivityManagerS.finishReceiver"></a>4.1 ActivityManagerS.finishReceiver</h2><p>参数 IBinder who 表示的是句柄，代表我们广播的目标客户端！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finishReceiver</span><span class="params">(IBinder who, <span class="keyword">int</span> resultCode, String resultData,</span></span></span><br><span class="line"><span class="function"><span class="params">        Bundle resultExtras, <span class="keyword">boolean</span> resultAbort, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, <span class="string">"Finish receiver: "</span> + who);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】不能传递文件描述符！</span></span><br><span class="line">    <span class="keyword">if</span> (resultExtras != <span class="keyword">null</span> &amp;&amp; resultExtras.hasFileDescriptors()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"File descriptors passed in Bundle"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> doNext = <span class="keyword">false</span>;</span><br><span class="line">        BroadcastRecord r;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">//【2】根据广播的 Intent 是否设置了 FLAG_RECEIVER_FOREGROUND 标志位，选择前台/后台队列！</span></span><br><span class="line">            BroadcastQueue queue = (flags &amp; Intent.FLAG_RECEIVER_FOREGROUND) != <span class="number">0</span></span><br><span class="line">                    ? mFgBroadcastQueue : mBgBroadcastQueue;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//【×4.1.1】接着是在 mOrderedBroadcasts 匹配到 who 对应的广播，也就是我们这次分发的广播！</span></span><br><span class="line">            r = queue.getMatchingOrderedReceiver(who);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//【×4.1.2】判断是否需要继续分发该广播！</span></span><br><span class="line">                doNext = r.queue.finishReceiverLocked(r, resultCode,</span><br><span class="line">                    resultData, resultExtras, resultAbort, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【3】如果 doNext 为 true，继续下一次分发！</span></span><br><span class="line">        <span class="keyword">if</span> (doNext) &#123;</span><br><span class="line">            r.queue.processNextBroadcast(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 回收资源！</span></span><br><span class="line">        trimApplications();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>流程很简单，不多说了！</p>
<h3 id="4-1-1-BroadcastQueue-getMatchingOrderedReceiver"><a href="#4-1-1-BroadcastQueue-getMatchingOrderedReceiver" class="headerlink" title="4.1.1 BroadcastQueue.getMatchingOrderedReceiver"></a>4.1.1 BroadcastQueue.getMatchingOrderedReceiver</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BroadcastRecord <span class="title">getMatchingOrderedReceiver</span><span class="params">(IBinder receiver)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mOrderedBroadcasts.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> BroadcastRecord r = mOrderedBroadcasts.get(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//【1】匹配接收者处理的广播，并返回！</span></span><br><span class="line">        <span class="keyword">if</span> (r != <span class="keyword">null</span> &amp;&amp; r.receiver == receiver) &#123;</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>getMatchingOrderedReceiver</code> 逻辑很简单，这里就不多说了！</p>
<h3 id="4-1-2-BroadcastQueue-finishReceiverLocked"><a href="#4-1-2-BroadcastQueue-finishReceiverLocked" class="headerlink" title="4.1.2 BroadcastQueue.finishReceiverLocked"></a>4.1.2 BroadcastQueue.finishReceiverLocked</h3><p>接下来看看 finishReceiverLocked 方法做了什么！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">finishReceiverLocked</span><span class="params">(BroadcastRecord r, <span class="keyword">int</span> resultCode,</span></span></span><br><span class="line"><span class="function"><span class="params">        String resultData, Bundle resultExtras, <span class="keyword">boolean</span> resultAbort, <span class="keyword">boolean</span> waitForServices)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】保存之前的状态！</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> state = r.state;</span><br><span class="line">    <span class="keyword">final</span> ActivityInfo receiver = r.curReceiver;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【2】初始化广播的一些变量！</span></span><br><span class="line">    r.state = BroadcastRecord.IDLE;</span><br><span class="line">    <span class="keyword">if</span> (state == BroadcastRecord.IDLE) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"finishReceiver ["</span> + mQueueName + <span class="string">"] called but state is IDLE"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【3】将 r.receiver 置为 null，因为该接收者已经处理完了广播！</span></span><br><span class="line">    r.receiver = <span class="keyword">null</span>;</span><br><span class="line">    r.intent.setComponent(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.curApp != <span class="keyword">null</span> &amp;&amp; r.curApp.curReceiver == r) &#123;</span><br><span class="line">        r.curApp.curReceiver = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r.curFilter != <span class="keyword">null</span>) &#123;</span><br><span class="line">        r.curFilter.receiverList.curBroadcast = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    r.curFilter = <span class="keyword">null</span>;</span><br><span class="line">    r.curReceiver = <span class="keyword">null</span>;</span><br><span class="line">    r.curApp = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【4】将 mPendingBroadcast 置为 null;</span></span><br><span class="line">    mPendingBroadcast = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    r.resultCode = resultCode;</span><br><span class="line">    r.resultData = resultData;</span><br><span class="line">    r.resultExtras = resultExtras;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【5】判断是否需要终止该广播的继续分发！</span></span><br><span class="line">    <span class="comment">// 当 resultAbort 为 true，且广播没有设置 Intent.FLAG_RECEIVER_NO_ABORT 标志位，</span></span><br><span class="line">    <span class="comment">// 那么该广播就会终止继续传递！</span></span><br><span class="line">    <span class="keyword">if</span> (resultAbort &amp;&amp; (r.intent.getFlags()&amp;Intent.FLAG_RECEIVER_NO_ABORT) == <span class="number">0</span>) &#123;</span><br><span class="line">        r.resultAbort = resultAbort;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        r.resultAbort = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【6】这里的 waitForServices 传入的是 true，对于后台队列来说 mDelayBehindServices 为 true！</span></span><br><span class="line">    <span class="keyword">if</span> (waitForServices &amp;&amp; r.curComponent != <span class="keyword">null</span> &amp;&amp; r.queue.mDelayBehindServices</span><br><span class="line">            &amp;&amp; r.queue.mOrderedBroadcasts.size() &gt; <span class="number">0</span></span><br><span class="line">            &amp;&amp; r.queue.mOrderedBroadcasts.get(<span class="number">0</span>) == r) &#123;</span><br><span class="line"></span><br><span class="line">        ActivityInfo nextReceiver;</span><br><span class="line">        <span class="keyword">if</span> (r.nextReceiver &lt; r.receivers.size()) &#123;</span><br><span class="line">            <span class="comment">//【6.1】计算下一个接收者！</span></span><br><span class="line">            Object obj = r.receivers.get(r.nextReceiver);</span><br><span class="line">            nextReceiver = (obj <span class="keyword">instanceof</span> ActivityInfo) ? (ActivityInfo)obj : <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            nextReceiver = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果本次接受广播的接收者和下一个接收者不在同一个进程，或者下一个接收者为 null</span></span><br><span class="line">        <span class="keyword">if</span> (receiver == <span class="keyword">null</span> || nextReceiver == <span class="keyword">null</span></span><br><span class="line">                || receiver.applicationInfo.uid != nextReceiver.applicationInfo.uid</span><br><span class="line">                || !receiver.processName.equals(nextReceiver.processName)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对于后台队列中的有序发送的广播，如果广播的目标设别用户下有需要后台延迟启动的服务</span></span><br><span class="line">            <span class="comment">// 那就不能继续分发，这里会将广播的状态改为 BroadcastRecord.WAITING_SERVICES，返回 false！</span></span><br><span class="line">            <span class="keyword">if</span> (mService.mServices.hasBackgroundServices(r.userId)) &#123;</span><br><span class="line">                Slog.i(TAG, <span class="string">"Delay finish: "</span> + r.curComponent.flattenToShortString());。。。。</span><br><span class="line">                r.state = BroadcastRecord.WAITING_SERVICES;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r.curComponent = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【7】前面我们知道，由于发送广播是异步操作，所以正常情况发送前，状态就改为了下面的状态；</span></span><br><span class="line">    <span class="comment">// 这是返回的是 true，那么 doNext 就是 true；如果需要等待 Service 启动，那么状态就为 WAITING_SERVICES；</span></span><br><span class="line">    <span class="comment">// 此时 doNext 就为 false；</span></span><br><span class="line">    <span class="keyword">return</span> state == BroadcastRecord.APP_RECEIVE</span><br><span class="line">            || state == BroadcastRecord.CALL_DONE_RECEIVE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于静态注册的接收者 r.state 被置为 BroadcastRecord.APP_RECEIVE；<br>对于动态注册的接收者 r.state 被置为 BroadcastRecord.CALL_DONE_RECEIVE；</p>
<p>这里的 <code>r.queue.mDelayBehindServices</code> 要解释一下，他是在创建前台和后台队列时初始化的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mFgBroadcastQueue = <span class="keyword">new</span> BroadcastQueue(<span class="keyword">this</span>, mHandler, <span class="string">"foreground"</span>, BROADCAST_FG_TIMEOUT, <span class="keyword">false</span>);</span><br><span class="line">mBgBroadcastQueue = <span class="keyword">new</span> BroadcastQueue(<span class="keyword">this</span>, mHandler, <span class="string">"background"</span>, BROADCAST_BG_TIMEOUT, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure></p>
<p>可以看到，对于后台队列，其 mDelayBehindServices 为 true！表示如果有后台延迟启动的服务，就延迟广播的发送！</p>
<p>那么我们如何判断目标设备用户下是否有后台延迟发送的广播，这就要调用 ActiveServices 的 hasBackgroundServices 方法了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasBackgroundServices</span><span class="params">(<span class="keyword">int</span> callingUser)</span> </span>&#123;</span><br><span class="line">    ServiceMap smap = mServiceMap.get(callingUser);</span><br><span class="line">    <span class="keyword">return</span> smap != <span class="keyword">null</span> ? smap.mStartingBackground.size() &gt;= mMaxStartingBackground : <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>和 <code>Service</code> 的生命周期相关的内容，请去看其他的博客！</p>
<p>最后又再次回到了 <code>processNextBroadcast</code> 方法中了！</p>
<h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h1><p>到这里，<code>sendBroadcast</code> 方法的流程就分析完了，下面我们来总结一下：</p>
<h2 id="5-1-广播的处理流程"><a href="#5-1-广播的处理流程" class="headerlink" title="5.1 广播的处理流程"></a>5.1 广播的处理流程</h2><p>在发送广播之前，都需要收集其目标接收者，包括静态接收者和动态接收者！</p>
<p>如果广播设置了 <code>Intent.FLAG_RECEIVER_FOREGROUND</code> 标志位，会被添加到前台队列 <code>mFgBroadcastQueue</code> 中，否则就被添加到后台队列 <code>mBgBroadcastQueue</code> 中！</p>
<p>如果广播设置了 <code>Intent.FLAG_RECEIVER_NO_ABORT</code> 标志位，有序发送的情况下不能被强制中断分发！</p>
<h3 id="5-1-1-普通广播的处理流程"><a href="#5-1-1-普通广播的处理流程" class="headerlink" title="5.1.1 普通广播的处理流程"></a>5.1.1 普通广播的处理流程</h3><ul>
<li><strong>1</strong> 先发送给<strong>动态接收者</strong>，并行分发，广播会被加入到 <code>mParallelBroadcasts</code> 集合中，通过一个 <code>while</code> 循环，不断遍历 <code>mParallelBroadcasts</code>，直到为空 。<ul>
<li><strong>1.1</strong> 设置广播开始分发时间：<code>r.dispatchTime = SystemClock.uptimeMillis();</code> 和 <code>r.dispatchClockTime = System.currentTimeMillis();</code></li>
<li><strong>1.2</strong> 设置当前接收者的分发状态：<code>r.delivery[index] = BroadcastRecord.DELIVERY_DELIVERED</code></li>
<li><strong>1.3</strong> 对于动态接收者来说，系统进程保存着其 <code>IIntentReceiver.Proxy</code> 对象！</li>
<li><strong>1.4</strong> 通过 <code>app.thread.scheduleRegisteredReceiver</code>，进入应用进程，调用 <code>InnerReceiver.performReceive</code> 拉起广播接收者的 <code>onReceive</code> 方法！如果 <code>app = null</code>，就直接通过 <code>IIntentReceiver.Proxy.performReceive</code>，进入应用进程！<pre><code>- **1.4.1** 这时会创建一个 `Args` 对象（继承了 `BroadcastReceiver.PendingResult` 实现了 `Runnable`），通过主线程执行 `Args.run` 方法！
- **1.4.2** `PendingResult` 有一个内部成员变量 `mType`，用来保存接收者的类型，对于动态接收者：`mType = TYPE_REGISTERED/TYPE_UNREGISTERED`！
- **1.4.3** 最后通过反射，拉起 `onReceive` 方法！
</code></pre></li>
</ul>
</li>
</ul>
<p><br>    </p>
<ul>
<li><p><strong>2</strong> 然后发送给<strong>静态接收者</strong>，广播会被加入到 <code>mOrderedBroadcasts</code> 集合中，有序发送！</p>
<ul>
<li><strong>2.1</strong> 如果已经有一个正在等待目标进程启动的广播 <code>mPendingBroadcast</code>，那就等待对应进程启动后处理！</li>
<li><strong>2.2</strong> 否则，计算本次该广播要分发的接收者的序号：<code>recIdx</code>，和下一个接收者的序号：<code>r.nextReceiver</code>，二者满足：<code>int recIdx = r.nextReceiver++</code></li>
<li><p><strong>2.3</strong> 设置广播开始分发时间（当 <code>recIdx</code> 为第一个接收者的时候）<code>r.dispatchTime = r.receiverTime;　r.dispatchClockTime = System.currentTimeMillis();</code></p>
<ul>
<li>设置当前接收者的分发状态：<code>r.delivery[recIdx] = BroadcastRecord.DELIVERY_DELIVERED;</code></li>
<li>设置广播的当前状态：<code>r.state = BroadcastRecord.APP_RECEIVE;</code></li>
<li>设置广播当前的目标组件：<code>r.curComponent = component;</code></li>
<li>设置广播当前的目标接收者：<code>r.curReceiver = info.activityInfo;</code></li>
</ul>
</li>
<li><p><strong>2.4</strong> 对于静态接收者，发送广播时候，其进程未必启动，所以要分情况处理：</p>
<pre><code>- **2.4.1** 如果进程未启动，就先启动其进程，并将广播添加到 `mPendingBroadcast` 中，等待进程启动后处理！
     进程启动后，会判断当前进程是否有 `mPendingBroadcast`，有的话，就将 `mPendingBroadcast` 发送目标接收者（2.4.2），并设置 `mPendingBroadcast = null;`！

  &lt;/br&gt;

- **2.4.2** 如果进程已启动，那就直接发送广播！
     - 设置广播的目标接收者通信对象：`r.receiver = app.thread.asBinder();`，即目标进程的 `ApplicationThreadProxy` 对象！
     - 设置广播的目标进程：`r.curApp = app;`
     - 设置目标进程的当前要接收广播的接收者：`app.curReceiver = r;`
     - 设置广播的组件信息；`r.intent.setComponent(r.curComponent);`

     - 通过 `app.thread.scheduleReceiver`，跨进程拉起接收者的 `onReceive` 方法！
         - 进入应用进程后，会创建一个 `ReceiverData` 对象（其继承了 `BroadcastReceiver.PendingResult`）
         - `PendingResult` 有一个内部成员变量 `mType`，用来保存接收者的类型，对于静态接收者：`mType =  TYPE_COMPONENT`！
         - 最后通过反射，拉起 `onReceive` 方法！
</code></pre></li>
<li><p><strong>2.5</strong> 最后，调用 <code>ActivityManagerService.finishReceiver</code>，通知系统进程，接收者完成了广播处理，继续分发!！</p>
<ul>
<li><p>初始化广播的状态：<code>r.state = BroadcastRecord.IDLE;</code></p>
<ul>
<li>清空广播的目标接收者：<code>Binder</code> 对象：<code>r.receiver = null;</code></li>
<li>清空广播组件信息：<code>r.intent.setComponent(null);</code></li>
<li>清空广播目标进程的当前接收者：<code>r.curApp.curReceiver = null;</code></li>
<li><p>清空广播过滤器的当前广播：<code>r.curFilter.receiverList.curBroadcast = null;</code></p>
</li>
<li><p>清空广播的过滤器：<code>r.curFilter = null;</code></p>
</li>
<li>清空广播接收者信息：<code>r.curReceiver = null;</code></li>
<li>清空广播的目标进程：<code>r.curApp = null;</code></li>
<li>清空广播的组件信息：<code>r.curComponent = null;</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="5-1-2-有序广播的处理流程"><a href="#5-1-2-有序广播的处理流程" class="headerlink" title="5.1.2 有序广播的处理流程"></a>5.1.2 有序广播的处理流程</h3><p>对于有序广播来说，会将收集到的静态接收者和动态接收者通过优先级的不同合并到同一个集合中去，然后将该集合添加到指定队列的 <code>mOrderedBroadcasts</code> 集合中！</p>
<ul>
<li><strong>1</strong> 如果已经有一个正在等待目标进程启动的广播 <code>mPendingBroadcast</code>，那就等待对应进程启动后处理，此时不能继续有序发送！</li>
</ul>
<p><br></p>
<ul>
<li><strong>2</strong> 从 <code>mOrderedBroadcasts</code> 中移除不需要发送的广播，比如：没有接收者，或者所有接收者都已接收了该广播或者被终止继续传递，或者超时了，找到下一个需要分发的广播 r！</li>
</ul>
<p><br></p>
<ul>
<li><strong>3</strong> 准备工作：<ul>
<li>计算本次该广播的目标接收者的序号：<code>recIdx</code>，和下一个接收者的序号：<code>r.nextReceiver</code>，二者满足：<code>int recIdx = r.nextReceiver++</code>；</li>
<li>初始化该广播的接收时间： <code>r.receiverTime = SystemClock.uptimeMillis();</code>，根据该事件设置超时任务！</li>
<li>设置广播开始分发时间： <code>r.dispatchTime = r.receiverTime;　r.dispatchClockTime = System.currentTimeMillis();</code>（当 <code>recIdx</code> 为第一个接收者的时候）</li>
</ul>
</li>
</ul>
<p><br></p>
<ul>
<li><p><strong>4</strong> 从广播的接收者列表中找到 <code>recIdx</code> 对应的目标接收者，接下来就是分发广播了：</p>
<ul>
<li><p><strong>4.1</strong> 如果是<strong>动态注册的接收者</strong>，<code>deliverToRegisteredReceiverLocked</code>！</p>
<ul>
<li><strong>4.1.1</strong> 设置目标接收者的分发状态： <code>r.delivery[index] = BroadcastRecord.DELIVERY_DELIVERED</code></li>
<li><p><strong>4.1.2</strong> 设置广播的属性：</p>
<ul>
<li>设置广播接收者对应的 <code>Binder</code> 通信对象：<code>r.receiver = filter.receiverList.receiver.asBinder();</code>，即 <code>IIntentReceiver.Proxy</code> 对象！</li>
<li>设置广播的过滤器对象： <code>r.curFilter = filter;</code></li>
<li>设置过滤器处理的广播：  <code>filter.receiverList.curBroadcast = r;</code></li>
<li>设置广播的状态： <code>r.state = BroadcastRecord.CALL_IN_RECEIVE;</code></li>
<li>设置广播的目标进程：  <code>r.curApp = filter.receiverList.app;</code></li>
<li><p>设置目标进程当前处理的广播：  <code>filter.receiverList.app.curReceiver = r;</code></p>
<ul>
<li><strong>4.1.3</strong> 立刻设置广播的状态：<code>r.state = BroadcastRecord.CALL_DONE_RECEIVE;</code> 表示接收完毕！</li>
<li><strong>4.1.4</strong> 发送广播！</li>
<li><strong>4.1.4.1</strong> 通过 <code>app.thread.scheduleRegisteredReceiver</code>，进入应用进程，调用 <code>InnerReceiver.performReceive</code> 拉起广播接收者的 <code>onReceive</code> 方法！如果 <code>app = null</code>，就直接通过 <code>IIntentReceiver.Proxy.performReceive</code>，进入应用进程！</li>
<li><p><strong>4.1.4.2</strong> 调用 <code>ReceiverDispatcher.performReceive</code> 方法，处理广播！      </p>
<ul>
<li>这时会创建一个 <code>Args</code> 对象（继承了 <code>BroadcastReceiver.PendingResult</code> 实现了 <code>Runnable</code>），通过主线程执行 <code>Args.run</code> 方法！</li>
<li><code>PendingResult</code> 有一个内部成员变量 <code>mType</code>，用来保存接收者的类型，对于动态接收者：<code>mType = TYPE_REGISTERED/TYPE_UNREGISTERED</code>！</li>
<li>最后通过反射，拉起 <code>onReceive</code> 方法！</li>
<li><p>调用 <code>ActivityManagerService.finishReceiver</code>，通知系统进程，接收者完成了广播处理，继续分发！</p>
<ul>
<li>初始化广播的状态：<code>r.state = BroadcastRecord.IDLE;</code></li>
<li>清空广播的目标接收者：Binder 对象：<code>r.receiver = null;</code></li>
<li>清空广播组件信息：<code>r.intent.setComponent(null);</code><ul>
<li>清空广播目标进程的当前接收者：<code>r.curApp.curReceiver = null;</code></li>
</ul>
</li>
<li><p>清空广播过滤器的当前广播：<code>r.curFilter.receiverList.curBroadcast = null;</code></p>
</li>
<li><p>清空广播的过滤器：<code>r.curFilter = null;</code></p>
</li>
<li>清空广播接收者信息：<code>r.curReceiver = null;</code></li>
<li>清空广播的目标进程：<code>r.curApp = null;</code></li>
<li>清空广播的组件信息：<code>r.curComponent = null;</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>- **4.2** 如果是**静态注册的接收者**，`deliverToRegisteredReceiverLocked`！
    - **4.1.1** 设置目标接收者的分发状态：  `r.delivery[index] = BroadcastRecord.DELIVERY_DELIVERED`
    - **4.1.2** 设置广播的属性：
         - 设置广播的状态：`r.state = BroadcastRecord.APP_RECEIVE;`
         - 设置广播的目标组件信息：`r.curComponent = component;`
         - 设置广播的目标接收者信息：`r.curReceiver = info.activityInfo;`

    - **4.1.3** 根据静态接收者的进程状态来做不同处理：
        - **4.1.3.1** 如果进程未启动，就先启动其进程，并将广播添加到 `mPendingBroadcast` 中，等待进程启动后处理！进程启动后，会判断当前进程是否有 `mPendingBroadcast`，有的话，就将 `mPendingBroadcast` 发送目标接收者（4.1.3.2），并设置 `mPendingBroadcast = null;`！

        - **4.1.3.2** 如果进程已启动，那就直接发送广播！
         - 设置广播的目标接收者通信对象：`r.receiver = app.thread.asBinder();`，即目标进程的 `ApplicationThreadProxy` 对象！
         - 设置广播的目标进程：`r.curApp = app;`
         - 设置目标进程的当前要接收广播的接收者：`app.curReceiver = r;`
         - 设置广播的组件信息；`r.intent.setComponent(r.curComponent);`

         - 通过 `app.thread.scheduleReceiver`，跨进程拉起接收者的 `onReceive` 方法！
         - 进入应用进程后，会创建一个 `ReceiverData` 对象（其继承了 `BroadcastReceiver.PendingResult`）
         - `PendingResult` 有一个内部成员变量 `mType`，用来保存接收者的类型，对于静态接收者：`mType =  TYPE_COMPONENT`！
         - 最后通过反射，拉起 `onReceive` 方法！

         - 调用 `ActivityManagerService.finishReceiver`，通知系统进程，接收者完成了广播处理，继续广播分发！
                - 初始化广播的状态：`r.state = BroadcastRecord.IDLE;`
                - 清空广播的目标接收者：`Binder` 对象：`r.receiver = null;`
                - 清空广播组件信息：`r.intent.setComponent(null);`
                - 清空广播目标进程的当前接收者：`r.curApp.curReceiver = null;`
                - 清空广播过滤器的当前广播：`r.curFilter.receiverList.curBroadcast = null;`

                - 清空广播的过滤器：`r.curFilter = null;`
                - 清空广播接收者信息：`r.curReceiver = null;`
                - 清空广播的目标进程：`r.curApp = null;`
                - 清空广播的组件信息：`r.curComponent = null;`
</code></pre><h3 id="5-1-3-粘性广播的处理流程"><a href="#5-1-3-粘性广播的处理流程" class="headerlink" title="5.1.3 粘性广播的处理流程"></a>5.1.3 粘性广播的处理流程</h3><p>粘性是一个附加的属性，和有序，普通不冲突，普通广播和有序广播都可以是粘性的，粘性广播的一个特性是，系统会将该粘性广播保存下来，以便分发给以后注册的接收者！</p>
<p>保存的集合为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> SparseArray&lt;ArrayMap&lt;String, ArrayList&lt;Intent&gt;&gt;&gt; mStickyBroadcasts =</span><br><span class="line">        <span class="keyword">new</span> SparseArray&lt;ArrayMap&lt;String, ArrayList&lt;Intent&gt;&gt;&gt;();</span><br></pre></td></tr></table></figure>
<p>除去这个特性之外，粘性广播的处理方式和普通广播、有序广播是一样的，这里就不多说了！</p>
<ul>
<li>如果要发送粘性广播，应用必须配置 android.Manifest.permission.BROADCAST_STICKY 权限！</li>
<li>对于粘性广播，不能强制广播接收者应该具有某些权限！</li>
<li>对于粘性广播，如果有相同的全局粘性广播，会产生冲突，抛出异常！</li>
<li>Android 7.1.1 上已经不推荐使用粘性广播了，因为会产生安全问题！</li>
</ul>
<h2 id="5-2-广播的状态周期"><a href="#5-2-广播的状态周期" class="headerlink" title="5.2 广播的状态周期"></a>5.2 广播的状态周期</h2><p>对于广播来说，会有如下的几种状态：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> IDLE = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> APP_RECEIVE = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CALL_IN_RECEIVE = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CALL_DONE_RECEIVE = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WAITING_SERVICES = <span class="number">4</span>;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>普通广播：</li>
</ul>
<p>如果是静态注册的接收者：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BroadcastReocrd.IDLE -&gt; BroadcastReocrd.IDLE.APP_RECEIVE -&gt; BroadcastReocrd.CALL_DONE_RECEIVE -&gt;（BroadcastReocrd.WAITING_SERVICES）-&gt; BroadcastReocrd.IDLE</span><br></pre></td></tr></table></figure></p>
<p>如果是动态注册的接收者：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BroadcastReocrd.IDLE</span><br></pre></td></tr></table></figure></p>
<ul>
<li>有序广播：</li>
</ul>
<p>如果是静态注册的接收者：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BroadcastReocrd.IDLE -&gt; BroadcastReocrd.APP_RECEIVE -&gt; BroadcastReocrd.CALL_DONE_RECEIVE -&gt;（BroadcastReocrd.WAITING_SERVICES）-&gt; BroadcastReocrd.IDLE</span><br></pre></td></tr></table></figure></p>
<p>如果是动态注册的接收者：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BroadcastReocrd.IDLE -&gt; BroadcastReocrd.CALL_IN_RECEIVE -&gt; BroadcastReocrd.CALL_DONE_RECEIVE -&gt;（BroadcastReocrd.WAITING_SERVICES）-&gt; BroadcastReocrd.IDLE</span><br></pre></td></tr></table></figure></p>
<p>这里的 <code>BroadcastReocrd.WAITING_SERVICES</code> 只会对后台队列中有序发送的广播有效，因为这些广播可能在等待一些后台服务的启动！</p>
<p>当后台服务启动后，<code>ActiveServices</code> 会通过 <code>rescheduleDelayedStarts</code> 方法拉起这些服务！这里不多说了！</p>
<h2 id="5-3-接收者的分发状态"><a href="#5-3-接收者的分发状态" class="headerlink" title="5.3 接收者的分发状态"></a>5.3 接收者的分发状态</h2><p>对于接收者来说，下面这些状态用来表示广播的分发状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DELIVERY_PENDING = <span class="number">0</span>; <span class="comment">// 没有用到！</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DELIVERY_DELIVERED = <span class="number">1</span>; <span class="comment">// 广播已经分发给该广播接收者</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DELIVERY_SKIPPED = <span class="number">2</span>; <span class="comment">// 广播跳过了该广播接收者</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DELIVERY_TIMEOUT = <span class="number">3</span>; <span class="comment">// 广播超时了</span></span><br></pre></td></tr></table></figure>
<p>关于广播的超时，我们会单独一篇博文中介绍！</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Coolqi.Li</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lishuaiqi.top/2016/05/10/BroadcastReceiver5-sendBroadcast/">https://lishuaiqi.top/2016/05/10/BroadcastReceiver5-sendBroadcast/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lishuaiqi.top">Coolqi`s Blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/BroadcastReceiver广播接收者/">BroadcastReceiver广播接收者</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="/img/zfb.jpg"><div class="post-qr-code__desc">支付宝打赏</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="/img/wechat.jpg"><div class="post-qr-code__desc">微信打赏</div></div></div><div class="social-share pull-right"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2016/05/15/Process5-oomAdjSchedulingAlgorithms/"><i class="fa fa-chevron-left">  </i><span>Process篇 5 - 进程的 oomAdj 调度算法</span></a></div><div class="next-post pull-right"><a href="/2016/05/08/BroadcastReceiver4-staticRegisterReceiver/"><span>BroadcastReceiver篇 4 - BroadcastReceiver 静态注册</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitment-container"></div><script>var gitment = new Gitment({
  id: md5(decodeURI(location.pathname)),
  owner: '',
  repo: '',
  oauth: {
    client_id: '7b4efbcd7027d15749d6',
    client_secret: '14b5d7e8580ee29f7aeca733a25c000795967448'
  }
})
gitment.render('gitment-container')</script></div></div><footer class="footer-bg" style="background-image: url(/img/blog-bg.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2015 - 2020 By Coolqi.Li</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://lishuaiqi.top/">blog</a>!</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>