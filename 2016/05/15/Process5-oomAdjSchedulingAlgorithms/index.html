<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Process篇 5 - 进程的 oomAdj 调度算法"><meta name="keywords" content="Process进程"><meta name="author" content="Coolqi.Li,undefined"><meta name="copyright" content="Coolqi.Li"><title>Process篇 5 - 进程的 oomAdj 调度算法 | Coolqi`s Blog</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.5.6"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css?version=1.5.6"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: 'ca-pub-6845729157331145',
  enable_page_level_ads: 'true'
});
</script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?b7acef5306e54116ad8a99e8b753a92d";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-进程-oomAdj-的调度方法"><span class="toc-text">1 进程 oomAdj 的调度方法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-调度时机"><span class="toc-text">2 调度时机</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-Activity-调整"><span class="toc-text">2.1 Activity 调整</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-realStartActivityLocked"><span class="toc-text">2.1.1 realStartActivityLocked</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-resumeTopActivityInnerLocked"><span class="toc-text">2.1.2 resumeTopActivityInnerLocked</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-3-finishCurrentActivityLocked"><span class="toc-text">2.1.3 finishCurrentActivityLocked</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-4-destroyActivityLocked"><span class="toc-text">2.1.4 destroyActivityLocked</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-Service-调整"><span class="toc-text">2.2 Service 调整</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-realStartServiceLocked"><span class="toc-text">2.2.1 realStartServiceLocked</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-bindServiceLocked"><span class="toc-text">2.2.2 bindServiceLocked</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-3-unbindServiceLocked"><span class="toc-text">2.2.3 unbindServiceLocked</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-4-bringDownServiceLocked"><span class="toc-text">2.2.4 bringDownServiceLocked</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-5-sendServiceArgsLocked"><span class="toc-text">2.2.5 sendServiceArgsLocked</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-6-serviceDoneExecutingLocked"><span class="toc-text">2.2.6 serviceDoneExecutingLocked</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-7-removeConnectionLocked"><span class="toc-text">2.2.7 removeConnectionLocked</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-8-setServiceForegroundLocked"><span class="toc-text">2.5.8 setServiceForegroundLocked</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-broadcast-调整"><span class="toc-text">2.3 broadcast 调整</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-processNextBroadcast"><span class="toc-text">2.3.1 processNextBroadcast</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-processCurBroadcastLocked"><span class="toc-text">2.3.2 processCurBroadcastLocked</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-3-deliverToRegisteredReceiverLocked"><span class="toc-text">2.3.3 deliverToRegisteredReceiverLocked</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-ContentProvider-调整"><span class="toc-text">2.4 ContentProvider 调整</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-1-removeContentProviderXXX"><span class="toc-text">2.4.1 removeContentProviderXXX</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-2-publishContentProviders"><span class="toc-text">2.4.2 publishContentProviders</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-3-getContentProviderImpl"><span class="toc-text">2.4.3 getContentProviderImpl</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-Process-调整"><span class="toc-text">2.5 Process 调整</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-1-setSystemProcess"><span class="toc-text">2.5.1 setSystemProcess</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-2-addAppLocked"><span class="toc-text">2.5.2 addAppLocked</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-3-attachApplicationLocked"><span class="toc-text">2.5.3 attachApplicationLocked</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-4-trimApplications"><span class="toc-text">2.5.4 trimApplications</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-5-appDiedLocked"><span class="toc-text">2.5.5 appDiedLocked</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-6-killAllBackgroundProcesses"><span class="toc-text">2.5.6 killAllBackgroundProcesses</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-7-killPackageProcessesLocked"><span class="toc-text">2.5.7 killPackageProcessesLocked</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-8-setProcessForeground"><span class="toc-text">2.5.8 setProcessForeground</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-9-setHasTopUi"><span class="toc-text">2.5.9 setHasTopUi</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-10-updateSleepIfNeededLocked"><span class="toc-text">2.5.10 updateSleepIfNeededLocked</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-总结"><span class="toc-text">2.6 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-oomAdj-算法分析"><span class="toc-text">3 oomAdj 算法分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-1-ActivityManagerS-updateOomAdjLocked-更新指定进程-oomAdj"><span class="toc-text">3.1 [1]ActivityManagerS.updateOomAdjLocked - 更新指定进程 oomAdj</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1-ActivityManagerS-resumedAppLocked"><span class="toc-text">3.1.1 ActivityManagerS.resumedAppLocked</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-1-1-ActivityStackSupervisor-resumedAppLocked"><span class="toc-text">3.1.1.1 ActivityStackSupervisor.resumedAppLocked</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-0-ActivityManagerS-updateOomAdjLocked-更新-LRU-列表中的所有进程"><span class="toc-text">3.3 [0]ActivityManagerS.updateOomAdjLocked - 更新 LRU 列表中的所有进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-变量总结"><span class="toc-text">3.2.1 变量总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-过程总结"><span class="toc-text">3.2.2 过程总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-5-ActivityManagerS-updateOomAdjLocked"><span class="toc-text">3.3 [5]ActivityManagerS.updateOomAdjLocked</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-1-ActivityManagerS-computeOomAdjLocked"><span class="toc-text">3.3.1 ActivityManagerS.computeOomAdjLocked</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-1-已经更新-进程未启动的情况"><span class="toc-text">3.3.1.1 已经更新/进程未启动的情况</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-2-系统进程"><span class="toc-text">3.3.1.2 系统进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-3-前台进程"><span class="toc-text">3.3.1.3 前台进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-4-处理非前台-activity-所在进程"><span class="toc-text">3.3.1.4 处理非前台 activity 所在进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-5-调整可感知进程"><span class="toc-text">3.3.1.5 调整可感知进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-6-heavy-weight-进程"><span class="toc-text">3.3.1.6 heavy weight 进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-7-home-进程"><span class="toc-text">3.3.1.7 home 进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-8-持有-activity-的-previous-进程"><span class="toc-text">3.3.1.8 持有 activity 的 previous 进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-9-处于-back-up-的进程"><span class="toc-text">3.3.1.9 处于 back-up 的进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-10-处理持有-services-的进程"><span class="toc-text">3.3.1.10 处理持有 services 的进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-11-处理持有-providers-的进程"><span class="toc-text">3.3.1.11 处理持有 providers 的进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-12-最后调整阶段"><span class="toc-text">3.3.1.12 最后调整阶段</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-2-ActivityManagerS-applyOomAdjLocked"><span class="toc-text">3.3.2  ActivityManagerS.applyOomAdjLocked</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-总结"><span class="toc-text">4 总结</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Coolqi.Li</div><div class="author-info__description text-center">“你好，我是李帅奇，Android 系统工程师，MineCraft 忠实玩家，设计和绘画爱好者，缺妹纸晚期患者，熬夜星人。”</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">81</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">19</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">23</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="https://developer.android.google.cn/">AndroidDeveloper</a><a class="author-info-links__name text-center" href="http://www.android-studio.org/">AndroidStudio</a><a class="author-info-links__name text-center" href="https://www.jianshu.com/u/123a20a96441">简书</a><a class="author-info-links__name text-center" href="https://weibo.com/coolqiLi">微博</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://ws1.sinaimg.cn/large/8700af19ly1fvpabr30o6j22yo1o0q7i.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Coolqi`s Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/about">About</a></span></div><div id="post-info"><div id="post-title">Process篇 5 - 进程的 oomAdj 调度算法</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2016-05-15</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/AndroidFramework源码分析/">AndroidFramework源码分析</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/AndroidFramework源码分析/Process进程/">Process进程</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">20.8k</span><span class="post-meta__separator">|</span><span>阅读时长: 90 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>[toc]</p>
<p>基于 Android 7.1.1 源码，总结进程状态调整的调度策略！</p>
<h1 id="1-进程-oomAdj-的调度方法"><a href="#1-进程-oomAdj-的调度方法" class="headerlink" title="1 进程 oomAdj 的调度方法"></a>1 进程 oomAdj 的调度方法</h1><p>和进程的 oomAdj 调度相关的主要有`3 个方法：</p>
<ul>
<li><strong>updateOomAdjLocked</strong>：用于更新进程的 adj，该方法会依次调用 computeOomAdjLocked 和 applyOomAdjLocked;</li>
<li><strong>computeOomAdjLocked</strong>：计算进程的 adj，返回计算后 RawAdj 值;</li>
<li><strong>applyOomAdjLocked</strong>：应用 adj，当需要杀掉目标进程则返回 false；否则返回 true。</li>
</ul>
<p>当在一些特定的场景下，系统会调用 updateOomAdjLocked 来更新指定进程的 oomAdj，该方法会先调用 computeOomAdjLocked 计算出一个新的 oomAdj，然后在调用 applyOomAdjLocked 来设置指定进程的 oomAdj！</p>
<p>updateOomAdjLocked 有多个重载函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新指定进程的 oomAdj</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">updateOomAdjLocked</span><span class="params">(ProcessRecord app)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">updateOomAdjLocked</span><span class="params">(ProcessRecord app, <span class="keyword">int</span> cachedAdj, ProcessRecord TOP_APP, <span class="keyword">boolean</span> doingAll, <span class="keyword">long</span> now)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 更新所有进程的 oomAdj</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateOomAdjLocked</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p><strong>其中，五个参数的 updateOomAdjLocked 方法是私有方法，只提供给其他的两个方法调用！！</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">updateOomAdjLocked</span><span class="params">(ProcessRecord app, <span class="keyword">int</span> cachedAdj, ProcessRecord TOP_APP, <span class="keyword">boolean</span> doingAll, <span class="keyword">long</span> now)</span></span></span><br></pre></td></tr></table></figure>
<h1 id="2-调度时机"><a href="#2-调度时机" class="headerlink" title="2 调度时机"></a>2 调度时机</h1><p>接下里，我们看看 updateOomAdjLocked 的调度时机：</p>
<h2 id="2-1-Activity-调整"><a href="#2-1-Activity-调整" class="headerlink" title="2.1 Activity 调整"></a>2.1 Activity 调整</h2><p>和 Activity 相关的调整代码主要是位于 ActivityStackSupervisor.java 和 ActivityStack.java 中：</p>
<h3 id="2-1-1-realStartActivityLocked"><a href="#2-1-1-realStartActivityLocked" class="headerlink" title="2.1.1 realStartActivityLocked"></a>2.1.1 realStartActivityLocked</h3><p>ActivityStackSupervisor.realStartActivityLocked：启动 Activity，以下是关键代码段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//【1】将 activity 所在的进程添加到 lru process 列表中！</span></span><br><span class="line">mService.updateLruProcessLocked(app, <span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//【2】更新所有进程的 oomAdj！</span></span><br><span class="line">mService.updateOomAdjLocked();</span><br></pre></td></tr></table></figure>
<p>在启动之前会调用 updateOomAdjLocked 更新所有进程的 oomAdj！</p>
<h3 id="2-1-2-resumeTopActivityInnerLocked"><a href="#2-1-2-resumeTopActivityInnerLocked" class="headerlink" title="2.1.2 resumeTopActivityInnerLocked"></a>2.1.2 resumeTopActivityInnerLocked</h3><p>ActivityStack.resumeTopActivityInnerLocked: 恢复栈顶 Activity，以下是关键代码段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//【1】next 表示的是下一个要被 resume 的 activity</span></span><br><span class="line">next.state = ActivityState.RESUMED;</span><br><span class="line">mResumedActivity = next;</span><br><span class="line">next.task.touchActiveTime();</span><br><span class="line">mRecentTasks.addLocked(next.task);</span><br><span class="line"><span class="comment">//【2】更新 lru process 列表！</span></span><br><span class="line">mService.updateLruProcessLocked(next.app, <span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//【3】更新 lru activity 列表！</span></span><br><span class="line">updateLRUListLocked(next);</span><br><span class="line"><span class="comment">//【4】更新所有进程的 oomAdj 值</span></span><br><span class="line">mService.updateOomAdjLocked();</span><br></pre></td></tr></table></figure>
<p>更新所有进程的 oomAdj！</p>
<h3 id="2-1-3-finishCurrentActivityLocked"><a href="#2-1-3-finishCurrentActivityLocked" class="headerlink" title="2.1.3 finishCurrentActivityLocked"></a>2.1.3 finishCurrentActivityLocked</h3><p>ActivityStack.finishCurrentActivityLocked: 结束 Activity，以下是关键代码段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mode == FINISH_AFTER_VISIBLE &amp;&amp; (r.visible || r.nowVisible)</span><br><span class="line">        &amp;&amp; next != <span class="keyword">null</span> &amp;&amp; !next.nowVisible) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mStackSupervisor.mStoppingActivities.contains(r)) &#123;</span><br><span class="line">        addToStopping(r, <span class="keyword">false</span> <span class="comment">/* immediate */</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_STATES) Slog.v(TAG_STATES,</span><br><span class="line">            <span class="string">"Moving to STOPPING: "</span>+ r + <span class="string">" (finish requested)"</span>);</span><br><span class="line">    <span class="comment">// 将 activity 的状态改为 stopping！</span></span><br><span class="line">    r.state = ActivityState.STOPPING;</span><br><span class="line">    <span class="comment">//【1】如果 oomAdj 为 true，那就需要调整所有进程的 `oomAdj`</span></span><br><span class="line">    <span class="keyword">if</span> (oomAdj) &#123;</span><br><span class="line">        mService.updateOomAdjLocked();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更新所有进程的 oomAdj！</p>
<h3 id="2-1-4-destroyActivityLocked"><a href="#2-1-4-destroyActivityLocked" class="headerlink" title="2.1.4 destroyActivityLocked"></a>2.1.4 destroyActivityLocked</h3><p>ActivityStack.destroyActivityLocked: 摧毁 Activity，以下是关键代码段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (hadApp) &#123;</span><br><span class="line">    <span class="keyword">if</span> (removeFromApp) &#123;</span><br><span class="line">        r.app.activities.remove(r);</span><br><span class="line">        <span class="keyword">if</span> (mService.mHeavyWeightProcess == r.app &amp;&amp; r.app.activities.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            mService.mHeavyWeightProcess = <span class="keyword">null</span>;</span><br><span class="line">            mService.mHandler.sendEmptyMessage(</span><br><span class="line">                    ActivityManagerService.CANCEL_HEAVY_NOTIFICATION_MSG);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【1】如果被 destroy 的 activity 所在的进程已经没有任何 activity 了，那就需要调整 oomAdj！</span></span><br><span class="line">        <span class="keyword">if</span> (r.app.activities.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//【1.1】通知所有的服务，该进程没有任何 activity</span></span><br><span class="line">            mService.mServices.updateServiceConnectionActivitiesLocked(r.app);</span><br><span class="line">            <span class="comment">//【1.2】该进程没有了 activity，需要更新 lru list 和 oomAdj 的值！</span></span><br><span class="line">            mService.updateLruProcessLocked(r.app, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">            <span class="comment">//【1.2】更新所有进程的 adj</span></span><br><span class="line">            mService.updateOomAdjLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ... ... ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会更新所有进程的 oomAdj！</p>
<h2 id="2-2-Service-调整"><a href="#2-2-Service-调整" class="headerlink" title="2.2 Service 调整"></a>2.2 Service 调整</h2><p>和 Service 相关的调整代码主要是位于 ActiveServices.java 中：</p>
<h3 id="2-2-1-realStartServiceLocked"><a href="#2-2-1-realStartServiceLocked" class="headerlink" title="2.2.1 realStartServiceLocked"></a>2.2.1 realStartServiceLocked</h3><p><strong>ActiveServices.realStartServiceLocked</strong>: 启动服务，以下是关键代码段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> newService = app.services.add(r);</span><br><span class="line">bumpServiceExecutingLocked(r, execInFg, <span class="string">"create"</span>); <span class="comment">// 设置拉起 onCreate 方法超时处理！</span></span><br><span class="line">mAm.updateLruProcessLocked(app, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">mAm.updateOomAdjLocked(); <span class="comment">//【1】更新所有进程的 oomAdj</span></span><br></pre></td></tr></table></figure>
<h3 id="2-2-2-bindServiceLocked"><a href="#2-2-2-bindServiceLocked" class="headerlink" title="2.2.2 bindServiceLocked"></a>2.2.2 bindServiceLocked</h3><p><strong>ActiveServices.bindServiceLocked</strong>: 绑定服务，以下是关键代码段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s.app != <span class="keyword">null</span>) &#123; <span class="comment">// 这里的 s.app 表示服务所在的进程！</span></span><br><span class="line">    <span class="keyword">if</span> ((flags&amp;Context.BIND_TREAT_LIKE_ACTIVITY) != <span class="number">0</span>) &#123;</span><br><span class="line">        s.app.treatLikeActivity = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s.whitelistManager) &#123;</span><br><span class="line">        s.app.whitelistManager = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【1】当我们 bind 一个服务的时候，该服务的优先级会被提升！</span></span><br><span class="line">    mAm.updateLruProcessLocked(s.app, s.app.hasClientActivities</span><br><span class="line">            || s.app.treatLikeActivity, b.client);</span><br><span class="line">    <span class="comment">//【2】更新服务所在进程的 oomAdj</span></span><br><span class="line">    mAm.updateOomAdjLocked(s.app);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只更新服务所在进程的 oomAdj!</p>
<h3 id="2-2-3-unbindServiceLocked"><a href="#2-2-3-unbindServiceLocked" class="headerlink" title="2.2.3 unbindServiceLocked"></a>2.2.3 unbindServiceLocked</h3><p><strong>ActiveServices.unbindServiceLocked</strong>: 解绑服务，以下是关键代码段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (r.binding.service.app != <span class="keyword">null</span>) &#123; <span class="comment">// r.binding.service.app 在这里表示的是服务所在的进程！</span></span><br><span class="line">    <span class="keyword">if</span> (r.binding.service.app.whitelistManager) &#123;</span><br><span class="line">        updateWhitelistManagerLocked(r.binding.service.app);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【1】当我们 unbind 一个服务的时候，该服务的优先级会被降低！</span></span><br><span class="line">    <span class="keyword">if</span> ((r.flags&amp;Context.BIND_TREAT_LIKE_ACTIVITY) != <span class="number">0</span>) &#123;</span><br><span class="line">        r.binding.service.app.treatLikeActivity = <span class="keyword">true</span>;</span><br><span class="line">        mAm.updateLruProcessLocked(r.binding.service.app,</span><br><span class="line">                r.binding.service.app.hasClientActivities</span><br><span class="line">                || r.binding.service.app.treatLikeActivity, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【2】更新服务所在进程的 oomAdj！</span></span><br><span class="line">    mAm.updateOomAdjLocked(r.binding.service.app);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只更新服务所在进程的 oomAdj！！</p>
<h3 id="2-2-4-bringDownServiceLocked"><a href="#2-2-4-bringDownServiceLocked" class="headerlink" title="2.2.4 bringDownServiceLocked"></a>2.2.4 bringDownServiceLocked</h3><p><strong>ActiveServices.bringDownServiceLocked</strong>: 结束服务，以下是关键代码段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当我们要结束一个服务的时候，我们需要接触所有的绑定操作！</span></span><br><span class="line"><span class="keyword">if</span> (r.app != <span class="keyword">null</span> &amp;&amp; r.app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=r.bindings.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">        IntentBindRecord ibr = r.bindings.valueAt(i);</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE, <span class="string">"Bringing down binding "</span> + ibr</span><br><span class="line">                + <span class="string">": hasBound="</span> + ibr.hasBound);</span><br><span class="line">        <span class="comment">// 如果有绑定操作，接触绑定！</span></span><br><span class="line">        <span class="keyword">if</span> (ibr.hasBound) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bumpServiceExecutingLocked(r, <span class="keyword">false</span>, <span class="string">"bring down unbind"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//【1】更新服务所在进程的 oomAdj！</span></span><br><span class="line">                mAm.updateOomAdjLocked(r.app);</span><br><span class="line">                ibr.hasBound = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//【2】拉起服务的 onUnBind 方法！</span></span><br><span class="line">                r.app.thread.scheduleUnbindService(r,</span><br><span class="line">                        ibr.intent.getIntent());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Exception when unbinding service "</span></span><br><span class="line">                        + r.shortName, e);</span><br><span class="line">                serviceProcessGoneLocked(r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">... ... ... ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (r.app != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (r.stats.getBatteryStats()) &#123;</span><br><span class="line">        r.stats.stopLaunchedLocked();</span><br><span class="line">    &#125;</span><br><span class="line">    r.app.services.remove(r);</span><br><span class="line">    <span class="keyword">if</span> (r.whitelistManager) &#123;</span><br><span class="line">        updateWhitelistManagerLocked(r.app);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r.app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">        updateServiceForegroundLocked(r.app, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//【1】设置拉起 onDestroy 方法的超时处理！</span></span><br><span class="line">            bumpServiceExecutingLocked(r, <span class="keyword">false</span>, <span class="string">"destroy"</span>);</span><br><span class="line">            mDestroyingServices.add(r);</span><br><span class="line">            r.destroying = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//【2】更新服务所在进程的 oomAdj 值！</span></span><br><span class="line">            mAm.updateOomAdjLocked(r.app);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//【3】拉起服务的 onDestroy 服务！</span></span><br><span class="line">            r.app.thread.scheduleStopService(r);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Exception when destroying service "</span></span><br><span class="line">                    + r.shortName, e);</span><br><span class="line">            serviceProcessGoneLocked(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(</span><br><span class="line">            TAG_SERVICE, <span class="string">"Removed service that has no process: "</span> + r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(</span><br><span class="line">        TAG_SERVICE, <span class="string">"Removed service that is not running: "</span> + r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只更新服务所在进程的 oomAdj!</p>
<h3 id="2-2-5-sendServiceArgsLocked"><a href="#2-2-5-sendServiceArgsLocked" class="headerlink" title="2.2.5 sendServiceArgsLocked"></a>2.2.5 sendServiceArgsLocked</h3><p><strong>ActiveServices.sendServiceArgsLocked</strong>: 发送启动参数，该方法会拉起服务的 onStart 方法，以下是关键代码段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bumpServiceExecutingLocked(r, execInFg, <span class="string">"start"</span>); <span class="comment">// 设置拉起 onStart 方法超时处理</span></span><br><span class="line"><span class="comment">//【1】当 oomAdjusted 为 fasle，才会执行 oomAdj 的更新！</span></span><br><span class="line"><span class="keyword">if</span> (!oomAdjusted) &#123;</span><br><span class="line">    oomAdjusted = <span class="keyword">true</span>;</span><br><span class="line">    mAm.updateOomAdjLocked(r.app); <span class="comment">// 更新服务所在进程的 oomAdj！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sendServiceArgsLocked 在很多地方都有调用：</p>
<ul>
<li><p><strong>realStartServiceLocked</strong> 方法在拉起 onCreate 方法之前，会对所有进程的 oomAdj 做一次调整；接着调用 sendServiceArgsLocked，但是由于其第三个参数 oomAdjusted 传入的是 true，所以不会再次 oomAdj 更新！</p>
</li>
<li><p><strong>cleanUpRemovedTaskLocked</strong> 方法是当我们从最近任务中移除一个任务时候，我们会移除该任务所对应的 Service，那么如果 Service 没有设置 ServiceInfo.FLAG_STOP_WITH_TASK 标志位的话，并且如果服务所在进程没有死亡，那么系统会重新拉起服务：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = services.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    ServiceRecord sr = services.get(i);</span><br><span class="line">    <span class="keyword">if</span> (sr.startRequested) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((sr.serviceInfo.flags&amp;ServiceInfo.FLAG_STOP_WITH_TASK) != <span class="number">0</span>) &#123;</span><br><span class="line">            Slog.i(TAG, <span class="string">"Stopping service "</span> + sr.shortName + <span class="string">": remove task"</span>);</span><br><span class="line">            stopServiceLocked(sr);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//【1】创建启动项！</span></span><br><span class="line">            sr.pendingStarts.add(<span class="keyword">new</span> ServiceRecord.StartItem(sr, <span class="keyword">true</span>,</span><br><span class="line">                    sr.makeNextStartId(), baseIntent, <span class="keyword">null</span>));</span><br><span class="line">            <span class="keyword">if</span> (sr.app != <span class="keyword">null</span> &amp;&amp; sr.app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//【2】拉起服务的 onStart 方法！</span></span><br><span class="line">                    sendServiceArgsLocked(sr, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (TransactionTooLargeException e) &#123;</span><br><span class="line">                    <span class="comment">// Ignore, keep going.</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，第三个参数 oomAdjusted 传入的是 false，所以会发生 oomAdj 更新！</p>
<ul>
<li><strong>bringUpServiceLocked</strong> 方法中如果服务所在进程已经被启动，并且服务的 onCreate 方法已经被拉起，那就会直接 sendServiceArgsLocked 拉起服务的 onStart 方法！</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (r.app != <span class="keyword">null</span> &amp;&amp; r.app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">    sendServiceArgsLocked(r, execInFg, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里，第三个参数 oomAdjusted 也传入的是 false，所以也会发生 oomAdj 更新！</p>
<h3 id="2-2-6-serviceDoneExecutingLocked"><a href="#2-2-6-serviceDoneExecutingLocked" class="headerlink" title="2.2.6 serviceDoneExecutingLocked"></a>2.2.6 serviceDoneExecutingLocked</h3><p><strong>ActiveServices.serviceDoneExecutingLocked</strong> 以下是关键代码段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (r.executeNesting &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (r.app != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE,</span><br><span class="line">                <span class="string">"Nesting at 0 of "</span> + r.shortName);</span><br><span class="line">        r.app.execServicesFg = <span class="keyword">false</span>;</span><br><span class="line">        r.app.executingServices.remove(r);</span><br><span class="line">        <span class="keyword">if</span> (r.app.executingServices.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_SERVICE || DEBUG_SERVICE_EXECUTING) Slog.v(TAG_SERVICE_EXECUTING,</span><br><span class="line">                    <span class="string">"No more executingServices of "</span> + r.shortName);</span><br><span class="line">            mAm.mHandler.removeMessages(ActivityManagerService.SERVICE_TIMEOUT_MSG, r.app);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.executeFg) &#123;</span><br><span class="line">            <span class="comment">// Need to re-evaluate whether the app still needs to be in the foreground.</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=r.app.executingServices.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (r.app.executingServices.valueAt(i).executeFg) &#123;</span><br><span class="line">                    r.app.execServicesFg = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (inDestroying) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_SERVICE) Slog.v(TAG_SERVICE,</span><br><span class="line">                    <span class="string">"doneExecuting remove destroying "</span> + r);</span><br><span class="line">            mDestroyingServices.remove(r);</span><br><span class="line">            r.bindings.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【1】更新服务所在进程的 oomAdj！</span></span><br><span class="line">        mAm.updateOomAdjLocked(r.app);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>serviceDoneExecutingLocked 方法的调用时机主要是在：</p>
<ul>
<li>执行启动 Service 等等一些操作时抛出异</li>
<li>服务所在进程死亡时；</li>
<li>bind 操作完成后；</li>
<li>unbind 操作完成后等等！</li>
</ul>
<h3 id="2-2-7-removeConnectionLocked"><a href="#2-2-7-removeConnectionLocked" class="headerlink" title="2.2.7 removeConnectionLocked"></a>2.2.7 removeConnectionLocked</h3><p><strong>ActiveServices.removeConnectionLocked</strong>：当我们要移除对一个服务的绑定的时候，会触发该方法，以下是关键代码段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (s.app != <span class="keyword">null</span> &amp;&amp; s.app.thread != <span class="keyword">null</span> &amp;&amp; b.intent.apps.size() == <span class="number">0</span></span><br><span class="line">        &amp;&amp; b.intent.hasBound) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        bumpServiceExecutingLocked(s, <span class="keyword">false</span>, <span class="string">"unbind"</span>);</span><br><span class="line">        <span class="keyword">if</span> (b.client != s.app &amp;&amp; (c.flags&amp;Context.BIND_WAIVE_PRIORITY) == <span class="number">0</span></span><br><span class="line">                &amp;&amp; s.app.setProcState &lt;= ActivityManager.PROCESS_STATE_RECEIVER) &#123;</span><br><span class="line">            mAm.updateLruProcessLocked(s.app, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【1】更新进程的 oomAdj 的值！</span></span><br><span class="line">        mAm.updateOomAdjLocked(s.app);</span><br><span class="line">        b.intent.hasBound = <span class="keyword">false</span>;</span><br><span class="line">        b.intent.doRebind = <span class="keyword">false</span>;</span><br><span class="line">        s.app.thread.scheduleUnbindService(s, b.intent.intent.getIntent());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"Exception when unbinding service "</span> + s.shortName, e);</span><br><span class="line">        serviceProcessGoneLocked(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>removeConnectionLocked 的调用时机如下：</p>
<ul>
<li><p><strong>killServicesLocked</strong>：当我们要杀掉某个应用进程的时候，我们会解除该进程对其他进程中服务的绑定：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Clean up any connections this application has to other services.</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = app.connections.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    ConnectionRecord r = app.connections.valueAt(i);</span><br><span class="line">    removeConnectionLocked(r, app, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>cleanUpActivityServicesLocked</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (r.connections != <span class="keyword">null</span>) &#123;</span><br><span class="line">    Iterator&lt;ConnectionRecord&gt; it = r.connections.iterator();</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        ConnectionRecord c = it.next();</span><br><span class="line">        <span class="comment">// 移除该绑定关系！</span></span><br><span class="line">        mService.mServices.removeConnectionLocked(c, <span class="keyword">null</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">    r.connections = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>unbindServiceLocked: 当我们要接触绑定某个服务的时候，会调用 removeConnectionLocked，断开连接！</p>
</li>
</ul>
<h3 id="2-5-8-setServiceForegroundLocked"><a href="#2-5-8-setServiceForegroundLocked" class="headerlink" title="2.5.8 setServiceForegroundLocked"></a>2.5.8 setServiceForegroundLocked</h3><p>ActiveServices.setServiceForegroundLocked：用于将一个服务设置为前台，关键代码段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ServiceRecord r = findServiceLocked(className, token, userId);</span><br><span class="line"><span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (id != <span class="number">0</span>) &#123;</span><br><span class="line">        ... ... ...</span><br><span class="line">        <span class="keyword">if</span> (r.app != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//【1】设置服务为前台</span></span><br><span class="line">            updateServiceForegroundLocked(r.app, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ... ... ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (r.isForeground) &#123;</span><br><span class="line">            r.isForeground = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (r.app != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mAm.updateLruProcessLocked(r.app, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">                <span class="comment">//【2】设置服务为前台</span></span><br><span class="line">                updateServiceForegroundLocked(r.app, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ... ... ... ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 updateServiceForegroundLocked 方法中，会调用：AMS.updateProcessForegroundLocked 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateServiceForegroundLocked</span><span class="params">(ProcessRecord proc, <span class="keyword">boolean</span> oomAdj)</span> </span>&#123;</span><br><span class="line">    ... ... ... ...</span><br><span class="line">    <span class="comment">//【1】更新前台进程的优先级；</span></span><br><span class="line">    mAm.updateProcessForegroundLocked(proc, anyForeground, oomAdj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AMS.updateProcessForegroundLocked 中会根据第三个参数是否为 true 来设置进程的 oomAdj：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">updateProcessForegroundLocked</span><span class="params">(ProcessRecord proc, <span class="keyword">boolean</span> isForeground,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> oomAdj)</span> </span>&#123;</span><br><span class="line">        ... ... ... ...</span><br><span class="line">        <span class="keyword">if</span> (oomAdj) &#123;</span><br><span class="line">            <span class="comment">//【1】调整 oomAdj！</span></span><br><span class="line">            updateOomAdjLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更新所有进程的 oomAdj 的值！</p>
<p>这里我们来说一下 updateProcessForegroundLocked，我们设置一个服务为前台，实际上是设置其所在的进程为前台进程，updateProcessForegroundLocked 的调用有多处，但只有在 setServiceForegroundLocked 方法的调用链中，boolean oomAdj 为 true！！</p>
<h2 id="2-3-broadcast-调整"><a href="#2-3-broadcast-调整" class="headerlink" title="2.3 broadcast 调整"></a>2.3 broadcast 调整</h2><p>和 broadcast 相关的调整代码主要是在 BroadcastQueue.java 中：</p>
<h3 id="2-3-1-processNextBroadcast"><a href="#2-3-1-processNextBroadcast" class="headerlink" title="2.3.1 processNextBroadcast"></a>2.3.1 processNextBroadcast</h3><p>BroadcastQueue.processNextBroadcast: 发送下一个广播，以下是关键代码段：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mOrderedBroadcasts.size() == <span class="number">0</span>) &#123;</span><br><span class="line">    mService.scheduleAppGcsLocked();</span><br><span class="line">    <span class="comment">//【1】在处理完最后一个有序广播队列中的广播后，会更新所有进程的 oomAdj！</span></span><br><span class="line">    <span class="keyword">if</span> (looped) &#123;</span><br><span class="line">        mService.updateOomAdjLocked();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>只针对有序发送的广播！</p>
<h3 id="2-3-2-processCurBroadcastLocked"><a href="#2-3-2-processCurBroadcastLocked" class="headerlink" title="2.3.2 processCurBroadcastLocked"></a>2.3.2 processCurBroadcastLocked</h3><p>BroadcastQueue.processCurBroadcastLocked: 处理当前广播，以下是关键代码段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">r.receiver = app.thread.asBinder();</span><br><span class="line">r.curApp = app;</span><br><span class="line">app.curReceiver = r;</span><br><span class="line"><span class="comment">//【1】更新进程的状态！</span></span><br><span class="line">app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_RECEIVER);</span><br><span class="line"><span class="comment">//【2】更新 LRU 进程列表！</span></span><br><span class="line">mService.updateLruProcessLocked(app, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//【3】更新所有进程的 oomAdj 值！</span></span><br><span class="line">mService.updateOomAdjLocked();</span><br></pre></td></tr></table></figure>
<p>只针对有序发送的广播！</p>
<h3 id="2-3-3-deliverToRegisteredReceiverLocked"><a href="#2-3-3-deliverToRegisteredReceiverLocked" class="headerlink" title="2.3.3 deliverToRegisteredReceiverLocked"></a>2.3.3 deliverToRegisteredReceiverLocked</h3><p>BroadcastQueue.deliverToRegisteredReceiverLocked: 分发已注册的广播，以下是关键代码段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ordered) &#123; <span class="comment">// 只针对有序发送的广播！</span></span><br><span class="line">    r.receiver = filter.receiverList.receiver.asBinder();</span><br><span class="line">    r.curFilter = filter;</span><br><span class="line">    filter.receiverList.curBroadcast = r;</span><br><span class="line">    r.state = BroadcastRecord.CALL_IN_RECEIVE;</span><br><span class="line">    <span class="keyword">if</span> (filter.receiverList.app != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//【1】r.curApp 表示要接受该广播的目标进程！</span></span><br><span class="line">        r.curApp = filter.receiverList.app;</span><br><span class="line">        filter.receiverList.app.curReceiver = r;</span><br><span class="line">        <span class="comment">//【2】更新目标进程的 oomAdj！</span></span><br><span class="line">        mService.updateOomAdjLocked(r.curApp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只针对有序发送的广播，只针对指定的目标进程！</p>
<h2 id="2-4-ContentProvider-调整"><a href="#2-4-ContentProvider-调整" class="headerlink" title="2.4 ContentProvider 调整"></a>2.4 ContentProvider 调整</h2><p>和 ContentProvider 相关的调整代码主要是在 ActivityManagerService.java 中：</p>
<h3 id="2-4-1-removeContentProviderXXX"><a href="#2-4-1-removeContentProviderXXX" class="headerlink" title="2.4.1 removeContentProviderXXX"></a>2.4.1 removeContentProviderXXX</h3><p>ActivityManagerService.removeContentProvider: 移除 provider，关键代码段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//【1】如果该 provider 没有其他人在使用，就会返回 true！</span></span><br><span class="line"><span class="keyword">if</span> (decProviderCountLocked(conn, <span class="keyword">null</span>, <span class="keyword">null</span>, stable)) &#123;</span><br><span class="line">    <span class="comment">//【1】更新所有进程的 oomAdj 值！</span></span><br><span class="line">    updateOomAdjLocked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更新所有进程的 oomAdj 值！</p>
<p>ActivityManagerService.removeContentProviderExternalUnchecked: 移除 provider，关键代码段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//【1】当 contentProvier 有扩展进程的引用，并且引用均被移除，更新所有进程的 oomAdj 值！</span></span><br><span class="line"><span class="keyword">if</span> (localCpr.hasExternalProcessHandles()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (localCpr.removeExternalProcessHandleLocked(token)) &#123;</span><br><span class="line">        <span class="comment">//【1.1】更新所有进程的 oomAdj 值！</span></span><br><span class="line">        updateOomAdjLocked();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Slog.e(TAG, <span class="string">"Attmpt to remove content provider "</span> + localCpr</span><br><span class="line">                + <span class="string">" with no external reference for token: "</span></span><br><span class="line">                + token + <span class="string">"."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Slog.e(TAG, <span class="string">"Attmpt to remove content provider: "</span> + localCpr</span><br><span class="line">            + <span class="string">" with no external references."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更新所有进程的 oomAdj 值！</p>
<h3 id="2-4-2-publishContentProviders"><a href="#2-4-2-publishContentProviders" class="headerlink" title="2.4.2 publishContentProviders"></a>2.4.2 publishContentProviders</h3><p>ActivityManagerService.publishContentProviders: 发布 provider，关键代码段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> N = providers.size();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">    ContentProviderHolder src = providers.get(i);</span><br><span class="line">    <span class="keyword">if</span> (src == <span class="keyword">null</span> || src.info == <span class="keyword">null</span> || src.provider == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ContentProviderRecord dst = r.pubProviders.get(src.info.name);</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_MU) Slog.v(TAG_MU, <span class="string">"ContentProviderRecord uid = "</span> + dst.uid);</span><br><span class="line">    <span class="keyword">if</span> (dst != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ComponentName comp = <span class="keyword">new</span> ComponentName(dst.info.packageName, dst.info.name);</span><br><span class="line">        mProviderMap.putProviderByClass(comp, dst);</span><br><span class="line">        String names[] = dst.info.authority.split(<span class="string">";"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; names.length; j++) &#123;</span><br><span class="line">            mProviderMap.putProviderByName(names[j], dst);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ... ... ... ...<span class="comment">// 处理 mLaunchingProviders</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (dst) &#123;</span><br><span class="line">            dst.provider = src.provider;</span><br><span class="line">            dst.proc = r;</span><br><span class="line">            dst.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【1】更新指定进程的 oomAdj！</span></span><br><span class="line">        updateOomAdjLocked(r);</span><br><span class="line">        maybeUpdateProviderUsageStatsLocked(r, src.info.packageName,</span><br><span class="line">                src.info.authority);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更新指定进程的 oomAdj！</p>
<h3 id="2-4-3-getContentProviderImpl"><a href="#2-4-3-getContentProviderImpl" class="headerlink" title="2.4.3 getContentProviderImpl"></a>2.4.3 getContentProviderImpl</h3><p>ActivityManagerService.getContentProviderImpl: 获取 provider，下面是关键代码段！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">... ... ... ...</span><br><span class="line"><span class="comment">//【1】更新 provider 所在进程的 adj！</span></span><br><span class="line"><span class="keyword">boolean</span> success = updateOomAdjLocked(cpr.proc);</span><br><span class="line">... ... ... ...</span><br></pre></td></tr></table></figure>
<p>provider 所在进程的 adj！</p>
<p>关于 ContentProvider，我会单独开一个系列来分析</p>
<h2 id="2-5-Process-调整"><a href="#2-5-Process-调整" class="headerlink" title="2.5 Process 调整"></a>2.5 Process 调整</h2><p>和 Process 相关的调整代码主要是在 ActivityManagerService.java 中:</p>
<h3 id="2-5-1-setSystemProcess"><a href="#2-5-1-setSystemProcess" class="headerlink" title="2.5.1 setSystemProcess"></a>2.5.1 setSystemProcess</h3><p>ActivityManagerService.setSystemProcess: 创建并设置系统进程，以下是关键代码段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="comment">// 创建系统进程对应的 ProcessRecord，并设置其为 persistent 类型的进程！</span></span><br><span class="line">    ProcessRecord app = newProcessRecordLocked(info, info.processName, <span class="keyword">false</span>, <span class="number">0</span>);</span><br><span class="line">    app.persistent = <span class="keyword">true</span>;</span><br><span class="line">    app.pid = MY_PID;</span><br><span class="line">    <span class="comment">// 设置系统进程的 maxAdj 为 SYSTEM_ADJ！</span></span><br><span class="line">    app.maxAdj = ProcessList.SYSTEM_ADJ;</span><br><span class="line">    app.makeActive(mSystemThread.getApplicationThread(), mProcessStats);</span><br><span class="line">    <span class="keyword">synchronized</span> (mPidsSelfLocked) &#123;</span><br><span class="line">        mPidsSelfLocked.put(app.pid, app);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 加入到 lru process 列表中！</span></span><br><span class="line">    updateLruProcessLocked(app, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 更新所有进程的 adj 值！</span></span><br><span class="line">    updateOomAdjLocked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更新所有进程的 <code>adj</code> 值！</p>
<h3 id="2-5-2-addAppLocked"><a href="#2-5-2-addAppLocked" class="headerlink" title="2.5.2 addAppLocked"></a>2.5.2 addAppLocked</h3><p>ActivityManagerService.addAppLocked: 创建 persistent 进程，以下是关键代码段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//【1】当该进程第一次或者重新创建时，会更新所有进程的 oomAdj！</span></span><br><span class="line"><span class="keyword">if</span> (app == <span class="keyword">null</span>) &#123;</span><br><span class="line">    app = newProcessRecordLocked(info, <span class="keyword">null</span>, isolated, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//【1.1】更新 lru 进程列表；</span></span><br><span class="line">    updateLruProcessLocked(app, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//【1.2】更新进程 oomAdj；</span></span><br><span class="line">    updateOomAdjLocked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更新所有进程的 oomAdj！</p>
<h3 id="2-5-3-attachApplicationLocked"><a href="#2-5-3-attachApplicationLocked" class="headerlink" title="2.5.3 attachApplicationLocked"></a>2.5.3 attachApplicationLocked</h3><p>ActivityManagerService.attachApplicationLocked: 进程创建后 attach 到 system_server 的过程，以下是关键代码段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">... ... ... ...</span><br><span class="line"><span class="keyword">if</span> (badApp) &#123;</span><br><span class="line">    app.kill(<span class="string">"error during init"</span>, <span class="keyword">true</span>);</span><br><span class="line">    handleAppDiedLocked(app, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//【1】didSomething 表示我们在启动进程后是否执行了启动组件的操作</span></span><br><span class="line"><span class="comment">// 如果有 didSomething 就为 true，那就不需要在这里更新了，因为组件启动过程会有更新的操作！</span></span><br><span class="line"><span class="keyword">if</span> (!didSomething) &#123;</span><br><span class="line">    updateOomAdjLocked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更新所有进程的 adj 值！</p>
<h3 id="2-5-4-trimApplications"><a href="#2-5-4-trimApplications" class="headerlink" title="2.5.4 trimApplications"></a>2.5.4 trimApplications</h3><p>ActivityManagerService.trimApplications: 回收应用程序内存，以下是关键代码段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理所有要被移除的进程，回收资源！</span></span><br><span class="line"><span class="keyword">for</span> (i = mRemovedProcesses.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">    <span class="keyword">final</span> ProcessRecord app = mRemovedProcesses.get(i);</span><br><span class="line">    <span class="keyword">if</span> (app.activities.size() == <span class="number">0</span></span><br><span class="line">            &amp;&amp; app.curReceiver == <span class="keyword">null</span> &amp;&amp; app.services.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (app.pid &gt; <span class="number">0</span> &amp;&amp; app.pid != MY_PID) &#123;</span><br><span class="line">            app.kill(<span class="string">"empty"</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                app.thread.scheduleExit();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cleanUpApplicationRecordLocked(app, <span class="keyword">false</span>, <span class="keyword">true</span>, -<span class="number">1</span>, <span class="keyword">false</span> <span class="comment">/*replacingPid*/</span>);</span><br><span class="line">        mRemovedProcesses.remove(i);</span><br><span class="line">        <span class="comment">//【1】如果该进程是 persistent，那就要 addAppLocked！</span></span><br><span class="line">        <span class="keyword">if</span> (app.persistent) &#123;</span><br><span class="line">            addAppLocked(app.info, <span class="keyword">false</span>, <span class="keyword">null</span> <span class="comment">/* ABI override */</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//【2】更新所有进程的 oomAdj！</span></span><br><span class="line">updateOomAdjLocked();</span><br></pre></td></tr></table></figure>
<p>更新所有进程的 oomAdj！</p>
<h3 id="2-5-5-appDiedLocked"><a href="#2-5-5-appDiedLocked" class="headerlink" title="2.5.5 appDiedLocked"></a>2.5.5 appDiedLocked</h3><p>ActivityManagerService.appDiedLocked：进程死亡，以下是关键代码段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表示进程被重启了！</span></span><br><span class="line"><span class="keyword">if</span> (app.pid == pid &amp;&amp; app.thread != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">         app.thread.asBinder() == thread.asBinder()) &#123;</span><br><span class="line">     <span class="keyword">boolean</span> doLowMem = app.instrumentationClass == <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">boolean</span> doOomAdj = doLowMem;</span><br><span class="line">     <span class="keyword">if</span> (!app.killedByAm) &#123;</span><br><span class="line">         Slog.i(TAG, <span class="string">"Process "</span> + app.processName + <span class="string">" (pid "</span> + pid</span><br><span class="line">                 + <span class="string">") has died"</span>);</span><br><span class="line">         mAllowLowerMemLevel = <span class="keyword">true</span>;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// Note that we always want to do oom adj to update our state with the</span></span><br><span class="line">         <span class="comment">// new number of procs.</span></span><br><span class="line">         mAllowLowerMemLevel = <span class="keyword">false</span>;</span><br><span class="line">         doLowMem = <span class="keyword">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     EventLog.writeEvent(EventLogTags.AM_PROC_DIED, app.userId, app.pid, app.processName);</span><br><span class="line">     <span class="keyword">if</span> (DEBUG_CLEANUP) Slog.v(TAG_CLEANUP,</span><br><span class="line">         <span class="string">"Dying app: "</span> + app + <span class="string">", pid: "</span> + pid + <span class="string">", thread: "</span> + thread.asBinder());</span><br><span class="line">     handleAppDiedLocked(app, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (doOomAdj) &#123;</span><br><span class="line">         <span class="comment">//【1】更新所有进程的 oomAdj！</span></span><br><span class="line">         updateOomAdjLocked();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (doLowMem) &#123;</span><br><span class="line">         doLowMemReportIfNeededLocked(app);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (app.pid != pid) &#123;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>更新所有进程的 oomAdj！</p>
<h3 id="2-5-6-killAllBackgroundProcesses"><a href="#2-5-6-killAllBackgroundProcesses" class="headerlink" title="2.5.6 killAllBackgroundProcesses"></a>2.5.6 killAllBackgroundProcesses</h3><p>ActivityManagerService.killAllBackgroundProcesses: 杀死所有后台进程，以下是关键代码段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">final</span> ArrayList&lt;ProcessRecord&gt; procs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> NP = mProcessNames.getMap().size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> ip = <span class="number">0</span>; ip &lt; NP; ip++) &#123;</span><br><span class="line">        <span class="keyword">final</span> SparseArray&lt;ProcessRecord&gt; apps = mProcessNames.getMap().valueAt(ip);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> NA = apps.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> ia = <span class="number">0</span>; ia &lt; NA; ia++) &#123;</span><br><span class="line">            <span class="keyword">final</span> ProcessRecord app = apps.valueAt(ia);</span><br><span class="line">            <span class="comment">//【1】跳过 persistent 进程！</span></span><br><span class="line">            <span class="keyword">if</span> (app.persistent) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//【2】杀死 removed 为 ture 的进程</span></span><br><span class="line">            <span class="keyword">if</span> (app.removed) &#123;</span><br><span class="line">                procs.add(app);</span><br><span class="line">            <span class="comment">//【3】杀死 adj &gt;= CACHED_APP_MIN_ADJ 的进程！</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (app.setAdj &gt;= ProcessList.CACHED_APP_MIN_ADJ) &#123;</span><br><span class="line">                app.removed = <span class="keyword">true</span>;</span><br><span class="line">                procs.add(app);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【4】杀死上述两种进程！</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> N = procs.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        removeProcessLocked(procs.get(i), <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="string">"kill all background"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mAllowLowerMemLevel = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【5】更新了所有进程</span></span><br><span class="line">    updateOomAdjLocked();</span><br><span class="line">    doLowMemReportIfNeededLocked(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续分析！</p>
<h3 id="2-5-7-killPackageProcessesLocked"><a href="#2-5-7-killPackageProcessesLocked" class="headerlink" title="2.5.7 killPackageProcessesLocked"></a>2.5.7 killPackageProcessesLocked</h3><p><code>ActivityManagerService.killPackageProcessesLocked</code>: 杀掉指定包名相关的进程，以下是关键代码段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">... ... ...<span class="comment">// 收集需要被杀掉的进程，这里就列出了！</span></span><br><span class="line"><span class="keyword">int</span> N = procs.size();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">    removeProcessLocked(procs.get(i), callerWillRestart, allowRestart, reason);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调整所有进程的 oomAdj！</span></span><br><span class="line">updateOomAdjLocked();</span><br></pre></td></tr></table></figure>
<p>调整所有进程的 oomAdj！</p>
<h3 id="2-5-8-setProcessForeground"><a href="#2-5-8-setProcessForeground" class="headerlink" title="2.5.8 setProcessForeground"></a>2.5.8 setProcessForeground</h3><p><code>ActivityManagerService.setProcessForeground</code>：设置进程为前台进程，下面是关键代码片段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里的 isForeground 是 setProcessForeground 的参数，表示是否为前台进程！</span></span><br><span class="line"><span class="keyword">synchronized</span> (mPidsSelfLocked) &#123;</span><br><span class="line">    <span class="comment">// 获得 pid 对应的进程！</span></span><br><span class="line">    ProcessRecord pr = mPidsSelfLocked.get(pid);</span><br><span class="line">    <span class="keyword">if</span> (pr == <span class="keyword">null</span> &amp;&amp; isForeground) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"setProcessForeground called on unknown pid: "</span> + pid);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获得该进程对应的前台 token，如果不为 null，说明该进程已经是前台进程</span></span><br><span class="line">    <span class="comment">// 那就要先移除旧的 token！</span></span><br><span class="line">    ForegroundToken oldToken = mForegroundProcesses.get(pid);</span><br><span class="line">    <span class="keyword">if</span> (oldToken != <span class="keyword">null</span>) &#123;</span><br><span class="line">        oldToken.token.unlinkToDeath(oldToken, <span class="number">0</span>); <span class="comment">// 解除绑定死亡仆告对象！</span></span><br><span class="line">        mForegroundProcesses.remove(pid);</span><br><span class="line">        <span class="keyword">if</span> (pr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pr.forcingToForeground = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        changed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果 isForeground 为 true，且 token 不为 null，这里的</span></span><br><span class="line">    <span class="keyword">if</span> (isForeground &amp;&amp; token != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ForegroundToken newToken = <span class="keyword">new</span> ForegroundToken() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">binderDied</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                foregroundTokenDied(<span class="keyword">this</span>); <span class="comment">// 当 binder 对象死亡后，该方法会被调用！</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        newToken.pid = pid; <span class="comment">// 设置 newToken 的 pid 和 token！</span></span><br><span class="line">        newToken.token = token;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            token.linkToDeath(newToken, <span class="number">0</span>); <span class="comment">// 给 token 绑定死亡仆告对象！</span></span><br><span class="line">            mForegroundProcesses.put(pid, newToken); <span class="comment">// 将该进程加入到 mForegroundProcesses 列表中！</span></span><br><span class="line">            pr.forcingToForeground = token;</span><br><span class="line">            changed = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (changed) &#123; <span class="comment">// 当我们设置了一个进程为前台进程，我们需要更新所有进程的 oomAdj！</span></span><br><span class="line">    updateOomAdjLocked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调整所有进程的 <code>oomAdj</code>！</p>
<p>首先我说下 <code>ForegroundToken</code>，表示一个前台句柄，其内部有一个 <code>token</code> 对象，该对象是一个 <code>Binder</code> 对象！当我们设置了一个进程为前台进程后，每个进程都会有一个 <code>token</code> 对象！</p>
<p>其使用场景是，弹出 <code>Toast</code>，当一个进程中会弹出 <code>Toast</code> 后，该进程会被设置为前台进程，就会触发 <code>setProcessForeground</code> 方法！<code>token</code> 对象定义是在 <code>NotificationManagerService</code> 中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> IBinder mForegroundToken = <span class="keyword">new</span> Binder();</span><br></pre></td></tr></table></figure>
<p>再说一下：<code>ForegroundToken.binderDied</code> 方法，当 <code>token</code> 死亡后，其会被调用，从而触发 <code>foregroundTokenDied</code>!</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foregroundTokenDied</span><span class="params">(ForegroundToken token)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (ActivityManagerService.<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mPidsSelfLocked) &#123;</span><br><span class="line">            ForegroundToken cur</span><br><span class="line">                = mForegroundProcesses.get(token.pid);</span><br><span class="line">            <span class="keyword">if</span> (cur != token) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mForegroundProcesses.remove(token.pid);</span><br><span class="line">            ProcessRecord pr = mPidsSelfLocked.get(token.pid);</span><br><span class="line">            <span class="keyword">if</span> (pr == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pr.forcingToForeground = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 更新前台进程信息！</span></span><br><span class="line">            updateProcessForegroundLocked(pr, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新进程的 oomAdj</span></span><br><span class="line">        updateOomAdjLocked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调整所有进程的 <code>oomAdj</code>！</p>
<h3 id="2-5-9-setHasTopUi"><a href="#2-5-9-setHasTopUi" class="headerlink" title="2.5.9 setHasTopUi"></a>2.5.9 setHasTopUi</h3><p><code>ActivityManagerService.setHasTopUi</code>：设置进程是否具有 <code>top ui</code>！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHasTopUi</span><span class="params">(<span class="keyword">boolean</span> hasTopUi)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    <span class="comment">// 检查 permission.INTERNAL_SYSTEM_WINDOW 权限！</span></span><br><span class="line">    <span class="keyword">if</span> (checkCallingPermission(permission.INTERNAL_SYSTEM_WINDOW) != PERMISSION_GRANTED) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> pid = Binder.getCallingPid();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> changed = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// 获得 pid 对应的进程！</span></span><br><span class="line">            ProcessRecord pr;</span><br><span class="line">            <span class="keyword">synchronized</span> (mPidsSelfLocked) &#123;</span><br><span class="line">                pr = mPidsSelfLocked.get(pid);</span><br><span class="line">                <span class="keyword">if</span> (pr == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Slog.w(TAG, <span class="string">"setHasTopUi called on unknown pid: "</span> + pid);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 判断进程的 hasTopUi 是否发生变化！</span></span><br><span class="line">                <span class="keyword">if</span> (pr.hasTopUi != hasTopUi) &#123;</span><br><span class="line">                    Slog.i(TAG, <span class="string">"Setting hasTopUi="</span> + hasTopUi + <span class="string">" for pid="</span> + pid);</span><br><span class="line">                    pr.hasTopUi = hasTopUi;</span><br><span class="line">                    changed = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 发生了变化，那就更新该进程的 oomAdj！</span></span><br><span class="line">            <span class="keyword">if</span> (changed) &#123;</span><br><span class="line">                updateOomAdjLocked(pr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只更新特定进程的 <code>oomAdj</code>！</p>
<p>该方法主要是在状态栏使用，具体的代码在 <code>StatusBarWindowManager.apply</code> 方法中，以下是关键代码！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(State state)</span> </span>&#123;</span><br><span class="line">    ... ... ...</span><br><span class="line">    <span class="keyword">if</span> (mHasTopUi != mHasTopUiChanged) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mActivityManager.setHasTopUi(mHasTopUiChanged);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">"Failed to call setHasTopUi"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        mHasTopUi = mHasTopUiChanged;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-5-10-updateSleepIfNeededLocked"><a href="#2-5-10-updateSleepIfNeededLocked" class="headerlink" title="2.5.10 updateSleepIfNeededLocked"></a>2.5.10 updateSleepIfNeededLocked</h3><p><code>ActivityManagerService.updateSleepIfNeededLocked</code>：更新睡眠状态！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateSleepIfNeededLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mSleeping &amp;&amp; !shouldSleepLocked()) &#123; <span class="comment">// 退出休眠时！</span></span><br><span class="line">        mSleeping = <span class="keyword">false</span>;</span><br><span class="line">        startTimeTrackingFocusedActivityLocked();</span><br><span class="line">        mTopProcessState = ActivityManager.PROCESS_STATE_TOP;</span><br><span class="line">        mStackSupervisor.comeOutOfSleepIfNeededLocked();</span><br><span class="line">        <span class="comment">// 更新服务的 oomAdj！</span></span><br><span class="line">        updateOomAdjLocked();</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!mSleeping &amp;&amp; shouldSleepLocked()) &#123; <span class="comment">// 进入休眠时！</span></span><br><span class="line">        mSleeping = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (mCurAppTimeTracker != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mCurAppTimeTracker.stop();</span><br><span class="line">        &#125;</span><br><span class="line">        mTopProcessState = ActivityManager.PROCESS_STATE_TOP_SLEEPING;</span><br><span class="line">        mStackSupervisor.goingToSleepLocked();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新服务的 oomAdj！</span></span><br><span class="line">        updateOomAdjLocked();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Initialize the wake times of all processes.</span></span><br><span class="line">        checkExcessivePowerUsageLocked(<span class="keyword">false</span>);</span><br><span class="line">        mHandler.removeMessages(CHECK_EXCESSIVE_WAKE_LOCKS_MSG);</span><br><span class="line">        Message nmsg = mHandler.obtainMessage(CHECK_EXCESSIVE_WAKE_LOCKS_MSG);</span><br><span class="line">        mHandler.sendMessageDelayed(nmsg, POWER_CHECK_DELAY);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更新所有服务的 <code>oomAdj</code>！</p>
<h2 id="2-6-总结"><a href="#2-6-总结" class="headerlink" title="2.6 总结"></a>2.6 总结</h2><p>下面我用思维导图总结下，<code>updateOomAdjLocked</code> 的调用时机，当然了，随着版本的更替，代码逻辑和调用机制势必会发生变化，但是，<strong>已有的架构和逻辑依然具有很强的参考性</strong>，也能帮助我们在新的版本上快速建立代价整体结构的认识！！</p>
<h1 id="3-oomAdj-算法分析"><a href="#3-oomAdj-算法分析" class="headerlink" title="3 oomAdj 算法分析"></a>3 oomAdj 算法分析</h1><p>接下来，我们就要分析下 <code>oomAdj</code> 调度的核心算法了，我们从 <code>updateOomAdjLocked</code> 方法入手，我们先从最简单的一参函数看起：</p>
<h2 id="3-1-1-ActivityManagerS-updateOomAdjLocked-更新指定进程-oomAdj"><a href="#3-1-1-ActivityManagerS-updateOomAdjLocked-更新指定进程-oomAdj" class="headerlink" title="3.1 [1]ActivityManagerS.updateOomAdjLocked - 更新指定进程 oomAdj"></a>3.1 [1]ActivityManagerS.updateOomAdjLocked - 更新指定进程 oomAdj</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">updateOomAdjLocked</span><span class="params">(ProcessRecord app)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获得 top activity 以及其所在的进程 top process！</span></span><br><span class="line">    <span class="keyword">final</span> ActivityRecord TOP_ACT = resumedAppLocked();</span><br><span class="line">    <span class="keyword">final</span> ProcessRecord TOP_APP = TOP_ACT != <span class="keyword">null</span> ? TOP_ACT.app : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该进程是否是缓存进程！</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> wasCached = app.cached;</span><br><span class="line"></span><br><span class="line">    mAdjSeq++; <span class="comment">// adj 序列计数加 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】计算 cahce 状态的 adj</span></span><br><span class="line">    <span class="comment">// 如果我们知道，我们的目标进程是处于缓存状态，那么我们返回 app.curRawAdj，否则</span></span><br><span class="line">    <span class="comment">// 我们不能确定其 adj 的值，设置其为 UNKNOWN_ADJ</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> cachedAdj = app.curRawAdj &gt;= ProcessList.CACHED_APP_MIN_ADJ</span><br><span class="line">            ? app.curRawAdj : ProcessList.UNKNOWN_ADJ;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【2】更新指定进程的 oomAdj 的值，调用 5 个参数的 updateOomAdjLocked 方法，具体见[3.2]；       </span></span><br><span class="line">    <span class="keyword">boolean</span> success = updateOomAdjLocked(app, cachedAdj, TOP_APP, <span class="keyword">false</span>,</span><br><span class="line">            SystemClock.uptimeMillis());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【3】如果进程的从非缓存状态变为了缓存状态，或者相反，我们也要更新 lru 列表中其他进程的 adj！</span></span><br><span class="line">    <span class="keyword">if</span> (wasCached != app.cached || app.curRawAdj == ProcessList.UNKNOWN_ADJ) &#123;</span><br><span class="line">        updateOomAdjLocked();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更新指定进程的 <code>oomAdj</code>，被更新的进程的 <code>app.adjSeq</code> 值会等于 <code>mAdjSeq</code>，这个我们后续再看！</p>
<p>对于 <code>cachedAdj</code> 的取值范围：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNKNOWN_ADJ = <span class="number">1001</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CACHED_APP_MIN_ADJ = <span class="number">900</span>;</span><br></pre></td></tr></table></figure>
<p>该方法主要功能：</p>
<ul>
<li>执行五参 <code>updateOomAdjLocked</code>，更新指定进程的 <code>adj</code>；</li>
<li>当 <code>app</code> 经过更新 <code>adj</code> 操作后，其 <code>cached</code> 状态改变，或者 <code>curRawAdj=UNKNOWN_ADJ</code>，则执行空参 <code>updateOomAdjLocked</code>，更新所有进程的<code>adj</code>；</li>
</ul>
<p>继续来看：</p>
<h3 id="3-1-1-ActivityManagerS-resumedAppLocked"><a href="#3-1-1-ActivityManagerS-resumedAppLocked" class="headerlink" title="3.1.1 ActivityManagerS.resumedAppLocked"></a>3.1.1 ActivityManagerS.resumedAppLocked</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> ActivityRecord <span class="title">resumedAppLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获得当前的 top activity！</span></span><br><span class="line">    ActivityRecord act = mStackSupervisor.resumedAppLocked();</span><br><span class="line">    String pkg;</span><br><span class="line">    <span class="keyword">int</span> uid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//　获得 top activity 的 uid 和 package！</span></span><br><span class="line">    <span class="keyword">if</span> (act != <span class="keyword">null</span>) &#123;</span><br><span class="line">        pkg = act.packageName;</span><br><span class="line">        uid = act.info.applicationInfo.uid;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pkg = <span class="keyword">null</span>;</span><br><span class="line">        uid = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Has the UID or resumed package name changed?</span></span><br><span class="line">    <span class="comment">// 更新一下　mCurResumedUid 和 mCurResumedPackage</span></span><br><span class="line">    <span class="keyword">if</span> (uid != mCurResumedUid || (pkg != mCurResumedPackage</span><br><span class="line">            &amp;&amp; (pkg == <span class="keyword">null</span> || !pkg.equals(mCurResumedPackage)))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCurResumedPackage != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mBatteryStatsService.noteEvent(BatteryStats.HistoryItem.EVENT_TOP_FINISH,</span><br><span class="line">                    mCurResumedPackage, mCurResumedUid);</span><br><span class="line">        &#125;</span><br><span class="line">        mCurResumedPackage = pkg;</span><br><span class="line">        mCurResumedUid = uid;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 当前的 current resume pacakge 发生了变化，通知 BatteryStats</span></span><br><span class="line">        <span class="keyword">if</span> (mCurResumedPackage != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mBatteryStatsService.noteEvent(BatteryStats.HistoryItem.EVENT_TOP_START,</span><br><span class="line">                    mCurResumedPackage, mCurResumedUid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> act;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-1-1-1-ActivityStackSupervisor-resumedAppLocked"><a href="#3-1-1-1-ActivityStackSupervisor-resumedAppLocked" class="headerlink" title="3.1.1.1 ActivityStackSupervisor.resumedAppLocked"></a>3.1.1.1 ActivityStackSupervisor.resumedAppLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ActivityRecord <span class="title">resumedAppLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】获得焦点 stack!</span></span><br><span class="line">    ActivityStack stack = mFocusedStack;</span><br><span class="line">    <span class="keyword">if</span> (stack == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【2】获得 resume activity！</span></span><br><span class="line">    ActivityRecord resumedActivity = stack.mResumedActivity;</span><br><span class="line">    <span class="keyword">if</span> (resumedActivity == <span class="keyword">null</span> || resumedActivity.app == <span class="keyword">null</span>) &#123;</span><br><span class="line">        resumedActivity = stack.mPausingActivity;</span><br><span class="line">        <span class="keyword">if</span> (resumedActivity == <span class="keyword">null</span> || resumedActivity.app == <span class="keyword">null</span>) &#123;</span><br><span class="line">            resumedActivity = stack.topRunningActivityLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resumedActivity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们可以看到 <code>resumedActivity</code> 的获取逻辑！</p>
<ul>
<li>首先会焦点 <code>stack</code> 获取 <code>mResumedActivity</code>;</li>
<li>如果 <code>resumedActivity</code> 不存在，那就获取 <code>mPausingActivity</code>;</li>
<li>如果 <code>mPausingActivity</code> 不存在，那就获取 <code>top activity</code>！</li>
</ul>
<h2 id="3-3-0-ActivityManagerS-updateOomAdjLocked-更新-LRU-列表中的所有进程"><a href="#3-3-0-ActivityManagerS-updateOomAdjLocked-更新-LRU-列表中的所有进程" class="headerlink" title="3.3 [0]ActivityManagerS.updateOomAdjLocked - 更新 LRU 列表中的所有进程"></a>3.3 [0]ActivityManagerS.updateOomAdjLocked - 更新 LRU 列表中的所有进程</h2><p>刚才我们看了 <code>updateOomAdjLocked</code> 的一参和多参数方法，用来更新指定的进程的 <code>adj</code>，到那时如果该进程的状态在 <code>cache</code> 和非 <code>cache</code> 之前切换了，那就会更新所有进程的 <code>adj</code> 状态！</p>
<p>这个是最核心的一个方法，方法体很长，我们耐心点来看！！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">updateOomAdjLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】获取 top Activity 以及其所在的 top process!</span></span><br><span class="line">    <span class="keyword">final</span> ActivityRecord TOP_ACT = resumedAppLocked();</span><br><span class="line">    <span class="keyword">final</span> ProcessRecord TOP_APP = TOP_ACT != <span class="keyword">null</span> ? TOP_ACT.app : <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> nowElapsed = SystemClock.elapsedRealtime();</span><br><span class="line">    <span class="comment">// MAX_EMPTY_TIME 表示空进程的存活时长，为 30min！</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> oldTime = now - ProcessList.MAX_EMPTY_TIME;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【2】获得 LRU 进程列表的大小！</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> N = mLruProcesses.size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">        RuntimeException e = <span class="keyword">new</span> RuntimeException();</span><br><span class="line">        e.fillInStackTrace();</span><br><span class="line">        Slog.i(TAG, <span class="string">"updateOomAdj: top="</span> + TOP_ACT, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【3】重置当前所有 active uid 内部记录的进程状态：ActivityManager.PROCESS_STATE_CACHED_EMPTY：16</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=mActiveUids.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">final</span> UidRecord uidRec = mActiveUids.valueAt(i);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">false</span> &amp;&amp; DEBUG_UID_OBSERVERS) Slog.i(TAG_UID_OBSERVERS,</span><br><span class="line">                <span class="string">"Starting update of "</span> + uidRec);</span><br><span class="line">        uidRec.reset();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【4】给所有的 task 排序，更新 task 的 mLayerRank 变量！</span></span><br><span class="line">    mStackSupervisor.rankTaskLayersIfNeeded();</span><br><span class="line"></span><br><span class="line">    mAdjSeq++; <span class="comment">// 更新本次计算序列号 +1</span></span><br><span class="line"></span><br><span class="line">    mNewNumServiceProcs = <span class="number">0</span>; <span class="comment">// 表示最新的服务进程数（更新 adj 后）；</span></span><br><span class="line">    mNewNumAServiceProcs = <span class="number">0</span>; <span class="comment">// 表示最新的 A service 进程数（更新 adj 后）；</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//【5】根据系统空进程和缓存进程的总限制量，计算空进程和缓存进程限制数！！</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> emptyProcessLimit;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> cachedProcessLimit;</span><br><span class="line">    <span class="keyword">if</span> (mProcessLimit &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        emptyProcessLimit = cachedProcessLimit = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mProcessLimit == <span class="number">1</span>) &#123;</span><br><span class="line">        emptyProcessLimit = <span class="number">1</span>;</span><br><span class="line">        cachedProcessLimit = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 调用 ProcessList.computeEmptyProcessLimit 计算空进程限制数，计算方法为：totalProcessLimit(参数) / 2</span></span><br><span class="line">        emptyProcessLimit = ProcessList.computeEmptyProcessLimit(mProcessLimit);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可以得到：</span></span><br><span class="line">        <span class="comment">// 缓存进程限制数 = 空进程限制数 = 总进程限制数 / 2；</span></span><br><span class="line">        cachedProcessLimit = mProcessLimit - emptyProcessLimit;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CACHED_APP_MAX_ADJ 为 906，而 CACHED_APP_MIN_ADJ 为 900，所以计算出的 numSlots 为 3</span></span><br><span class="line">    <span class="comment">// 就是说，我们将 cache adj 划分为 3 个范围，每个范围可以容纳定量的 empty 和 cache 进程！</span></span><br><span class="line">    <span class="keyword">int</span> numSlots = (ProcessList.CACHED_APP_MAX_ADJ</span><br><span class="line">            - ProcessList.CACHED_APP_MIN_ADJ + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算当前空进程的数量：等于所有进程数 N - 非 cache 进程数 - 被隐藏的 cache 进程数！ </span></span><br><span class="line">    <span class="keyword">int</span> numEmptyProcs = N - mNumNonCachedProcs - mNumCachedHiddenProcs;</span><br><span class="line">    <span class="keyword">if</span> (numEmptyProcs &gt; cachedProcessLimit) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 空进程的数量不能超过缓存进程限制数，最大只能和其相等，这是一定的！</span></span><br><span class="line">        numEmptyProcs = cachedProcessLimit;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算空进程分配因子（每个 slot 可以容纳的空进程数量），最高为 1；</span></span><br><span class="line">    <span class="keyword">int</span> emptyFactor = numEmptyProcs / numSlots;</span><br><span class="line">    <span class="keyword">if</span> (emptyFactor &lt; <span class="number">1</span>) emptyFactor = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算缓存进程分配因子（计算出每个 slot 中，可容纳后台进程的数量），最高为 1；</span></span><br><span class="line">    <span class="keyword">int</span> cachedFactor = (mNumCachedHiddenProcs &gt; <span class="number">0</span> ? mNumCachedHiddenProcs : <span class="number">1</span>) / numSlots;</span><br><span class="line">    <span class="keyword">if</span> (cachedFactor &lt; <span class="number">1</span>) cachedFactor = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> stepCached = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> stepEmpty = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numCached = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> numEmpty = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> numTrimming = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    mNumNonCachedProcs = <span class="number">0</span>; <span class="comment">// 用于记录非 cache/empty 进程数，初始化为 0；</span></span><br><span class="line">    mNumCachedHiddenProcs = <span class="number">0</span>; <span class="comment">// 用于记录 cache 进程数，初四化为 0；</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于为 cache 进程和 empty 进程分配 adj！</span></span><br><span class="line">    <span class="keyword">int</span> curCachedAdj = ProcessList.CACHED_APP_MIN_ADJ; <span class="comment">// 900；</span></span><br><span class="line">    <span class="keyword">int</span> nextCachedAdj = curCachedAdj + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> curEmptyAdj = ProcessList.CACHED_APP_MIN_ADJ; <span class="comment">// 900；</span></span><br><span class="line">    <span class="keyword">int</span> nextEmptyAdj = curEmptyAdj + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【8】逆序遍历 mLruProcesses 进程列表，更新每一个进程的 adj！</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=N-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">        ProcessRecord app = mLruProcesses.get(i);</span><br><span class="line">        <span class="keyword">if</span> (!app.killedByAm &amp;&amp; app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            app.procStateChanged = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【8.1】这里调用了 5 个参数的 computeOomAdjLocked 方法，更新指定的进程的 adj</span></span><br><span class="line">            <span class="comment">// 注意这里的 doingAll 参数传入的是 true，具体分析见 3.3.1 节!</span></span><br><span class="line">            computeOomAdjLocked(app, ProcessList.UNKNOWN_ADJ, TOP_APP, <span class="keyword">true</span>, now);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果计算后，仍然没有分配给进程一个合适的 adj，即：app.curAdj &gt;= ProcessList.UNKNOWN_ADJ</span></span><br><span class="line">            <span class="comment">// 那就在这里分配！</span></span><br><span class="line">            <span class="comment">// （computeOomAdjLocked 可能无法计算 cache 进程和 empty 进程的 adj，所以在下面处理！）</span></span><br><span class="line">            <span class="keyword">if</span> (app.curAdj &gt;= ProcessList.UNKNOWN_ADJ) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 根据进程的状态进行处理：</span></span><br><span class="line">                <span class="keyword">switch</span> (app.curProcState) &#123;</span><br><span class="line">                    <span class="keyword">case</span> ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:</span><br><span class="line">                    <span class="keyword">case</span> ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 如果进程是持有 activity 的 cache 进程，或者</span></span><br><span class="line">                        <span class="comment">// 给其分配一个 cache adj！</span></span><br><span class="line">                        <span class="comment">// 从 900 到 906，逐个分配，最大不超过 906！</span></span><br><span class="line">                        app.curRawAdj = curCachedAdj;</span><br><span class="line">                        app.curAdj = app.modifyRawOomAdj(curCachedAdj); <span class="comment">// 此时是单纯的加 1；</span></span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (DEBUG_LRU &amp;&amp; <span class="keyword">false</span>) Slog.d(TAG_LRU, <span class="string">"Assigning activity LRU #"</span> + i</span><br><span class="line">                                + <span class="string">" adj: "</span> + app.curAdj + <span class="string">" (curCachedAdj="</span> + curCachedAdj</span><br><span class="line">                                + <span class="string">")"</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (curCachedAdj != nextCachedAdj) &#123;</span><br><span class="line">                            stepCached++;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (stepCached &gt;= cachedFactor) &#123; <span class="comment">// 判断是否到达分配因子！</span></span><br><span class="line">                                stepCached = <span class="number">0</span>; <span class="comment">// stepCached 置为 0，进行下一个 slot 的分配！</span></span><br><span class="line">                                curCachedAdj = nextCachedAdj;</span><br><span class="line">                                nextCachedAdj += <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">if</span> (nextCachedAdj &gt; ProcessList.CACHED_APP_MAX_ADJ) &#123; <span class="comment">// 控制 adj 的不超过最大值！</span></span><br><span class="line">                                    nextCachedAdj = ProcessList.CACHED_APP_MAX_ADJ;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="comment">// 否则，将其视为 empty 进程对待，给其分配一个 empty adj！</span></span><br><span class="line">                        <span class="comment">// 从 900 到 906，逐个分配，最大不超过 906！</span></span><br><span class="line">                        app.curRawAdj = curEmptyAdj;</span><br><span class="line">                        app.curAdj = app.modifyRawOomAdj(curEmptyAdj);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (DEBUG_LRU &amp;&amp; <span class="keyword">false</span>) Slog.d(TAG_LRU, <span class="string">"Assigning empty LRU #"</span> + i</span><br><span class="line">                                + <span class="string">" adj: "</span> + app.curAdj + <span class="string">" (curEmptyAdj="</span> + curEmptyAdj</span><br><span class="line">                                + <span class="string">")"</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (curEmptyAdj != nextEmptyAdj) &#123;</span><br><span class="line">                            stepEmpty++;</span><br><span class="line">                            <span class="keyword">if</span> (stepEmpty &gt;= emptyFactor) &#123;</span><br><span class="line">                                stepEmpty = <span class="number">0</span>;</span><br><span class="line">                                curEmptyAdj = nextEmptyAdj;</span><br><span class="line">                                nextEmptyAdj += <span class="number">2</span>;</span><br><span class="line">                                <span class="keyword">if</span> (nextEmptyAdj &gt; ProcessList.CACHED_APP_MAX_ADJ) &#123;</span><br><span class="line">                                    nextEmptyAdj = ProcessList.CACHED_APP_MAX_ADJ;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//【8.2】分配好后，调用 applyOomAdjLocked 更新进程的 adj，具体分析见 3.3.2 节!</span></span><br><span class="line">            applyOomAdjLocked(app, <span class="keyword">true</span>, now, nowElapsed);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【8.3】根据进程的类型，统计不同类型的进程数量!</span></span><br><span class="line">            <span class="keyword">switch</span> (app.curProcState) &#123;</span><br><span class="line">                <span class="keyword">case</span> ActivityManager.PROCESS_STATE_CACHED_ACTIVITY:</span><br><span class="line">                <span class="keyword">case</span> ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT:</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 如果进程是持有 activity 的 cache 进程或者是客户端进程，</span></span><br><span class="line">                    <span class="comment">// 属于 cache 进程，mNumCachedHiddenProcs 加 1!</span></span><br><span class="line">                    mNumCachedHiddenProcs++;</span><br><span class="line">                    numCached++;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 注意，如果当前 cache 进程数量超过了限制量，那就杀掉超过限制的所有进程！</span></span><br><span class="line">                    <span class="comment">// 但是依然统计数量！</span></span><br><span class="line">                    <span class="keyword">if</span> (numCached &gt; cachedProcessLimit) &#123;</span><br><span class="line">                        app.kill(<span class="string">"cached #"</span> + numCached, <span class="keyword">true</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> ActivityManager.PROCESS_STATE_CACHED_EMPTY:</span><br><span class="line">            </span><br><span class="line">                    <span class="comment">// 如果进程是 empty cache 进程，下面的处理！</span></span><br><span class="line">                    <span class="keyword">if</span> (numEmpty &gt; ProcessList.TRIM_EMPTY_APPS</span><br><span class="line">                            &amp;&amp; app.lastActivityTime &lt; oldTime) &#123;</span><br><span class="line">                        <span class="comment">// 如果空进程的数量超过了空进程上限数，且该空进程的空闲时间超过了 30 min</span></span><br><span class="line">                        <span class="comment">// 那就杀掉该进程！</span></span><br><span class="line">                        app.kill(<span class="string">"empty for "</span></span><br><span class="line">                                + ((oldTime + ProcessList.MAX_EMPTY_TIME - app.lastActivityTime)</span><br><span class="line">                                / <span class="number">1000</span>) + <span class="string">"s"</span>, <span class="keyword">true</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 否则，numEmpty 加 1，如果此时空进程数超过了空进程限制数，杀掉该进程！</span></span><br><span class="line">                        <span class="comment">// 但是依然统计数量！</span></span><br><span class="line">                        numEmpty++;</span><br><span class="line">                        <span class="keyword">if</span> (numEmpty &gt; emptyProcessLimit) &#123;</span><br><span class="line">                            app.kill(<span class="string">"empty #"</span> + numEmpty, <span class="keyword">true</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="comment">// 其他类型，默认属于非 cache/empty 进程，mNumNonCachedProcs 加 1；</span></span><br><span class="line">                    mNumNonCachedProcs++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【8.4】进一步处理进程的状态！</span></span><br><span class="line">            <span class="keyword">if</span> (app.isolated &amp;&amp; app.services.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果这是一个隔离进程，且内部不再运行任何服务，kill 该进程！</span></span><br><span class="line">                app.kill(<span class="string">"isolated not needed"</span>, <span class="keyword">true</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            </span><br><span class="line">                <span class="comment">// 否则，保留该进程，更新其对应的 uid 中记录的进程状态！</span></span><br><span class="line">                <span class="keyword">final</span> UidRecord uidRec = app.uidRecord;</span><br><span class="line">                <span class="keyword">if</span> (uidRec != <span class="keyword">null</span> &amp;&amp; uidRec.curProcState &gt; app.curProcState) &#123;</span><br><span class="line">                    uidRec.curProcState = app.curProcState;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【8.5】进一步处理进程的状态！</span></span><br><span class="line">            <span class="keyword">if</span> (app.curProcState &gt;= ActivityManager.PROCESS_STATE_HOME</span><br><span class="line">                    &amp;&amp; !app.killedByAm) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 记录需要回收内存的，进程状态优先级不高于 PROCESS_STATE_HOME 的后台进程数量！</span></span><br><span class="line">                <span class="comment">// PROCESS_STATE_HOME 表示持有 Home 的后台进程的状态！</span></span><br><span class="line">                numTrimming++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【9】mNewNumServiceProcs 用于保存更新 adj 后，最新的服务进程数，更新 mNumServiceProcs！</span></span><br><span class="line">    mNumServiceProcs = mNewNumServiceProcs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【10】计算统计到的 cache 和 empty 进程总数！</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> numCachedAndEmpty = numCached + numEmpty;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【11】根据统计的 cache 和 empty 进程总数，计算内存回收等级，用于内存回收！</span></span><br><span class="line">    <span class="keyword">int</span> memFactor;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// TRIM_CACHED_APPS 表示触发内存回收的 cache 进程上限： 5；</span></span><br><span class="line">    <span class="comment">// TRIM_EMPTY_APPS 表示触发内存回收的 empty 进程上限：16；</span></span><br><span class="line">    <span class="keyword">if</span> (numCached &lt;= ProcessList.TRIM_CACHED_APPS</span><br><span class="line">            &amp;&amp; numEmpty &lt;= ProcessList.TRIM_EMPTY_APPS) &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (numCachedAndEmpty &lt;= ProcessList.TRIM_CRITICAL_THRESHOLD) &#123; <span class="comment">// 个数为 3；</span></span><br><span class="line">            <span class="comment">// 总数小于 3 时，内存回收等级为 critical，取值为 3！</span></span><br><span class="line">            memFactor = ProcessStats.ADJ_MEM_FACTOR_CRITICAL;</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (numCachedAndEmpty &lt;= ProcessList.TRIM_LOW_THRESHOLD) &#123; <span class="comment">// 个数为 5；</span></span><br><span class="line">            <span class="comment">// 总数小于 3 时，内存回收等级为 low，取值为 2；</span></span><br><span class="line">            memFactor = ProcessStats.ADJ_MEM_FACTOR_LOW; </span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则，内存回收等级为 moderate，取值为 1；</span></span><br><span class="line">            memFactor = ProcessStats.ADJ_MEM_FACTOR_MODERATE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 取值为 0，cachce 和 empty 进程足够时，内存回收等级为 normal</span></span><br><span class="line">        memFactor = ProcessStats.ADJ_MEM_FACTOR_NORMAL; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG_OOM_ADJ) Slog.d(TAG_OOM_ADJ, <span class="string">"oom: memFactor="</span> + memFactor</span><br><span class="line">            + <span class="string">" last="</span> + mLastMemoryLevel + <span class="string">" allowLow="</span> + mAllowLowerMemLevel</span><br><span class="line">            + <span class="string">" numProcs="</span> + mLruProcesses.size() + <span class="string">" last="</span> + mLastNumProcesses);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果新的内存回收等级比上一次的大，判读是否使用新的内存回收等级！</span></span><br><span class="line">    <span class="comment">// 一般情况下，内存回收等级变高时（即允许尽可能多地回收），是不允许降级的</span></span><br><span class="line">    <span class="comment">// 但 mAllowLowerMemLevel  为false，或进程数量变多时，可以降级！</span></span><br><span class="line">    <span class="keyword">if</span> (memFactor &gt; mLastMemoryLevel) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mAllowLowerMemLevel || mLruProcesses.size() &gt;= mLastNumProcesses) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 使用上一次的低内存级别！</span></span><br><span class="line">            memFactor = mLastMemoryLevel;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_OOM_ADJ) Slog.d(TAG_OOM_ADJ, <span class="string">"Keeping last mem factor!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (memFactor != mLastMemoryLevel) &#123;</span><br><span class="line">        EventLogTags.writeAmMemFactor(memFactor, mLastMemoryLevel);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新内存级别和进程数量！</span></span><br><span class="line">    mLastMemoryLevel = memFactor;</span><br><span class="line">    mLastNumProcesses = mLruProcesses.size();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将最新的内存回收等级保存到 ProcessStats 中，如果和上一次的不同，allChanged 为 true！</span></span><br><span class="line">    <span class="keyword">boolean</span> allChanged = mProcessStats.setMemFactorLocked(memFactor, !isSleepingLocked(), now);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> trackerMemFactor = mProcessStats.getMemFactorLocked();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果最新的内存回收等级不等于 normal，那么所有进程都要进行内存回收工作！</span></span><br><span class="line">    <span class="keyword">if</span> (memFactor != ProcessStats.ADJ_MEM_FACTOR_NORMAL) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mLowRamStartTime == <span class="number">0</span>) &#123; <span class="comment">// 记录内存回收时间</span></span><br><span class="line">            mLowRamStartTime = now;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> fgTrimLevel;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算前台进程的内存回收等级；</span></span><br><span class="line">        <span class="keyword">switch</span> (memFactor) &#123;</span><br><span class="line">            <span class="keyword">case</span> ProcessStats.ADJ_MEM_FACTOR_CRITICAL:</span><br><span class="line">                fgTrimLevel = ComponentCallbacks2.TRIM_MEMORY_RUNNING_CRITICAL; <span class="comment">// critical 级别；</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ProcessStats.ADJ_MEM_FACTOR_LOW:</span><br><span class="line">                fgTrimLevel = ComponentCallbacks2.TRIM_MEMORY_RUNNING_LOW; <span class="comment">// low 级别；</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                fgTrimLevel = ComponentCallbacks2.TRIM_MEMORY_RUNNING_MODERATE; <span class="comment">// moderate 级别；</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算回收因子，numTrimming 表示所有需要回收内存的后台进程！</span></span><br><span class="line">        <span class="comment">// 其实就是分阶段的回收！</span></span><br><span class="line">        <span class="keyword">int</span> factor = numTrimming / <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> minFactor = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 home 进程不会 null，previous 进程不为 null，最小因子均加 1；</span></span><br><span class="line">        <span class="keyword">if</span> (mHomeProcess != <span class="keyword">null</span>) minFactor++;</span><br><span class="line">        <span class="keyword">if</span> (mPreviousProcess != <span class="keyword">null</span>) minFactor++;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 回收因子不能低于最小因子！</span></span><br><span class="line">        <span class="keyword">if</span> (factor &lt; minFactor) factor = minFactor;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始默认的回收级别为 complete！</span></span><br><span class="line">        <span class="keyword">int</span> curLevel = ComponentCallbacks2.TRIM_MEMORY_COMPLETE;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 再次逆序遍历 mLruProcesses 列表，根据进程的状态进行不同的回收处理！</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=N-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">// 开始处理进程！</span></span><br><span class="line">            ProcessRecord app = mLruProcesses.get(i);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果内存回收等级变化了，或者进程的状态发生变化，更新进程的监控信息！</span></span><br><span class="line">            <span class="keyword">if</span> (allChanged || app.procStateChanged) &#123;</span><br><span class="line">                setProcessTrackerStateLocked(app, trackerMemFactor, now);</span><br><span class="line">                app.procStateChanged = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (app.curProcState &gt;= ActivityManager.PROCESS_STATE_HOME</span><br><span class="line">                    &amp;&amp; !app.killedByAm) &#123;</span><br><span class="line">            <span class="comment">// 如果进程的状态优先级不高于 PROCESS_STATE_HOME：12，并且没有被 AMS 后台杀死，进入该分支！</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (app.trimMemoryLevel &lt; curLevel &amp;&amp; app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果进程的内存回收级别低于 curLevel，并且进程还在运行，执行内存回收！</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,</span><br><span class="line">                                <span class="string">"Trimming memory of "</span> + app.processName + <span class="string">" to "</span> + curLevel);</span><br><span class="line">                        <span class="comment">// 回收内存！</span></span><br><span class="line">                        app.thread.scheduleTrimMemory(curLevel);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">false</span>) &#123; <span class="comment">// 这里默认是不进入的！</span></span><br><span class="line">                        <span class="keyword">if</span> (curLevel &gt;= ComponentCallbacks2.TRIM_MEMORY_COMPLETE</span><br><span class="line">                                &amp;&amp; app != mHomeProcess &amp;&amp; app != mPreviousProcess) &#123;</span><br><span class="line">                            mStackSupervisor.scheduleDestroyAllActivities(app, <span class="string">"trim"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 更新进程的内存回收级别！</span></span><br><span class="line">                app.trimMemoryLevel = curLevel;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 记录处理的进度，当到达回收因子的时候，step 归 0，准备进入下一个回收因子阶段！</span></span><br><span class="line">                step++;</span><br><span class="line">                <span class="keyword">if</span> (step &gt;= factor) &#123;</span><br><span class="line">                    step = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">switch</span> (curLevel) &#123;</span><br><span class="line">                        <span class="keyword">case</span> ComponentCallbacks2.TRIM_MEMORY_COMPLETE: </span><br><span class="line">                            <span class="comment">// 如果是 COMPLETE:80，设置 curLevel 为 MODERATE:60</span></span><br><span class="line">                            curLevel = ComponentCallbacks2.TRIM_MEMORY_MODERATE;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                            </span><br><span class="line">                        <span class="keyword">case</span> ComponentCallbacks2.TRIM_MEMORY_MODERATE:</span><br><span class="line">                            <span class="comment">// 如果是 COMPLETE:60，设置 curLevel 为 BACKGROUND:40</span></span><br><span class="line">                            curLevel = ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                            </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (app.curProcState == ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) &#123;</span><br><span class="line">            <span class="comment">// 如果进程的状态属于 height weight 类型（9）的进程，进入该分支！</span></span><br><span class="line">            </span><br><span class="line">                <span class="keyword">if</span> (app.trimMemoryLevel &lt; ComponentCallbacks2.TRIM_MEMORY_BACKGROUND</span><br><span class="line">                        &amp;&amp; app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 如果进程的内存回收级别低于 BACKGROUND:40，并且进程还在运行，执行内存回收！</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,</span><br><span class="line">                                <span class="string">"Trimming memory of heavy-weight "</span> + app.processName</span><br><span class="line">                                + <span class="string">" to "</span> + ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);</span><br><span class="line">                        <span class="comment">// 回收内存！</span></span><br><span class="line">                        app.thread.scheduleTrimMemory(</span><br><span class="line">                                ComponentCallbacks2.TRIM_MEMORY_BACKGROUND);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 更新进程的内存回收登记为 BACKGROUND:40</span></span><br><span class="line">                app.trimMemoryLevel = ComponentCallbacks2.TRIM_MEMORY_BACKGROUND;</span><br><span class="line">                </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 其他情况，进入这里：</span></span><br><span class="line">            </span><br><span class="line">                <span class="keyword">if</span> ((app.curProcState &gt;= ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND</span><br><span class="line">                        || app.systemNoUi) &amp;&amp; app.pendingUiClean) &#123;</span><br><span class="line">                <span class="comment">// 如果该进程的进程状态优先级低于 important background: 7，或者其是 system 进程但是不显示 ui</span></span><br><span class="line">                <span class="comment">// 且 pendingUiClean 为 true，这种进程的回收登记很特殊，为 TRIM_MEMORY_UI_HIDDEN: 20</span></span><br><span class="line">                </span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> level = ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN;</span><br><span class="line">                    <span class="keyword">if</span> (app.trimMemoryLevel &lt; level &amp;&amp; app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// 如果进程的内存回收级别低于 level，并且进程还在运行，执行内存回收！</span></span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,</span><br><span class="line">                                    <span class="string">"Trimming memory of bg-ui "</span> + app.processName</span><br><span class="line">                                    + <span class="string">" to "</span> + level);</span><br><span class="line">                            <span class="comment">// 回收内存！</span></span><br><span class="line">                            app.thread.scheduleTrimMemory(level);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 设置 pendingUiClean 为 false，表示 ui 资源已经被回收了</span></span><br><span class="line">                    app.pendingUiClean = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 如果 TRIM_MEMORY_UI_HIDDEN 等级不够无法回收，则以前台进程的回收级别再次回收！！</span></span><br><span class="line">                <span class="keyword">if</span> (app.trimMemoryLevel &lt; fgTrimLevel &amp;&amp; app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,</span><br><span class="line">                                <span class="string">"Trimming memory of fg "</span> + app.processName</span><br><span class="line">                                + <span class="string">" to "</span> + fgTrimLevel);</span><br><span class="line">                        <span class="comment">// 回收内存！</span></span><br><span class="line">                        app.thread.scheduleTrimMemory(fgTrimLevel);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 更新进程的内存回收登记！</span></span><br><span class="line">                app.trimMemoryLevel = fgTrimLevel;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果最新的内存回收等级等于 normal，那么进入该分支！</span></span><br><span class="line">        <span class="keyword">if</span> (mLowRamStartTime != <span class="number">0</span>) &#123;</span><br><span class="line">            mLowRamTimeSinceLastIdle += now - mLowRamStartTime;</span><br><span class="line">            mLowRamStartTime = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 逆序遍历 mLruProcesses！</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=N-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            ProcessRecord app = mLruProcesses.get(i);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 同样的，更新进程信息！</span></span><br><span class="line">            <span class="keyword">if</span> (allChanged || app.procStateChanged) &#123;</span><br><span class="line">                setProcessTrackerStateLocked(app, trackerMemFactor, now);</span><br><span class="line">                app.procStateChanged = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果该进程的进程状态优先级低于 important background: 6，或者其是 system 进程但是不显示 ui</span></span><br><span class="line">            <span class="comment">// 且 pendingUiClean 为 true，才会回收内存！！</span></span><br><span class="line">            <span class="keyword">if</span> ((app.curProcState &gt;= ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND</span><br><span class="line">                    || app.systemNoUi) &amp;&amp; app.pendingUiClean) &#123;</span><br><span class="line">                    </span><br><span class="line">                <span class="comment">// 回收等级是 TRIM_MEMORY_UI_HIDDEN: 20</span></span><br><span class="line">                <span class="keyword">if</span> (app.trimMemoryLevel &lt; ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN</span><br><span class="line">                        &amp;&amp; app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,</span><br><span class="line">                                <span class="string">"Trimming memory of ui hidden "</span> + app.processName</span><br><span class="line">                                + <span class="string">" to "</span> + ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);</span><br><span class="line">                                </span><br><span class="line">                        <span class="comment">// 回收内存！</span></span><br><span class="line">                        app.thread.scheduleTrimMemory(</span><br><span class="line">                                ComponentCallbacks2.TRIM_MEMORY_UI_HIDDEN);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 设置 pendingUiClean 为 false；</span></span><br><span class="line">                app.pendingUiClean = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 这里很特殊，设置 trimMemoryLevel 为 0；</span></span><br><span class="line">            app.trimMemoryLevel = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果允许销毁后台 Activity</span></span><br><span class="line">    <span class="comment">// 可以通过：开发者选项 ——》不保留活动，开启！</span></span><br><span class="line">    <span class="keyword">if</span> (mAlwaysFinishActivities) &#123;</span><br><span class="line">        mStackSupervisor.scheduleDestroyAllActivities(<span class="keyword">null</span>, <span class="string">"always-finish"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// allChanged 为 true，表示发生了内存回收，这里是请求 PSS 内存！</span></span><br><span class="line">    <span class="keyword">if</span> (allChanged) &#123;</span><br><span class="line">        requestPssAllProcsLocked(now, <span class="keyword">false</span>, mProcessStats.isMemFactorLowered());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新活跃的 uid 的状态！</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=mActiveUids.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">final</span> UidRecord uidRec = mActiveUids.valueAt(i);</span><br><span class="line">        <span class="keyword">int</span> uidChange = UidRecord.CHANGE_PROCSTATE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 setProcState 和 curProcState 不相等，说明所属进程状态发生了变化！</span></span><br><span class="line">        <span class="keyword">if</span> (uidRec.setProcState != uidRec.curProcState) &#123;</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">if</span> (DEBUG_UID_OBSERVERS) Slog.i(TAG_UID_OBSERVERS,</span><br><span class="line">                    <span class="string">"Changes in "</span> + uidRec + <span class="string">": proc state from "</span> + uidRec.setProcState</span><br><span class="line">                    + <span class="string">" to "</span> + uidRec.curProcState);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (ActivityManager.isProcStateBackground(uidRec.curProcState)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ActivityManager.isProcStateBackground(uidRec.setProcState)) &#123;</span><br><span class="line">                    <span class="comment">// 如果 uid 所属进程当前的状态是后台进程，但是之前的状态不是后台进程！</span></span><br><span class="line">                    <span class="comment">// 更新 uid 的 lastBackgroundTime 变量！</span></span><br><span class="line"></span><br><span class="line">                    uidRec.lastBackgroundTime = nowElapsed;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (!mHandler.hasMessages(IDLE_UIDS_MSG)) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 发送 uid 处于 idle 状态的消息！</span></span><br><span class="line">                        mHandler.sendEmptyMessageDelayed(IDLE_UIDS_MSG, BACKGROUND_SETTLE_TIME);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果 uid 所属进程当前的状态是前台进程，那么该 uid 处于 active 状态！</span></span><br><span class="line">                <span class="keyword">if</span> (uidRec.idle) &#123;</span><br><span class="line">                    uidChange = UidRecord.CHANGE_ACTIVE;</span><br><span class="line">                    uidRec.idle = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                uidRec.lastBackgroundTime = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 更新 setProcState 为 curProcState！</span></span><br><span class="line">            uidRec.setProcState = uidRec.curProcState;</span><br><span class="line">            enqueueUidChangeLocked(uidRec, -<span class="number">1</span>, uidChange);</span><br><span class="line">            noteUidProcessState(uidRec.uid, uidRec.curProcState);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新进程的状态！</span></span><br><span class="line">    <span class="keyword">if</span> (mProcessStats.shouldWriteNowLocked(now)) &#123;</span><br><span class="line">        mHandler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (ActivityManagerService.<span class="keyword">this</span>) &#123;</span><br><span class="line">                    mProcessStats.writeStateAsyncLocked();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG_OOM_ADJ) &#123; <span class="comment">// debug 相关，不处理！</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> duration = SystemClock.uptimeMillis() - now;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">            Slog.d(TAG_OOM_ADJ, <span class="string">"Did OOM ADJ in "</span> + duration + <span class="string">"ms"</span>,</span><br><span class="line">                    <span class="keyword">new</span> RuntimeException(<span class="string">"here"</span>).fillInStackTrace());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Slog.d(TAG_OOM_ADJ, <span class="string">"Did OOM ADJ in "</span> + duration + <span class="string">"ms"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-1-变量总结"><a href="#3-2-1-变量总结" class="headerlink" title="3.2.1 变量总结"></a>3.2.1 变量总结</h3><p>下面我们来总结，空参 <code>updateOomAdjLocked</code> 中遇到的一些变量：</p>
<h3 id="3-2-2-过程总结"><a href="#3-2-2-过程总结" class="headerlink" title="3.2.2 过程总结"></a>3.2.2 过程总结</h3><h2 id="3-3-5-ActivityManagerS-updateOomAdjLocked"><a href="#3-3-5-ActivityManagerS-updateOomAdjLocked" class="headerlink" title="3.3 [5]ActivityManagerS.updateOomAdjLocked"></a>3.3 [5]ActivityManagerS.updateOomAdjLocked</h2><p>最后，我们来看 <code>5</code> 参的 <code>updateOomAdjLocked</code> 方法更新指定进程的 <code>oomAdj</code>，参数传递：</p>
<ul>
<li><strong>ProcessRecord app</strong>：要更新 <code>oomAdj</code> 的进程；</li>
<li><strong>int cachedAdj</strong>：进程处于 <code>cache</code> 状态的 <code>adj</code> 值；</li>
<li><strong>ProcessRecord TOP_APP</strong>：<code>top activity</code> 所在进程；</li>
<li><strong>boolean doingAll</strong>：是否对所有进程都更新 <code>adj</code> 的值！</li>
<li><strong>long now</strong>：更新的时间点！</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">updateOomAdjLocked</span><span class="params">(ProcessRecord app, <span class="keyword">int</span> cachedAdj,</span></span></span><br><span class="line"><span class="function"><span class="params">        ProcessRecord TOP_APP, <span class="keyword">boolean</span> doingAll, <span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (app.thread == <span class="keyword">null</span>) &#123; <span class="comment">// 进程没有启动！</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【1】计算 oomAdj 的值，doingAll 表示是否是对所有的进程都更新</span></span><br><span class="line">    <span class="comment">// 如果是的话，那就会统计进程数量！</span></span><br><span class="line">    computeOomAdjLocked(app, cachedAdj, TOP_APP, doingAll, now);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】应用 oomAdj 的值；</span></span><br><span class="line">    <span class="keyword">return</span> applyOomAdjLocked(app, doingAll, now, SystemClock.elapsedRealtime());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到，更新指定进程的 <code>oomAdj</code> 的会先调用 <code>computeOomAdjLocked</code> 计算 <code>oomAdj</code>，在调用 <code>applyOomAdjLocked</code> 应用计算的  <code>oomAdj</code>！！</p>
<h3 id="3-3-1-ActivityManagerS-computeOomAdjLocked"><a href="#3-3-1-ActivityManagerS-computeOomAdjLocked" class="headerlink" title="3.3.1 ActivityManagerS.computeOomAdjLocked"></a>3.3.1 ActivityManagerS.computeOomAdjLocked</h3><p>该方法用于计算除了 <code>cachedProcess</code> 和 <code>emptyProcess</code> 进程以外的进程的 <code>oom_adj</code> 值！</p>
<p>该方法的判断分支很多，我们按照模块划分下：</p>
<h4 id="3-3-1-1-已经更新-进程未启动的情况"><a href="#3-3-1-1-已经更新-进程未启动的情况" class="headerlink" title="3.3.1.1 已经更新/进程未启动的情况"></a>3.3.1.1 已经更新/进程未启动的情况</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">computeOomAdjLocked</span><span class="params">(ProcessRecord app, <span class="keyword">int</span> cachedAdj, ProcessRecord TOP_APP,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> doingAll, <span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】如果该进程的 app.adjSeq 和 mAdjSeq 相等，说明已经计算过了，直接返回计算的结果！</span></span><br><span class="line">    <span class="keyword">if</span> (mAdjSeq == app.adjSeq) &#123;</span><br><span class="line">        <span class="keyword">return</span> app.curRawAdj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】如果进程的 thread 为 null，说明进程没有启动，</span></span><br><span class="line">    <span class="comment">// 设置进程的调度组为 SCHED_GROUP_BACKGROUND，进程状态为 SCHED_GROUP_BACKGROUND</span></span><br><span class="line">    <span class="comment">// curAdj 和 curRawAdj 均为 CACHED_APP_MAX_ADJ；                                              </span></span><br><span class="line">    <span class="keyword">if</span> (app.thread == <span class="keyword">null</span>) &#123;</span><br><span class="line">        app.adjSeq = mAdjSeq; </span><br><span class="line">        app.curSchedGroup = ProcessList.SCHED_GROUP_BACKGROUND;</span><br><span class="line">        app.curProcState = ActivityManager.PROCESS_STATE_CACHED_EMPTY;</span><br><span class="line">        <span class="keyword">return</span> (app.curAdj=app.curRawAdj=ProcessList.CACHED_APP_MAX_ADJ);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ... ... ... ... <span class="comment">// 见下面[3.1.2.1.2]！</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>对于已经更新过的进程，通过 <code>mAdjSeq == app.adjSeq</code> 进行判断，当系统每次调用 <code>updateOomAdjLocked</code> 方法更新系统中进程的 <code>adj</code> 的时候，<code>mAdjSeq</code> 的值就会加一，同时，本次更新过的进程的 <code>adjSeq</code> 也会等于 <code>mAdjSeq</code>！</p>
</li>
<li><p>对于<strong>进程还没有启动的情况</strong>，我们默认设置初始的值给对应的属性！</p>
<ul>
<li><code>app.curSchedGroup = ProcessList.SCHED_GROUP_BACKGROUND</code> : </li>
<li><code>app.curProcState = ActivityManager.PROCESS_STATE_CACHED_EMPTY</code> : <code>16</code></li>
<li><code>app.curAdj = app.curRawAdj = ProcessList.CACHED_APP_MAX_ADJ</code> : <code>906</code></li>
</ul>
</li>
</ul>
<h4 id="3-3-1-2-系统进程"><a href="#3-3-1-2-系统进程" class="headerlink" title="3.3.1.2 系统进程"></a>3.3.1.2 系统进程</h4><p>下面我们来看看系统进程的处理！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">... ... ... ... <span class="comment">// 见上面[3.1.2.1.1]！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化一些 debug 的变量，后续会使用！</span></span><br><span class="line">app.adjTypeCode = ActivityManager.RunningAppProcessInfo.REASON_UNKNOWN;</span><br><span class="line">app.adjSource = <span class="keyword">null</span>;</span><br><span class="line">app.adjTarget = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">app.empty = <span class="keyword">false</span>; <span class="comment">// 进程是否会为空；</span></span><br><span class="line">app.cached = <span class="keyword">false</span>; <span class="comment">// 进程是否被缓存；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> activitiesSize = app.activities.size(); <span class="comment">// 该进程中的 activity 数！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//【3】如果进程的 maxAdj &lt;= FOREGROUND_APP_ADJ(0)，说明该进程是系统进程，那么一定是在前台！</span></span><br><span class="line"><span class="keyword">if</span> (app.maxAdj &lt;= ProcessList.FOREGROUND_APP_ADJ) &#123;</span><br><span class="line">    app.adjType = <span class="string">"fixed"</span>;</span><br><span class="line">    app.adjSeq = mAdjSeq;</span><br><span class="line">    app.curRawAdj = app.maxAdj;</span><br><span class="line">    app.foregroundActivities = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置进程的调度组为 SCHED_GROUP_DEFAULT；</span></span><br><span class="line">    app.curSchedGroup = ProcessList.SCHED_GROUP_DEFAULT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置进程的状态为 PROCESS_STATE_PERSISTENT；</span></span><br><span class="line">    app.curProcState = ActivityManager.PROCESS_STATE_PERSISTENT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断系统进程当前是否正在显示 ui，如果正在显示，那么我们需要等到用户离开 ui 后再回收内存！</span></span><br><span class="line">    app.systemNoUi = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (app == TOP_APP) &#123; <span class="comment">// 如果该系统进程是 top activity 所在进程，systemNoUi 为 false；</span></span><br><span class="line">        app.systemNoUi = <span class="keyword">false</span>;</span><br><span class="line">        app.curSchedGroup = ProcessList.SCHED_GROUP_TOP_APP;</span><br><span class="line">        app.adjType = <span class="string">"pers-top-activity"</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (app.hasTopUi) &#123; <span class="comment">// 如果该系统进程 hasTopUi 为 true，说明其持有 top-level ui，systemNoUi 为 false；</span></span><br><span class="line">        app.systemNoUi = <span class="keyword">false</span>;</span><br><span class="line">        app.curSchedGroup = ProcessList.SCHED_GROUP_TOP_APP;</span><br><span class="line">        app.adjType = <span class="string">"pers-top-ui"</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (activitiesSize &gt; <span class="number">0</span>) &#123; <span class="comment">// 如果系统进程中的 activity 数目大于 0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; activitiesSize; j++) &#123;</span><br><span class="line">            <span class="keyword">final</span> ActivityRecord r = app.activities.get(j);</span><br><span class="line">            <span class="keyword">if</span> (r.visible) &#123; <span class="comment">// 如果有可见的 activity，那么 systemNoUi 为 false；</span></span><br><span class="line">                app.systemNoUi = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果系统进程持有 ui 界面，那其进程状态为 PROCESS_STATE_PERSISTENT_UI；</span></span><br><span class="line">    <span class="keyword">if</span> (!app.systemNoUi) &#123;</span><br><span class="line">        app.curProcState = ActivityManager.PROCESS_STATE_PERSISTENT_UI;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 那么其 curAdj 为 maxAdj 的值，这里直接 return！</span></span><br><span class="line">    <span class="keyword">return</span> (app.curAdj = app.maxAdj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">... ... ... ... <span class="comment">// 见下面[3.1.2.1.3]！</span></span><br></pre></td></tr></table></figure>
<p>对于系统进程，其一定是要在前台的，这里首先判断了最大的 <code>maxAdj</code> 的取值！<code>FOREGROUND_APP_ADJ</code> 的取值为 <code>0</code>，表示前台进程的 <code>adj</code>！</p>
<p><strong><code>maxAdj</code> 在进程对象刚创建的时候，会被初始化为 <code>UNKNOWN_ADJ</code></strong>！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">maxAdj = ProcessList.UNKNOWN_ADJ;</span><br><span class="line">curRawAdj = setRawAdj = ProcessList.INVALID_ADJ;</span><br><span class="line">curAdj = setAdj = verifiedAdj = ProcessList.INVALID_ADJ;</span><br></pre></td></tr></table></figure>
<p><strong>1、在设置系统进程 <code>setSystemProcess</code> 的时候，会被设置为如下值：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为系统进程创建 ProcessRecord 对象！</span></span><br><span class="line">ProcessRecord app = newProcessRecordLocked(info, info.processName, <span class="keyword">false</span>, <span class="number">0</span>);</span><br><span class="line">app.persistent = <span class="keyword">true</span>; <span class="comment">// 表示为常驻进程！</span></span><br><span class="line">app.pid = MY_PID;</span><br><span class="line">app.maxAdj = ProcessList.SYSTEM_ADJ; <span class="comment">// 设置 maxAdj！</span></span><br><span class="line">app.makeActive(mSystemThread.getApplicationThread(), mProcessStats);</span><br></pre></td></tr></table></figure></p>
<p><strong>2、在启动 <code>persistent app</code> 的时候，会调用 <code>addAppLocked</code> 方法，设置为如下值：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((info.flags &amp; PERSISTENT_MASK) == PERSISTENT_MASK) &#123;</span><br><span class="line">    app.persistent = <span class="keyword">true</span>;</span><br><span class="line">    app.maxAdj = ProcessList.PERSISTENT_PROC_ADJ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>这两个值对应的 <code>adj</code> 优先级都高于 <code>FOREGROUND_APP_ADJ</code>，都属于 <code>persistent adj</code>，都会进入该分支</strong>！</p>
<p>这一段的逻辑如下：</p>
<p>如果进程的 <code>maxAdj</code> 比 <code>FOREGROUND_APP_ADJ</code> 小，说明其是常驻进程或者系统进程，那么就做如下判断：</p>
<ul>
<li><strong><code>app == TOP_APP</code></strong></li>
</ul>
<p>当前的 <code>top activity</code> 所在进程就是该进程，那么有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.systemNoUi = <span class="keyword">false</span>;</span><br><span class="line">app.curSchedGroup = ProcessList.SCHED_GROUP_TOP_APP;</span><br><span class="line">app.curProcState = ActivityManager.PROCESS_STATE_PERSISTENT_UI;</span><br><span class="line">app.foregroundActivities = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>app.hasTopUi</code></strong></li>
</ul>
<p>当前进程不是 <code>top process</code>，但是显示 <code>top-level</code> 级别的 <code>ui</code>，那么有：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.systemNoUi = <span class="keyword">false</span>;</span><br><span class="line">app.curSchedGroup = ProcessList.SCHED_GROUP_TOP_APP;</span><br><span class="line">app.curProcState = ActivityManager.PROCESS_STATE_PERSISTENT_UI;</span><br><span class="line">app.foregroundActivities = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>activitiesSize &gt; 0</code></strong></li>
</ul>
<p>如果即不是<code>top process</code>，也没有显示<code>top-level ui</code>，那就要判断下内部的是否持有可见的<code>activity</code>，如果有那么<code>systemNoUi</code>为</p>
<p><code>false</code>，<code>curProcState = ActivityManager.PROCESS_STATE_PERSISTENT_UI</code>;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.systemNoUi = <span class="keyword">false</span>; / <span class="keyword">true</span></span><br><span class="line">app.curSchedGroup = ProcessList.SCHED_GROUP_TOP_APP;</span><br><span class="line">app.curProcState = ActivityManager.PROCESS_STATE_PERSISTENT_UI; / ActivityManager.PROCESS_STATE_PERSISTENT;</span><br><span class="line">app.foregroundActivities = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>
<p>对于 <code>persistent</code> 进程的情况，最后返回的是 <code>app.curAdj = app.curRawAdj = app.maxAdj</code>!</p>
<h4 id="3-3-1-3-前台进程"><a href="#3-3-1-3-前台进程" class="headerlink" title="3.3.1.3 前台进程"></a>3.3.1.3 前台进程</h4><p>对于其他的进程来说，<code>maxAdj</code> 只会在初始化的时候被设置为 <code>ProcessList.UNKNOWN_ADJ</code>; 显然，他们是需要进入下面的分支的，<strong>判断其是否属于前台进程</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">... ... ... ... <span class="comment">// 见上面[3.1.2.1.2]！</span></span><br><span class="line"></span><br><span class="line">app.systemNoUi = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> PROCESS_STATE_CUR_TOP = mTopProcessState; <span class="comment">// 用于保存当前 top process 的状态！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//【4】接下来就开始决定非系统前台进程的重要性了，从高级别开始一直到低级别，逐级分配 oomAdj！</span></span><br><span class="line"><span class="comment">// adj 用来保存计算出的 oomAdj，schedGroup 用来保存计算出的调度组，procState 用来保存计算出的进程状态！</span></span><br><span class="line"><span class="keyword">int</span> adj;</span><br><span class="line"><span class="keyword">int</span> schedGroup;</span><br><span class="line"><span class="keyword">int</span> procState;</span><br><span class="line"><span class="keyword">boolean</span> foregroundActivities = <span class="keyword">false</span>;</span><br><span class="line">BroadcastQueue queue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (app == TOP_APP) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该进程就是 top activity 所在的进程，此时进程处于前台！</span></span><br><span class="line">    adj = ProcessList.FOREGROUND_APP_ADJ; <span class="comment">// 0；</span></span><br><span class="line">    </span><br><span class="line">    schedGroup = ProcessList.SCHED_GROUP_TOP_APP;</span><br><span class="line">    app.adjType = <span class="string">"top-activity"</span>;</span><br><span class="line">    foregroundActivities = <span class="keyword">true</span>;</span><br><span class="line">    </span><br><span class="line">    procState = PROCESS_STATE_CUR_TOP;</span><br><span class="line">    </span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (app.instrumentationClass != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果进程中有正在运行的 instrumentation，用于测试，此时进程处于前台！</span></span><br><span class="line">    adj = ProcessList.FOREGROUND_APP_ADJ; <span class="comment">// 0</span></span><br><span class="line">    </span><br><span class="line">    schedGroup = ProcessList.SCHED_GROUP_DEFAULT;</span><br><span class="line">    app.adjType = <span class="string">"instrumentation"</span>;</span><br><span class="line">    </span><br><span class="line">    procState = ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE; <span class="comment">// 4</span></span><br><span class="line">    </span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ((queue = isReceivingBroadcast(app)) != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果进程中有正在运行的 BroadcastReceiver 接收处理广播，此时进程处于前台！</span></span><br><span class="line">    <span class="comment">// 然后根据广播所处的队列类型设置调度组！</span></span><br><span class="line">    adj = ProcessList.FOREGROUND_APP_ADJ; <span class="comment">// 0</span></span><br><span class="line">    </span><br><span class="line">    schedGroup = (queue == mFgBroadcastQueue)</span><br><span class="line">            ? ProcessList.SCHED_GROUP_DEFAULT : ProcessList.SCHED_GROUP_BACKGROUND;</span><br><span class="line">    app.adjType = <span class="string">"broadcast"</span>;</span><br><span class="line">    </span><br><span class="line">    procState = ActivityManager.PROCESS_STATE_RECEIVER; <span class="comment">// 11</span></span><br><span class="line">    </span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (app.executingServices.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果进程中有服务正在执行，此时进程处于前台，然后根据执行操作的前台后台，设置不同调度组；</span></span><br><span class="line">    adj = ProcessList.FOREGROUND_APP_ADJ; <span class="comment">// 0</span></span><br><span class="line">    </span><br><span class="line">    schedGroup = app.execServicesFg ?</span><br><span class="line">            ProcessList.SCHED_GROUP_DEFAULT : ProcessList.SCHED_GROUP_BACKGROUND;</span><br><span class="line">    app.adjType = <span class="string">"exec-service"</span>;</span><br><span class="line">    </span><br><span class="line">    procState = ActivityManager.PROCESS_STATE_SERVICE; <span class="comment">// 10</span></span><br><span class="line">    <span class="comment">//Slog.i(TAG, "EXEC " + (app.execServicesFg ? "FG" : "BG") + ": " + app);</span></span><br><span class="line">    </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他类型的进程进入该分支，进程状态为 PROCESS_STATE_CACHED_EMPTY，调度组为 SCHED_GROUP_BACKGROUND！</span></span><br><span class="line">    <span class="comment">// 这种情况下我们无法知道实际的 adj，我们暂时使用 cache adj，后续我们会继续调整！</span></span><br><span class="line">    schedGroup = ProcessList.SCHED_GROUP_BACKGROUND;</span><br><span class="line">    </span><br><span class="line">    adj = cachedAdj;</span><br><span class="line">    procState = ActivityManager.PROCESS_STATE_CACHED_EMPTY; <span class="comment">// 16</span></span><br><span class="line">    </span><br><span class="line">    app.cached = <span class="keyword">true</span>;</span><br><span class="line">    app.empty = <span class="keyword">true</span>;</span><br><span class="line">    app.adjType = <span class="string">"cch-empty"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">... ... ... ... <span class="comment">// 见下面[3.1.2.1.4]！</span></span><br></pre></td></tr></table></figure>
<p>首先来说一下：<code>mTopProcessState</code>，其表示 <code>top process</code> 的状态，其默认取值为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mTopProcessState = ActivityManager.PROCESS_STATE_TOP;</span><br></pre></td></tr></table></figure></p>
<p>当我们的系统进入睡眠状态的时候，会更新其状态，具体的方法在 <code>updateSleepIfNeededLocked</code> 方法：</p>
<ul>
<li>当系统不睡眠时候，设置 <code>mTopProcessState = ActivityManager.PROCESS_STATE_TOP</code>；</li>
<li>当系统睡眠时候，设置 <code>mTopProcessState = ActivityManager.PROCESS_STATE_TOP_SLEEPING</code>；</li>
</ul>
<p>我们来看看，<strong>那些进程能归类于前台进程</strong>：</p>
<ul>
<li><strong>1、当前进程是 <code>top process</code></strong>，进行如下处理：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">adj = ProcessList.FOREGROUND_APP_ADJ; <span class="comment">// 取值 0</span></span><br><span class="line">schedGroup = ProcessList.SCHED_GROUP_TOP_APP;</span><br><span class="line">foregroundActivities = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">procState = PROCESS_STATE_CUR_TOP; <span class="comment">// 进程状态 2 或者 5！</span></span><br></pre></td></tr></table></figure>
<p>这里的 <code>PROCESS_STATE_CUR_TOP</code> 就是 <code>mTopProcessState</code>，且 <code>foregroundActivities</code> 只有在该条件下才为 <code>true</code>；</p>
<ul>
<li><strong>4、当前进程不是 <code>top process</code>，但是其内部运行着 <code>instrumentation</code> 用于测试的话：</strong> </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">adj = ProcessList.FOREGROUND_APP_ADJ; <span class="comment">// 取值 0</span></span><br><span class="line">schedGroup = ProcessList.SCHED_GROUP_DEFAULT;</span><br><span class="line">foregroundActivities = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">procState = ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE; <span class="comment">// 进程状态 4；</span></span><br></pre></td></tr></table></figure>
<p>继续来看：</p>
<p><br></p>
<ul>
<li><strong>3、当前进程不是 <code>top process</code>，内部没有运行着 <code>instrumentation</code>，但是其内部有正在接受处理广播的 <code>BroadcastReceiver</code> 的话：</strong> </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">adj = ProcessList.FOREGROUND_APP_ADJ; <span class="comment">// 取值 0</span></span><br><span class="line">schedGroup = (queue == mFgBroadcastQueue) ? ProcessList.SCHED_GROUP_DEFAULT : ProcessList.SCHED_GROUP_BACKGROUND;</span><br><span class="line">foregroundActivities = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">procState = ActivityManager.PROCESS_STATE_RECEIVER; <span class="comment">// 进程状态 11；</span></span><br></pre></td></tr></table></figure>
<p>如果广播所在的队列是后台队列，所属的调度组为：<code>SCHED_GROUP_BACKGROUND</code>，如果是前台，调度组为 <code>SCHED_GROUP_DEFAULT</code>；</p>
<p><br></p>
<ul>
<li><strong>4、当前进程不是 <code>top process</code>，内部没有运行着 <code>instrumentation</code>，也没有接受处理广播的 <code>BroadcastReceiver</code>，但是有正在执行的 <code>Service</code> 的话：</strong> </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">adj = ProcessList.FOREGROUND_APP_ADJ; <span class="comment">// 取值 0</span></span><br><span class="line">schedGroup = app.execServicesFg ? ProcessList.SCHED_GROUP_DEFAULT : ProcessList.SCHED_GROUP_BACKGROUND;</span><br><span class="line">foregroundActivities = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">procState = ActivityManager.PROCESS_STATE_SERVICE; <span class="comment">// 进程状态 10；</span></span><br></pre></td></tr></table></figure>
<p>如果后台执行，所属的调度组为：<code>SCHED_GROUP_BACKGROUND</code>，如果是前台，调度组为 <code>SCHED_GROUP_DEFAULT</code>；</p>
<p><br></p>
<ul>
<li>5、其他不属于以上的情况，说明其不是前台进程，有如下处理：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">schedGroup = ProcessList.SCHED_GROUP_BACKGROUND;</span><br><span class="line">adj = cachedAdj; <span class="comment">// 我们使用 cachedAdj ，或者为 unknowAdj；</span></span><br><span class="line"></span><br><span class="line">procState = ActivityManager.PROCESS_STATE_CACHED_EMPTY; <span class="comment">// 进程状态为 16；</span></span><br><span class="line">foregroundActivities = <span class="keyword">false</span>;</span><br><span class="line">app.cached = <span class="keyword">true</span>;</span><br><span class="line">app.empty = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>
<p>对于这种情况，我们将其当作 <code>cache</code> 进程处理，后续会进行调整！</p>
<p>对于前台进程，其 <code>oom_adj</code> 均被赋值为 <code>FOREGROUND_APP_ADJ</code>，即从 <code>LowMemoryKiller</code> 的角度来看，它们的重要性是一致的。<br>但这些进程的 <code>procState</code> 不同，于是从 <code>ActivityManagerService</code> 主动回收内存的角度来看，它们的重要性不同。</p>
<p>这里我们关注一个变量 <code>foregroundActivities</code>，这里只有在 <code>app == TOP_APP</code> 的情况下为 <code>true</code>，表示持有前台 <code>activity</code>!</p>
<p>我们继续来看！</p>
<h4 id="3-3-1-4-处理非前台-activity-所在进程"><a href="#3-3-1-4-处理非前台-activity-所在进程" class="headerlink" title="3.3.1.4 处理非前台 activity 所在进程"></a>3.3.1.4 处理非前台 activity 所在进程</h4><p>处理完了前台进程，接下来，处理非前台 <code>activity</code> 的情况，这里可以看作上面部分的延续，以下几种情况，会进入下面的逻辑，进一步的调整其 <code>adj</code>!</p>
<ul>
<li><strong>如果该进程是前台进程，但不是 <code>top process</code>，并且内部持有 <code>activity</code></strong>，其 <code>adj</code> 为 <code>FOREGROUND_APP_ADJ</code>！</li>
<li><strong>如果该进程不是前台进程，并且内部持有 <code>activity</code></strong>，其 <code>adj</code> 为 <code>cachedAdj</code>！</li>
</ul>
<p>这里的 <code>top process</code> 是 <code>top activity</code> 所在的进程！！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">... ... ... ... <span class="comment">// 见上面[3.1.2.1.3]！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//【5】处理完了前台进程，接下来，处理非前台 activity 的情况！</span></span><br><span class="line"><span class="keyword">if</span> (!foregroundActivities &amp;&amp; activitiesSize &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// minLayer 默认等于 PERCEPTIBLE_APP_ADJ（200） - VISIBLE_APP_ADJ（100）- 1，等于 99！</span></span><br><span class="line">    <span class="keyword">int</span> minLayer = ProcessList.VISIBLE_APP_LAYER_MAX;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; activitiesSize; j++) &#123; <span class="comment">// 遍历！</span></span><br><span class="line">        <span class="keyword">final</span> ActivityRecord r = app.activities.get(j);</span><br><span class="line">        <span class="keyword">if</span> (r.app != app) &#123;</span><br><span class="line"></span><br><span class="line">            Log.e(TAG, <span class="string">"Found activity "</span> + r + <span class="string">" in proc activity list using "</span> + r.app</span><br><span class="line">                    + <span class="string">" instead of expected "</span> + app);</span><br><span class="line">                    </span><br><span class="line">            <span class="keyword">if</span> (r.app == <span class="keyword">null</span> || (r.app.uid == app.uid)) &#123;</span><br><span class="line">                <span class="comment">// 处理数据异常的问题！</span></span><br><span class="line">                r.app = app;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (r.visible) &#123;</span><br><span class="line">            <span class="comment">//【5.1】如果 activity 是可见的，</span></span><br><span class="line">            <span class="comment">// 那提高 adj 最高为 VISIBLE_APP_ADJ，提高 procState 最高为 PROCESS_STATE_CUR_TOP！</span></span><br><span class="line">            <span class="keyword">if</span> (adj &gt; ProcessList.VISIBLE_APP_ADJ) &#123; <span class="comment">// 100</span></span><br><span class="line">                adj = ProcessList.VISIBLE_APP_ADJ;</span><br><span class="line">                app.adjType = <span class="string">"visible"</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (procState &gt; PROCESS_STATE_CUR_TOP) &#123; <span class="comment">// top state: 2/5</span></span><br><span class="line">                procState = PROCESS_STATE_CUR_TOP;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            schedGroup = ProcessList.SCHED_GROUP_DEFAULT; <span class="comment">// 调整调度组为 default！</span></span><br><span class="line"></span><br><span class="line">            app.cached = <span class="keyword">false</span>;</span><br><span class="line">            app.empty = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            foregroundActivities = <span class="keyword">true</span>; <span class="comment">// 设置 foregroundActivities 为 true；</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果其所在 task 如果不为 null，需要根据 task.mLayerRank</span></span><br><span class="line">            <span class="comment">// 调整 minLayer 的值！</span></span><br><span class="line">            <span class="keyword">if</span> (r.task != <span class="keyword">null</span> &amp;&amp; minLayer &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> layer = r.task.mLayerRank;</span><br><span class="line">                <span class="keyword">if</span> (layer &gt;= <span class="number">0</span> &amp;&amp; minLayer &gt; layer) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// minLayer 为其所在 task.mLayerRank 值！</span></span><br><span class="line">                    minLayer = layer;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.state == ActivityState.PAUSING || r.state == ActivityState.PAUSED) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【5.2】如果 activity 正在暂停，或者已经暂停，</span></span><br><span class="line">            <span class="comment">// 调整 adj 至少为 PERCEPTIBLE_APP_ADJ，调整 procState 至少为 top 进程的状态；</span></span><br><span class="line">            <span class="keyword">if</span> (adj &gt; ProcessList.PERCEPTIBLE_APP_ADJ) &#123; <span class="comment">// 200</span></span><br><span class="line">                adj = ProcessList.PERCEPTIBLE_APP_ADJ;</span><br><span class="line">                app.adjType = <span class="string">"pausing"</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (procState &gt; PROCESS_STATE_CUR_TOP) &#123; <span class="comment">// top state: 2/5</span></span><br><span class="line">                procState = PROCESS_STATE_CUR_TOP;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            schedGroup = ProcessList.SCHED_GROUP_DEFAULT;</span><br><span class="line"></span><br><span class="line">            app.cached = <span class="keyword">false</span>;</span><br><span class="line">            app.empty = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            foregroundActivities = <span class="keyword">true</span>; <span class="comment">// 设置 foregroundActivities 为 true；</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.state == ActivityState.STOPPING) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【5.3】如果 activity 正在停止， 调整 adj 至少为 PERCEPTIBLE_APP_ADJ</span></span><br><span class="line">            <span class="keyword">if</span> (adj &gt; ProcessList.PERCEPTIBLE_APP_ADJ) &#123; <span class="comment">// 200</span></span><br><span class="line">                adj = ProcessList.PERCEPTIBLE_APP_ADJ;</span><br><span class="line">                app.adjType = <span class="string">"stopping"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果此时 activity 没有开始 finish，那就调整 procState 最低为 PROCESS_STATE_LAST_ACTIVITY！</span></span><br><span class="line">            <span class="keyword">if</span> (!r.finishing) &#123;</span><br><span class="line">                <span class="keyword">if</span> (procState &gt; ActivityManager.PROCESS_STATE_LAST_ACTIVITY) &#123; <span class="comment">// 13</span></span><br><span class="line">                    procState = ActivityManager.PROCESS_STATE_LAST_ACTIVITY; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            app.cached = <span class="keyword">false</span>;</span><br><span class="line">            app.empty = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            foregroundActivities = <span class="keyword">true</span>; <span class="comment">// 设置 foregroundActivities 为 true；</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【5.4】不属于以上情况的话，只是含有 cached activity 的进程！</span></span><br><span class="line">            <span class="comment">// 这里只会设置进程状态 procState 最低为 PROCESS_STATE_CACHED_ACTIVITY！</span></span><br><span class="line">            <span class="keyword">if</span> (procState &gt; ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) &#123; <span class="comment">// 14</span></span><br><span class="line">                procState = ActivityManager.PROCESS_STATE_CACHED_ACTIVITY; </span><br><span class="line">                app.adjType = <span class="string">"cch-act"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同时，不同可见进程的 oom_adj 有一定的差异，我们根据其所在的 task 的 mLayerRank 来动态调整其 adj！</span></span><br><span class="line">    <span class="comment">// 如果此时 adj 为 VISIBLE_APP_ADJ（100），那就给 adj 加上 minLayer！</span></span><br><span class="line">    <span class="comment">// minLayer </span></span><br><span class="line">    <span class="keyword">if</span> (adj == ProcessList.VISIBLE_APP_ADJ) &#123;</span><br><span class="line">        adj += minLayer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">... ... ... ... <span class="comment">// 见下面[3.1.2.1.5]！</span></span><br></pre></td></tr></table></figure>
<p><strong>如果进程中没有 <code>top activity</code>，但是内部运行着 <code>activity</code></strong>，还需要进入如下的判断：</p>
<ul>
<li><strong>1、如果 r.visible，表示内部有 activity 是可见的：</strong><ul>
<li>如果 <code>adj &gt; ProcessList.VISIBLE_APP_ADJ</code>：<strong>100</strong>，那就调整到 <code>ProcessList.VISIBLE_APP_ADJ</code>；</li>
<li>如果 <code>procState &gt; PROCESS_STATE_CUR_TOP</code>，那就调整到 <code>top process state</code>；</li>
<li>设置 <code>foregroundActivities</code> 为 <code>true</code>；</li>
</ul>
</li>
</ul>
<p><strong>然后结束处理</strong>；</p>
<p><br></p>
<ul>
<li><p><strong>2、如果 r.state == ActivityState.PAUSING || r.state == ActivityState.PAUSED，表示内部有 activity 是正在暂停，或者已经暂停：</strong></p>
<ul>
<li>如果 <code>adj &gt; ProcessList.VISIBLE_APP_ADJ</code>：<strong>100</strong>，那就调整到 <code>ProcessList.VISIBLE_APP_ADJ</code>；</li>
<li>如果 <code>procState &gt; PROCESS_STATE_CUR_TOP</code>，那就调整到 <code>top process state</code>；</li>
<li>设置 <code>foregroundActivities</code> 为 <code>true</code>；</li>
</ul>
</li>
</ul>
<p><strong>然后继续处理其他 <code>activity</code></strong></p>
<p><br></p>
<ul>
<li><p><strong>3、如果 r.state == ActivityState.STOPPING，表示内部有 activity 是正在停止：</strong></p>
<ul>
<li>如果 <code>adj &gt; ProcessList.PERCEPTIBLE_APP_ADJ</code>：<strong>200</strong>，那就调整到 <code>ProcessList.PERCEPTIBLE_APP_ADJ</code>；</li>
<li>如果此时 <code>activity</code> 没有开始 <code>finish</code>，并且 <code>procState &gt; ActivityManager.PROCESS_STATE_LAST_ACTIVITY</code>：<strong>13</strong>，那就调整 <code>procState</code> 为 <code>PROCESS_STATE_LAST_ACTIVITY</code>；</li>
<li>设置 <code>foregroundActivities</code> 为 <code>true</code>，<strong>然后继续处理其他 <code>activity</code></strong>；</li>
</ul>
</li>
</ul>
<p><br></p>
<ul>
<li><strong>4、其他情况：</strong><ul>
<li>如果 <code>procState &gt; ActivityManager.PROCESS_STATE_CACHED_ACTIVITY</code>: <strong>14</strong>，那就设置 <code>procState</code> 为 <code>PROCESS_STATE_CACHED_ACTIVITY</code>，然后继续处理其他 <code>activity</code>!</li>
</ul>
</li>
</ul>
<p><br></p>
<ul>
<li><strong>5、最后，如果 <code>adj</code> 等于 <code>VISIBLE_APP_ADJ：100</code></strong>，在其之上加入 <code>minLayer</code> 调整，这样的话，最后的 <code>adj</code> 介于 <code>100</code> 和 <code>200</code> 之间！</li>
</ul>
<p><br></p>
<p><strong>我们得到：</strong></p>
<ul>
<li>对于 <strong>如果该进程是前台进程，但不是 <code>top process</code> 这种情况，其 <code>adj</code> 为 <code>FOREGROUND_APP_ADJ：0</code>，不会做 <code>adj</code> 调整</strong>，<strong>但是其 <code>procState</code> 会发生变化</strong>，其变化依据是依赖于进程内部的 <code>activity</code> 的状态，根据【3.3.1.3】节我们知道，其  <code>procState</code> 的取值如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">procState = PROCESS_STATE_CUR_TOP; <span class="comment">// 进程状态 2 或者 5！</span></span><br><span class="line">procState = ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE; <span class="comment">// 进程状态 4；</span></span><br><span class="line">procState = ActivityManager.PROCESS_STATE_RECEIVER; <span class="comment">// 进程状态 11；</span></span><br><span class="line">procState = ActivityManager.PROCESS_STATE_SERVICE; <span class="comment">// 进程状态 10；</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>可以看到，如果其内部持有非 <code>top activity</code>，这里的调整，顶多会将其调整到 <code>PROCESS_STATE_CUR_TOP</code> 级别！</p>
<ul>
<li><strong>而对于非前台进程，在【3.3.1.3】节，会被置为如下的状态</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adj = cachedAdj; <span class="comment">// 我们使用 cachedAdj ，或者为 unknowAdj；</span></span><br><span class="line">procState = ActivityManager.PROCESS_STATE_CACHED_EMPTY; <span class="comment">// 进程状态为 16；</span></span><br><span class="line">foregroundActivities = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>可以看到，如果其内持有非 <code>top activity</code>，会根据其 <code>activity</code> 的状态，其 <code>adj</code> 被调整为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内部有非 top activity，且其 visible；</span></span><br><span class="line">ProcessList.VISIBLE_APP_ADJ <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部有非 top activity，其没 visible，但是 pausing 或者 paused，或者 stoping；</span></span><br><span class="line">ProcessList.PERCEPTIBLE_APP_ADJ <span class="comment">// 200</span></span><br></pre></td></tr></table></figure></p>
<p>其 <code>procState</code> 被调整为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内部有非 top activity，其 visible / pausing / pauesed，且其 procState &gt; PROCESS_STATE_CUR_TOP（满足）</span></span><br><span class="line">ActivityManager.PROCESS_STATE_CUR_TOP <span class="comment">// 2 或者 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部有非 top activity，其 stopping，但没 finishing，且其 procState &gt; ActivityManager.PROCESS_STATE_LAST_ACTIVITY（满足）</span></span><br><span class="line">ActivityManager.PROCESS_STATE_LAST_ACTIVITY <span class="comment">// 13</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内部有非 top activity，其没 visible / pausing / pauesed / stopping，且其 procState &gt; PROCESS_STATE_CACHED_ACTIVITY（满足）</span></span><br><span class="line">ActivityManager.PROCESS_STATE_CACHED_ACTIVITY <span class="comment">// 14</span></span><br></pre></td></tr></table></figure>
<p><br></p>
<p>我们接着来看！！</p>
<h4 id="3-3-1-5-调整可感知进程"><a href="#3-3-1-5-调整可感知进程" class="headerlink" title="3.3.1.5 调整可感知进程"></a>3.3.1.5 调整可感知进程</h4><p>接下来处理可感知的进程，可以看到，能够进入该分支的需要满足下面某一个条件：</p>
<ul>
<li><code>adj</code> 的值大于 <code>PERCEPTIBLE_APP_ADJ（200）</code>：</li>
<li><code>procState</code> 的值大于 <code>PROCESS_STATE_FOREGROUND_SERVICE（4）</code>：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">... ... ... ... // 见上面[3.1.2.1.4]！</span><br><span class="line"></span><br><span class="line">//【5】接下来，处理 adj 大于 PERCEPTIBLE_APP_ADJ（200） </span><br><span class="line">// 或者 procState 大于 PROCESS_STATE_FOREGROUND_SERVICE（4）的情况！</span><br><span class="line">if (adj &gt; ProcessList.PERCEPTIBLE_APP_ADJ</span><br><span class="line">        || procState &gt; ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE) &#123;</span><br><span class="line"></span><br><span class="line">    if (app.foregroundServices) &#123;</span><br><span class="line"></span><br><span class="line">        //【5.1】如果该进程中有前台服务，那么用户是可以感知到这种进程的，所以是可见的！</span><br><span class="line">        // 设置 adj 最低为 PERCEPTIBLE_APP_ADJ（200）</span><br><span class="line">        // 设置 procState 最低为 PROCESS_STATE_FOREGROUND_SERVICE（4）</span><br><span class="line">        adj = ProcessList.PERCEPTIBLE_APP_ADJ;</span><br><span class="line">        procState = ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE;</span><br><span class="line">        app.cached = false;</span><br><span class="line">        app.adjType = &quot;fg-service&quot;;</span><br><span class="line">        schedGroup = ProcessList.SCHED_GROUP_DEFAULT;</span><br><span class="line"></span><br><span class="line">    &#125; else if (app.forcingToForeground != null) &#123;</span><br><span class="line"></span><br><span class="line">        //【5.2】如果进程 forcingToForeground 不为 null，说明进程被强制设置到前台，同样可见！</span><br><span class="line">        // 设置 adj 最低为 PERCEPTIBLE_APP_ADJ（200）</span><br><span class="line">        // 设置 procState 最低为 PROCESS_STATE_IMPORTANT_FOREGROUND（6）</span><br><span class="line">        adj = ProcessList.PERCEPTIBLE_APP_ADJ;</span><br><span class="line">        procState = ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;</span><br><span class="line">        app.cached = false;</span><br><span class="line">        app.adjType = &quot;force-fg&quot;;</span><br><span class="line">        app.adjSource = app.forcingToForeground;</span><br><span class="line">        schedGroup = ProcessList.SCHED_GROUP_DEFAULT;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">... ... ... ... // 见下面[3.1.2.1.6]！</span><br></pre></td></tr></table></figure>
<p>对于系统进程和前台进程 <code>adj</code> 的优先级均是高于 <code>ProcessList.FOREGROUND_APP_ADJ</code>，所以第一个条件是不满足的！</p>
<p>我们来看看<strong>那些进程属于可感知的进程</strong>：</p>
<ul>
<li><strong><code>app.foregroundServices</code> 为 <code>true</code>，表示服务被 <code>start</code> 后，调用了 <code>startForeground</code> 方法</strong><br>此时我们来看看进程的属性：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adj = ProcessList.PERCEPTIBLE_APP_ADJ; <span class="comment">// 200;</span></span><br><span class="line">procState = ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE; <span class="comment">// 4</span></span><br><span class="line">schedGroup = ProcessList.SCHED_GROUP_DEFAULT;</span><br></pre></td></tr></table></figure>
<p>在 <code>Service</code> 的被启动后，可以调用 <code>startForeground</code>，让服务进程变为可感知的</p>
<ul>
<li><strong><code>app.foregroundServices</code> 为 <code>false</code>，但是 <code>app.forcingToForeground != null</code>，表示调用了 <code>setProcessForeground</code> 方法</strong><br>此时我们来看看进程的属性：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adj = ProcessList.PERCEPTIBLE_APP_ADJ; <span class="comment">// 200</span></span><br><span class="line">procState = ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND; <span class="comment">// 6</span></span><br><span class="line">schedGroup = ProcessList.SCHED_GROUP_DEFAULT;</span><br></pre></td></tr></table></figure>
<p>当我们在进程中调用了 <code>setProcessForeground</code> 方法后，该进程的 <code>app.forcingToForeground</code> 不为 <code>null</code>，这样进程就会变为可感知的！！</p>
<p><br></p>
<p><strong>注意</strong></p>
<p><strong>这里要重点看第二个条件：<code>procState &gt; ActivityManager.PROCESS_STATE_FOREGROUND_SERVICE : 4</code></strong></p>
<p>只要满足该条件的进程，也可以进入该分支，即使对于前台进程，其 <code>adj == FOREGROUND_APP_ADJ</code>，也可能会进入该分支，比如：</p>
<ul>
<li><p>不是 <code>top process</code>，其内部没有非<code>top activity</code>，但是其内部有正在接受处理广播的 <code>BroadcastReceiver</code>，其 <code>procState ==  PROCESS_STATE_RECEIVER：11</code>!</p>
</li>
<li><p>不是 <code>top process</code>，其内部没有非<code>top activity</code>，但是其内部有正在执行的 <code>Service</code>，其 <code>procState == PROCESS_STATE_SERVICE：10</code>!</p>
</li>
</ul>
<p>如果其被显示设置成了前台的话，<code>adj</code> 和 <code>procState</code> 也会发生调整！</p>
<p>接着来看：</p>
<h4 id="3-3-1-6-heavy-weight-进程"><a href="#3-3-1-6-heavy-weight-进程" class="headerlink" title="3.3.1.6 heavy weight 进程"></a>3.3.1.6 heavy weight 进程</h4><p>下面是处理 <code>heavy weight</code> 类型的进程！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">... ... ... ... // 见上面[3.1.2.1.5]</span><br><span class="line"></span><br><span class="line">//【6】接下来，处理 heavy weight 进程！</span><br><span class="line">if (app == mHeavyWeightProcess) &#123;</span><br><span class="line"></span><br><span class="line">    //【6.1】设置进程 adj 最低为 HEAVY_WEIGHT_APP_ADJ</span><br><span class="line">    if (adj &gt; ProcessList.HEAVY_WEIGHT_APP_ADJ) &#123; // 400</span><br><span class="line">        adj = ProcessList.HEAVY_WEIGHT_APP_ADJ;</span><br><span class="line">        schedGroup = ProcessList.SCHED_GROUP_BACKGROUND;</span><br><span class="line">        app.cached = false;</span><br><span class="line">        app.adjType = &quot;heavy&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //【6.2】设置进程状态 procState 最低为 PROCESS_STATE_HEAVY_WEIGHT</span><br><span class="line">    if (procState &gt; ActivityManager.PROCESS_STATE_HEAVY_WEIGHT) &#123; // 9</span><br><span class="line">        procState = ActivityManager.PROCESS_STATE_HEAVY_WEIGHT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">... ... ... ... // 见下面[3.1.2.1.7]</span><br></pre></td></tr></table></figure>
<p><code>ams</code> 通过 <code>mHeavyWeightProcess</code> 来保存系统中的 <code>heavy weight</code> 进程！</p>
<ul>
<li><p>如果 <code>app == mHeavyWeightProcess</code>，说明该进程是 <code>heavy weight</code> 类型的进程，我们来看看其属性设置：</p>
<ul>
<li><strong>adj = ProcessList.HEAVY_WEIGHT_APP_ADJ;</strong></li>
<li><strong>procState = ActivityManager.PROCESS_STATE_HEAVY_WEIGHT;</strong></li>
<li>schedGroup = ProcessList.SCHED_GROUP_BACKGROUND;</li>
</ul>
</li>
</ul>
<p><strong>注意</strong>，对于 <code>adj</code> 的调整，只有 <code>cacheAdj</code> 或者 <code>unKnowAdj</code> 的情况下，如果满足条件，才会被调整为 <code>HEAVY_WEIGHT_APP_ADJ</code>；</p>
<p>而对于 <code>stateProc</code>，只要 <code>procState &gt; ActivityManager.PROCESS_STATE_HEAVY_WEIGHT：9</code>，并且该进程是 <code>heavy weight</code> 进程，那就会发生调整，这个可以参见【3.3.1.6】节！</p>
<p>接着来看：</p>
<h4 id="3-3-1-7-home-进程"><a href="#3-3-1-7-home-进程" class="headerlink" title="3.3.1.7 home 进程"></a>3.3.1.7 home 进程</h4><p>下面是处理 <code>home</code> 进程！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> ... ... ... ... <span class="comment">// 见上面[3.1.2.1.6]</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//【7】接下来，处理 home 进程！</span></span><br><span class="line"> <span class="keyword">if</span> (app == mHomeProcess) &#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//【7.1】设置进程 adj 最低为 HOME_APP_ADJ</span></span><br><span class="line">     <span class="keyword">if</span> (adj &gt; ProcessList.HOME_APP_ADJ) &#123; <span class="comment">// 600</span></span><br><span class="line">         adj = ProcessList.HOME_APP_ADJ;</span><br><span class="line">         schedGroup = ProcessList.SCHED_GROUP_BACKGROUND;</span><br><span class="line">         app.cached = <span class="keyword">false</span>;</span><br><span class="line">         app.adjType = <span class="string">"home"</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//【7.2】设置进程状态 procState 最低为 PROCESS_STATE_HOME！</span></span><br><span class="line">     <span class="keyword">if</span> (procState &gt; ActivityManager.PROCESS_STATE_HOME) &#123; <span class="comment">// 12</span></span><br><span class="line">         procState = ActivityManager.PROCESS_STATE_HOME;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line">... ... ... ... <span class="comment">// 见下面[3.1.2.1.8]</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>如果 <code>app == mHomeProcess</code>，说明该进程是 <code>home</code> 所在的进程，我们来看看其属性设置：</p>
<ul>
<li><strong>adj = ProcessList.HOME_APP_ADJ; // 600</strong></li>
<li><strong>procState = ActivityManager.PROCESS_STATE_HOME; // 12</strong></li>
<li>schedGroup = ProcessList.SCHED_GROUP_BACKGROUND;</li>
</ul>
</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li><p>对于 <code>home process</code> 的情况，只有 <code>cacheAdj</code> 或者 <code>unKnowAdj</code> 的情况下，才会被调整 <code>adj</code> 和 <code>procState</code>！</p>
</li>
<li><p>而对于 <code>foreground process</code>，<code>visible process</code>，<code>perceptible process</code>和 <code>heavy weight process</code> 来说，他们的 <code>adj</code> 和 <code>procState</code>都远远高于 <code>home process</code>，所以是不会调整的！</p>
</li>
</ul>
<p>接着来看：</p>
<h4 id="3-3-1-8-持有-activity-的-previous-进程"><a href="#3-3-1-8-持有-activity-的-previous-进程" class="headerlink" title="3.3.1.8 持有 activity 的 previous 进程"></a>3.3.1.8 持有 activity 的 previous 进程</h4><p>下面是处理持有 <code>activity</code> 的 <code>previous</code> 进程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> ... ... ... ... <span class="comment">// 见上面[3.1.2.1.7]</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//【8】接下来，处理用户之前所在的，持有 activity 的 previous 进程！</span></span><br><span class="line"> <span class="comment">// 因为这是前一个显示 ui 给用户的进程，我们尽量不杀死它，这样能够给用户一个好的用户体验！</span></span><br><span class="line"> <span class="keyword">if</span> (app == mPreviousProcess &amp;&amp; app.activities.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//【8.1】设置进程 adj 最低为 PREVIOUS_APP_ADJ！</span></span><br><span class="line">     <span class="keyword">if</span> (adj &gt; ProcessList.PREVIOUS_APP_ADJ) &#123; <span class="comment">// 700</span></span><br><span class="line">         adj = ProcessList.PREVIOUS_APP_ADJ;</span><br><span class="line">         schedGroup = ProcessList.SCHED_GROUP_BACKGROUND;</span><br><span class="line">         app.cached = <span class="keyword">false</span>;</span><br><span class="line">         app.adjType = <span class="string">"previous"</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//【8.2】设置进程状态 procState 最低为 PROCESS_STATE_LAST_ACTIVITY！</span></span><br><span class="line">     <span class="keyword">if</span> (procState &gt; ActivityManager.PROCESS_STATE_LAST_ACTIVITY) &#123; <span class="comment">// 13</span></span><br><span class="line">         procState = ActivityManager.PROCESS_STATE_LAST_ACTIVITY;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">false</span>) Slog.i(TAG, <span class="string">"OOM "</span> + app + <span class="string">": initial adj="</span> + adj</span><br><span class="line">         + <span class="string">" reason="</span> + app.adjType);</span><br><span class="line">         </span><br><span class="line">... ... ... ... <span class="comment">// 见下面[3.1.2.1.9]</span></span><br></pre></td></tr></table></figure>
<p><strong>持有 <code>activity</code> 的 <code>previous</code> 进程</strong>，就是上一个显示 <code>activity</code> 的进程！</p>
<ul>
<li><p><strong><code>app == mPreviousProcess &amp;&amp; app.activities.size() &gt; 0</code>，表示该进程是用户所在的上一个进程，并且该进程内部运行着 <code>activity</code>：</strong><br>下面我们来看看这类进程的属性设置：</p>
<ul>
<li><strong>adj = ProcessList.PREVIOUS_APP_ADJ</strong>;</li>
<li><strong>procState = ActivityManager.PROCESS_STATE_LAST_ACTIVITY</strong>;</li>
<li>schedGroup = ProcessList.SCHED_GROUP_BACKGROUND;</li>
</ul>
</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li><p>对于 <code>previous process</code> 的情况，只有 <code>cacheAdj</code> 或者 <code>unKnowAdj</code> 的情况下，才会被调整 <code>adj</code> 和 <code>procState</code>！</p>
</li>
<li><p>而对于 <code>foreground process</code>，<code>visible process</code>，<code>perceptible process</code>和 <code>heavy weight process</code>， <code>home process</code> 来说，他们的 <code>adj</code> 和 <code>procState</code>都远远高于 <code>previous process</code>，所以是不会调整的！</p>
</li>
</ul>
<p>接着来看：</p>
<h4 id="3-3-1-9-处于-back-up-的进程"><a href="#3-3-1-9-处于-back-up-的进程" class="headerlink" title="3.3.1.9 处于 back-up 的进程"></a>3.3.1.9 处于 back-up 的进程</h4><p>下面是处理处于 <code>back-up</code> 的进程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> ... ... ... ... <span class="comment">// 见上面[3.1.2.1.8]</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 设置进程的 adjSeq 为此时的 mAdjSeq，通过比较 adjSeq 和 mAdjSeq 就可以知道进程是否已经进行了 oomAdj 更新！</span></span><br><span class="line"> app.adjSeq = mAdjSeq;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 如果进程中的 services 或者 providers 被其他进程依赖，那么该进程的 oomAdj 也会发生变化，所以后续还要调整！</span></span><br><span class="line"> app.curRawAdj = adj; </span><br><span class="line"> app.hasStartedServices = <span class="keyword">false</span>; <span class="comment">// hasStartedServices 表示该进程中是否有被启动的 service</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//【9】接下来，处理正在执行备份操作的进程，对比这类进程，我们要避免杀死他们；</span></span><br><span class="line"> <span class="keyword">if</span> (mBackupTarget != <span class="keyword">null</span> &amp;&amp; app == mBackupTarget.app) &#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//【9.1】设置进程 adj 最低为 BACKUP_APP_ADJ：300</span></span><br><span class="line">     <span class="keyword">if</span> (adj &gt; ProcessList.BACKUP_APP_ADJ) &#123; <span class="comment">// 300</span></span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (DEBUG_BACKUP) Slog.v(TAG_BACKUP, <span class="string">"oom BACKUP_APP_ADJ for "</span> + app);</span><br><span class="line">         adj = ProcessList.BACKUP_APP_ADJ;</span><br><span class="line">         </span><br><span class="line">         <span class="comment">// 同时，设置进程 procState 最低为 PROCESS_STATE_IMPORTANT_BACKGROUND</span></span><br><span class="line">         <span class="keyword">if</span> (procState &gt; ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) &#123; <span class="comment">// 7</span></span><br><span class="line">             procState = ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         app.adjType = <span class="string">"backup"</span>;</span><br><span class="line">         app.cached = <span class="keyword">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//【9.2】设置进程状态 procState 最低为 PROCESS_STATE_BACKUP：8！</span></span><br><span class="line">     <span class="keyword">if</span> (procState &gt; ActivityManager.PROCESS_STATE_BACKUP) &#123;</span><br><span class="line">         procState = ActivityManager.PROCESS_STATE_BACKUP;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">... ... ... ... <span class="comment">// 见下面[3.1.2.1.10]</span></span><br></pre></td></tr></table></figure>
<p>对于正在备份的进程有：</p>
<ul>
<li><code>mBackupTarget != null &amp;&amp; app == mBackupTarget.app</code> 条件满足，那就做如下调整：</li>
</ul>
<p>如果 <code>adj &gt; ProcessList.BACKUP_APP_ADJ</code> 的话：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">adj = ProcessList.BACKUP_APP_ADJ; <span class="comment">// 优先级最低为 BACKUP_APP_ADJ</span></span><br><span class="line">procState = ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND; <span class="comment">// 优先级最低为 PROCESS_STATE_IMPORTANT_BACKGROUND</span></span><br></pre></td></tr></table></figure></p>
<p>否则，只调整 <code>procState</code> 优先级最低为 <code>PROCESS_STATE_BACKUP</code> </p>
<p><strong>注意：</strong></p>
<ul>
<li><strong>正在备份的进程和前面遇到的进程并不冲突</strong>，比如，一个前台进程也有可能正在做备份操作，所以这里将其对应的调整放在了其他进程之后！</li>
</ul>
<p>我们继续来看：</p>
<h4 id="3-3-1-10-处理持有-services-的进程"><a href="#3-3-1-10-处理持有-services-的进程" class="headerlink" title="3.3.1.10 处理持有 services 的进程"></a>3.3.1.10 处理持有 services 的进程</h4><p>下面是处理处于持有 <code>services</code> 的进程，当进程中持有 <code>services</code> 并且别其他进程绑定后，该进程的 <code>adj</code> 和 <code>state</code> 会发生变化！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br></pre></td><td class="code"><pre><span class="line">       ... ... ... ... <span class="comment">// 见上面[3.1.2.1.9]  </span></span><br><span class="line">       </span><br><span class="line">        <span class="keyword">boolean</span> mayBeTop = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【9】处理该进程中的 serivce，判断是否有其他进程依赖这些 service，如果有，那么该进程的 adj 会发生变化！</span></span><br><span class="line">        <span class="comment">// 循环触发的条件是：adj &gt; ProcessList.FOREGROUND_APP_ADJ / schedGroup == ProcessList.SCHED_GROUP_BACKGROUND</span></span><br><span class="line">        <span class="comment">//  / procState &gt; ActivityManager.PROCESS_STATE_TOP</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> is = app.services.size()-<span class="number">1</span>;</span><br><span class="line">                is &gt;= <span class="number">0</span> &amp;&amp; (adj &gt; ProcessList.FOREGROUND_APP_ADJ</span><br><span class="line">                        || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND</span><br><span class="line">                        || procState &gt; ActivityManager.PROCESS_STATE_TOP);</span><br><span class="line">                is--) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------------------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//【9.1】处理每一个 ServiceRecord 对象！</span></span><br><span class="line">            ServiceRecord s = app.services.valueAt(is);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//【9.2】s.startRequested 为 true 表示服务是通过 startService 方式启动了！</span></span><br><span class="line">            <span class="keyword">if</span> (s.startRequested) &#123;</span><br><span class="line">                <span class="comment">// 设置 hasStartedServices 为 true！</span></span><br><span class="line">                app.hasStartedServices = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 同时设置 procState 至少为 PROCESS_STATE_SERVICE！</span></span><br><span class="line">                <span class="keyword">if</span> (procState &gt; ActivityManager.PROCESS_STATE_SERVICE) &#123; <span class="comment">// 10！</span></span><br><span class="line">                    procState = ActivityManager.PROCESS_STATE_SERVICE;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (app.hasShownUi &amp;&amp; app != mHomeProcess) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 如果进程自启动后，显示过 ui ，并且不是 home 进程，这里并没有做调整，设置了一个标记，用于 debug！</span></span><br><span class="line">                    <span class="keyword">if</span> (adj &gt; ProcessList.SERVICE_ADJ) &#123;</span><br><span class="line">                        app.adjType = <span class="string">"cch-started-ui-services"</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 如果该服务的在 30 mins 内活跃过，那么我们会保持其进程在后台之前！</span></span><br><span class="line">                    <span class="comment">// 调整 adj 最低为 SERVICE_ADJ，可以看到 adj 大于 500 的进程均会受此判断的影响！</span></span><br><span class="line">                    <span class="keyword">if</span> (now &lt; (s.lastActivity + ActiveServices.MAX_SERVICE_INACTIVITY)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (adj &gt; ProcessList.SERVICE_ADJ) &#123; <span class="comment">// 500</span></span><br><span class="line">                            adj = ProcessList.SERVICE_ADJ;</span><br><span class="line">                            app.adjType = <span class="string">"started-services"</span>;</span><br><span class="line">                            app.cached = <span class="keyword">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                   </span><br><span class="line">                    <span class="comment">// 如果该服务没有活跃的时间已经超过了 30 mins，那就不会更新其 adj！</span></span><br><span class="line">                    <span class="keyword">if</span> (adj &gt; ProcessList.SERVICE_ADJ) &#123;</span><br><span class="line">                        app.adjType = <span class="string">"cch-started-services"</span>; <span class="comment">// 增加 debug 的描述信息！</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//----------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//【9.3】如果该服务被 bind 了，处理该服务的所有绑定信息！</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> conni = s.connections.size()-<span class="number">1</span>;</span><br><span class="line">                    conni &gt;= <span class="number">0</span> &amp;&amp; (adj &gt; ProcessList.FOREGROUND_APP_ADJ</span><br><span class="line">                            || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND</span><br><span class="line">                            || procState &gt; ActivityManager.PROCESS_STATE_TOP);</span><br><span class="line">                    conni--) &#123;</span><br><span class="line"></span><br><span class="line">                ArrayList&lt;ConnectionRecord&gt; clist = s.connections.valueAt(conni);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">                        i &lt; clist.size() &amp;&amp; (adj &gt; ProcessList.FOREGROUND_APP_ADJ</span><br><span class="line">                                || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND</span><br><span class="line">                                || procState &gt; ActivityManager.PROCESS_STATE_TOP);</span><br><span class="line">                        i++) &#123;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 获得连接的 client 客户端！</span></span><br><span class="line">                    ConnectionRecord cr = clist.get(i);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//【9.3.1】如果 client 的宿主进程就是当前进程，跳过！</span></span><br><span class="line">                    <span class="keyword">if</span> (cr.binding.client == app) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//【9.3.1】接下来，根据 bind 时候设置的 flags 的不同，进行不同的处理！</span></span><br><span class="line">                    </span><br><span class="line"><span class="comment">///--------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//【9.3.1.1】如果 bind 的时候没有设置 BIND_WAIVE_PRIORITY，进入下面的分支！</span></span><br><span class="line">                    <span class="comment">// BIND_WAIVE_PRIORITY 表示 client 会不会影响服务进程的优先级，为 1 表示不会影响，就不会进入 if 分支</span></span><br><span class="line">                    <span class="comment">// 为 0 表示会影响！</span></span><br><span class="line">                    <span class="keyword">if</span> ((cr.flags &amp; Context.BIND_WAIVE_PRIORITY) == <span class="number">0</span>) &#123;</span><br><span class="line">                        </span><br><span class="line">                        ProcessRecord client = cr.binding.client;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 计算绑定者进程 client 的 adj，这里依然是调用 computeOomAdjLocked 方法，不多说！</span></span><br><span class="line">                        <span class="comment">// 计算绑定者进程 client 的状态！ </span></span><br><span class="line">                        <span class="keyword">int</span> clientAdj = computeOomAdjLocked(client, cachedAdj,</span><br><span class="line">                                TOP_APP, doingAll, now);</span><br><span class="line">                        <span class="keyword">int</span> clientProcState = client.curProcState;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 当绑定者进程 client 的状态 clientProcState &gt;= PROCESS_STATE_CACHED_ACTIVITY：14</span></span><br><span class="line">                        <span class="comment">// 设置其为 PROCESS_STATE_CACHED_EMPTY：16</span></span><br><span class="line">                        <span class="keyword">if</span> (clientProcState &gt;= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) &#123;</span><br><span class="line">                            clientProcState = ActivityManager.PROCESS_STATE_CACHED_EMPTY;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        String adjType = <span class="keyword">null</span>;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 如果 bind 的时候还设置了 BIND_ALLOW_OOM_MANAGEMENT 标志位，表明</span></span><br><span class="line">                        <span class="comment">// 如果遇到 OOM 需要杀死进程，被绑定的服务进程会被 OOM 杀掉，那就不调整该进程的 adj！！</span></span><br><span class="line">                        <span class="keyword">if</span> ((cr.flags &amp; Context.BIND_ALLOW_OOM_MANAGEMENT) != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (app.hasShownUi &amp;&amp; app != mHomeProcess) &#123;</span><br><span class="line">                                <span class="comment">// 如果当前进程已经显示 ui 且不是 home 进程，</span></span><br><span class="line">                                <span class="comment">// 此时设置 clientAdj 和 clientProcState 均为当前进程的 adj 和 procState！</span></span><br><span class="line">                                <span class="comment">// 不再考虑 client 的影响！</span></span><br><span class="line">                                <span class="keyword">if</span> (adj &gt; clientAdj) &#123;</span><br><span class="line">                                    <span class="comment">// 用一个标签标记，用于debug</span></span><br><span class="line">                                    adjType = <span class="string">"cch-bound-ui-services"</span>;</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                app.cached = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                                <span class="comment">// 设置 client 的 adj 和 procState；</span></span><br><span class="line">                                clientAdj = adj;</span><br><span class="line">                                clientProcState = procState;</span><br><span class="line"></span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="comment">// 如果当前进程没有显示 ui，并且在距离上次该服务活跃的时间超过 30mins</span></span><br><span class="line">                                <span class="comment">// 此时只设置 clientAdj 为当前进程的 adj！</span></span><br><span class="line">                                <span class="comment">// 不再考虑 client 的影响！</span></span><br><span class="line">                                <span class="keyword">if</span> (now &gt;= (s.lastActivity</span><br><span class="line">                                        + ActiveServices.MAX_SERVICE_INACTIVITY)) &#123;</span><br><span class="line"></span><br><span class="line">                                    <span class="keyword">if</span> (adj &gt; clientAdj) &#123;</span><br><span class="line">                                        adjType = <span class="string">"cch-bound-services"</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line"></span><br><span class="line">                                    clientAdj = adj;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 如果 client 的 adj 和当前进程的 adj 一样，即不需要考虑客户端进程了</span></span><br><span class="line">                        <span class="comment">// 如果当前进程的 adj &gt; 绑定者进程的 clientAdj，那就需要调整当前进程的 adj，进入以下分支！</span></span><br><span class="line">                        <span class="keyword">if</span> (adj &gt; clientAdj) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (app.hasShownUi &amp;&amp; app != mHomeProcess</span><br><span class="line">                                    &amp;&amp; clientAdj &gt; ProcessList.PERCEPTIBLE_APP_ADJ) &#123;</span><br><span class="line"></span><br><span class="line">                                <span class="comment">// 如果进程显示 ui，并且不是 home process，</span></span><br><span class="line">                                <span class="comment">// 并且绑定者进程的 adj 优先级低于可感知 ProcessList.PERCEPTIBLE_APP_ADJ: 200</span></span><br><span class="line">                                <span class="comment">// 这种情况也不需要考虑客户端进程的影响！</span></span><br><span class="line">                                adjType = <span class="string">"cch-bound-ui-services"</span>;</span><br><span class="line"></span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                                <span class="comment">// 不满足上述条件，进入下面的判断，此时该进程的 adj 会收到 client 进程的 adj 的影响！</span></span><br><span class="line">                                <span class="keyword">if</span> ((cr.flags &amp; (Context.BIND_ABOVE_CLIENT</span><br><span class="line">                                        | Context.BIND_IMPORTANT)) != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                                    <span class="comment">// 如果绑定设置了 BIND_IMPORTANT 和 BIND_ABOVE_CLIENT 标记</span></span><br><span class="line">                                    <span class="comment">// BIND_ABOVE_CLIENT 表示客户端处于前台时，绑定的 service 进程也变为前台进程</span></span><br><span class="line">                                    <span class="comment">// 那么该进程的 adj 满足一下关系：</span></span><br><span class="line">                                    <span class="comment">// adj 会被调整到和 client 一样但是不超过 PERSISTENT_SERVICE_ADJ！</span></span><br><span class="line">                                    adj = clientAdj &gt;= ProcessList.PERSISTENT_SERVICE_ADJ</span><br><span class="line">                                            ? clientAdj : ProcessList.PERSISTENT_SERVICE_ADJ;</span><br><span class="line"></span><br><span class="line">                                &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((cr.flags &amp; Context.BIND_NOT_VISIBLE) != <span class="number">0</span></span><br><span class="line">                                        &amp;&amp; clientAdj &lt; ProcessList.PERCEPTIBLE_APP_ADJ</span><br><span class="line">                                        &amp;&amp; adj &gt; ProcessList.PERCEPTIBLE_APP_ADJ) &#123;</span><br><span class="line"></span><br><span class="line">                                    <span class="comment">// BIND_NOT_VISIBLE 表示服务进程不能变为 visible 进程</span></span><br><span class="line">                                    <span class="comment">// 如果绑定设置了 BIND_NOT_VISIBLE 标记，且绑定者 adj 优先级</span></span><br><span class="line">                                    <span class="comment">// 高于可感知，而当前进程的 adj 优先级低于可感知</span></span><br><span class="line">                                    <span class="comment">// 那么该进程的 adj 会被提升到可感知 PERCEPTIBLE_APP_ADJ！</span></span><br><span class="line">                                    adj = ProcessList.PERCEPTIBLE_APP_ADJ;</span><br><span class="line"></span><br><span class="line">                                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (clientAdj &gt;= ProcessList.PERCEPTIBLE_APP_ADJ) &#123;</span><br><span class="line"></span><br><span class="line">                                    <span class="comment">// 其他情况，如果 clientAdj 优先级不高于可感知</span></span><br><span class="line">                                    <span class="comment">// 那么当前进程的 adj 和 client 一样！</span></span><br><span class="line">                                    adj = clientAdj;</span><br><span class="line"> </span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">                                    <span class="comment">// 其他情况，如果当前进程的 adj 大于可感知 VISIBLE_APP_ADJ</span></span><br><span class="line">                                    <span class="comment">// 那么 adj 取绑定者进程 clientAdj 和 VISIBLE_APP_ADJ 的最大值，即优先级最低的那个！</span></span><br><span class="line">                                    <span class="keyword">if</span> (adj &gt; ProcessList.VISIBLE_APP_ADJ) &#123;</span><br><span class="line">                                        adj = Math.max(clientAdj, ProcessList.VISIBLE_APP_ADJ);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                <span class="comment">// 如果绑定者进程没有处于 cache 状态，那么当前进程也不能处于 cache！</span></span><br><span class="line">                                <span class="keyword">if</span> (!client.cached) &#123;</span><br><span class="line">                                    app.cached = <span class="keyword">false</span>;</span><br><span class="line">                                &#125;</span><br><span class="line"></span><br><span class="line">                                adjType = <span class="string">"service"</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 接下来，处理 BIND_NOT_FOREGROUND 标志位的情况！</span></span><br><span class="line">                        <span class="keyword">if</span> ((cr.flags &amp; Context.BIND_NOT_FOREGROUND) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">//【9.3.1.2】如果 bind 的时候没有设置 BIND_NOT_FOREGROUND 标志位，</span></span><br><span class="line">                            <span class="comment">// 那么被绑定的服务进程优先级可以被提升到 FOREGROUND 级别！</span></span><br><span class="line">                            </span><br><span class="line">                            <span class="comment">// 如果 client 的调度组大于该进程的调度组，调整该进程的调度组</span></span><br><span class="line">                            <span class="keyword">if</span> (client.curSchedGroup &gt; schedGroup) &#123;</span><br><span class="line">                                <span class="keyword">if</span> ((cr.flags &amp; Context.BIND_IMPORTANT) != <span class="number">0</span>) &#123;</span><br><span class="line">                                    schedGroup = client.curSchedGroup;</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    schedGroup = ProcessList.SCHED_GROUP_DEFAULT;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// 根据 client 进程的状态，设置 clientProcState 的值，后面会根据 clientProcState 为参考</span></span><br><span class="line">                            <span class="comment">// 调整该进程的 procState！</span></span><br><span class="line">                            <span class="comment">// 如果 clientProcState 优先级不低于 PROCESS_STATE_TOP，说明其处于 top 状态，进入 IF 分支</span></span><br><span class="line">                            <span class="keyword">if</span> (clientProcState &lt;= ActivityManager.PROCESS_STATE_TOP) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (clientProcState == ActivityManager.PROCESS_STATE_TOP) &#123;</span><br><span class="line">                                </span><br><span class="line">                                    <span class="comment">// 如果 clientProcState 等于 PROCESS_STATE_TOP，说明 client 进程就是 top 进程！</span></span><br><span class="line">                                    <span class="comment">// 设置 mayBeTop 为 true，后续会统一做调整，这里不做调整！</span></span><br><span class="line">                                    <span class="comment">// 设置 clientProcState 为 PROCESS_STATE_CACHED_EMPTY，不做参考！</span></span><br><span class="line">                                    mayBeTop = <span class="keyword">true</span>;</span><br><span class="line">                                    clientProcState = ActivityManager.PROCESS_STATE_CACHED_EMPTY;</span><br><span class="line"></span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    </span><br><span class="line">                                    <span class="comment">// 如果 clientProcState 小于 PROCESS_STATE_TOP，说明 client 进程的优先级比 top process</span></span><br><span class="line">                                    <span class="comment">// 还要高，比如 persistent 进程，这种情况不会将当前进程调整为 top，而是需要</span></span><br><span class="line">                                    <span class="comment">// 调整 clientProcState 的值，作为参考！</span></span><br><span class="line">                                    <span class="keyword">if</span> ((cr.flags &amp; Context.BIND_FOREGROUND_SERVICE) != <span class="number">0</span>) &#123;</span><br><span class="line">                                        clientProcState =</span><br><span class="line">                                                ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;</span><br><span class="line"></span><br><span class="line">                                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mWakefulness</span><br><span class="line">                                                    == PowerManagerInternal.WAKEFULNESS_AWAKE &amp;&amp;</span><br><span class="line">                                            (cr.flags &amp; Context.BIND_FOREGROUND_SERVICE_WHILE_AWAKE)</span><br><span class="line">                                                    != <span class="number">0</span>) &#123;</span><br><span class="line">                                        clientProcState =</span><br><span class="line">                                                ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;</span><br><span class="line"></span><br><span class="line">                                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                        clientProcState =</span><br><span class="line">                                                ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;</span><br><span class="line"></span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            </span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">//【9.3.1.2】如果 bind 的时候设置了 BIND_NOT_FOREGROUND 标志位，</span></span><br><span class="line">                            <span class="comment">// 那么被绑定的服务进程优先级不能被提升到 FOREGROUND 级别！</span></span><br><span class="line">                            <span class="comment">// 设置 clientProcState 最高为 PROCESS_STATE_IMPORTANT_BACKGROUND！</span></span><br><span class="line">                            <span class="keyword">if</span> (clientProcState &lt;</span><br><span class="line">                                    ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND) &#123;</span><br><span class="line"></span><br><span class="line">                                clientProcState =</span><br><span class="line">                                        ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 如果当前进程的 state 优先级低于 client 进程的 state，设置二者相等！</span></span><br><span class="line">                        <span class="keyword">if</span> (procState &gt; clientProcState) &#123;</span><br><span class="line">                            procState = clientProcState;</span><br><span class="line">                        &#125;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 如果当前进程的状态高于 PROCESS_STATE_IMPORTANT_BACKGROUND</span></span><br><span class="line">                        <span class="comment">// 并且绑定时候设置了 BIND_SHOWING_UI 标志位，那就设置 pendingUiClean 为 true</span></span><br><span class="line">                        <span class="keyword">if</span> (procState &lt; ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND</span><br><span class="line">                                &amp;&amp; (cr.flags &amp; Context.BIND_SHOWING_UI) != <span class="number">0</span>) &#123;</span><br><span class="line">                            app.pendingUiClean = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// debug 调试相关，暂不处理！</span></span><br><span class="line">                        <span class="keyword">if</span> (adjType != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            app.adjType = adjType;</span><br><span class="line">                            app.adjTypeCode = ActivityManager.RunningAppProcessInfo</span><br><span class="line">                                    .REASON_SERVICE_IN_USE;</span><br><span class="line">                            app.adjSource = cr.binding.client;</span><br><span class="line">                            app.adjSourceProcState = clientProcState;</span><br><span class="line">                            app.adjTarget = s.name;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///------------------------------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//【9.2.1.2】如果 bind 的时候设置了 BIND_TREAT_LIKE_ACTIVITY，设置其 treatLikeActivity 为 true！</span></span><br><span class="line">                    <span class="keyword">if</span> ((cr.flags &amp; Context.BIND_TREAT_LIKE_ACTIVITY) != <span class="number">0</span>) &#123;</span><br><span class="line">                        app.treatLikeActivity = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///-----------------------------------------------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">final</span> ActivityRecord a = cr.activity; <span class="comment">// 获得绑定该 service 的 activity！</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//【9.2.1.3】如果 bind 的时候设置了 BIND_ADJUST_WITH_ACTIVITY，</span></span><br><span class="line">                    <span class="comment">// 表示系统根据绑定 service 的 activity 的重要程度来调整这个 service 的优先级！</span></span><br><span class="line">                    <span class="keyword">if</span> ((cr.flags&amp;Context.BIND_ADJUST_WITH_ACTIVITY) != <span class="number">0</span>) &#123;</span><br><span class="line">    </span><br><span class="line">                        <span class="comment">// 如果存在绑定者 activity，并且进程此时的 adj 大于 FOREGROUND_APP_ADJ</span></span><br><span class="line">                        <span class="comment">// 同时 activity 是可见的，或者 activity 处于 resume 或者 pause 状态，</span></span><br><span class="line">                        <span class="comment">// 那就需要调整其 adj 为 FOREGROUND_APP_ADJ！</span></span><br><span class="line">                        <span class="keyword">if</span> (a != <span class="keyword">null</span> &amp;&amp; adj &gt; ProcessList.FOREGROUND_APP_ADJ &amp;&amp;</span><br><span class="line">                            (a.visible || a.state == ActivityState.RESUMED ||</span><br><span class="line">                             a.state == ActivityState.PAUSING)) &#123;</span><br><span class="line"></span><br><span class="line">                            adj = ProcessList.FOREGROUND_APP_ADJ; <span class="comment">// 那就需要调整其 adj 为 FOREGROUND_APP_ADJ！</span></span><br><span class="line">                            </span><br><span class="line">                            <span class="comment">// 接着判断 flags 是否设置了 BIND_NOT_FOREGROUND 标志位，</span></span><br><span class="line">                            <span class="comment">// 该 flags 表示被绑定的 service 永远不会有运行于前台的优先级，如果没有设置，进入该分支！</span></span><br><span class="line">                            <span class="keyword">if</span> ((cr.flags &amp; Context.BIND_NOT_FOREGROUND) == <span class="number">0</span>) &#123;</span><br><span class="line">                            </span><br><span class="line">                                <span class="comment">// 接着判断 flags 是否设置了 BIND_IMPORTANT 标志位，</span></span><br><span class="line">                                <span class="comment">// 该标志位表示服务对客户端是非常重要的，会将服务提升至前台进程优先级！</span></span><br><span class="line">                                <span class="comment">// 调整其所属的调度组；</span></span><br><span class="line">                                <span class="keyword">if</span> ((cr.flags &amp; Context.BIND_IMPORTANT) != <span class="number">0</span>) &#123;</span><br><span class="line">                                    schedGroup = ProcessList.SCHED_GROUP_TOP_APP_BOUND;</span><br><span class="line"></span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    schedGroup = ProcessList.SCHED_GROUP_DEFAULT;</span><br><span class="line"></span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            app.cached = <span class="keyword">false</span>;</span><br><span class="line">                            app.adjType = <span class="string">"service"</span>;</span><br><span class="line">                            app.adjTypeCode = ActivityManager.RunningAppProcessInfo</span><br><span class="line">                                    .REASON_SERVICE_IN_USE;</span><br><span class="line">                            app.adjSource = a;</span><br><span class="line">                            app.adjSourceProcState = procState;</span><br><span class="line">                            app.adjTarget = s.name;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       ... ... ... ... <span class="comment">// 见下面[3.1.2.1.11]</span></span><br></pre></td></tr></table></figure>
<p><strong>1、进入条件：</strong></p>
<ul>
<li>`is &gt;= 0 &amp;&amp; (adj &gt; ProcessList.FOREGROUND_APP_ADJ || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND<pre><code>|| procState &gt; ActivityManager.PROCESS_STATE_TOP`
</code></pre><strong>第一个条件</strong>：该进程中运行着服务！<br><strong>第二个条件</strong>：<pre><code>该进程的 `adj &gt; ProcessList.FOREGROUND_APP_ADJ`，只要优先级低于前台进程，都可以满足；
或者 `schedGroup == ProcessList.SCHED_GROUP_BACKGROUND`，只要调度组为后台类型，就可以满足；
或者 `procState &gt; ActivityManager.PROCESS_STATE_TOP`，只要进程状态优先级低于 `top state`；
</code></pre></li>
</ul>
<p><strong>2、处理 <code>Service</code> 的逻辑如下</strong>：</p>
<ul>
<li>处理进程中通过 <code>startService</code> 启动的服务：</li>
<li>处理进程中被其他进程 <code>bind</code> 的服务，针对 <code>bind</code> 时候传入的 <code>flags</code> 进行不同的处理：<ul>
<li>如果设置了 <code>Context.BIND_WAIVE_PRIORITY</code>：</li>
<li>如果设置了 <code>Context.BIND_TREAT_LIKE_ACTIVITY</code>：</li>
<li>如果设置了 <code>Context.BIND_ADJUST_WITH_ACTIVITY</code>：</li>
</ul>
</li>
</ul>
<h4 id="3-3-1-11-处理持有-providers-的进程"><a href="#3-3-1-11-处理持有-providers-的进程" class="headerlink" title="3.3.1.11 处理持有 providers 的进程"></a>3.3.1.11 处理持有 providers 的进程</h4><p>最后，来看看对持有 <code>ContentProvider</code> 进程的处理， 由于 <code>ContentProvider</code> 也是有 <code>client</code> 的，所以客户端的绑定也会影响其进程！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line">... ... ... ... <span class="comment">// 见上面[3.1.2.1.10]  </span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//【10】处理该进程中的 providers，判断是否有其他进程依赖这些 providers，如果有，那么该进程的 adj 会发生变化！</span></span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> provi = app.pubProviders.size()-<span class="number">1</span>;</span><br><span class="line">         provi &gt;= <span class="number">0</span> &amp;&amp; (adj &gt; ProcessList.FOREGROUND_APP_ADJ</span><br><span class="line">                 || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND</span><br><span class="line">                 || procState &gt; ActivityManager.PROCESS_STATE_TOP);</span><br><span class="line">         provi--) &#123;</span><br><span class="line">         </span><br><span class="line">     <span class="comment">//【10.1】app.pubProviders 内部用于保存该进程中所有的 provider！</span></span><br><span class="line">     ContentProviderRecord cpr = app.pubProviders.valueAt(provi);</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = cpr.connections.size()-<span class="number">1</span>;</span><br><span class="line">             i &gt;= <span class="number">0</span> &amp;&amp; (adj &gt; ProcessList.FOREGROUND_APP_ADJ</span><br><span class="line">                     || schedGroup == ProcessList.SCHED_GROUP_BACKGROUND</span><br><span class="line">                     || procState &gt; ActivityManager.PROCESS_STATE_TOP);</span><br><span class="line">             i--) &#123;</span><br><span class="line"></span><br><span class="line">         ContentProviderConnection conn = cpr.connections.get(i);</span><br><span class="line">         ProcessRecord client = conn.client;</span><br><span class="line"></span><br><span class="line">         <span class="comment">//【10.1.1】跳过那些同一个进程中的绑定！</span></span><br><span class="line">         <span class="keyword">if</span> (client == app) &#123;</span><br><span class="line">             <span class="keyword">continue</span>;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">//【10.1.2】计算 client 进程的 adj 和 procState！</span></span><br><span class="line">         <span class="keyword">int</span> clientAdj = computeOomAdjLocked(client, cachedAdj, TOP_APP, doingAll, now);</span><br><span class="line">         <span class="keyword">int</span> clientProcState = client.curProcState;</span><br><span class="line">    </span><br><span class="line">         <span class="comment">//【10.1.3】如果 client 的 procState 优先级比 PROCESS_STATE_CACHED_ACTIVITY 还低，调整其最低为：</span></span><br><span class="line">         <span class="comment">// PROCESS_STATE_CACHED_EMPTY，即如果 client 进程属于缓存状态，我们一律将其视为空进程；</span></span><br><span class="line">         <span class="keyword">if</span> (clientProcState &gt;= ActivityManager.PROCESS_STATE_CACHED_ACTIVITY) &#123;</span><br><span class="line">             clientProcState = ActivityManager.PROCESS_STATE_CACHED_EMPTY;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">//【10.1.4】处理该进程的 adj 的优先级比 client 进程的 adj 低，那就需要调整该进程的 adj 了！</span></span><br><span class="line">         <span class="keyword">if</span> (adj &gt; clientAdj) &#123;</span><br><span class="line">             <span class="comment">// 这里和 Service 的处理是一样的！</span></span><br><span class="line">             <span class="comment">// 如果该进程已经显示过了 ui，并且不是 home proces，且其 client 进程的 adj 优先级低于可感知</span></span><br><span class="line">             <span class="comment">// 那就不考虑 client 进程对当前进程的影响，不调整其 adj！</span></span><br><span class="line">             <span class="keyword">if</span> (app.hasShownUi &amp;&amp; app != mHomeProcess</span><br><span class="line">                     &amp;&amp; clientAdj &gt; ProcessList.PERCEPTIBLE_APP_ADJ) &#123;</span><br><span class="line">                 app.adjType = <span class="string">"cch-ui-provider"</span>;</span><br><span class="line"></span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="comment">// 否则，将当前进程的 adj 调整为 client 进程的 adj，但是不超过 FOREGROUND_APP_ADJ！</span></span><br><span class="line">                 adj = clientAdj &gt; ProcessList.FOREGROUND_APP_ADJ</span><br><span class="line">                         ? clientAdj : ProcessList.FOREGROUND_APP_ADJ;</span><br><span class="line">                 app.adjType = <span class="string">"provider"</span>;</span><br><span class="line"></span><br><span class="line">             &#125;</span><br><span class="line"></span><br><span class="line">             app.cached &amp;= client.cached;</span><br><span class="line"></span><br><span class="line">             <span class="comment">// debug 相关，不处理！</span></span><br><span class="line">             app.adjTypeCode = ActivityManager.RunningAppProcessInfo</span><br><span class="line">                     .REASON_PROVIDER_IN_USE;</span><br><span class="line">             app.adjSource = client;</span><br><span class="line">             app.adjSourceProcState = clientProcState;</span><br><span class="line">             app.adjTarget = cpr.name;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">//【10.1.5】调整该进程的 procState！！</span></span><br><span class="line">         <span class="comment">// 如果 client 进程的 procState 优先级不高于 top process 的状态，我们要对 clientProcState 做一下调整！</span></span><br><span class="line">         <span class="keyword">if</span> (clientProcState &lt;= ActivityManager.PROCESS_STATE_TOP) &#123;</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 要先调整下 client 进程的 procState！</span></span><br><span class="line">             <span class="keyword">if</span> (clientProcState == ActivityManager.PROCESS_STATE_TOP) &#123;</span><br><span class="line">                 <span class="comment">// 如果 client 进程是 top 级别的，设置 mayBeTop 为 true，此时我们不会立刻做调整，后续会做调整！</span></span><br><span class="line">                 <span class="comment">// 设置 clientProcState 为 PROCESS_STATE_CACHED_EMPTY，不做参考！ </span></span><br><span class="line">                 mayBeTop = <span class="keyword">true</span>;</span><br><span class="line">                 clientProcState = ActivityManager.PROCESS_STATE_CACHED_EMPTY;</span><br><span class="line">                 </span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="comment">// 如果 clientProcState 小于 PROCESS_STATE_TOP，说明 client 进程的优先级比 top process</span></span><br><span class="line">                 <span class="comment">// 还要高，比如 persistent 进程，这种情况不会将当前进程调整为 top，而是需要</span></span><br><span class="line">                 <span class="comment">// 调整 clientProcState 的值，作为参考，这里是设置其为 PROCESS_STATE_BOUND_FOREGROUND_SERVICE</span></span><br><span class="line">                 clientProcState =</span><br><span class="line">                         ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 如果此时该进程的 procState 优先级低于 client 进程的 procState，提高其等于 client 进程的 procState</span></span><br><span class="line">         <span class="keyword">if</span> (procState &gt; clientProcState) &#123;</span><br><span class="line">             procState = clientProcState;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">//【10.1.6】调整该进程的调度组 schedGroup！       </span></span><br><span class="line">         <span class="keyword">if</span> (client.curSchedGroup &gt; schedGroup) &#123;</span><br><span class="line">             schedGroup = ProcessList.SCHED_GROUP_DEFAULT;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//【10.2】如何当前的 provider 依赖于一些 external (non-framework) process，</span></span><br><span class="line">     <span class="comment">// 那么我们要保证当前进程的 adj 至少为 FOREGROUND_APP_ADJ</span></span><br><span class="line">     <span class="keyword">if</span> (cpr.hasExternalProcessHandles()) &#123;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (adj &gt; ProcessList.FOREGROUND_APP_ADJ) &#123;</span><br><span class="line">             adj = ProcessList.FOREGROUND_APP_ADJ;</span><br><span class="line">             schedGroup = ProcessList.SCHED_GROUP_DEFAULT;</span><br><span class="line">             app.cached = <span class="keyword">false</span>;</span><br><span class="line">             app.adjType = <span class="string">"provider"</span>;</span><br><span class="line">             app.adjTarget = cpr.name;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span> (procState &gt; ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND) &#123;</span><br><span class="line">             procState = ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//【11】如果该进程中之前有 provider 活跃过，并且距离上一次 provider 活时间超过了 20 秒</span></span><br><span class="line"> <span class="comment">// 对该进程的 adj，schedGroup 和 procState 做进一步调整；</span></span><br><span class="line"> <span class="keyword">if</span> (app.lastProviderTime &gt; <span class="number">0</span> &amp;&amp; (app.lastProviderTime + CONTENT_PROVIDER_RETAIN_TIME) &gt; now) &#123;</span><br><span class="line">     <span class="keyword">if</span> (adj &gt; ProcessList.PREVIOUS_APP_ADJ) &#123;</span><br><span class="line">         adj = ProcessList.PREVIOUS_APP_ADJ;</span><br><span class="line">         schedGroup = ProcessList.SCHED_GROUP_BACKGROUND;</span><br><span class="line">         app.cached = <span class="keyword">false</span>;</span><br><span class="line">         app.adjType = <span class="string">"provider"</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (procState &gt; ActivityManager.PROCESS_STATE_LAST_ACTIVITY) &#123;</span><br><span class="line">         procState = ActivityManager.PROCESS_STATE_LAST_ACTIVITY;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> ... ... ...<span class="comment">// 见下面[3.1.2.1.12]</span></span><br></pre></td></tr></table></figure>
<p>这个方法的流程很长，我们总结一下整个的计算过程：</p>
<ul>
<li>整个的计算过程是从优先级高的 <code>adj</code> 开始，逐级向下遍历，逐渐的调整进程的 <code>oomAdj</code> 和 <code>procState</code> 的状态，知道找到一个合适的 <code>oomAdj</code> 和 <code>procState</code> 值！</li>
</ul>
<h4 id="3-3-1-12-最后调整阶段"><a href="#3-3-1-12-最后调整阶段" class="headerlink" title="3.3.1.12 最后调整阶段"></a>3.3.1.12 最后调整阶段</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">    ... ... ...<span class="comment">// 见上面[3.1.2.1.11]  </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//【12】处理 top process 绑定了当前进程的 Service 或者 Provider 的情况！</span></span><br><span class="line">    <span class="keyword">if</span> (mayBeTop &amp;&amp; procState &gt; ActivityManager.PROCESS_STATE_TOP) &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// top 进程绑定了该进程 Service 或者 provider，我们应该将该进程也设置为 top 状态</span></span><br><span class="line">        <span class="comment">// 但是如果此时该进程因为一些原因正在后台运行，我们会将其设置到特定的状态！</span></span><br><span class="line">        <span class="keyword">switch</span> (procState) &#123;</span><br><span class="line">            <span class="keyword">case</span> ActivityManager.PROCESS_STATE_IMPORTANT_FOREGROUND: <span class="comment">// 很重要，可以感知到；</span></span><br><span class="line">            <span class="keyword">case</span> ActivityManager.PROCESS_STATE_IMPORTANT_BACKGROUND: <span class="comment">// 很重要，感知不到；</span></span><br><span class="line">            <span class="keyword">case</span> ActivityManager.PROCESS_STATE_SERVICE: <span class="comment">// 后台服务；</span></span><br><span class="line">                <span class="comment">// 上面这三这种状态都是会长时间保持的状态，将其设置为 PROCESS_STATE_BOUND_FOREGROUND_SERVICE！</span></span><br><span class="line">                <span class="comment">// 在所有的后台进程之上</span></span><br><span class="line">                procState = ActivityManager.PROCESS_STATE_BOUND_FOREGROUND_SERVICE;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">// 其他情况，该进程的状态为 top</span></span><br><span class="line">                procState = ActivityManager.PROCESS_STATE_TOP;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【13】如果该进程的 procState 优先级低于 PROCESS_STATE_CACHED_EMPTY，表示当前进程是一个 cache 进程！</span></span><br><span class="line">    <span class="keyword">if</span> (procState &gt;= ActivityManager.PROCESS_STATE_CACHED_EMPTY) &#123;</span><br><span class="line">        <span class="keyword">if</span> (app.hasClientActivities) &#123; </span><br><span class="line"></span><br><span class="line">            <span class="comment">// hasClientActivities 为 true，表示该进程内部有 activity 作为客户端绑定其他的服务！ </span></span><br><span class="line">            <span class="comment">// 调整 procState 为 PROCESS_STATE_CACHED_ACTIVITY_CLIENT</span></span><br><span class="line">            procState = ActivityManager.PROCESS_STATE_CACHED_ACTIVITY_CLIENT;</span><br><span class="line">            app.adjType = <span class="string">"cch-client-act"</span>;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (app.treatLikeActivity) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// treatLikeActivity 为 true，表示该进程需要被当作有 activity 的进程对待！</span></span><br><span class="line">            <span class="comment">// 设置 procState 为 PROCESS_STATE_CACHED_ACTIVITY</span></span><br><span class="line">            procState = ActivityManager.PROCESS_STATE_CACHED_ACTIVITY;</span><br><span class="line">            app.adjType = <span class="string">"cch-as-act"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【14】如果该进程的 adj 等于 SERVICE_ADJ，这边会对进程根据 Service A list 和 Service B list 做一个划分！</span></span><br><span class="line">    <span class="keyword">if</span> (adj == ProcessList.SERVICE_ADJ) &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// doingAll 为 true 表示本次 update 更新的是所有进程的 adj，只有在空参数 update 调用的时候会为 true！</span></span><br><span class="line">        <span class="keyword">if</span> (doingAll) &#123; </span><br><span class="line">        </span><br><span class="line">            <span class="comment">// 先判断该进程是否是 Service B list 进程</span></span><br><span class="line">            app.serviceb = mNewNumAServiceProcs &gt; (mNumServiceProcs / <span class="number">3</span>);</span><br><span class="line">            </span><br><span class="line">            mNewNumServiceProcs++; <span class="comment">// 计算最新的服务进程数， + 1；</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//Slog.i(TAG, "ADJ " + app + " serviceb=" + app.serviceb);</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!app.serviceb) &#123;</span><br><span class="line">            </span><br><span class="line">                <span class="comment">// This service isn't far enough down on the LRU list to</span></span><br><span class="line">                <span class="comment">// normally be a B service, but if we are low on RAM and it</span></span><br><span class="line">                <span class="comment">// is large we want to force it down since we would prefer to</span></span><br><span class="line">                <span class="comment">// keep launcher over it.</span></span><br><span class="line">                <span class="comment">// 如果不是 Service B list，但内存回收等级过高，也被视为 Service B list</span></span><br><span class="line">                <span class="keyword">if</span> (mLastMemoryLevel &gt; ProcessStats.ADJ_MEM_FACTOR_NORMAL</span><br><span class="line">                        &amp;&amp; app.lastPss &gt;= mProcessList.getCachedRestoreThresholdKb()) &#123;</span><br><span class="line">                    app.serviceHighRam = <span class="keyword">true</span>;</span><br><span class="line">                    app.serviceb = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="comment">//Slog.i(TAG, "ADJ " + app + " high ram!");</span></span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Service A list 类型的进程数 + 1；</span></span><br><span class="line">                    mNewNumAServiceProcs++;</span><br><span class="line">                    <span class="comment">//Slog.i(TAG, "ADJ " + app + " not high ram!");</span></span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                app.serviceHighRam = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (app.serviceb) &#123; </span><br><span class="line">            <span class="comment">// 如果 serviceb 为 true，则该进程是 Service B list 中的！</span></span><br><span class="line">            <span class="comment">// 设置其 adj 为 SERVICE_B_ADJ！</span></span><br><span class="line">            adj = ProcessList.SERVICE_B_ADJ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置进程的 curRawAdj 为最终的计算结果！</span></span><br><span class="line">    app.curRawAdj = adj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Slog.i(TAG, "OOM ADJ " + app + ": pid=" + app.pid +</span></span><br><span class="line">    <span class="comment">//      " adj=" + adj + " curAdj=" + app.curAdj + " maxAdj=" + app.maxAdj);</span></span><br><span class="line">    <span class="keyword">if</span> (adj &gt; app.maxAdj) &#123;</span><br><span class="line">        adj = app.maxAdj;</span><br><span class="line">        <span class="keyword">if</span> (app.maxAdj &lt;= ProcessList.PERCEPTIBLE_APP_ADJ) &#123;</span><br><span class="line">            schedGroup = ProcessList.SCHED_GROUP_DEFAULT;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do final modification to adj.  Everything we do between here and applying</span></span><br><span class="line">    <span class="comment">// the final setAdj must be done in this function, because we will also use</span></span><br><span class="line">    <span class="comment">// it when computing the final cached adj later.  Note that we don't need to</span></span><br><span class="line">    <span class="comment">// worry about this for max adj above, since max adj will always be used to</span></span><br><span class="line">    <span class="comment">// keep it out of the cached vaues.</span></span><br><span class="line">    <span class="comment">// 对上面计算出的 adj 做第二次修正计算，其返回值是进程的最终 adj！！</span></span><br><span class="line">    app.curAdj = app.modifyRawOomAdj(adj);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置其他的一些变量属性！</span></span><br><span class="line">    app.curSchedGroup = schedGroup;</span><br><span class="line">    app.curProcState = procState;</span><br><span class="line">    app.foregroundActivities = foregroundActivities;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.curRawAdj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里调用了 <code>modifyRawOomAdj</code> 方法，根据 <code>BIND_ABOVE_CLIENT</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">modifyRawOomAdj</span><span class="params">(<span class="keyword">int</span> adj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// hasAboveClient 为 true，表示该进程通过 BIND_ABOVE_CLIENT 方式绑定了 Service！</span></span><br><span class="line">    <span class="comment">// BIND_ABOVE_CLIENT 表示该进程的优先级已经超过了 Activity，也就是说当资源不够的时候 Activity 要比 Service 先死；</span></span><br><span class="line">    <span class="comment">// 所以需要降低该进程的 adj 优先级！</span></span><br><span class="line">    <span class="keyword">if</span> (hasAboveClient) &#123;</span><br><span class="line">        <span class="keyword">if</span> (adj &lt; ProcessList.FOREGROUND_APP_ADJ) &#123;</span><br><span class="line">            <span class="comment">// System process will not get dropped, ever</span></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (adj &lt; ProcessList.VISIBLE_APP_ADJ) &#123;</span><br><span class="line">            adj = ProcessList.VISIBLE_APP_ADJ;</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (adj &lt; ProcessList.PERCEPTIBLE_APP_ADJ) &#123;</span><br><span class="line">            adj = ProcessList.PERCEPTIBLE_APP_ADJ;</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (adj &lt; ProcessList.CACHED_APP_MIN_ADJ) &#123;</span><br><span class="line">            adj = ProcessList.CACHED_APP_MIN_ADJ;</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (adj &lt; ProcessList.CACHED_APP_MAX_ADJ) &#123;</span><br><span class="line">            adj++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 一般情况是直接返回第一次计算后的值的！</span></span><br><span class="line">    <span class="keyword">return</span> adj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>LRU list</code> 中，从后往前数，前 <code>1/3</code> 的 <code>service</code> 进程就是 <code>AService</code> 进程，其余的就是 <code>BService</code> 进程；</p>
<h3 id="3-3-2-ActivityManagerS-applyOomAdjLocked"><a href="#3-3-2-ActivityManagerS-applyOomAdjLocked" class="headerlink" title="3.3.2  ActivityManagerS.applyOomAdjLocked"></a>3.3.2  ActivityManagerS.applyOomAdjLocked</h3><p>最后，<code>applyOomAdjLocked</code> 方法用来应用计算出的 <code>adj</code>！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">applyOomAdjLocked</span><span class="params">(ProcessRecord app, <span class="keyword">boolean</span> doingAll, <span class="keyword">long</span> now,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span> nowElapsed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> success = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】更新 setRawAdj 的值！</span></span><br><span class="line">    <span class="keyword">if</span> (app.curRawAdj != app.setRawAdj) &#123;</span><br><span class="line">        app.setRawAdj = app.curRawAdj; <span class="comment">// 更新 setRawAdj！</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> changes = <span class="number">0</span>; <span class="comment">// 用于记录进程的状态是否发生了变化！</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】更新 setAdj 的值！</span></span><br><span class="line">    <span class="keyword">if</span> (app.curAdj != app.setAdj) &#123;</span><br><span class="line">        ProcessList.setOomAdj(app.pid, app.info.uid, app.curAdj); <span class="comment">// 设置进程的最新 adj！</span></span><br><span class="line">        <span class="keyword">if</span> (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,</span><br><span class="line">                <span class="string">"Set "</span> + app.pid + <span class="string">" "</span> + app.processName + <span class="string">" adj "</span> + app.curAdj + <span class="string">": "</span></span><br><span class="line">                + app.adjType);</span><br><span class="line">        app.setAdj = app.curAdj;  <span class="comment">// 更新 setAdj！</span></span><br><span class="line">        app.verifiedAdj = ProcessList.INVALID_ADJ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【3】更新 setSchedGroup 调度组信息！</span></span><br><span class="line">    <span class="keyword">if</span> (app.setSchedGroup != app.curSchedGroup) &#123;</span><br><span class="line">        <span class="keyword">int</span> oldSchedGroup = app.setSchedGroup;</span><br><span class="line">        app.setSchedGroup = app.curSchedGroup; <span class="comment">// 更新 setSchedGroup！</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,</span><br><span class="line">                <span class="string">"Setting sched group of "</span> + app.processName</span><br><span class="line">                + <span class="string">" to "</span> + app.curSchedGroup);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (app.waitingToKill != <span class="keyword">null</span> &amp;&amp; app.curReceiver == <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; app.setSchedGroup == ProcessList.SCHED_GROUP_BACKGROUND) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【3.1】杀掉那些之前延迟 kill，现在不持有 receiver 且属于后台的进程！</span></span><br><span class="line">            app.kill(app.waitingToKill, <span class="keyword">true</span>);</span><br><span class="line">            success = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【3.2】根据调度组 curSchedGroup，设置进程组信息！</span></span><br><span class="line">            <span class="keyword">int</span> processGroup;</span><br><span class="line">            <span class="keyword">switch</span> (app.curSchedGroup) &#123;</span><br><span class="line">                <span class="keyword">case</span> ProcessList.SCHED_GROUP_BACKGROUND:</span><br><span class="line">                    <span class="comment">// 后台调度组: 6</span></span><br><span class="line">                    processGroup = Process.THREAD_GROUP_BG_NONINTERACTIVE;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> ProcessList.SCHED_GROUP_TOP_APP:</span><br><span class="line">                <span class="keyword">case</span> ProcessList.SCHED_GROUP_TOP_APP_BOUND:</span><br><span class="line">                    <span class="comment">// 前台调度组：5</span></span><br><span class="line">                    processGroup = Process.THREAD_GROUP_TOP_APP;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">    </span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="comment">// 默认调度组：-1</span></span><br><span class="line">                    processGroup = Process.THREAD_GROUP_DEFAULT;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> oldId = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//【3.3】设置进程的调度组！</span></span><br><span class="line">                Process.setProcessGroup(app.pid, processGroup);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//【3.4】根据调度组，设置</span></span><br><span class="line">                <span class="keyword">if</span> (app.curSchedGroup == ProcessList.SCHED_GROUP_TOP_APP) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// do nothing if we already switched to RT</span></span><br><span class="line">                    <span class="comment">//【3.3.1】如果之前进程的调度组不是 top app 级别，而现在的调度组是 top app 级别，进入这里！</span></span><br><span class="line">                    <span class="keyword">if</span> (oldSchedGroup != ProcessList.SCHED_GROUP_TOP_APP) &#123;</span><br><span class="line">                    </span><br><span class="line">                        <span class="comment">// Switch VR thread for app to SCHED_FIFO</span></span><br><span class="line">                        <span class="keyword">if</span> (mInVrMode &amp;&amp; app.vrThreadTid != <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                <span class="comment">// 如果进程启动了 VR    </span></span><br><span class="line">                                Process.setThreadScheduler(app.vrThreadTid,</span><br><span class="line">                                    Process.SCHED_FIFO | Process.SCHED_RESET_ON_FORK, <span class="number">1</span>);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">                                <span class="comment">// thread died, ignore</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (mUseFifoUiScheduling) &#123;</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// Switch UI pipeline for app to SCHED_FIFO</span></span><br><span class="line">                            app.savedPriority = Process.getThreadPriority(app.pid);</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                Process.setThreadScheduler(app.pid,</span><br><span class="line">                                    Process.SCHED_FIFO | Process.SCHED_RESET_ON_FORK, <span class="number">1</span>);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">                                <span class="comment">// thread died, ignore</span></span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="keyword">if</span> (app.renderThreadTid != <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    Process.setThreadScheduler(app.renderThreadTid,</span><br><span class="line">                                        Process.SCHED_FIFO | Process.SCHED_RESET_ON_FORK, <span class="number">1</span>);</span><br><span class="line">                                &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">                                    <span class="comment">// thread died, ignore</span></span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">if</span> (DEBUG_OOM_ADJ) &#123;</span><br><span class="line">                                    Slog.d(<span class="string">"UI_FIFO"</span>, <span class="string">"Set RenderThread (TID "</span> +</span><br><span class="line">                                        app.renderThreadTid + <span class="string">") to FIFO"</span>);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (DEBUG_OOM_ADJ) &#123;</span><br><span class="line">                                    Slog.d(<span class="string">"UI_FIFO"</span>, <span class="string">"Not setting RenderThread TID"</span>);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// Boost priority for top app UI and render threads</span></span><br><span class="line">                            Process.setThreadPriority(app.pid, -<span class="number">10</span>);</span><br><span class="line">                            <span class="keyword">if</span> (app.renderThreadTid != <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    Process.setThreadPriority(app.renderThreadTid, -<span class="number">10</span>);</span><br><span class="line">                                &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">                                    <span class="comment">// thread died, ignore</span></span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldSchedGroup == ProcessList.SCHED_GROUP_TOP_APP &amp;&amp;</span><br><span class="line">                           app.curSchedGroup != ProcessList.SCHED_GROUP_TOP_APP) &#123;</span><br><span class="line">                <span class="comment">//【3.3.2】如果之前进程的调度组是 top app 级别，而现在的调度组不是 top app 级别，则进入这里！</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Reset VR thread to SCHED_OTHER</span></span><br><span class="line">                    <span class="comment">// Safe to do even if we're not in VR mode</span></span><br><span class="line">                    <span class="comment">// 进程的 vrThreadTid 不等于 0，说明我们在 VR 模式！</span></span><br><span class="line">                    <span class="keyword">if</span> (app.vrThreadTid != <span class="number">0</span>) &#123;</span><br><span class="line">                        Process.setThreadScheduler(app.vrThreadTid, Process.SCHED_OTHER, <span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (mUseFifoUiScheduling) &#123;</span><br><span class="line">                        <span class="comment">// Reset UI pipeline to SCHED_OTHER</span></span><br><span class="line">                        Process.setThreadScheduler(app.pid, Process.SCHED_OTHER, <span class="number">0</span>);</span><br><span class="line">                        Process.setThreadPriority(app.pid, app.savedPriority);</span><br><span class="line">                        <span class="keyword">if</span> (app.renderThreadTid != <span class="number">0</span>) &#123;</span><br><span class="line">                            Process.setThreadScheduler(app.renderThreadTid,</span><br><span class="line">                                Process.SCHED_OTHER, <span class="number">0</span>);</span><br><span class="line">                            Process.setThreadPriority(app.renderThreadTid, -<span class="number">4</span>);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// Reset priority for top app UI and render threads</span></span><br><span class="line">                        Process.setThreadPriority(app.pid, <span class="number">0</span>);</span><br><span class="line">                        <span class="keyword">if</span> (app.renderThreadTid != <span class="number">0</span>) &#123;</span><br><span class="line">                            Process.setThreadPriority(app.renderThreadTid, <span class="number">0</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Failed setting process group of "</span> + app.pid</span><br><span class="line">                        + <span class="string">" to "</span> + app.curSchedGroup);</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                Binder.restoreCallingIdentity(oldId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【4】接下来是记录进程的信息和状态的变化！</span></span><br><span class="line">    <span class="comment">// 进程内部的 acitivity 的状态发生了变化！ProcessChangeItem.CHANGE_ACTIVITIES</span></span><br><span class="line">    <span class="keyword">if</span> (app.repForegroundActivities != app.foregroundActivities) &#123;</span><br><span class="line">        app.repForegroundActivities = app.foregroundActivities; <span class="comment">// 更新 repForegroundActivities！</span></span><br><span class="line">        changes |= ProcessChangeItem.CHANGE_ACTIVITIES;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【5】进程状态发生了变化，通知上层应用进程！！</span></span><br><span class="line">    <span class="keyword">if</span> (app.repProcState != app.curProcState) &#123;</span><br><span class="line">        app.repProcState = app.curProcState; <span class="comment">// 更新 repProcState！</span></span><br><span class="line">        changes |= ProcessChangeItem.CHANGE_PROCESS_STATE;</span><br><span class="line">        <span class="keyword">if</span> (app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">                    <span class="comment">//RuntimeException h = new RuntimeException("here");</span></span><br><span class="line">                    Slog.i(TAG, <span class="string">"Sending new process state "</span> + app.repProcState</span><br><span class="line">                            + <span class="string">" to "</span> + app <span class="comment">/*, h*/</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//【5.1】通知上层进程！</span></span><br><span class="line">                app.thread.setProcessState(app.repProcState);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【5】如果进程在先后状态下的内存状态不同，那就要更新下下次申请 PSS 的时间！</span></span><br><span class="line">    <span class="keyword">if</span> (app.setProcState == ActivityManager.PROCESS_STATE_NONEXISTENT</span><br><span class="line">            || ProcessList.procStatesDifferForMem(app.curProcState, app.setProcState)) &#123;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">false</span> &amp;&amp; mTestPssMode &amp;&amp; app.setProcState &gt;= <span class="number">0</span> &amp;&amp; app.lastStateTime &lt;= (now - <span class="number">200</span>)) &#123; <span class="comment">// 用于 debug！</span></span><br><span class="line">            <span class="keyword">long</span> start = SystemClock.uptimeMillis();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 记录 PPS 物理内存！</span></span><br><span class="line">            <span class="keyword">long</span> pss = Debug.getPss(app.pid, mTmpLong, <span class="keyword">null</span>);</span><br><span class="line">            recordPssSampleLocked(app, app.curProcState, pss, mTmpLong[<span class="number">0</span>], mTmpLong[<span class="number">1</span>], now);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从 mPendingPssProcesses 列表中删除当前进程！</span></span><br><span class="line">            mPendingPssProcesses.remove(app);</span><br><span class="line">            Slog.i(TAG, <span class="string">"Recorded pss for "</span> + app + <span class="string">" state "</span> + app.setProcState</span><br><span class="line">                    + <span class="string">" to "</span> + app.curProcState + <span class="string">": "</span></span><br><span class="line">                    + (SystemClock.uptimeMillis()-start) + <span class="string">"ms"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        app.lastStateTime = now;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【5.1】更新下次申请 pss 内存的时间！</span></span><br><span class="line">        app.nextPssTime = ProcessList.computeNextPssTime(app.curProcState, <span class="keyword">true</span>,</span><br><span class="line">                mTestPssMode, isSleepingLocked(), now);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DEBUG_PSS) Slog.d(TAG_PSS, <span class="string">"Process state change from "</span></span><br><span class="line">                + ProcessList.makeProcStateString(app.setProcState) + <span class="string">" to "</span></span><br><span class="line">                + ProcessList.makeProcStateString(app.curProcState) + <span class="string">" next pss in "</span></span><br><span class="line">                + (app.nextPssTime-now) + <span class="string">": "</span> + app);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//【5.2】如果当前时间已经超过了 nextPssTime 下一次申请 PSS 的时间</span></span><br><span class="line">        <span class="comment">// 那就要请求 PSS 物理内存！</span></span><br><span class="line">        <span class="keyword">if</span> (now &gt; app.nextPssTime || (now &gt; (app.lastPssTime + ProcessList.PSS_MAX_INTERVAL)</span><br><span class="line">                &amp;&amp; now &gt; (app.lastStateTime + ProcessList.minTimeFromStateChange(</span><br><span class="line">                mTestPssMode)))) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 请求物理内存！</span></span><br><span class="line">            requestPssLocked(app, app.setProcState);</span><br><span class="line">            app.nextPssTime = ProcessList.computeNextPssTime(app.curProcState, <span class="keyword">false</span>,</span><br><span class="line">                    mTestPssMode, isSleepingLocked(), now);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">false</span> &amp;&amp; DEBUG_PSS) Slog.d(TAG_PSS,</span><br><span class="line">                <span class="string">"Not requesting PSS of "</span> + app + <span class="string">": next="</span> + (app.nextPssTime-now));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【6】更新 setProcState 属性！</span></span><br><span class="line">    <span class="keyword">if</span> (app.setProcState != app.curProcState) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_SWITCH || DEBUG_OOM_ADJ) Slog.v(TAG_OOM_ADJ,</span><br><span class="line">                <span class="string">"Proc state change of "</span> + app.processName</span><br><span class="line">                        + <span class="string">" to "</span> + app.curProcState);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算进程状态变化前后的重要性！</span></span><br><span class="line">        <span class="keyword">boolean</span> setImportant = app.setProcState &lt; ActivityManager.PROCESS_STATE_SERVICE;</span><br><span class="line">        <span class="keyword">boolean</span> curImportant = app.curProcState &lt; ActivityManager.PROCESS_STATE_SERVICE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (setImportant &amp;&amp; !curImportant) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果进程变的不重要了，需要记录下其 wake time，用于后续的 kill 操作！</span></span><br><span class="line">            BatteryStatsImpl stats = mBatteryStatsService.getActiveStatistics();</span><br><span class="line">            <span class="keyword">synchronized</span> (stats) &#123;</span><br><span class="line">                app.lastWakeTime = stats.getProcessWakeTime(app.info.uid,</span><br><span class="line">                        app.pid, nowElapsed);</span><br><span class="line">            &#125;</span><br><span class="line">            app.lastCpuTime = app.curCpuTime;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新进程的使用情况！</span></span><br><span class="line">        maybeUpdateUsageStatsLocked(app, nowElapsed);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新 setProcState！</span></span><br><span class="line">        app.setProcState = app.curProcState;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (app.setProcState &gt;= ActivityManager.PROCESS_STATE_HOME) &#123;</span><br><span class="line">            app.notCachedSinceIdle = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!doingAll) &#123;</span><br><span class="line">            setProcessTrackerStateLocked(app, mProcessStats.getMemFactorLocked(), now);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            app.procStateChanged = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (app.reportedInteraction &amp;&amp; (nowElapsed - app.interactionEventTime)</span><br><span class="line">            &gt; USAGE_STATS_INTERACTION_INTERVAL) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// For apps that sit around for a long time in the interactive state, we need</span></span><br><span class="line">        <span class="comment">// to report this at least once a day so they don't go idle.</span></span><br><span class="line">        maybeUpdateUsageStatsLocked(app, nowElapsed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【7】如果 changes 不等于 0，说明进程的状态信息发生了变化！</span></span><br><span class="line">    <span class="comment">// 我们需要将这次的改变封装为 mPendingProcessChanges，通知那些监控进程变化的服务！</span></span><br><span class="line">    <span class="keyword">if</span> (changes  != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DEBUG_PROCESS_OBSERVERS) Slog.i(TAG_PROCESS_OBSERVERS,</span><br><span class="line">                <span class="string">"Changes in "</span> + app + <span class="string">": "</span> + changes);</span><br><span class="line">                </span><br><span class="line">        <span class="comment">// 判断该进程是否已经有一个 ProcessChangeItem！</span></span><br><span class="line">        <span class="keyword">int</span> i = mPendingProcessChanges.size()-<span class="number">1</span>;</span><br><span class="line">        ProcessChangeItem item = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            item = mPendingProcessChanges.get(i);</span><br><span class="line">            <span class="keyword">if</span> (item.pid == app.pid) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_PROCESS_OBSERVERS) Slog.i(TAG_PROCESS_OBSERVERS,</span><br><span class="line">                        <span class="string">"Re-using existing item: "</span> + item);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// i &lt; 0 说明该进程没有已存在的等待处理的 ProcessChangeItem 项，那就创建一个新的！</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> NA = mAvailProcessChanges.size();</span><br><span class="line">            <span class="comment">// 尝试从 mAvailProcessChanges 中回收复用一个 ProcessChangeItem 项！</span></span><br><span class="line">            <span class="comment">// 不能回收，就创建一个新的！</span></span><br><span class="line">            <span class="keyword">if</span> (NA &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                item = mAvailProcessChanges.remove(NA-<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_PROCESS_OBSERVERS) Slog.i(TAG_PROCESS_OBSERVERS,</span><br><span class="line">                        <span class="string">"Retrieving available item: "</span> + item);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                item = <span class="keyword">new</span> ProcessChangeItem();</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_PROCESS_OBSERVERS) Slog.i(TAG_PROCESS_OBSERVERS,</span><br><span class="line">                        <span class="string">"Allocating new item: "</span> + item);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 初始化变量！</span></span><br><span class="line">            item.changes = <span class="number">0</span>;</span><br><span class="line">            item.pid = app.pid;</span><br><span class="line">            item.uid = app.info.uid;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mPendingProcessChanges.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_PROCESS_OBSERVERS) Slog.i(TAG_PROCESS_OBSERVERS,</span><br><span class="line">                        <span class="string">"*** Enqueueing dispatch processes changed!"</span>);</span><br><span class="line">                mUiHandler.obtainMessage(DISPATCH_PROCESSES_CHANGED_UI_MSG).sendToTarget();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加到 mPendingProcessChanges 列表中！</span></span><br><span class="line">            mPendingProcessChanges.add(item);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置 ProcessChangeItem 的属性！</span></span><br><span class="line">        item.changes |= changes;</span><br><span class="line">        item.processState = app.repProcState;</span><br><span class="line">        item.foregroundActivities = app.repForegroundActivities;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (DEBUG_PROCESS_OBSERVERS) Slog.i(TAG_PROCESS_OBSERVERS,</span><br><span class="line">                <span class="string">"Item "</span> + Integer.toHexString(System.identityHashCode(item))</span><br><span class="line">                + <span class="string">" "</span> + app.toShortString() + <span class="string">": changes="</span> + item.changes</span><br><span class="line">                + <span class="string">" procState="</span> + item.processState</span><br><span class="line">                + <span class="string">" foreground="</span> + item.foregroundActivities</span><br><span class="line">                + <span class="string">" type="</span> + app.adjType + <span class="string">" source="</span> + app.adjSource</span><br><span class="line">                + <span class="string">" target="</span> + app.adjTarget);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h1><p>首先，我们知道对于进程的优先级，<code>Android</code> 有 <code>2</code> 套分级机制：</p>
<ul>
<li><code>ActivityManagerService</code> 中对进程优先级的分级，以 <code>PROCESS_STATE_</code> 开头，定义在 <code>ActivityManager.java</code> 中;</li>
<li><code>LowMemoryKiller</code> 通过 <code>oomAdj</code> 对进程优先级的分级;</li>
</ul>
<pre><code>//开始逆序处理LRU中的每一个进程
// 对应重要性大于home的进程而言，重要性越高，内存回收等级越低
// 对于重要性小于home的进程，排在LRU表越靠后，即越重要回收等级越高
// 这么安排的理由有两个：1、此时越不重要的进程，其中运行的组件越少，能够回收的内存不多，不需要高回收等级
// 2、越不重要的进程越有可能被LMK kill掉，没必要以高等级回收内存
</code></pre><p>Android 并不是 kill 掉所有 Empty 进程后，才 kill 后台进程。<br>它是将 CACHED_APP_MIN_ADJ 和 CACHED_APP_MAX_ADJ 之间的范围，分成 3 个 slot。 </p>
<p>然后在每个 slot 中，分别分配一定量的后台进程和 Empty 进程。<br>在单独的 slot 中，会先 kill 掉 empty 进程，后 kill 掉后台进程。<br>只有当一个 slot 中的进程 kill 完毕后，才会 kill 掉下一个 slot 中的进程。<br>我们将从后面的代码中，得到对应的分析依据，这里先有个印象即可。</p>
<p>  <a href="http://blog.csdn.net/Gaugamela/article/details/54176460" target="_blank" rel="noopener">http://blog.csdn.net/Gaugamela/article/details/54176460</a></p>
<p>  <a href="http://www.cnblogs.com/tiger-wang-ms/p/6445213.html" target="_blank" rel="noopener">http://www.cnblogs.com/tiger-wang-ms/p/6445213.html</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Coolqi.Li</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://coolqi.top/2016/05/15/Process5-oomAdjSchedulingAlgorithms/">https://coolqi.top/2016/05/15/Process5-oomAdjSchedulingAlgorithms/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://coolqi.top">Coolqi`s Blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Process进程/">Process进程</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="/img/zfb.jpg"><div class="post-qr-code__desc">支付宝打赏</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="/img/wechat.jpg"><div class="post-qr-code__desc">微信打赏</div></div></div><div class="social-share"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2016/05/31/Serivce4-bindService/"><i class="fa fa-chevron-left">  </i><span>Serivce 篇 4 - bindService 流程分析</span></a></div><div class="next-post pull-right"><a href="/2016/05/10/BroadcastReceiver5-sendBroadcast/"><span>BroadcastReceiver篇 5 - sendBroadcast 流程分析</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2015 - 2019 By Coolqi.Li</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://lishuaiqi.top/">blog</a>!</div><div class="busuanzi"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.6"></script><script src="/js/fancybox.js?version=1.5.6"></script><script src="/js/sidebar.js?version=1.5.6"></script><script src="/js/copy.js?version=1.5.6"></script><script src="/js/fireworks.js?version=1.5.6"></script><script src="/js/transition.js?version=1.5.6"></script><script src="/js/scroll.js?version=1.5.6"></script><script src="/js/head.js?version=1.5.6"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="/js/search/local-search.js"></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"live2d-widget-model-hijiki"},"display":{"position":"right","width":110,"height":220},"mobile":{"show":false},"log":false});</script></body></html>