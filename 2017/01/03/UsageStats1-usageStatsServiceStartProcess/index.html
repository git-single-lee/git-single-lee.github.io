<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="UsageStats 第 1 篇 - UsageStatsService 的启动"><meta name="keywords" content="UsageStats使用状态管理"><meta name="author" content="Coolqi.Li,undefined"><meta name="copyright" content="Coolqi.Li"><title>UsageStats 第 1 篇 - UsageStatsService 的启动 | Coolqi`s Blog</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.5.6"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css?version=1.5.6"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: 'ca-pub-6845729157331145',
  enable_page_level_ads: 'true'
});
</script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?b7acef5306e54116ad8a99e8b753a92d";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#0-综述"><span class="toc-text">0 综述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-new-UsageStatsService"><span class="toc-text">1 new UsageStatsService</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-UsageStatsS-onStart"><span class="toc-text">2 UsageStatsS.onStart</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-new-H"><span class="toc-text">2.1 new H</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-new-UserActionsReceiver-监听用户状态"><span class="toc-text">2.2 new UserActionsReceiver - 监听用户状态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-UsageStatsService-postCheckIdleStates"><span class="toc-text">2.2.1 UsageStatsService.postCheckIdleStates</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-new-PackageReceiver-监听包状态"><span class="toc-text">2.3 new PackageReceiver - 监听包状态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-UsageStatsS-clearCarrierPrivilegedApps"><span class="toc-text">2.3.1 UsageStatsS.clearCarrierPrivilegedApps</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-UsageStatsS-clearAppIdleForPackage"><span class="toc-text">2.3.2 UsageStatsS.clearAppIdleForPackage</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-1-AppIdleHistory-clearUsageLocked"><span class="toc-text">2.3.2.1 AppIdleHistory.clearUsageLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-2-AppIdleHistory-getUserHistoryLocked"><span class="toc-text">2.3.2.2 AppIdleHistory.getUserHistoryLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-3-AppIdleHistory-readAppIdleTimesLocked"><span class="toc-text">2.3.2.3 AppIdleHistory.readAppIdleTimesLocked</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-new-DeviceStateReceiver-监听设备状态"><span class="toc-text">2.4 new DeviceStateReceiver - 监听设备状态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-1-UsageStatsS-setChargingState-充电状态变化"><span class="toc-text">2.4.1 UsageStatsS.setChargingState - 充电状态变化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1-1-UsageStatsS-postParoleStateChanged"><span class="toc-text">2.4.1.1 UsageStatsS.postParoleStateChanged</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-2-UsageStatsS-onDeviceIdleModeChanged-doze-状态变化"><span class="toc-text">2.4.2 UsageStatsS.onDeviceIdleModeChanged - doze 状态变化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2-1-UsageStatsS-checkAndGetTimeLocked"><span class="toc-text">2.4.2.1 UsageStatsS.checkAndGetTimeLocked</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-UsageStatsS-cleanUpRemovedUsersLocked-删除被移除的-User-使用数据"><span class="toc-text">2.5 UsageStatsS.cleanUpRemovedUsersLocked - 删除被移除的 User 使用数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-new-AppIdleHistory-管理-App-Idle-信息"><span class="toc-text">2.6 new AppIdleHistory - 管理 App Idle 信息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-1-AppIdleHistory-readScreenOnTimeLocked"><span class="toc-text">2.6.1 AppIdleHistory.readScreenOnTimeLocked</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7-publish-LocalService"><span class="toc-text">2.7 publish LocalService</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-8-publish-BinderService"><span class="toc-text">2.8 publish BinderService</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-UsageStatsS-onBootPhase"><span class="toc-text">3 UsageStatsS.onBootPhase</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-new-SettingsObserver-监听数据库变化"><span class="toc-text">3.1 new SettingsObserver - 监听数据库变化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1-SettingsObserver-registerObserver"><span class="toc-text">3.1.1 SettingsObserver.registerObserver</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2-SettingsObserver-onChange"><span class="toc-text">3.1.2 SettingsObserver.onChange</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-3-SettingsObserver-updateSettings"><span class="toc-text">3.1.3 SettingsObserver.updateSettings</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-3-1-AppIdleHistory-setThresholds"><span class="toc-text">3.1.3.1 AppIdleHistory.setThresholds</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-register-DisplayListener-监听屏幕状态"><span class="toc-text">3.2 register DisplayListener - 监听屏幕状态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-AppIdleHistory-updateDisplayLocked"><span class="toc-text">3.2.1 AppIdleHistory.updateDisplayLocked</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-UsageStatsS-postOneTimeCheckIdleStates"><span class="toc-text">3.4 UsageStatsS.postOneTimeCheckIdleStates</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Coolqi.Li</div><div class="author-info__description text-center">“Hi，我是李帅奇，Android 开发工程师，TeamLeader，熬夜星人，一个努力赚钱，积极向上的好人。”</div><div class="follow-button"><a href="https://github.com/single-li">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">86</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">21</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">26</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="https://developer.android.google.cn/">AndroidDeveloper</a><a class="author-info-links__name text-center" href="http://www.android-studio.org/">AndroidStudio</a><a class="author-info-links__name text-center" href="https://www.jianshu.com/u/123a20a96441">简书</a><a class="author-info-links__name text-center" href="https://weibo.com/coolqiLi">微博</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://ws1.sinaimg.cn/large/8700af19ly1fvpabr30o6j22yo1o0q7i.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Coolqi`s Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/about">About</a></span></div><div id="post-info"><div id="post-title">UsageStats 第 1 篇 - UsageStatsService 的启动</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-01-03</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/AndroidFramework源码分析/">AndroidFramework源码分析</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/AndroidFramework源码分析/UsageStats使用状态管理/">UsageStats使用状态管理</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">5.6k</span><span class="post-meta__separator">|</span><span>阅读时长: 26 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>[toc]</p>
<p>基于 Android7.1.1 源码分析 UsageStatsService 的架构和原理！</p>
<h1 id="0-综述"><a href="#0-综述" class="headerlink" title="0 综述"></a>0 综述</h1><p>启动 UsageStatsService 服务，是从 SystemServer.startCoreServices 开始！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startCoreServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mSystemServiceManager.startService(BatteryService.class);</span><br><span class="line"></span><br><span class="line">    mSystemServiceManager.startService(UsageStatsService.class);</span><br><span class="line">    mActivityManagerService.setUsageStatsManager(</span><br><span class="line">            LocalServices.getService(UsageStatsManagerInternal.class));</span><br><span class="line"></span><br><span class="line">    mWebViewUpdateService = mSystemServiceManager.startService(WebViewUpdateService.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="1-new-UsageStatsService"><a href="#1-new-UsageStatsService" class="headerlink" title="1 new UsageStatsService"></a>1 new UsageStatsService</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UsageStatsService</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>UsageStatsService 的构造器很简单，没有过多的数据！</p>
<h1 id="2-UsageStatsS-onStart"><a href="#2-UsageStatsS-onStart" class="headerlink" title="2 UsageStatsS.onStart"></a>2 UsageStatsS.onStart</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】获得一些重要的服务管理对象！</span></span><br><span class="line">    mAppOps = (AppOpsManager) getContext().getSystemService(Context.APP_OPS_SERVICE);</span><br><span class="line">    mUserManager = (UserManager) getContext().getSystemService(Context.USER_SERVICE);</span><br><span class="line">    mPackageManager = getContext().getPackageManager();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【*2.1】创建 H 消息处理 Handler！</span></span><br><span class="line">    mHandler = <span class="keyword">new</span> H(BackgroundThread.get().getLooper());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】创建数据目录</span></span><br><span class="line">    File systemDataDir = <span class="keyword">new</span> File(Environment.getDataDirectory(), <span class="string">"system"</span>);</span><br><span class="line">    mUsageStatsDir = <span class="keyword">new</span> File(systemDataDir, <span class="string">"usagestats"</span>);</span><br><span class="line">    mUsageStatsDir.mkdirs();</span><br><span class="line">    <span class="keyword">if</span> (!mUsageStatsDir.exists()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Usage stats directory does not exist: "</span></span><br><span class="line">                + mUsageStatsDir.getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【*2.2】动态注册一个广播接收者：UserActionsReceiver</span></span><br><span class="line">    <span class="comment">// 监听 Intent.ACTION_USER_STARTED 和 Intent.ACTION_USER_REMOVED 广播；</span></span><br><span class="line">    IntentFilter filter = <span class="keyword">new</span> IntentFilter(Intent.ACTION_USER_REMOVED);</span><br><span class="line">    filter.addAction(Intent.ACTION_USER_STARTED);</span><br><span class="line">    getContext().registerReceiverAsUser(<span class="keyword">new</span> UserActionsReceiver(), UserHandle.ALL, filter,</span><br><span class="line">            <span class="keyword">null</span>, mHandler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2.3】动态注册一个广播接收者：PackageReceiver</span></span><br><span class="line">    <span class="comment">// 监听 Intent.ACTION_PACKAGE_ADDED，Intent.ACTION_PACKAGE_REMOVED 和 Intent.ACTION_PACKAGE_CHANGED 广播；</span></span><br><span class="line">    IntentFilter packageFilter = <span class="keyword">new</span> IntentFilter();</span><br><span class="line">    packageFilter.addAction(Intent.ACTION_PACKAGE_ADDED);</span><br><span class="line">    packageFilter.addAction(Intent.ACTION_PACKAGE_CHANGED);</span><br><span class="line">    packageFilter.addAction(Intent.ACTION_PACKAGE_REMOVED);</span><br><span class="line">    packageFilter.addDataScheme(<span class="string">"package"</span>);</span><br><span class="line"></span><br><span class="line">    getContext().registerReceiverAsUser(<span class="keyword">new</span> PackageReceiver(), UserHandle.ALL, packageFilter,</span><br><span class="line">            <span class="keyword">null</span>, mHandler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【*2.4】通过系统属性 config_enableAutoPowerModes 值来判断是否支持 app idle，注意 doze 模式也是通过这个值判断的</span></span><br><span class="line">    <span class="comment">// 如果支持，创建一个动态注册的接收者：DeviceStateReceiver，用于接收 ACTION_BATTERY_CHANGED</span></span><br><span class="line">    <span class="comment">// ACTION_DISCHARGING，ACTION_DEVICE_IDLE_MODE_CHANGED（doze 模式的广播），监听设备状态！</span></span><br><span class="line">    mAppIdleEnabled = getContext().getResources().getBoolean(</span><br><span class="line">            com.android.internal.R.bool.config_enableAutoPowerModes);</span><br><span class="line">    <span class="keyword">if</span> (mAppIdleEnabled) &#123;</span><br><span class="line">        IntentFilter deviceStates = <span class="keyword">new</span> IntentFilter(Intent.ACTION_BATTERY_CHANGED);</span><br><span class="line">        deviceStates.addAction(BatteryManager.ACTION_DISCHARGING);</span><br><span class="line">        deviceStates.addAction(PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED);</span><br><span class="line">        getContext().registerReceiver(<span class="keyword">new</span> DeviceStateReceiver(), deviceStates);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="comment">//【*2.5】清楚被移除的用户信息！</span></span><br><span class="line">        cleanUpRemovedUsersLocked();</span><br><span class="line">        <span class="comment">//【*2.6】创建一个 AppIdleHistory 对象，用于加载和保存 app idle 的历史信息！</span></span><br><span class="line">        mAppIdleHistory = <span class="keyword">new</span> AppIdleHistory(SystemClock.elapsedRealtime());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【3】记录此时的系统时间到 mSystemTimeSnapshot，距离开始的时间间隔到 mRealTimeSnapshot</span></span><br><span class="line">    <span class="comment">// 后续时间检查时会用到！</span></span><br><span class="line">    mRealTimeSnapshot = SystemClock.elapsedRealtime();</span><br><span class="line">    mSystemTimeSnapshot = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【*2.7】注册 LocalService 服务对象，方便进程内部通信</span></span><br><span class="line">    <span class="comment">// 同时将自身注册到 ServiceManager 中，用于跨进程通信！</span></span><br><span class="line">    publishLocalService(UsageStatsManagerInternal.class, <span class="keyword">new</span> LocalService());</span><br><span class="line">    publishBinderService(Context.USAGE_STATS_SERVICE, <span class="keyword">new</span> BinderService());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续分析;</p>
<h2 id="2-1-new-H"><a href="#2-1-new-H" class="headerlink" title="2.1 new H"></a>2.1 new H</h2><p>创建了一个 Handler 对，处理 UsageStatsService 中的一些重要的消息，下面我们先开看看有哪些消息！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">H</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">H</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(looper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="keyword">case</span> MSG_REPORT_EVENT: <span class="comment">//【1】处理其他进程传递的 UsageEvents；</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MSG_FLUSH_TO_DISK: <span class="comment">//【2】处理其他进程传递的 UsageEvents 时间；</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MSG_REMOVE_USER: <span class="comment">//【3】移除某个 user；</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MSG_INFORM_LISTENERS: <span class="comment">//【4】</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MSG_FORCE_IDLE_STATE: <span class="comment">//【5】设置应用进入 idle 状态；</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MSG_CHECK_IDLE_STATES:  <span class="comment">//【6】每隔一段时间检查 idle 状态；</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MSG_ONE_TIME_CHECK_IDLE_STATES: <span class="comment">//【7】只检查一次 idle 状态；</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MSG_CHECK_PAROLE_TIMEOUT: <span class="comment">//【8】</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MSG_PAROLE_END_TIMEOUT: <span class="comment">//【9】</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MSG_REPORT_CONTENT_PROVIDER_USAGE: <span class="comment">//【10】记录 content provider 的使用；</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MSG_PAROLE_STATE_CHANGED: <span class="comment">//【11】充电状态变化；</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在启动的过程中也会发送一些 MSG 给 H 进行处理，对于消息的处理，我们放在第四节分析！</p>
<h2 id="2-2-new-UserActionsReceiver-监听用户状态"><a href="#2-2-new-UserActionsReceiver-监听用户状态" class="headerlink" title="2.2 new UserActionsReceiver - 监听用户状态"></a>2.2 new UserActionsReceiver - 监听用户状态</h2><p>UserActionsReceiver 接收者用于监听 User 相关的广播！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">UserActionsReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> userId = intent.getIntExtra(Intent.EXTRA_USER_HANDLE, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">final</span> String action = intent.getAction();</span><br><span class="line">        <span class="keyword">if</span> (Intent.ACTION_USER_REMOVED.equals(action)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (userId &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//【1】如果是用户被移除的广播，发送 MSG_REMOVE_USER 消息给 H！</span></span><br><span class="line">                mHandler.obtainMessage(MSG_REMOVE_USER, userId, <span class="number">0</span>).sendToTarget();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Intent.ACTION_USER_STARTED.equals(action)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (userId &gt;=<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//【*2.2.1】如果是用户被启动的广播，调用 postCheckIdleStates 方法，检查 idle 状态信息！</span></span><br><span class="line">                postCheckIdleStates(userId);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-2-1-UsageStatsService-postCheckIdleStates"><a href="#2-2-1-UsageStatsService-postCheckIdleStates" class="headerlink" title="2.2.1 UsageStatsService.postCheckIdleStates"></a>2.2.1 UsageStatsService.postCheckIdleStates</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postCheckIdleStates</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    mHandler.sendMessage(mHandler.obtainMessage(MSG_CHECK_IDLE_STATES, userId, <span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是用户被启动的广播，调用 postCheckIdleStates 方法，发送 MSG_CHECK_IDLE_STATES 消息给 H，检查 idle 状态信息！</p>
<h2 id="2-3-new-PackageReceiver-监听包状态"><a href="#2-3-new-PackageReceiver-监听包状态" class="headerlink" title="2.3 new PackageReceiver - 监听包状态"></a>2.3 new PackageReceiver - 监听包状态</h2><p>PackageReceiver 接收者用于监听 package 相关的广播！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">PackageReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String action = intent.getAction();</span><br><span class="line">        <span class="keyword">if</span> (Intent.ACTION_PACKAGE_ADDED.equals(action)</span><br><span class="line">                || Intent.ACTION_PACKAGE_CHANGED.equals(action)) &#123;</span><br><span class="line">            <span class="comment">//【*2.3.1】清除运营商特权应用程序列表！</span></span><br><span class="line">            clearCarrierPrivilegedApps();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((Intent.ACTION_PACKAGE_REMOVED.equals(action) ||</span><br><span class="line">                Intent.ACTION_PACKAGE_ADDED.equals(action))</span><br><span class="line">                &amp;&amp; !intent.getBooleanExtra(Intent.EXTRA_REPLACING, <span class="keyword">false</span>)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【*2.3.2】清楚 package 的 idle 状态</span></span><br><span class="line">            clearAppIdleForPackage(intent.getData().getSchemeSpecificPart(),</span><br><span class="line">                    getSendingUserId());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果接收到的广播是：Intent.ACTION_PACKAGE_ADDED 或者 Intent.ACTION_PACKAGE_CHANGED，那就调用 clearCarrierPrivilegedApps 方法，清除运营商特权应用程序列表了；</p>
<p>如果接收到的广播是：Intent.ACTION_PACKAGE_REMOVED(移除应用) 或者 Intent.ACTION_PACKAGE_ADDED，且 Intent.EXTRA_REPLACING 为 false  (新安装的应用)，那就会清楚 package 的 idle 状态！</p>
<h3 id="2-3-1-UsageStatsS-clearCarrierPrivilegedApps"><a href="#2-3-1-UsageStatsS-clearCarrierPrivilegedApps" class="headerlink" title="2.3.1 UsageStatsS.clearCarrierPrivilegedApps"></a>2.3.1 UsageStatsS.clearCarrierPrivilegedApps</h3><p>清除运营商特权应用程序列表!<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearCarrierPrivilegedApps</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">        Slog.i(TAG, <span class="string">"Clearing carrier privileged apps list"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        mHaveCarrierPrivilegedApps = <span class="keyword">false</span>;</span><br><span class="line">        mCarrierPrivilegedApps = <span class="keyword">null</span>; <span class="comment">// Need to be refetched.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里涉及到 2 个变量：</p>
<ul>
<li>mHaveCarrierPrivilegedApps 表示是否持有运营商特权应用程序；</li>
<li>mCarrierPrivilegedApps 是一个 list，保存了运营商特权应用程序；</li>
</ul>
<p>当然了，有删除也就有添加的方法 fetchCarrierPrivilegedAppsLocked：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fetchCarrierPrivilegedAppsLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用了 TelephonyManager 的方法获得运营商特权应用程序列表！</span></span><br><span class="line">    <span class="comment">// 同时设置 mHaveCarrierPrivilegedApps 为 true！</span></span><br><span class="line">    TelephonyManager telephonyManager =</span><br><span class="line">            getContext().getSystemService(TelephonyManager.class);</span><br><span class="line">    mCarrierPrivilegedApps = telephonyManager.getPackagesWithCarrierPrivileges();</span><br><span class="line">    mHaveCarrierPrivilegedApps = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">        Slog.d(TAG, <span class="string">"apps with carrier privilege "</span> + mCarrierPrivilegedApps);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至于运营商特权应用程序列表相关内容，我们后续在看！</p>
<h3 id="2-3-2-UsageStatsS-clearAppIdleForPackage"><a href="#2-3-2-UsageStatsS-clearAppIdleForPackage" class="headerlink" title="2.3.2 UsageStatsS.clearAppIdleForPackage"></a>2.3.2 UsageStatsS.clearAppIdleForPackage</h3><p>清楚 package 的 idle 状态：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearAppIdleForPackage</span><span class="params">(String packageName, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="comment">//【2.3.2.1】调用 AppIdleHistory.clearUsageLocked 方法！</span></span><br><span class="line">        mAppIdleHistory.clearUsageLocked(packageName, userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，调用的是 AppIdleHistory.clearUsageLocked 方法！</p>
<h4 id="2-3-2-1-AppIdleHistory-clearUsageLocked"><a href="#2-3-2-1-AppIdleHistory-clearUsageLocked" class="headerlink" title="2.3.2.1 AppIdleHistory.clearUsageLocked"></a>2.3.2.1 AppIdleHistory.clearUsageLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearUsageLocked</span><span class="params">(String packageName, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【2.3.2.2】获得指定 userId 下的所有应用的历史信息，然后从中移除 packageName 的信息！</span></span><br><span class="line">    ArrayMap&lt;String, PackageHistory&gt; userHistory = getUserHistoryLocked(userId);</span><br><span class="line">    userHistory.remove(packageName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-3-2-2-AppIdleHistory-getUserHistoryLocked"><a href="#2-3-2-2-AppIdleHistory-getUserHistoryLocked" class="headerlink" title="2.3.2.2 AppIdleHistory.getUserHistoryLocked"></a>2.3.2.2 AppIdleHistory.getUserHistoryLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ArrayMap&lt;String, PackageHistory&gt; <span class="title">getUserHistoryLocked</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】从 mIdleHistory 中查找 userId 的数据，如果 userHistory 为 null。就从本地数据恢复！</span></span><br><span class="line">    ArrayMap&lt;String, PackageHistory&gt; userHistory = mIdleHistory.get(userId);</span><br><span class="line">    <span class="keyword">if</span> (userHistory == <span class="keyword">null</span>) &#123;</span><br><span class="line">        userHistory = <span class="keyword">new</span> ArrayMap&lt;&gt;();</span><br><span class="line">        mIdleHistory.put(userId, userHistory);</span><br><span class="line">        <span class="comment">//【2.3.2.3】尝试从本地持久化文件中读取数据；</span></span><br><span class="line">        readAppIdleTimesLocked(userId, userHistory);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【2】返回！</span></span><br><span class="line">    <span class="keyword">return</span> userHistory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AppIdleHistory 内部有一个 mIdleHistory 集合，用于保存每个 userId 下的所有 package 的空闲历史信息！</p>
<h4 id="2-3-2-3-AppIdleHistory-readAppIdleTimesLocked"><a href="#2-3-2-3-AppIdleHistory-readAppIdleTimesLocked" class="headerlink" title="2.3.2.3 AppIdleHistory.readAppIdleTimesLocked"></a>2.3.2.3 AppIdleHistory.readAppIdleTimesLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readAppIdleTimesLocked</span><span class="params">(<span class="keyword">int</span> userId, ArrayMap&lt;String, PackageHistory&gt; userHistory)</span> </span>&#123;</span><br><span class="line">    FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//【1】准备读取 /data/system/users/&lt;userId&gt;/app_idle_stats.xml 文件</span></span><br><span class="line">        AtomicFile appIdleFile = <span class="keyword">new</span> AtomicFile(getUserFile(userId));</span><br><span class="line">        fis = appIdleFile.openRead();</span><br><span class="line">        XmlPullParser parser = Xml.newPullParser();</span><br><span class="line">        parser.setInput(fis, StandardCharsets.UTF_8.name());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> type;</span><br><span class="line">        <span class="keyword">while</span> ((type = parser.next()) != XmlPullParser.START_TAG</span><br><span class="line">                &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (type != XmlPullParser.START_TAG) &#123;</span><br><span class="line">            Slog.e(TAG, <span class="string">"Unable to read app idle file for user "</span> + userId);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!parser.getName().equals(TAG_PACKAGES)) &#123; <span class="comment">// packages 标签</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> ((type = parser.next()) != XmlPullParser.END_DOCUMENT) &#123;</span><br><span class="line">            <span class="keyword">if</span> (type == XmlPullParser.START_TAG) &#123;</span><br><span class="line">                <span class="keyword">final</span> String name = parser.getName();</span><br><span class="line">                <span class="comment">//【2】解析 package 标签和其属性！</span></span><br><span class="line">                <span class="keyword">if</span> (name.equals(TAG_PACKAGE)) &#123; <span class="comment">// 解析 “package” 标签</span></span><br><span class="line">                    <span class="keyword">final</span> String packageName = parser.getAttributeValue(<span class="keyword">null</span>, ATTR_NAME);  <span class="comment">// 解析 “name” 属性</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//【3】创建 PackageHistory 对象，封装解析到的信息；</span></span><br><span class="line">                    PackageHistory packageHistory = <span class="keyword">new</span> PackageHistory();</span><br><span class="line">                    </span><br><span class="line">                    packageHistory.lastUsedElapsedTime =   <span class="comment">// 解析 “screenIdleTime” 属性</span></span><br><span class="line">                            Long.parseLong(parser.getAttributeValue(<span class="keyword">null</span>, ATTR_ELAPSED_IDLE));</span><br><span class="line">                   </span><br><span class="line">                    packageHistory.lastUsedScreenTime =    <span class="comment">// 解析 “elapsedIdleTime” 属性</span></span><br><span class="line">                            Long.parseLong(parser.getAttributeValue(<span class="keyword">null</span>, ATTR_SCREEN_IDLE));</span><br><span class="line">                    <span class="comment">//【4】添加到 userHistory 中，最后返回！</span></span><br><span class="line">                    userHistory.put(packageName, packageHistory);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException | XmlPullParserException e) &#123;</span><br><span class="line">        Slog.e(TAG, <span class="string">"Unable to read app idle file for user "</span> + userId);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        IoUtils.closeQuietly(fis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看看 /data/system/users/0/app_idle_stats.xml 文件中的主要内容：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">'1.0'</span> encoding=<span class="string">'utf-8'</span> standalone=<span class="string">'yes'</span> ?&gt;</span><br><span class="line">&lt;packages&gt;</span><br><span class="line">    &lt;<span class="keyword">package</span> name=<span class="string">"com.github.shadowsocks"</span> elapsedIdleTime=<span class="string">"6836535861"</span> screenIdleTime=<span class="string">"2173999944"</span> /&gt;</span><br><span class="line">&lt;/packages&gt;</span><br></pre></td></tr></table></figure></p>
<p>getUserFile 方法返回的是：<code>/data/system/users/&lt;userId&gt;/app_idle_stats.xml</code> 文件对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> String APP_IDLE_FILENAME = <span class="string">"app_idle_stats.xml"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> File <span class="title">getUserFile</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> File(<span class="keyword">new</span> File(<span class="keyword">new</span> File(mStorageDir, <span class="string">"users"</span>),</span><br><span class="line">            Integer.toString(userId)), APP_IDLE_FILENAME);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>#####2.3.2.3.1 new PackageHistory<br>创建 PackageHistory 对象！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PackageHistory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">byte</span>[] recent = <span class="keyword">new</span> <span class="keyword">byte</span>[HISTORY_SIZE];</span><br><span class="line">    <span class="keyword">long</span> lastUsedElapsedTime;</span><br><span class="line">    <span class="keyword">long</span> lastUsedScreenTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-4-new-DeviceStateReceiver-监听设备状态"><a href="#2-4-new-DeviceStateReceiver-监听设备状态" class="headerlink" title="2.4 new DeviceStateReceiver - 监听设备状态"></a>2.4 new DeviceStateReceiver - 监听设备状态</h2><p>DeviceStateReceiver 监听设备状态的变化！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">DeviceStateReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String action = intent.getAction();</span><br><span class="line">        <span class="keyword">if</span> (Intent.ACTION_BATTERY_CHANGED.equals(action)) &#123;</span><br><span class="line">            <span class="comment">//【2.4.1】设置充电状态！</span></span><br><span class="line">            setChargingState(intent.getIntExtra(<span class="string">"plugged"</span>, <span class="number">0</span>) != <span class="number">0</span>);</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED.equals(action)) &#123;</span><br><span class="line">            <span class="comment">//【2.4.2】处理 device idle (doze)模式变化！</span></span><br><span class="line">            onDeviceIdleModeChanged();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>如果广播是 Intent.ACTION_BATTERY_CHANGED，说明此时正在充电，那么会调用 setChargingState 设置充电状态；</li>
<li>如果广播是 PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED，说明此时 device idle 模式的状态发生了变化；</li>
</ul>
<h3 id="2-4-1-UsageStatsS-setChargingState-充电状态变化"><a href="#2-4-1-UsageStatsS-setChargingState-充电状态变化" class="headerlink" title="2.4.1 UsageStatsS.setChargingState - 充电状态变化"></a>2.4.1 UsageStatsS.setChargingState - 充电状态变化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setChargingState</span><span class="params">(<span class="keyword">boolean</span> charging)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCharging != charging) &#123;</span><br><span class="line">            <span class="comment">// 更新 mCharging！</span></span><br><span class="line">            mCharging = charging;</span><br><span class="line">            <span class="comment">//【2.4.1.1】调用 postParoleStateChanged 方法！</span></span><br><span class="line">            postParoleStateChanged();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mCharging 表示当前设备是否正在充电，可以看到，只有当设备在未充电和充电状态之间变化！</p>
<h4 id="2-4-1-1-UsageStatsS-postParoleStateChanged"><a href="#2-4-1-1-UsageStatsS-postParoleStateChanged" class="headerlink" title="2.4.1.1 UsageStatsS.postParoleStateChanged"></a>2.4.1.1 UsageStatsS.postParoleStateChanged</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postParoleStateChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">"Posting MSG_PAROLE_STATE_CHANGED"</span>);</span><br><span class="line">    <span class="comment">//【4.11】发送 MSG_PAROLE_STATE_CHANGED 消息给 H!</span></span><br><span class="line">    mHandler.removeMessages(MSG_PAROLE_STATE_CHANGED);</span><br><span class="line">    mHandler.sendEmptyMessage(MSG_PAROLE_STATE_CHANGED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发送 MSG_PAROLE_STATE_CHANGED 消息给 H！</p>
<h3 id="2-4-2-UsageStatsS-onDeviceIdleModeChanged-doze-状态变化"><a href="#2-4-2-UsageStatsS-onDeviceIdleModeChanged-doze-状态变化" class="headerlink" title="2.4.2 UsageStatsS.onDeviceIdleModeChanged - doze 状态变化"></a>2.4.2 UsageStatsS.onDeviceIdleModeChanged - doze 状态变化</h3><p>当 device idle (doze)模式发生了变化后，onDeviceIdleModeChanged 方法会被触发：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onDeviceIdleModeChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】调用 PowerManager.isDeviceIdleMode 方法，判断是否进入了 doze 模式！</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> deviceIdle = mPowerManager.isDeviceIdleMode();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (DEBUG) Slog.i(TAG, <span class="string">"DeviceIdleMode changed to "</span> + deviceIdle);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="comment">//【2】计算距离里上一次的应用假释时间，已经过去的时间！</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> timeSinceLastParole = checkAndGetTimeLocked() - mLastAppIdleParoledTime;</span><br><span class="line">        <span class="keyword">if</span> (!deviceIdle</span><br><span class="line">                &amp;&amp; timeSinceLastParole &gt;= mAppIdleParoleIntervalMillis) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG) Slog.i(TAG, <span class="string">"Bringing idle apps out of inactive state due to deviceIdleMode=false"</span>);</span><br><span class="line">            <span class="comment">//【2.1】如果已经退出了 device idle 模式，并且距离上一次的应用假释时间已经超过了 </span></span><br><span class="line">            <span class="comment">// mAppIdleParoleIntervalMillis，那么我们就进入假释状态！</span></span><br><span class="line">            setAppIdleParoled(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (deviceIdle) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG) Slog.i(TAG, <span class="string">"Device idle, back to prison"</span>);</span><br><span class="line">            <span class="comment">//【2.2】如果当前处于 device idle 状态，那么不允许应用假释；</span></span><br><span class="line">            setAppIdleParoled(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="2-4-2-1-UsageStatsS-checkAndGetTimeLocked"><a href="#2-4-2-1-UsageStatsS-checkAndGetTimeLocked" class="headerlink" title="2.4.2.1 UsageStatsS.checkAndGetTimeLocked"></a>2.4.2.1 UsageStatsS.checkAndGetTimeLocked</h4><p>checkAndGetTimeLocked 方法用于计算当前的时间！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">checkAndGetTimeLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】获得当前的系统时间，可以被系统设置修改；</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> actualSystemTime = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">//【2】获得自开机后，经过的时间，包括深度睡眠的时间；</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> actualRealtime = SystemClock.elapsedRealtime();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> expectedSystemTime = (actualRealtime - mRealTimeSnapshot) + mSystemTimeSnapshot;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> diffSystemTime = actualSystemTime - expectedSystemTime;</span><br><span class="line">    <span class="comment">//【3】判断时间是否有发生变化，</span></span><br><span class="line">    <span class="keyword">if</span> (Math.abs(diffSystemTime) &gt; TIME_CHANGE_THRESHOLD_MILLIS) &#123;</span><br><span class="line">        <span class="comment">// The time has changed.</span></span><br><span class="line">        Slog.i(TAG, <span class="string">"Time changed in UsageStats by "</span> + (diffSystemTime / <span class="number">1000</span>) + <span class="string">" seconds"</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> userCount = mUserState.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; userCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> UserUsageStatsService service = mUserState.valueAt(i);</span><br><span class="line">            <span class="comment">//【3.1】更新本地数据！</span></span><br><span class="line">            service.onTimeChanged(expectedSystemTime, actualSystemTime);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【3.2】记录本次的时间点到 mRealTimeSnapshot，mSystemTimeSnapshot！</span></span><br><span class="line">        mRealTimeSnapshot = actualRealtime;</span><br><span class="line">        mSystemTimeSnapshot = actualSystemTime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【4】返回当前的实际时间！</span></span><br><span class="line">    <span class="keyword">return</span> actualSystemTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 checkAndGetTimeLocked 返回的时间是  actualSystemTime 的值，也就是 System.currentTimeMillis()，这个时间值可以被系统设置修改，然后值就会发生跳变，比如联网对时，手动调时！</p>
<p>而 actualRealtime 的值为 System.elapsedRealtime 自开机后，经过的时间，包括深度睡眠的时间，这部分时间值是不会被修改；</p>
<p>如果判断时间是否有发生调时，对时情况呢？</p>
<ul>
<li>mSystemTimeSnapshot 中保存的是上一次 check 时的系统时间；</li>
<li>mRealTimeSnapshot 中保存的是上一次 check 时的自开机后，经过的时间；</li>
<li>先计算出期望的时间：<ul>
<li>本次距离开机的时间 actualRealtime - 上次距离开机的时间 mRealTimeSnapshot，这个时间差值是正常情况下的时间差值；</li>
<li>然后再加上上一次 check 时的系统时间 mSystemTimeSnapshot，如果没有发生调时的话，这个应该是理想的时间点 expectedSystemTime；</li>
<li>如果发生了调时，对时的情况，actualSystemTime 一定是会发生变化的！</li>
<li>计算 actualSystemTime 和 expectedSystemTime 的差值，如果大于 TIME_CHANGE_THRESHOLD_MILLIS，说明铁定发生了调时，对时；</li>
</ul>
</li>
</ul>
<p>如果发生上述情况，那就调用 UserUsageStatsService.onTimeChanged 更新本地持久化文件的日期！</p>
<p>对于 UsageStatsService 是如何存储应用数据，如何更新本地持久化文件的，这里我先不关注，我们只需要知道，该方法返回的时间值是实际的时间（正常，手动调时，联网对时）</p>
<h2 id="2-5-UsageStatsS-cleanUpRemovedUsersLocked-删除被移除的-User-使用数据"><a href="#2-5-UsageStatsS-cleanUpRemovedUsersLocked-删除被移除的-User-使用数据" class="headerlink" title="2.5 UsageStatsS.cleanUpRemovedUsersLocked - 删除被移除的 User 使用数据"></a>2.5 UsageStatsS.cleanUpRemovedUsersLocked - 删除被移除的 User 使用数据</h2><p>删除已经被移除的 User 的使用数据！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cleanUpRemovedUsersLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】获得所有的 user 信息！</span></span><br><span class="line">    <span class="keyword">final</span> List&lt;UserInfo&gt; users = mUserManager.getUsers(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (users == <span class="keyword">null</span> || users.size() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"There can't be no users"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【2】如果 /data/system/usagestats 目录下没有任何文件，不处理！</span></span><br><span class="line">    ArraySet&lt;String&gt; toDelete = <span class="keyword">new</span> ArraySet&lt;&gt;();</span><br><span class="line">    String[] fileNames = mUsageStatsDir.list();</span><br><span class="line">    <span class="keyword">if</span> (fileNames == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// No users to delete.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【3】去除那些存在的 user 的使用信息！</span></span><br><span class="line">    toDelete.addAll(Arrays.asList(fileNames));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> userCount = users.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; userCount; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> UserInfo userInfo = users.get(i);</span><br><span class="line">        toDelete.remove(Integer.toString(userInfo.id));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【4】移除剩下的没用的 user 信息；</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> deleteCount = toDelete.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; deleteCount; i++) &#123;</span><br><span class="line">        <span class="comment">// 递归删除！</span></span><br><span class="line">        deleteRecursively(<span class="keyword">new</span> File(mUsageStatsDir, toDelete.valueAt(i)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-6-new-AppIdleHistory-管理-App-Idle-信息"><a href="#2-6-new-AppIdleHistory-管理-App-Idle-信息" class="headerlink" title="2.6 new AppIdleHistory - 管理 App Idle 信息"></a>2.6 new AppIdleHistory - 管理 App Idle 信息</h2><p>创建一个 AppIdleHistory 对象，保存 app idle 相关的状态和信息！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">AppIdleHistory(<span class="keyword">long</span> elapsedRealtime) &#123;</span><br><span class="line">    <span class="keyword">this</span>(Environment.getDataSystemDirectory(), elapsedRealtime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@VisibleForTesting</span></span><br><span class="line">AppIdleHistory(File storageDir, <span class="keyword">long</span> elapsedRealtime) &#123;</span><br><span class="line">    <span class="comment">//【1】可以看到，初始化时候 mElapsedSnapshot 等于 mScreenOnSnapshot</span></span><br><span class="line">    mElapsedSnapshot = elapsedRealtime;</span><br><span class="line">    mScreenOnSnapshot = elapsedRealtime;</span><br><span class="line">    mStorageDir = storageDir;</span><br><span class="line">    <span class="comment">//【×2.6.1】读取亮屏时间信息！</span></span><br><span class="line">    readScreenOnTimeLocked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mStorageDir 指向 /data/system 目录！</p>
<h3 id="2-6-1-AppIdleHistory-readScreenOnTimeLocked"><a href="#2-6-1-AppIdleHistory-readScreenOnTimeLocked" class="headerlink" title="2.6.1 AppIdleHistory.readScreenOnTimeLocked"></a>2.6.1 AppIdleHistory.readScreenOnTimeLocked</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readScreenOnTimeLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】获得 /data/system/screen_on_time 文件</span></span><br><span class="line">    File screenOnTimeFile = getScreenOnTimeFile();</span><br><span class="line">    <span class="keyword">if</span> (screenOnTimeFile.exists()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(screenOnTimeFile));</span><br><span class="line">            <span class="comment">//【2】读取 mScreenOnDuration 和 mElapsedDuration 时间值！</span></span><br><span class="line">            mScreenOnDuration  = Long.parseLong(reader.readLine());</span><br><span class="line">            mElapsedDuration = Long.parseLong(reader.readLine());</span><br><span class="line">            reader.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | NumberFormatException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        writeScreenOnTimeLocked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个流程很简单，不多说了！</p>
<h2 id="2-7-publish-LocalService"><a href="#2-7-publish-LocalService" class="headerlink" title="2.7 publish LocalService"></a>2.7 publish LocalService</h2><p>LocalService 用于系统进程中服务间的相互通信，本地服务实现主要由ActivityManagerService 使用。ActivityManagerService 调用这些方法的时会持有自身的锁，不应该在这些方法中执行任何 IO 工作或其他长时间运行的任务。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalService</span> <span class="keyword">extends</span> <span class="title">UsageStatsManagerInternal</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】向 UsageStatsService 发送应用的使用信息 UsageEvents；</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reportEvent</span><span class="params">(ComponentName component, <span class="keyword">int</span> userId, <span class="keyword">int</span> eventType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (component == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Event reported without a component name"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        UsageEvents.Event event = <span class="keyword">new</span> UsageEvents.Event();</span><br><span class="line">        event.mPackage = component.getPackageName();</span><br><span class="line">        event.mClass = component.getClassName();</span><br><span class="line">        <span class="comment">// This will later be converted to system time.</span></span><br><span class="line">        event.mTimeStamp = SystemClock.elapsedRealtime();</span><br><span class="line">        event.mEventType = eventType;</span><br><span class="line">        <span class="comment">//【1.1】发送 MSG_REPORT_EVENT 给 H；</span></span><br><span class="line">        mHandler.obtainMessage(MSG_REPORT_EVENT, userId, <span class="number">0</span>, event).sendToTarget();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reportEvent</span><span class="params">(String packageName, <span class="keyword">int</span> userId, <span class="keyword">int</span> eventType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (packageName == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Event reported without a package name"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        UsageEvents.Event event = <span class="keyword">new</span> UsageEvents.Event();</span><br><span class="line">        event.mPackage = packageName;</span><br><span class="line">        event.mTimeStamp = SystemClock.elapsedRealtime();</span><br><span class="line">        event.mEventType = eventType;</span><br><span class="line">        mHandler.obtainMessage(MSG_REPORT_EVENT, userId, <span class="number">0</span>, event).sendToTarget();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】向 UsageStatsService 发送配置的使用信息 UsageEvents；</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reportConfigurationChange</span><span class="params">(Configuration config, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (config == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Configuration event reported with a null config"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        UsageEvents.Event event = <span class="keyword">new</span> UsageEvents.Event();</span><br><span class="line">        event.mPackage = <span class="string">"android"</span>;</span><br><span class="line">        event.mTimeStamp = SystemClock.elapsedRealtime();</span><br><span class="line">        event.mEventType = UsageEvents.Event.CONFIGURATION_CHANGE;</span><br><span class="line">        event.mConfiguration = <span class="keyword">new</span> Configuration(config);</span><br><span class="line">        <span class="comment">//【2.1】发送 MSG_REPORT_EVENT 给 H；</span></span><br><span class="line">        mHandler.obtainMessage(MSG_REPORT_EVENT, userId, <span class="number">0</span>, event).sendToTarget();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【3】向 UsageStatsService 发送 Shortcut 的使用信息 UsageEvents；</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reportShortcutUsage</span><span class="params">(String packageName, String shortcutId, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (packageName == <span class="keyword">null</span> || shortcutId == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Event reported without a package name or a shortcut ID"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        UsageEvents.Event event = <span class="keyword">new</span> UsageEvents.Event();</span><br><span class="line">        event.mPackage = packageName.intern();</span><br><span class="line">        event.mShortcutId = shortcutId.intern();</span><br><span class="line">        event.mTimeStamp = SystemClock.elapsedRealtime();</span><br><span class="line">        event.mEventType = Event.SHORTCUT_INVOCATION;</span><br><span class="line">        <span class="comment">//【3.1】发送 MSG_REPORT_EVENT 给 H；</span></span><br><span class="line">        mHandler.obtainMessage(MSG_REPORT_EVENT, userId, <span class="number">0</span>, event).sendToTarget();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【4】向 UsageStatsService 发送 ContentProvider 的使用信息；</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reportContentProviderUsage</span><span class="params">(String name, String packageName, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        SomeArgs args = SomeArgs.obtain();</span><br><span class="line">        args.arg1 = name;</span><br><span class="line">        args.arg2 = packageName;</span><br><span class="line">        args.arg3 = userId;</span><br><span class="line">        <span class="comment">//【4.1】发送 MSG_REPORT_CONTENT_PROVIDER_USAGE 给 H；</span></span><br><span class="line">        mHandler.obtainMessage(MSG_REPORT_CONTENT_PROVIDER_USAGE, args)</span><br><span class="line">                .sendToTarget();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【5】判断应用是否处于 idle 状态；</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAppIdle</span><span class="params">(String packageName, <span class="keyword">int</span> uidForAppId, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UsageStatsService.<span class="keyword">this</span>.isAppIdleFiltered(packageName, uidForAppId, userId,</span><br><span class="line">                SystemClock.elapsedRealtime());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【6】获得指定 userId 下的处于 idle 状态的 uid；</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getIdleUidsForUser(<span class="keyword">int</span> userId) &#123;</span><br><span class="line">        <span class="keyword">return</span> UsageStatsService.<span class="keyword">this</span>.getIdleUidsForUser(userId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【7】获得指定 userId 下的处于 idle 状态的 uid；</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAppIdleParoleOn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isParoledOrCharging();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【8】关机时调用！</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepareShutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【9】添加和移除 app idle 状态改变监听器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAppIdleStateChangeListener</span><span class="params">(AppIdleStateChangeListener listener)</span> </span>&#123;</span><br><span class="line">        UsageStatsService.<span class="keyword">this</span>.addListener(listener);</span><br><span class="line">        listener.onParoleStateChanged(isAppIdleParoleOn());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeAppIdleStateChangeListener</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            AppIdleStateChangeListener listener)</span> </span>&#123;</span><br><span class="line">        UsageStatsService.<span class="keyword">this</span>.removeListener(listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] getBackupPayload(<span class="keyword">int</span> user, String key) &#123;</span><br><span class="line">        <span class="comment">// Check to ensure that only user 0's data is b/r for now</span></span><br><span class="line">        <span class="keyword">if</span> (user == UserHandle.USER_SYSTEM) &#123;</span><br><span class="line">            <span class="keyword">final</span> UserUsageStatsService userStats =</span><br><span class="line">                    getUserDataAndInitializeIfNeededLocked(user, checkAndGetTimeLocked());</span><br><span class="line">            <span class="keyword">return</span> userStats.getBackupPayload(key);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">applyRestoredPayload</span><span class="params">(<span class="keyword">int</span> user, String key, <span class="keyword">byte</span>[] payload)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (user == UserHandle.USER_SYSTEM) &#123;</span><br><span class="line">            <span class="keyword">final</span> UserUsageStatsService userStats =</span><br><span class="line">                    getUserDataAndInitializeIfNeededLocked(user, checkAndGetTimeLocked());</span><br><span class="line">            userStats.applyRestoredPayload(key, payload);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>关于 LocalService 中的方法的触发，我们后面再看！</p>
<h2 id="2-8-publish-BinderService"><a href="#2-8-publish-BinderService" class="headerlink" title="2.8 publish BinderService"></a>2.8 publish BinderService</h2><p>BinderService 的所用是跨进程通信！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BinderService</span> <span class="keyword">extends</span> <span class="title">IUsageStatsManager</span>.<span class="title">Stub</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】判断调用者是否有 PACKAGE_USAGE_STATS 相关的权限！</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">hasPermission</span><span class="params">(String callingPackage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> callingUid = Binder.getCallingUid();</span><br><span class="line">        <span class="keyword">if</span> (callingUid == Process.SYSTEM_UID) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> mode = mAppOps.checkOp(AppOpsManager.OP_GET_USAGE_STATS,</span><br><span class="line">                callingUid, callingPackage);</span><br><span class="line">        <span class="keyword">if</span> (mode == AppOpsManager.MODE_DEFAULT) &#123;</span><br><span class="line">            <span class="comment">// The default behavior here is to check if PackageManager has given the app</span></span><br><span class="line">            <span class="comment">// permission.</span></span><br><span class="line">            <span class="keyword">return</span> getContext().checkCallingPermission(Manifest.permission.PACKAGE_USAGE_STATS)</span><br><span class="line">                    == PackageManager.PERMISSION_GRANTED;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mode == AppOpsManager.MODE_ALLOWED;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//【2】查询应用的使用状态！</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ParceledListSlice&lt;UsageStats&gt; <span class="title">queryUsageStats</span><span class="params">(<span class="keyword">int</span> bucketType, <span class="keyword">long</span> beginTime,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">long</span> endTime, String callingPackage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasPermission(callingPackage)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> userId = UserHandle.getCallingUserId();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> token = Binder.clearCallingIdentity();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> List&lt;UsageStats&gt; results = UsageStatsService.<span class="keyword">this</span>.queryUsageStats(</span><br><span class="line">                    userId, bucketType, beginTime, endTime);</span><br><span class="line">            <span class="keyword">if</span> (results != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ParceledListSlice&lt;&gt;(results);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Binder.restoreCallingIdentity(token);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【3】查询配置的使用状态！</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ParceledListSlice&lt;ConfigurationStats&gt; <span class="title">queryConfigurationStats</span><span class="params">(<span class="keyword">int</span> bucketType,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">long</span> beginTime, <span class="keyword">long</span> endTime, String callingPackage)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasPermission(callingPackage)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> userId = UserHandle.getCallingUserId();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> token = Binder.clearCallingIdentity();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> List&lt;ConfigurationStats&gt; results =</span><br><span class="line">                    UsageStatsService.<span class="keyword">this</span>.queryConfigurationStats(userId, bucketType,</span><br><span class="line">                            beginTime, endTime);</span><br><span class="line">            <span class="keyword">if</span> (results != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ParceledListSlice&lt;&gt;(results);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Binder.restoreCallingIdentity(token);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【4】查询应用的使用事件信息！</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UsageEvents <span class="title">queryEvents</span><span class="params">(<span class="keyword">long</span> beginTime, <span class="keyword">long</span> endTime, String callingPackage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasPermission(callingPackage)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> userId = UserHandle.getCallingUserId();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> token = Binder.clearCallingIdentity();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> UsageStatsService.<span class="keyword">this</span>.queryEvents(userId, beginTime, endTime);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Binder.restoreCallingIdentity(token);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【5】判断应用是否处于 inactive 状态！</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAppInactive</span><span class="params">(String packageName, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            userId = ActivityManagerNative.getDefault().handleIncomingUser(Binder.getCallingPid(),</span><br><span class="line">                    Binder.getCallingUid(), userId, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="string">"isAppInactive"</span>, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException re) &#123;</span><br><span class="line">            <span class="keyword">throw</span> re.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> token = Binder.clearCallingIdentity();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> UsageStatsService.<span class="keyword">this</span>.isAppIdleFilteredOrParoled(packageName, userId,</span><br><span class="line">                    SystemClock.elapsedRealtime());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Binder.restoreCallingIdentity(token);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【5】判断应用是否处于 inactive 状态！</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAppInactive</span><span class="params">(String packageName, <span class="keyword">boolean</span> idle, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> callingUid = Binder.getCallingUid();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            userId = ActivityManagerNative.getDefault().handleIncomingUser(</span><br><span class="line">                    Binder.getCallingPid(), callingUid, userId, <span class="keyword">false</span>, <span class="keyword">true</span>,</span><br><span class="line">                    <span class="string">"setAppIdle"</span>, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException re) &#123;</span><br><span class="line">            <span class="keyword">throw</span> re.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">        getContext().enforceCallingPermission(Manifest.permission.CHANGE_APP_IDLE_STATE,</span><br><span class="line">                <span class="string">"No permission to change app idle state"</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> token = Binder.clearCallingIdentity();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> appId = getAppId(packageName);</span><br><span class="line">            <span class="keyword">if</span> (appId &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">            UsageStatsService.<span class="keyword">this</span>.setAppIdle(packageName, idle, userId);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Binder.restoreCallingIdentity(token);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【6】将应用添加到 doze 模式临时白名单中！</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whitelistAppTemporarily</span><span class="params">(String packageName, <span class="keyword">long</span> duration, <span class="keyword">int</span> userId)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        StringBuilder reason = <span class="keyword">new</span> StringBuilder(<span class="number">32</span>);</span><br><span class="line">        reason.append(<span class="string">"from:"</span>);</span><br><span class="line">        UserHandle.formatUid(reason, Binder.getCallingUid());</span><br><span class="line">        mDeviceIdleController.addPowerSaveTempWhitelistApp(packageName, duration, userId,</span><br><span class="line">                reason.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【7】运营商特权应用变化！</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCarrierPrivilegedAppsChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">            Slog.i(TAG, <span class="string">"Carrier privileged apps changed"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        getContext().enforceCallingOrSelfPermission(</span><br><span class="line">                android.Manifest.permission.BIND_CARRIER_SERVICES,</span><br><span class="line">                <span class="string">"onCarrierPrivilegedAppsChanged can only be called by privileged apps."</span>);</span><br><span class="line">        UsageStatsService.<span class="keyword">this</span>.clearCarrierPrivilegedApps();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【8】用于 dumpsys！</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dump</span><span class="params">(FileDescriptor fd, PrintWriter pw, String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (getContext().checkCallingOrSelfPermission(android.Manifest.permission.DUMP)</span><br><span class="line">                != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">            pw.println(<span class="string">"Permission Denial: can't dump UsageStats from pid="</span></span><br><span class="line">                    + Binder.getCallingPid() + <span class="string">", uid="</span> + Binder.getCallingUid()</span><br><span class="line">                    + <span class="string">" without permission "</span> + android.Manifest.permission.DUMP);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        UsageStatsService.<span class="keyword">this</span>.dump(args, pw);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于 BinderService 中的方法的触发，我们后面再看！</p>
<h1 id="3-UsageStatsS-onBootPhase"><a href="#3-UsageStatsS-onBootPhase" class="headerlink" title="3 UsageStatsS.onBootPhase"></a>3 UsageStatsS.onBootPhase</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBootPhase</span><span class="params">(<span class="keyword">int</span> phase)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (phase == PHASE_SYSTEM_SERVICES_READY) &#123;</span><br><span class="line">        <span class="comment">//【*3.1】创建一个 SettingsObserver， 监听数据库变化！</span></span><br><span class="line">        SettingsObserver settingsObserver = <span class="keyword">new</span> SettingsObserver(mHandler);</span><br><span class="line">        settingsObserver.registerObserver();</span><br><span class="line">        settingsObserver.updateSettings();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【2】获得系统中的一些其他重要服务管理对象：DeviceIdleController，</span></span><br><span class="line">        <span class="comment">// BatteryStats，DisplayManager 和 PowerManager！</span></span><br><span class="line">        mAppWidgetManager = getContext().getSystemService(AppWidgetManager.class);</span><br><span class="line">        mDeviceIdleController = IDeviceIdleController.Stub.asInterface(</span><br><span class="line">                ServiceManager.getService(Context.DEVICE_IDLE_CONTROLLER));</span><br><span class="line">        mBatteryStats = IBatteryStats.Stub.asInterface(</span><br><span class="line">                ServiceManager.getService(BatteryStats.SERVICE_NAME));</span><br><span class="line">        mDisplayManager = (DisplayManager) getContext().getSystemService(</span><br><span class="line">                Context.DISPLAY_SERVICE);</span><br><span class="line">        mPowerManager = getContext().getSystemService(PowerManager.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【*3.2】注册 DisplayListener</span></span><br><span class="line">        mDisplayManager.registerDisplayListener(mDisplayListener, mHandler);</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            <span class="comment">//【*3.2.1】初始化 AppIdleHistory 的亮屏信息！</span></span><br><span class="line">            mAppIdleHistory.updateDisplayLocked(isDisplayOn(), SystemClock.elapsedRealtime());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【*3.4】mPendingOneTimeCheckIdleStates 为 true 表示正在等待查询 idle 状态！</span></span><br><span class="line">        <span class="comment">// 那么就会再次调用 postOneTimeCheckIdleStates 方法！</span></span><br><span class="line">        <span class="keyword">if</span> (mPendingOneTimeCheckIdleStates) &#123;</span><br><span class="line">            postOneTimeCheckIdleStates();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mSystemServicesReady = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (phase == PHASE_BOOT_COMPLETED) &#123;</span><br><span class="line">        <span class="comment">//【*2.4.1】初始化充电状态信息；</span></span><br><span class="line">        setChargingState(getContext().getSystemService(BatteryManager.class).isCharging());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>onBootPhase 方法会在两个阶段下调用：</p>
<ul>
<li><strong>PHASE_SYSTEM_SERVICES_READY</strong>：此时系统服务已经都启动了；</li>
<li><strong>PHASE_BOOT_COMPLETED</strong>：此时设备重启完成了；</li>
</ul>
<h2 id="3-1-new-SettingsObserver-监听数据库变化"><a href="#3-1-new-SettingsObserver-监听数据库变化" class="headerlink" title="3.1 new SettingsObserver - 监听数据库变化"></a>3.1 new SettingsObserver - 监听数据库变化</h2><p>这里会创建一个 SettingsObserver 观察者，监听数据表变化！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">SettingsObserver</span> <span class="keyword">extends</span> <span class="title">ContentObserver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> KeyValueListParser mParser = <span class="keyword">new</span> KeyValueListParser(<span class="string">','</span>);</span><br><span class="line"></span><br><span class="line">        SettingsObserver(Handler handler) &#123;</span><br><span class="line">            <span class="keyword">super</span>(handler);</span><br><span class="line">        &#125;</span><br><span class="line">        ... ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-1-1-SettingsObserver-registerObserver"><a href="#3-1-1-SettingsObserver-registerObserver" class="headerlink" title="3.1.1 SettingsObserver.registerObserver"></a>3.1.1 SettingsObserver.registerObserver</h3><p>监听的 Settings 表单是 app_idle_constants！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    getContext().getContentResolver().registerContentObserver(Settings.Global.getUriFor(</span><br><span class="line">            Settings.Global.APP_IDLE_CONSTANTS), <span class="keyword">false</span>, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-1-2-SettingsObserver-onChange"><a href="#3-1-2-SettingsObserver-onChange" class="headerlink" title="3.1.2 SettingsObserver.onChange"></a>3.1.2 SettingsObserver.onChange</h3><p>当数据库有变化后，会触发 onChange 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChange</span><span class="params">(<span class="keyword">boolean</span> selfChange)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【3.1.3】初始化数据！</span></span><br><span class="line">    updateSettings();</span><br><span class="line">    <span class="comment">//【3.4】调用 postOneTimeCheckIdleStates 方法进行一次 idle 检查！</span></span><br><span class="line">    postOneTimeCheckIdleStates();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-1-3-SettingsObserver-updateSettings"><a href="#3-1-3-SettingsObserver-updateSettings" class="headerlink" title="3.1.3 SettingsObserver.updateSettings"></a>3.1.3 SettingsObserver.updateSettings</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateSettings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mParser.setString(Settings.Global.getString(getContext().getContentResolver(),</span><br><span class="line">                        Settings.Global.APP_IDLE_CONSTANTS));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">                Slog.e(TAG, <span class="string">"Bad value for app idle settings: "</span> + e.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 值为 12 hours；</span></span><br><span class="line">            mAppIdleScreenThresholdMillis = mParser.getLong(KEY_IDLE_DURATION,</span><br><span class="line">                   COMPRESS_TIME ? ONE_MINUTE * <span class="number">4</span> : <span class="number">12</span> * <span class="number">60</span> * ONE_MINUTE);</span><br><span class="line">            <span class="comment">// 值为 48 hours；</span></span><br><span class="line">            mAppIdleWallclockThresholdMillis = mParser.getLong(KEY_WALLCLOCK_THRESHOLD,</span><br><span class="line">                    COMPRESS_TIME ? ONE_MINUTE * <span class="number">8</span> : <span class="number">2L</span> * <span class="number">24</span> * <span class="number">60</span> * ONE_MINUTE);</span><br><span class="line">            <span class="comment">// 值为 8 hours；</span></span><br><span class="line">            mCheckIdleIntervalMillis = Math.min(mAppIdleScreenThresholdMillis / <span class="number">4</span>,</span><br><span class="line">                    COMPRESS_TIME ? ONE_MINUTE : <span class="number">8</span> * <span class="number">60</span> * ONE_MINUTE);</span><br><span class="line">            <span class="comment">// 置为 24 hours；</span></span><br><span class="line">            mAppIdleParoleIntervalMillis = mParser.getLong(KEY_PAROLE_INTERVAL,</span><br><span class="line">                    COMPRESS_TIME ? ONE_MINUTE * <span class="number">10</span> : <span class="number">24</span> * <span class="number">60</span> * ONE_MINUTE);</span><br><span class="line">            <span class="comment">// 置为 10 mins；</span></span><br><span class="line">            mAppIdleParoleDurationMillis = mParser.getLong(KEY_PAROLE_DURATION,</span><br><span class="line">                    COMPRESS_TIME ? ONE_MINUTE : <span class="number">10</span> * ONE_MINUTE);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【3.1.3.1】设置阈值到 AppIdleHistory 中！</span></span><br><span class="line">            mAppIdleHistory.setThresholds(mAppIdleWallclockThresholdMillis,</span><br><span class="line">                    mAppIdleScreenThresholdMillis);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里涉及到几个重要的时间变量：</p>
<ul>
<li><strong>mAppIdleScreenThresholdMillis</strong>：12 hours，是应用是否进入 idle 状态的临界值！</li>
</ul>
<p><br></p>
<ul>
<li><strong>mAppIdleWallclockThresholdMillis</strong>：48 hours，是应用是否进入 idle 状态的临界值！</li>
</ul>
<p><br></p>
<ul>
<li><strong>mCheckIdleIntervalMillis</strong>：表示执行 check idle 操作的时间间隔，8 hours！</li>
</ul>
<p><br></p>
<ul>
<li><strong>mAppIdleParoleIntervalMillis</strong>：相邻 2 次进入假释状态的时间间隔，24 hours！</li>
</ul>
<p><br></p>
<ul>
<li><strong>mAppIdleParoleDurationMillis</strong>：假释状态的持续时间，10mins！</li>
</ul>
<p>这里的 COMPRESS_TIME 的值恒定为 false！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> COMPRESS_TIME = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>
<h4 id="3-1-3-1-AppIdleHistory-setThresholds"><a href="#3-1-3-1-AppIdleHistory-setThresholds" class="headerlink" title="3.1.3.1 AppIdleHistory.setThresholds"></a>3.1.3.1 AppIdleHistory.setThresholds</h4><p>设置阈值信息，该阈值会用于判断应用是否处于 idle 状态！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setThresholds</span><span class="params">(<span class="keyword">long</span> elapsedTimeThreshold, <span class="keyword">long</span> screenOnTimeThreshold)</span> </span>&#123;</span><br><span class="line">    mElapsedTimeThreshold = elapsedTimeThreshold;</span><br><span class="line">    mScreenOnTimeThreshold = screenOnTimeThreshold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们来解释下这两个阈值的作用：</p>
<h2 id="3-2-register-DisplayListener-监听屏幕状态"><a href="#3-2-register-DisplayListener-监听屏幕状态" class="headerlink" title="3.2 register DisplayListener - 监听屏幕状态"></a>3.2 register DisplayListener - 监听屏幕状态</h2><p>UsageStatsService 内部有一个 DisplayListener 实例：mDisplayListener，专门用于监听屏幕的状态，然后触发 AppIdleHistory 的更新！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> DisplayManager.DisplayListener mDisplayListener</span><br><span class="line">        = <span class="keyword">new</span> DisplayManager.DisplayListener() &#123;</span><br><span class="line">    ... ... ...</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDisplayChanged</span><span class="params">(<span class="keyword">int</span> displayId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (displayId == Display.DEFAULT_DISPLAY) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> displayOn = isDisplayOn();</span><br><span class="line">            <span class="keyword">synchronized</span> (UsageStatsService.<span class="keyword">this</span>.mLock) &#123;</span><br><span class="line">                <span class="comment">//【3.3】更新 AppIdleHistory 中的屏幕信息！</span></span><br><span class="line">                mAppIdleHistory.updateDisplayLocked(displayOn, SystemClock.elapsedRealtime());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当屏幕的状态发生变化后，会触发 DisplayListener.onDisplayChanged 方法，紧接着触发 AppIdleHistory.updateDisplayLocked 方法！</p>
<h3 id="3-2-1-AppIdleHistory-updateDisplayLocked"><a href="#3-2-1-AppIdleHistory-updateDisplayLocked" class="headerlink" title="3.2.1 AppIdleHistory.updateDisplayLocked"></a>3.2.1 AppIdleHistory.updateDisplayLocked</h3><p>updateDisplayLocked 方法用于更新屏幕状态信息！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateDisplayLocked</span><span class="params">(<span class="keyword">boolean</span> screenOn, <span class="keyword">long</span> elapsedRealtime)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】如果相等，无需更新！</span></span><br><span class="line">    <span class="keyword">if</span> (screenOn == mScreenOn) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//【2】更新 mScreenOn 的值；</span></span><br><span class="line">    mScreenOn = screenOn;</span><br><span class="line">    <span class="comment">//【3】根据当前屏幕的状态，更新不同的值；</span></span><br><span class="line">    <span class="keyword">if</span> (mScreenOn) &#123;</span><br><span class="line">        <span class="comment">//【3.1】如果此时亮屏，记录亮屏时间点！</span></span><br><span class="line">        mScreenOnSnapshot = elapsedRealtime;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//【3.2】如果此时灭屏，记录本次亮屏时长，累加到 mScreenOnDuration；</span></span><br><span class="line">        mScreenOnDuration += elapsedRealtime - mScreenOnSnapshot; </span><br><span class="line">        <span class="comment">// 计算距离上次灭屏时间点的时间间隔，累加到 mElapsedDuration；</span></span><br><span class="line">        mElapsedDuration += elapsedRealtime - mElapsedSnapshot;</span><br><span class="line">        <span class="comment">// 记录最新灭屏时间点；</span></span><br><span class="line">        mElapsedSnapshot = elapsedRealtime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 isDisplayOn 方法，来判断当前是亮屏还是熄屏：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isDisplayOn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mDisplayManager</span><br><span class="line">            .getDisplay(Display.DEFAULT_DISPLAY).getState() == Display.STATE_ON;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>AppIdleHistory 内部是有一个变量 mScreenOn，保存屏幕的状态信息，默认为 false：</p>
<p>mScreenOnSnapshot 用于每次亮屏的时间点，mElapsedSnapshot 用于记录每次灭屏的时间点；</p>
<p>mScreenOnDuration 用于累计所有亮屏的总时长，mElapsedDuration 用于了累计所有相邻两次灭屏的总时长！</p>
<p>如果是此时是亮屏的话，会将时间记录到 mScreenOnSnapshot 中！</p>
<h2 id="3-4-UsageStatsS-postOneTimeCheckIdleStates"><a href="#3-4-UsageStatsS-postOneTimeCheckIdleStates" class="headerlink" title="3.4 UsageStatsS.postOneTimeCheckIdleStates"></a>3.4 UsageStatsS.postOneTimeCheckIdleStates</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOneTimeCheckIdleStates</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDeviceIdleController == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mPendingOneTimeCheckIdleStates = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//【4.7】发送 MSG_ONE_TIME_CHECK_IDLE_STATES 消息给 H，触发 check idle 操作！</span></span><br><span class="line">        mHandler.sendEmptyMessage(MSG_ONE_TIME_CHECK_IDLE_STATES);</span><br><span class="line">        mPendingOneTimeCheckIdleStates = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>如果 mDeviceIdleController 为 null，说明 UsageStatsService 还没有启动完成，这里会先将 mPendingOneTimeCheckIdleStates 置为 true！等到启动完成后会判断该变量的值，如果为 true，那就会继续调用 postOneTimeCheckIdleStates 方法！</p>
</li>
<li><p>如果 mDeviceIdleController 不为 null，发送 MSG_ONE_TIME_CHECK_IDLE_STATES 消息给 H，触发 check idle 操作！同时设置 mPendingOneTimeCheckIdleStates 为 false；</p>
</li>
</ul>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Coolqi.Li</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://coolqi.top/2017/01/03/UsageStats1-usageStatsServiceStartProcess/">https://coolqi.top/2017/01/03/UsageStats1-usageStatsServiceStartProcess/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://coolqi.top">Coolqi`s Blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/UsageStats使用状态管理/">UsageStats使用状态管理</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="/img/zfb.jpg"><div class="post-qr-code__desc">支付宝打赏</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="/img/wechat.jpg"><div class="post-qr-code__desc">微信打赏</div></div></div><div class="social-share"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2017/01/13/Handler1-handlerInit/"><i class="fa fa-chevron-left">  </i><span>Handler篇 1 - Handler 初识</span></a></div><div class="next-post pull-right"><a href="/2016/10/29/Serivce8-serviceStopSelf/"><span>Serivce 篇 8 - Service stopSelf 流程分析</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2015 - 2020 By Coolqi.Li</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://lishuaiqi.top/">blog</a>!</div><div class="busuanzi"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.6"></script><script src="/js/fancybox.js?version=1.5.6"></script><script src="/js/sidebar.js?version=1.5.6"></script><script src="/js/copy.js?version=1.5.6"></script><script src="/js/fireworks.js?version=1.5.6"></script><script src="/js/transition.js?version=1.5.6"></script><script src="/js/scroll.js?version=1.5.6"></script><script src="/js/head.js?version=1.5.6"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="/js/search/local-search.js"></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>