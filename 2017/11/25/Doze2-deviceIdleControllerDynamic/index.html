<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Doze模式第 2 篇 - DeviceIdleController 动态机制"><meta name="keywords" content="Doze假寐模式"><meta name="author" content="Coolqi.Li,undefined"><meta name="copyright" content="Coolqi.Li"><title>Doze模式第 2 篇 - DeviceIdleController 动态机制 | Coolqi`s Blog</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.5.6"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css?version=1.5.6"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/gh/upupming/gitalk@36368e5dffd049e956cdbbd751ff96c28d8255cf/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?b7acef5306e54116ad8a99e8b753a92d";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#0-综述"><span class="toc-text">0 综述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-动态监听机制"><span class="toc-text">1 动态监听机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-monitor-display"><span class="toc-text">1.1 monitor display</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-1-updateDisplayLocked"><span class="toc-text">1.1.1 updateDisplayLocked</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-monitor-battey"><span class="toc-text">1.2 monitor battey</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1-updateChargingLocked"><span class="toc-text">1.2.1 updateChargingLocked</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-monitor-connectivity"><span class="toc-text">1.3 monitor connectivity</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-1-updateConnectivityState"><span class="toc-text">1.3.1 updateConnectivityState</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-monitor-Motion"><span class="toc-text">1.4 monitor Motion</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-1-startMonitoringMotionLocked"><span class="toc-text">1.4.1 startMonitoringMotionLocked</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-1-1-mMotionListener-registerLocked"><span class="toc-text">1.4.1.1 mMotionListener.registerLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-1-2-DeviceIdleC-motionLocked"><span class="toc-text">1.4.1.2 DeviceIdleC.motionLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-1-3-DeviceIdleC-handleMotionDetectedLocked"><span class="toc-text">1.4.1.3 DeviceIdleC.handleMotionDetectedLocked</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-monitor-Angle"><span class="toc-text">1.5 monitor Angle</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-1-AnyMotionDetector-checkForAnyMotion"><span class="toc-text">1.5.1 AnyMotionDetector.checkForAnyMotion</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-2-DeviceIdleC-onAnyMotionResult"><span class="toc-text">1.5.2 DeviceIdleC.onAnyMotionResult</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-monitor-Location-监听位置"><span class="toc-text">1.6 monitor Location - 监听位置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-1-mGenericLocationListener-onLocationChanged"><span class="toc-text">1.6.1 mGenericLocationListener.onLocationChanged</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-1-1-DeviceIdleC-receivedGenericLocationLocked"><span class="toc-text">1.6.1.1 DeviceIdleC.receivedGenericLocationLocked</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6-2-mGpsLocationListener-onLocationChanged"><span class="toc-text">1.6.2 mGpsLocationListener.onLocationChanged</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-6-2-1-DeviceIdleC-receivedGpsLocationLocked"><span class="toc-text">1.6.2.1 DeviceIdleC.receivedGpsLocationLocked</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-核心逻辑分析"><span class="toc-text">2 核心逻辑分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-DeviceIdleC-becomeInactiveIfAppropriateLocked"><span class="toc-text">2.1 DeviceIdleC.becomeInactiveIfAppropriateLocked</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-deep-idle-逻辑"><span class="toc-text">2.1.1 deep idle 逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-1-scheduleAlarmLocked"><span class="toc-text">2.1.1.1 scheduleAlarmLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-2-mDeepAlarmListener-onAlarm"><span class="toc-text">2.1.1.2 mDeepAlarmListener.onAlarm</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-light-idle-逻辑"><span class="toc-text">2.1.2 light idle 逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-1-scheduleLightAlarmLocked"><span class="toc-text">2.1.2.1 scheduleLightAlarmLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-2-mLightAlarmListener-onAlarm"><span class="toc-text">2.1.2.2 mLightAlarmListener.onAlarm</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-DeviceIdleC-becomeActiveLocked-退出-doze-模式"><span class="toc-text">2.2 DeviceIdleC.becomeActiveLocked - 退出 doze 模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-scheduleReportActiveLocked"><span class="toc-text">2.2.1 scheduleReportActiveLocked</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-Doze-模式状态处理"><span class="toc-text">3 Doze 模式状态处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-DeviceIdleC-stepIdleStateLocked"><span class="toc-text">3.1 DeviceIdleC.stepIdleStateLocked</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1-状态：STATE-INACTIVE"><span class="toc-text">3.1.1 状态：STATE_INACTIVE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2-状态：STATE-IDLE-PENDING"><span class="toc-text">3.1.2 状态：STATE_IDLE_PENDING</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-2-1-DeviceIdleC-scheduleSensingTimeoutAlarmLocked"><span class="toc-text">3.1.2.1 DeviceIdleC.scheduleSensingTimeoutAlarmLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-2-2-mSensingTimeoutAlarmListener-onAlarm"><span class="toc-text">3.1.2.2 mSensingTimeoutAlarmListener.onAlarm</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-3-状态：STATE-SENSING-and-STATE-LOCATING-and-STATE-IDLE-MAINTENANCE"><span class="toc-text">3.1.3 状态：STATE_SENSING and STATE_LOCATING and STATE_IDLE_MAINTENANCE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-4-状态：STATE-IDLE"><span class="toc-text">3.1.4 状态：STATE_IDLE</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-DeviceIdleC-stepLightIdleStateLocked"><span class="toc-text">3.2 DeviceIdleC.stepLightIdleStateLocked</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1-状态：LIGHT-STATE-INACTIVE"><span class="toc-text">3.1.1 状态：LIGHT_STATE_INACTIVE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2-状态：LIGHT-STATE-PRE-IDLE-and-LIGHT-STATE-IDLE-MAINTENANCE"><span class="toc-text">3.1.2 状态：LIGHT_STATE_PRE_IDLE and LIGHT_STATE_IDLE_MAINTENANCE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-3-状态：LIGHT-STATE-IDLE-and-LIGHT-STATE-WAITING-FOR-NETWORK"><span class="toc-text">3.1.3 状态：LIGHT_STATE_IDLE and LIGHT_STATE_WAITING_FOR_NETWORK</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-MyHandler-逻辑分析"><span class="toc-text">4 MyHandler 逻辑分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-消息：MSG-WRITE-CONFIG"><span class="toc-text">4.1 消息：MSG_WRITE_CONFIG</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-1-handleWriteConfigFile"><span class="toc-text">4.1.1 handleWriteConfigFile</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-消息：MSG-REPORT-IDLE-ON-and-MSG-REPORT-IDLE-ON-LIGHT"><span class="toc-text">4.2 消息：MSG_REPORT_IDLE_ON and MSG_REPORT_IDLE_ON_LIGHT</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-消息：MSG-REPORT-IDLE-OFF"><span class="toc-text">4.3 消息：MSG_REPORT_IDLE_OFF</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-1-IdleStartedDoneReceiver"><span class="toc-text">4.3.1 IdleStartedDoneReceiver</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-2-incActiveIdleOps"><span class="toc-text">4.3.2 incActiveIdleOps</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-3-decActiveIdleOps"><span class="toc-text">4.3.3 decActiveIdleOps</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-2-1-exitMaintenanceEarlyIfNeededLocked-提前退出时间窗"><span class="toc-text">4.3.2.1 exitMaintenanceEarlyIfNeededLocked - 提前退出时间窗</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-2-2-isOpsInactiveLocked"><span class="toc-text">4.3.2.2 isOpsInactiveLocked</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-消息：MSG-REPORT-ACTIVE"><span class="toc-text">4.4 消息：MSG_REPORT_ACTIVE</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-消息：MSG-TEMP-APP-WHITELIST-TIMEOUT"><span class="toc-text">4.5 消息：MSG_TEMP_APP_WHITELIST_TIMEOUT</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-1-checkTempAppWhitelistTimeout"><span class="toc-text">4.5.1 checkTempAppWhitelistTimeout</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-2-1-updateTempWhitelistAppIdsLocked"><span class="toc-text">4.5.2.1 updateTempWhitelistAppIdsLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-2-2-reportTempWhitelistChangedLocked"><span class="toc-text">4.5.2.2 reportTempWhitelistChangedLocked</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-消息：MSG-REPORT-MAINTENANCE-ACTIVITY"><span class="toc-text">4.6 消息：MSG_REPORT_MAINTENANCE_ACTIVITY</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-1-DeviceIdleC-setJobsActive"><span class="toc-text">4.6.1 DeviceIdleC.setJobsActive</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-6-1-1-DeviceIdleC-reportMaintenanceActivityIfNeededLocked"><span class="toc-text">4.6.1.1 DeviceIdleC.reportMaintenanceActivityIfNeededLocked</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-7-消息：MSG-FINISH-IDLE-OP"><span class="toc-text">4.7 消息：MSG_FINISH_IDLE_OP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-1-decActiveIdleOps"><span class="toc-text">4.7.1 decActiveIdleOps</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-重置操作"><span class="toc-text">5 重置操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-resetIdleManagementLocked"><span class="toc-text">5.1 resetIdleManagementLocked</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-1-cancelAlarmLocked"><span class="toc-text">5.1.1 cancelAlarmLocked</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-2-cancelSensingTimeoutAlarmLocked"><span class="toc-text">5.1.2 cancelSensingTimeoutAlarmLocked</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-3-cancelLocatingLocked"><span class="toc-text">5.1.3 cancelLocatingLocked</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-4-stopMonitoringMotionLocked"><span class="toc-text">5.1.4 stopMonitoringMotionLocked</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-resetLightIdleManagementLocked"><span class="toc-text">5.2 resetLightIdleManagementLocked</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-1-cancelLightAlarmLocked"><span class="toc-text">5.2.1 cancelLightAlarmLocked</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-提前退出时间窗"><span class="toc-text">6 提前退出时间窗</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-总结"><span class="toc-text">7 总结</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-状态监听器"><span class="toc-text">7.1 状态监听器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-deep-idle"><span class="toc-text">7.2 deep idle</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-light-idle"><span class="toc-text">7.3 light idle</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Coolqi.Li</div><div class="author-info__description text-center">“你好，我是李帅奇，Android 系统工程师，MineCraft 忠实玩家，设计和绘画爱好者，缺妹纸晚期患者，熬夜星人。”</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">64</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">14</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">15</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="https://developer.android.google.cn/">AndroidDeveloper</a><a class="author-info-links__name text-center" href="http://www.android-studio.org/">AndroidStudio</a><a class="author-info-links__name text-center" href="https://www.jianshu.com/u/123a20a96441">简书</a><a class="author-info-links__name text-center" href="https://weibo.com/coolqiLi">微博</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://ws1.sinaimg.cn/large/8700af19ly1fvpabr30o6j22yo1o0q7i.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Coolqi`s Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/about">About</a><a class="site-page" href="/archives">Archives</a></span></div><div id="post-info"><div id="post-title">Doze模式第 2 篇 - DeviceIdleController 动态机制</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-11-25</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/AndroidFramework源码分析/">AndroidFramework源码分析</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/AndroidFramework源码分析/Doze假寐模式/">Doze假寐模式</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">10.3k</span><span class="post-meta__separator">|</span><span>阅读时长: 44 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>[toc]</p>
<p>基于 Android 7.1.1 源码，分析 doze 模式的原理！</p>
<h1 id="0-综述"><a href="#0-综述" class="headerlink" title="0 综述"></a>0 综述</h1><p>在 doze 模式下，应用会受到以下限制：</p>
<ul>
<li>暂停访问 <strong>network</strong>。</li>
<li>系统将忽略 <strong>wake locks</strong>。</li>
<li>标准 <strong>AlarmManager</strong> 闹铃（包括 setExact() 和 setWindow()）推迟到 doze 模式的下一个 maintenance window 时间窗。<ul>
<li>如果您需要设置在低电耗模式下触发的闹铃，请使用 setAndAllowWhileIdle() 或 setExactAndAllowWhileIdle()。</li>
<li>一般情况下，使用 setAlarmClock() 设置的闹铃将继续触发，但系统会在这些闹铃触发之前不久退出低电耗模式。</li>
</ul>
</li>
<li>系统不执行 <strong>Wi-Fi 扫描</strong>。</li>
<li>系统不允许运行 <strong>同步适配器</strong>。</li>
<li>系统不允许运行 <strong>JobScheduler</strong>。</li>
</ul>
<p>下面先分析下 doze 模式内部机制是如何调控的：</p>
<h1 id="1-动态监听机制"><a href="#1-动态监听机制" class="headerlink" title="1 动态监听机制"></a>1 动态监听机制</h1><h2 id="1-1-monitor-display"><a href="#1-1-monitor-display" class="headerlink" title="1.1 monitor display"></a>1.1 monitor display</h2><h3 id="1-1-1-updateDisplayLocked"><a href="#1-1-1-updateDisplayLocked" class="headerlink" title="1.1.1 updateDisplayLocked"></a>1.1.1 updateDisplayLocked</h3><p>监控屏幕状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> DisplayManager.DisplayListener mDisplayListener</span><br><span class="line">        = <span class="keyword">new</span> DisplayManager.DisplayListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDisplayAdded</span><span class="params">(<span class="keyword">int</span> displayId)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDisplayRemoved</span><span class="params">(<span class="keyword">int</span> displayId)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDisplayChanged</span><span class="params">(<span class="keyword">int</span> displayId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (displayId == Display.DEFAULT_DISPLAY) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (DeviceIdleController.<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="comment">//【1】当屏幕状态发生变化后，会触发该方法！</span></span><br><span class="line">                updateDisplayLocked();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们去看看 DeviceIdleController.updateDisplayLocked 方法！</p>
<p>updateDisplayLocked 用于更新屏幕的状态！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateDisplayLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】获取屏幕当前的状态，并判断是否是亮屏状态！</span></span><br><span class="line">    mCurDisplay = mDisplayManager.getDisplay(Display.DEFAULT_DISPLAY);</span><br><span class="line">    <span class="keyword">boolean</span> screenOn = mCurDisplay.getState() == Display.STATE_ON;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">"updateDisplayLocked: screenOn="</span> + screenOn);</span><br><span class="line">    <span class="keyword">if</span> (!screenOn &amp;&amp; mScreenOn) &#123;</span><br><span class="line">        <span class="comment">//【2.1】如果是从亮屏转为熄屏，设置 mScreenOn 为 false！</span></span><br><span class="line">        <span class="comment">// 同时，尝试进入 Doze 模式；</span></span><br><span class="line">        mScreenOn = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!mForceIdle) &#123;</span><br><span class="line">            becomeInactiveIfAppropriateLocked(); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (screenOn) &#123;</span><br><span class="line">        <span class="comment">//【2.2】如果是从熄屏转亮屏，设置 mScreenOn 为 true！</span></span><br><span class="line">        <span class="comment">// 同时，退出 Doze 模式；</span></span><br><span class="line">        mScreenOn = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!mForceIdle) &#123;</span><br><span class="line">            becomeActiveLocked(<span class="string">"screen"</span>, Process.myUid());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mForceIdle 表示是否强制进入 idle 状态，默认为 false 的，目前唯一的开启方式是通过 adb shell，执行 dumpsys 命令，触发 force-idle，force-inactive 相关指令，强制进入 idle 状态！！</p>
<p>这里看到：</p>
<ul>
<li><p>当熄屏后，设置 mScreenOn 为 false，会调用 becomeInactiveIfAppropriateLocked 方法，进入 doze 模式；</p>
</li>
<li><p>当亮屏后，设置 mScreenOn 为 true，会调用 becomeActiveLocked 方法，退出 doze 模式；</p>
</li>
</ul>
<h2 id="1-2-monitor-battey"><a href="#1-2-monitor-battey" class="headerlink" title="1.2 monitor battey"></a>1.2 monitor battey</h2><h3 id="1-2-1-updateChargingLocked"><a href="#1-2-1-updateChargingLocked" class="headerlink" title="1.2.1 updateChargingLocked"></a>1.2.1 updateChargingLocked</h3><p>监控电池状态：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BroadcastReceiver mReceiver = <span class="keyword">new</span> BroadcastReceiver() &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (intent.getAction()) &#123;</span><br><span class="line">            ... ... ...</span><br><span class="line">            <span class="keyword">case</span> Intent.ACTION_BATTERY_CHANGED: &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (DeviceIdleController.<span class="keyword">this</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> plugged = intent.getIntExtra(<span class="string">"plugged"</span>, <span class="number">0</span>);</span><br><span class="line">                    updateChargingLocked(plugged != <span class="number">0</span>); <span class="comment">//【1】电量变化</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            ... ... ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我们继续看 DeviceIdleController.updateChargingLocked 方法！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateChargingLocked</span><span class="params">(<span class="keyword">boolean</span> charging)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) Slog.i(TAG, <span class="string">"updateChargingLocked: charging="</span> + charging);</span><br><span class="line">    <span class="keyword">if</span> (!charging &amp;&amp; mCharging) &#123;</span><br><span class="line">        <span class="comment">//【1】结束充电！</span></span><br><span class="line">        mCharging = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!mForceIdle) &#123;</span><br><span class="line">            <span class="comment">//【2.1】尝试进入 doze 模式！</span></span><br><span class="line">            becomeInactiveIfAppropriateLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (charging) &#123;</span><br><span class="line">        <span class="comment">//【2】开始充电！</span></span><br><span class="line">        mCharging = charging;</span><br><span class="line">        <span class="keyword">if</span> (!mForceIdle) &#123;</span><br><span class="line">            <span class="comment">//【2.2】退出 doze 模式！</span></span><br><span class="line">            becomeActiveLocked(<span class="string">"charging"</span>, Process.myUid());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里看到：</p>
<ul>
<li><p>当结束充电后，设置 mCharging 为 false，会调用 becomeInactiveIfAppropriateLocked 方法，进入 doze 模式；</p>
</li>
<li><p>当开始充电后，设置 mCharging 为 true，会调用 becomeActiveLocked 方法，退出 doze 模式；</p>
</li>
</ul>
<h2 id="1-3-monitor-connectivity"><a href="#1-3-monitor-connectivity" class="headerlink" title="1.3 monitor connectivity"></a>1.3 monitor connectivity</h2><h3 id="1-3-1-updateConnectivityState"><a href="#1-3-1-updateConnectivityState" class="headerlink" title="1.3.1 updateConnectivityState"></a>1.3.1 updateConnectivityState</h3><p>监控网络连接状态：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BroadcastReceiver mReceiver = <span class="keyword">new</span> BroadcastReceiver() &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (intent.getAction()) &#123;</span><br><span class="line">            <span class="keyword">case</span> ConnectivityManager.CONNECTIVITY_ACTION: &#123;</span><br><span class="line">                <span class="comment">//【1】更新网络连接状态！</span></span><br><span class="line">                updateConnectivityState(intent);</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            ... ... ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>我们继续看 DeviceIdleController.updateConnectivityState 方法！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateConnectivityState</span><span class="params">(Intent connIntent)</span> </span>&#123;</span><br><span class="line">    ConnectivityService cm;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        cm = mConnectivityService;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cm == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    NetworkInfo ni = cm.getActiveNetworkInfo();</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> conn;</span><br><span class="line">        <span class="keyword">if</span> (ni == <span class="keyword">null</span>) &#123;</span><br><span class="line">            conn = <span class="keyword">false</span>; <span class="comment">//【1】网络断开，conn 为 false；</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//【2】获得网络的连接状态；</span></span><br><span class="line">            <span class="keyword">if</span> (connIntent == <span class="keyword">null</span>) &#123;</span><br><span class="line">                conn = ni.isConnected();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> networkType =</span><br><span class="line">                        connIntent.getIntExtra(ConnectivityManager.EXTRA_NETWORK_TYPE,</span><br><span class="line">                                ConnectivityManager.TYPE_NONE);</span><br><span class="line">                <span class="keyword">if</span> (ni.getType() != networkType) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                conn = !connIntent.getBooleanExtra(ConnectivityManager.EXTRA_NO_CONNECTIVITY,</span><br><span class="line">                        <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【3】处理连接状态，如果当前状态和之前的状态发生了变化，更新 mNetworkConnected 的值！</span></span><br><span class="line">        <span class="keyword">if</span> (conn != mNetworkConnected) &#123;</span><br><span class="line">            mNetworkConnected = conn;</span><br><span class="line">            <span class="keyword">if</span> (conn &amp;&amp; mLightState == LIGHT_STATE_WAITING_FOR_NETWORK) &#123;</span><br><span class="line">                <span class="comment">//【2.3】如果本次状态是处于连接中，并且 mLightState 值为 LIGHT_STATE_WAITING_FOR_NETWORK！</span></span><br><span class="line">                <span class="comment">// 调用 stepLightIdleStateLocked 方法！</span></span><br><span class="line">                stepLightIdleStateLocked(<span class="string">"network"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>mNetworkConnected 表示之前的网络连接！</p>
<h2 id="1-4-monitor-Motion"><a href="#1-4-monitor-Motion" class="headerlink" title="1.4 monitor Motion"></a>1.4 monitor Motion</h2><h3 id="1-4-1-startMonitoringMotionLocked"><a href="#1-4-1-startMonitoringMotionLocked" class="headerlink" title="1.4.1 startMonitoringMotionLocked"></a>1.4.1 startMonitoringMotionLocked</h3><p>监听设备的运动：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startMonitoringMotionLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">"startMonitoringMotionLocked()"</span>);</span><br><span class="line">    <span class="keyword">if</span> (mMotionSensor != <span class="keyword">null</span> &amp;&amp; !mMotionListener.active) &#123;</span><br><span class="line">        mMotionListener.registerLocked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DeviceIdleController 内部有一个 mMotionListener 对象，用于监听传感器的变化！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MotionListener mMotionListener = <span class="keyword">new</span> MotionListener();</span><br></pre></td></tr></table></figure>
<p>我们来看下 MotionListener 中的方法！</p>
<h4 id="1-4-1-1-mMotionListener-registerLocked"><a href="#1-4-1-1-mMotionListener-registerLocked" class="headerlink" title="1.4.1.1 mMotionListener.registerLocked"></a>1.4.1.1 mMotionListener.registerLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MotionListener</span> <span class="keyword">extends</span> <span class="title">TriggerEventListener</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">SensorEventListener</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> active = <span class="keyword">false</span>; <span class="comment">// 表示 MotionListener 是否被注册！</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【1】当传感器的被触发后，会调用 onTrigger()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTrigger</span><span class="params">(TriggerEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (DeviceIdleController.<span class="keyword">this</span>) &#123;</span><br><span class="line">            active = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//【1.4.1.2】调用 motionLocked 方法！</span></span><br><span class="line">            motionLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【2】当传感器的值发生变化时，会调用 OnSensorChanged()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSensorChanged</span><span class="params">(SensorEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (DeviceIdleController.<span class="keyword">this</span>) &#123;</span><br><span class="line">            mSensorManager.unregisterListener(<span class="keyword">this</span>, mMotionSensor);</span><br><span class="line">            active = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//【1.4.1.2】调用 motionLocked 方法！</span></span><br><span class="line">            motionLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当传感器的精度发生变化时会调用 OnAccuracyChanged() 方法!</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAccuracyChanged</span><span class="params">(Sensor sensor, <span class="keyword">int</span> accuracy)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【3】注册 MotionListener！</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">registerLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> success;</span><br><span class="line">        <span class="comment">//【1.1】调用了 mSensorManager 的相关方法注册监听器！</span></span><br><span class="line">        <span class="keyword">if</span> (mMotionSensor.getReportingMode() == Sensor.REPORTING_MODE_ONE_SHOT) &#123;</span><br><span class="line">            success = mSensorManager.requestTriggerSensor(mMotionListener, mMotionSensor);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            success = mSensorManager.registerListener(</span><br><span class="line">                    mMotionListener, mMotionSensor, SensorManager.SENSOR_DELAY_NORMAL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (success) &#123;</span><br><span class="line">            active = <span class="keyword">true</span>; <span class="comment">//【1.2】设置监听器为活跃状态！</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Slog.e(TAG, <span class="string">"Unable to register for "</span> + mMotionSensor);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> success;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【4】解除注册 MotionListener！</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unregisterLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mMotionSensor.getReportingMode() == Sensor.REPORTING_MODE_ONE_SHOT) &#123;</span><br><span class="line">            mSensorManager.cancelTriggerSensor(mMotionListener, mMotionSensor);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mSensorManager.unregisterListener(mMotionListener);</span><br><span class="line">        &#125;</span><br><span class="line">        active = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续看：</p>
<h4 id="1-4-1-2-DeviceIdleC-motionLocked"><a href="#1-4-1-2-DeviceIdleC-motionLocked" class="headerlink" title="1.4.1.2 DeviceIdleC.motionLocked"></a>1.4.1.2 DeviceIdleC.motionLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">motionLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">"motionLocked()"</span>);</span><br><span class="line">    <span class="comment">//【1.4.1.3】调用 handleMotionDetectedLocked 处理传感器变化！</span></span><br><span class="line">    handleMotionDetectedLocked(mConstants.MOTION_INACTIVE_TIMEOUT, <span class="string">"motion"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-4-1-3-DeviceIdleC-handleMotionDetectedLocked"><a href="#1-4-1-3-DeviceIdleC-handleMotionDetectedLocked" class="headerlink" title="1.4.1.3 DeviceIdleC.handleMotionDetectedLocked"></a>1.4.1.3 DeviceIdleC.handleMotionDetectedLocked</h4><p>由于此时传感器被触发或者值发生了变化，那么此时我们不能进入 doze 模式，需要回退到 active 状态！！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleMotionDetectedLocked</span><span class="params">(<span class="keyword">long</span> timeout, String type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> becomeInactive = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//【1】处理 deep idle 模式的退出！！</span></span><br><span class="line">    <span class="keyword">if</span> (mState != STATE_ACTIVE) &#123;</span><br><span class="line">        <span class="comment">//【2.2.1】调用了 scheduleReportActiveLocked，退出 doze 模式，恢复 active 状态！</span></span><br><span class="line">        scheduleReportActiveLocked(type, Process.myUid());</span><br><span class="line">        mState = STATE_ACTIVE;</span><br><span class="line">        mInactiveTimeout = timeout;</span><br><span class="line">        mCurIdleBudget = <span class="number">0</span>;</span><br><span class="line">        mMaintenanceStartTime = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        EventLogTags.writeDeviceIdle(mState, type);</span><br><span class="line">        addEvent(EVENT_NORMAL);</span><br><span class="line"></span><br><span class="line">        becomeInactive = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【1】处理 light idle 模式的退出，我们只有在退出 deep idle 时才会同时退出 light idle！！</span></span><br><span class="line">    <span class="keyword">if</span> (mLightState == LIGHT_STATE_OVERRIDE) &#123;</span><br><span class="line">        mLightState = STATE_ACTIVE;</span><br><span class="line">        EventLogTags.writeDeviceIdleLight(mLightState, type);</span><br><span class="line">        becomeInactive = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2.1】这里 becomeInactive 为 true 时，会重新调用 becomeInactiveIfAppropriateLocked 方法</span></span><br><span class="line">    <span class="comment">// 重新开始了阶段条件的判断！</span></span><br><span class="line">    <span class="keyword">if</span> (becomeInactive) &#123;</span><br><span class="line">        becomeInactiveIfAppropriateLocked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就先分析到这里！</p>
<h2 id="1-5-monitor-Angle"><a href="#1-5-monitor-Angle" class="headerlink" title="1.5 monitor Angle"></a>1.5 monitor Angle</h2><h3 id="1-5-1-AnyMotionDetector-checkForAnyMotion"><a href="#1-5-1-AnyMotionDetector-checkForAnyMotion" class="headerlink" title="1.5.1 AnyMotionDetector.checkForAnyMotion"></a>1.5.1 AnyMotionDetector.checkForAnyMotion</h3><p>监听设备的角度变化，我们在 onStart 方法中有创建一个 AnyMotionDetector 实例，用于监听设备的角度变化是否超过阈值！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//【1】获得角度阈值；</span></span><br><span class="line"><span class="keyword">float</span> angleThreshold = getContext().getResources().getInteger(</span><br><span class="line">        com.android.internal.R.integer.config_autoPowerModeThresholdAngle) / <span class="number">100f</span>;</span><br><span class="line"><span class="comment">//【2】创建角度变化监听器；</span></span><br><span class="line">mAnyMotionDetector = <span class="keyword">new</span> AnyMotionDetector(</span><br><span class="line">        (PowerManager) getContext().getSystemService(Context.POWER_SERVICE),</span><br><span class="line">        mHandler, mSensorManager, <span class="keyword">this</span>, angleThreshold);</span><br></pre></td></tr></table></figure>
<p>这里面最关键的一个参数是 AnyMotionDetector 的倒数第二个参数：DeviceIdleCallback callback，这里传入的是 DeviceIdleController，因为 DeviceIdleController 实现了 AnyMotionDetector.DeviceIdleCallback！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnyMotionDetector</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">DeviceIdleCallback</span> </span>&#123;</span><br><span class="line">        <span class="comment">//【1.5.2】onAnyMotionResult 处理角度的变化；</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnyMotionResult</span><span class="params">(<span class="keyword">int</span> result)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ... ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当角度发生变化后，会触发 onAnyMotionResult 回调！</p>
<h3 id="1-5-2-DeviceIdleC-onAnyMotionResult"><a href="#1-5-2-DeviceIdleC-onAnyMotionResult" class="headerlink" title="1.5.2 DeviceIdleC.onAnyMotionResult"></a>1.5.2 DeviceIdleC.onAnyMotionResult</h3><p>我们来看看 onAnyMotionResult 方法！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnyMotionResult</span><span class="params">(<span class="keyword">int</span> result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">"onAnyMotionResult("</span> + result + <span class="string">")"</span>);</span><br><span class="line">    <span class="comment">//【1】正常情况，首先取消 mSensingTimeoutAlarmListener；</span></span><br><span class="line">    <span class="keyword">if</span> (result != AnyMotionDetector.RESULT_UNKNOWN) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">//【1.1.1.1.2】调用 cancelSensingTimeoutAlarmLocked 取消；</span></span><br><span class="line">            cancelSensingTimeoutAlarmLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】当 result 为 RESULT_MOVED，说明角度变化超过了阈值；</span></span><br><span class="line">    <span class="keyword">if</span> ((result == AnyMotionDetector.RESULT_MOVED) ||</span><br><span class="line">        (result == AnyMotionDetector.RESULT_UNKNOWN)) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">//【1.4.3】不处于静止状态，又调用了 handleMotionDetectedLocked 方法，恢复 active 状态；</span></span><br><span class="line">            handleMotionDetectedLocked(mConstants.INACTIVE_TIMEOUT, <span class="string">"non_stationary"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result == AnyMotionDetector.RESULT_STATIONARY) &#123;</span><br><span class="line">        <span class="comment">//【3】当 result 为 RESULT_STATIONARY，说明角度并没有发生超过阈值的变化；</span></span><br><span class="line">        <span class="keyword">if</span> (mState == STATE_SENSING) &#123;</span><br><span class="line">            <span class="comment">//【3.1】当 mState 是 STATE_SENSING，那么我们会进入下一阶段；</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="comment">// 设置 STATE_SENSING 为 true！</span></span><br><span class="line">                mNotMoving = <span class="keyword">true</span>; </span><br><span class="line">                stepIdleStateLocked(<span class="string">"s:stationary"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mState == STATE_LOCATING) &#123;</span><br><span class="line">            <span class="comment">//【3.1】当 mState 是 STATE_LOCATING，那么我们同样会进入下一阶段；</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                mNotMoving = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (mLocated) &#123;</span><br><span class="line">                    stepIdleStateLocked(<span class="string">"s:stationary"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="1-6-monitor-Location-监听位置"><a href="#1-6-monitor-Location-监听位置" class="headerlink" title="1.6 monitor Location - 监听位置"></a>1.6 monitor Location - 监听位置</h2><p>监控定位：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//【1】监听网络定位 network location provider！</span></span><br><span class="line"><span class="keyword">if</span> (mLocationManager != <span class="keyword">null</span></span><br><span class="line">        &amp;&amp; mLocationManager.getProvider(LocationManager.NETWORK_PROVIDER) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    mLocationManager.requestLocationUpdates(mLocationRequest,</span><br><span class="line">            mGenericLocationListener, mHandler.getLooper()); <span class="comment">//【1.6.1】</span></span><br><span class="line">    mLocating = <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    mHasNetworkLocation = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//【2】监听 GPS location provider！</span></span><br><span class="line"><span class="keyword">if</span> (mLocationManager != <span class="keyword">null</span></span><br><span class="line">        &amp;&amp; mLocationManager.getProvider(LocationManager.GPS_PROVIDER) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    mHasGps = <span class="keyword">true</span>;</span><br><span class="line">    mLocationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, <span class="number">1000</span>, <span class="number">5</span>,</span><br><span class="line">            mGpsLocationListener, mHandler.getLooper());  <span class="comment">//【1.6.2】</span></span><br><span class="line">    mLocating = <span class="keyword">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    mHasGps = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到，这里向 LocationManager 中注册了两个监听器：mGenericLocationListener 和 mGpsLocationListener！</p>
<h3 id="1-6-1-mGenericLocationListener-onLocationChanged"><a href="#1-6-1-mGenericLocationListener-onLocationChanged" class="headerlink" title="1.6.1 mGenericLocationListener.onLocationChanged"></a>1.6.1 mGenericLocationListener.onLocationChanged</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> LocationListener mGenericLocationListener = <span class="keyword">new</span> LocationListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLocationChanged</span><span class="params">(Location location)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (DeviceIdleController.<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">//【1.6.1.1】处理定位的变化！</span></span><br><span class="line">            receivedGenericLocationLocked(location);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ... ... ... ... <span class="comment">// 省去无需关注！</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当定位发生变化后，onLocationChanged 触发！</p>
<h4 id="1-6-1-1-DeviceIdleC-receivedGenericLocationLocked"><a href="#1-6-1-1-DeviceIdleC-receivedGenericLocationLocked" class="headerlink" title="1.6.1.1 DeviceIdleC.receivedGenericLocationLocked"></a>1.6.1.1 DeviceIdleC.receivedGenericLocationLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">receivedGenericLocationLocked</span><span class="params">(Location location)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】判断下 mState，如果不是 STATE_LOCATING，就调用 cancelLocatingLocked，取消定位监听！</span></span><br><span class="line">    <span class="keyword">if</span> (mState != STATE_LOCATING) &#123;</span><br><span class="line">        cancelLocatingLocked();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">"Generic location: "</span> + location);</span><br><span class="line">    <span class="comment">//【2】将定位信息保存到 mLastGenericLocation 中，用于 dumpsys！</span></span><br><span class="line">    mLastGenericLocation = <span class="keyword">new</span> Location(location);</span><br><span class="line">    <span class="comment">// 如果定位精度超过 mConstants.LOCATION_ACCURACY(20meter)，直接返回，不进入下一阶段；</span></span><br><span class="line">    <span class="keyword">if</span> (location.getAccuracy() &gt; mConstants.LOCATION_ACCURACY &amp;&amp; mHasGps) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【3】设置 mLocated 为 true，表示定位完成！</span></span><br><span class="line">    mLocated = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (mNotMoving) &#123;</span><br><span class="line">        <span class="comment">//【3.1】如果此时手机没有发生移动，调用 stepIdleStateLocked 处理 STATE_LOCATING 状态！</span></span><br><span class="line">        stepIdleStateLocked(<span class="string">"s:location"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不多说！</p>
<h3 id="1-6-2-mGpsLocationListener-onLocationChanged"><a href="#1-6-2-mGpsLocationListener-onLocationChanged" class="headerlink" title="1.6.2 mGpsLocationListener.onLocationChanged"></a>1.6.2 mGpsLocationListener.onLocationChanged</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private final LocationListener mGpsLocationListener = new LocationListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onLocationChanged(Location location) &#123;</span><br><span class="line">        synchronized (DeviceIdleController.this) &#123;</span><br><span class="line">            //【1.6.2.1】处理定位的变化！</span><br><span class="line">            receivedGpsLocationLocked(location);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ... ... ... ... ... // 省去无需关注！</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当定位发生变化后，onLocationChanged 触发！</p>
<h4 id="1-6-2-1-DeviceIdleC-receivedGpsLocationLocked"><a href="#1-6-2-1-DeviceIdleC-receivedGpsLocationLocked" class="headerlink" title="1.6.2.1 DeviceIdleC.receivedGpsLocationLocked"></a>1.6.2.1 DeviceIdleC.receivedGpsLocationLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">receivedGpsLocationLocked</span><span class="params">(Location location)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】判断下 mState，如果不是 STATE_LOCATING，就调用 cancelLocatingLocked，取消定位监听！</span></span><br><span class="line">    <span class="keyword">if</span> (mState != STATE_LOCATING) &#123;</span><br><span class="line">        cancelLocatingLocked();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">"GPS location: "</span> + location);</span><br><span class="line">    <span class="comment">//【2】将定位信息保存到 mLastGpsLocation 中，用于 dumpsys！</span></span><br><span class="line">    mLastGpsLocation = <span class="keyword">new</span> Location(location);</span><br><span class="line">    <span class="comment">// 如果定位精度超过 mConstants.LOCATION_ACCURACY(20meter)，直接返回，不进入下一阶段；</span></span><br><span class="line">    <span class="keyword">if</span> (location.getAccuracy() &gt; mConstants.LOCATION_ACCURACY) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【3】设置 mLocated 为 true，表示定位完成！</span></span><br><span class="line">    mLocated = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (mNotMoving) &#123;</span><br><span class="line">        <span class="comment">//【3.1】如果此时手机没有发生移动，调用 stepIdleStateLocked 处理 STATE_LOCATING 状态！</span></span><br><span class="line">        stepIdleStateLocked(<span class="string">"s:gps"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不多说！</p>
<h1 id="2-核心逻辑分析"><a href="#2-核心逻辑分析" class="headerlink" title="2 核心逻辑分析"></a>2 核心逻辑分析</h1><h2 id="2-1-DeviceIdleC-becomeInactiveIfAppropriateLocked"><a href="#2-1-DeviceIdleC-becomeInactiveIfAppropriateLocked" class="headerlink" title="2.1 DeviceIdleC.becomeInactiveIfAppropriateLocked"></a>2.1 DeviceIdleC.becomeInactiveIfAppropriateLocked</h2><p>尝试进入 doze 模式，这里会对 doze 模式第一阶段的条件做一个处理！！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">becomeInactiveIfAppropriateLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">"becomeInactiveIfAppropriateLocked()"</span>);</span><br><span class="line">    <span class="comment">//【1】如果是熄屏并且没有充电的充电的情况下，或者是强制进入 idle 状态下！</span></span><br><span class="line">    <span class="keyword">if</span> ((!mScreenOn &amp;&amp; !mCharging) || mForceIdle) &#123;</span><br><span class="line">        <span class="comment">//【1.1】处理 deep idle 模式逻辑！！</span></span><br><span class="line">        <span class="keyword">if</span> (mState == STATE_ACTIVE &amp;&amp; mDeepEnabled) &#123;</span><br><span class="line">            mState = STATE_INACTIVE;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">"Moved from STATE_ACTIVE to STATE_INACTIVE"</span>);</span><br><span class="line">            <span class="comment">//【5.1】重置相关变量！！</span></span><br><span class="line">            resetIdleManagementLocked();</span><br><span class="line">            <span class="comment">//【2.1.1.1】设置 alarm，用于进入下一阶段！！</span></span><br><span class="line">            scheduleAlarmLocked(mInactiveTimeout, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">            EventLogTags.writeDeviceIdle(mState, <span class="string">"no activity"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【1.2】处理 light idle 模式逻辑！！</span></span><br><span class="line">        <span class="keyword">if</span> (mLightState == LIGHT_STATE_ACTIVE &amp;&amp; mLightEnabled) &#123;</span><br><span class="line">            mLightState = LIGHT_STATE_INACTIVE;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">"Moved from LIGHT_STATE_ACTIVE to LIGHT_STATE_INACTIVE"</span>);</span><br><span class="line">            <span class="comment">//【5.2】重置相关变量！！</span></span><br><span class="line">            resetLightIdleManagementLocked();</span><br><span class="line">            <span class="comment">//【2.1.2.1】设置 alarm！！</span></span><br><span class="line">            scheduleLightAlarmLocked(mConstants.LIGHT_IDLE_AFTER_INACTIVE_TIMEOUT);</span><br><span class="line"></span><br><span class="line">            EventLogTags.writeDeviceIdleLight(mLightState, <span class="string">"no activity"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>首先判断了条件：</p>
<ul>
<li>如果是熄屏并且没有充电的充电的情况下，或者是强制进入 idle 状态下！</li>
</ul>
<p>然后针对 deep idle 和 light idle 两种模式，做了不同的处理！</p>
<h3 id="2-1-1-deep-idle-逻辑"><a href="#2-1-1-deep-idle-逻辑" class="headerlink" title="2.1.1 deep idle 逻辑"></a>2.1.1 deep idle 逻辑</h3><p>首先，设置 mState 从 STATE_ACTIVE 为 STATE_INACTIVE；</p>
<p>然后，重置 deep idle 逻辑相关的变量，取消 Alarm 和监控器！！</p>
<p>最后，设置 deep idle 的 Alarm：</p>
<h4 id="2-1-1-1-scheduleAlarmLocked"><a href="#2-1-1-1-scheduleAlarmLocked" class="headerlink" title="2.1.1.1 scheduleAlarmLocked"></a>2.1.1.1 scheduleAlarmLocked</h4><p>设置 deep idle 的 Alarm：</p>
<p>参数传递：</p>
<ul>
<li><p>long delay 传入的是 mInactiveTimeout，mInactiveTimeout 在 onStat 方法中被初始化为 mConstants.INACTIVE_TIMEOUT 为 30 mins;</p>
</li>
<li><p>boolean idleUntil 传入的是 false，因为还没有进入 idle 状态！</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleAlarmLocked</span><span class="params">(<span class="keyword">long</span> delay, <span class="keyword">boolean</span> idleUntil)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">"scheduleAlarmLocked("</span> + delay + <span class="string">", "</span> + idleUntil + <span class="string">")"</span>);</span><br><span class="line">    <span class="keyword">if</span> (mMotionSensor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//【1】如果当前设备没有运动传感器，那就不会设置 alarm，因为无法判断设备是否移动！</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【2】计算 alarm 的触发时间！</span></span><br><span class="line">    mNextAlarmTime = SystemClock.elapsedRealtime() + delay;</span><br><span class="line">    <span class="keyword">if</span> (idleUntil) &#123;</span><br><span class="line">        mAlarmManager.setIdleUntil(AlarmManager.ELAPSED_REALTIME_WAKEUP,</span><br><span class="line">                mNextAlarmTime, <span class="string">"DeviceIdleController.deep"</span>, mDeepAlarmListener, mHandler);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//【2.1.1.2】idleUntil 为 false，设置一个 delay 时间间隔后的 Alarm！</span></span><br><span class="line">        mAlarmManager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP,</span><br><span class="line">                mNextAlarmTime, <span class="string">"DeviceIdleController.deep"</span>, mDeepAlarmListener, mHandler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 delay 时间间隔后会触发 mDeepAlarmListener，在 mHandler 所在的线程执行！</p>
<h4 id="2-1-1-2-mDeepAlarmListener-onAlarm"><a href="#2-1-1-2-mDeepAlarmListener-onAlarm" class="headerlink" title="2.1.1.2 mDeepAlarmListener.onAlarm"></a>2.1.1.2 mDeepAlarmListener.onAlarm</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AlarmManager.OnAlarmListener mDeepAlarmListener</span><br><span class="line">        = <span class="keyword">new</span> AlarmManager.OnAlarmListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAlarm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (DeviceIdleController.<span class="keyword">this</span>) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【2.3】第一阶段条件满足！</span></span><br><span class="line">            stepIdleStateLocked(<span class="string">"s:alarm"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当设备处于熄屏并且未充电 30 mins 以后，DeepAlarmListener 会被触发，这时 deep idle 模式的第一阶段条件满足，执行 stepIdleStateLocked 方法！</p>
<h3 id="2-1-2-light-idle-逻辑"><a href="#2-1-2-light-idle-逻辑" class="headerlink" title="2.1.2 light idle 逻辑"></a>2.1.2 light idle 逻辑</h3><p>回顾下流程：</p>
<ul>
<li>首先，设置 mLightState 从 LIGHT_STATE_ACTIVE 变为 LIGHT_STATE_INACTIVE；</li>
<li>然后，同样的重置相关变量；</li>
<li>最后，设置 light idle 的 alarm；</li>
</ul>
<h4 id="2-1-2-1-scheduleLightAlarmLocked"><a href="#2-1-2-1-scheduleLightAlarmLocked" class="headerlink" title="2.1.2.1 scheduleLightAlarmLocked"></a>2.1.2.1 scheduleLightAlarmLocked</h4><p>设置 light idle 的 Alarm，参数 long delay 传入：mConstants.LIGHT_IDLE_AFTER_INACTIVE_TIMEOUT 为 5 mins！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleLightAlarmLocked</span><span class="params">(<span class="keyword">long</span> delay)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">"scheduleLightAlarmLocked("</span> + delay + <span class="string">")"</span>);</span><br><span class="line">    mNextLightAlarmTime = SystemClock.elapsedRealtime() + delay;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2.1.2.2】设置一个时间间隔为 delay 后的 alarm，用于触发 mLightAlarmListener！</span></span><br><span class="line">    mAlarmManager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP,</span><br><span class="line">            mNextLightAlarmTime, <span class="string">"DeviceIdleController.light"</span>, mLightAlarmListener, mHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>设置一个时间间隔为 delay 后的 alarm，用于触发 mLightAlarmListener！</p>
<h4 id="2-1-2-2-mLightAlarmListener-onAlarm"><a href="#2-1-2-2-mLightAlarmListener-onAlarm" class="headerlink" title="2.1.2.2 mLightAlarmListener.onAlarm"></a>2.1.2.2 mLightAlarmListener.onAlarm</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AlarmManager.OnAlarmListener mLightAlarmListener</span><br><span class="line">        = <span class="keyword">new</span> AlarmManager.OnAlarmListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAlarm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (DeviceIdleController.<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">//【3.2】进入 light idle 模式的第一阶段条件满足！</span></span><br><span class="line">            stepLightIdleStateLocked(<span class="string">"s:alarm"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当设备处于熄屏并且未充电 5 mins 以后，mLightAlarmListener.onAlarm 会被触发，这时 light idle 模式的第一阶段条件满足，执行 stepIdleStateLocked 方法！</p>
<h2 id="2-2-DeviceIdleC-becomeActiveLocked-退出-doze-模式"><a href="#2-2-DeviceIdleC-becomeActiveLocked-退出-doze-模式" class="headerlink" title="2.2 DeviceIdleC.becomeActiveLocked - 退出 doze 模式"></a>2.2 DeviceIdleC.becomeActiveLocked - 退出 doze 模式</h2><p>退出 doze 模式！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">becomeActiveLocked</span><span class="params">(String activeReason, <span class="keyword">int</span> activeUid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) Slog.i(TAG, <span class="string">"becomeActiveLocked, reason = "</span> + activeReason);</span><br><span class="line">    <span class="comment">//【1】如果 mState 不等于 STATE_ACTIVE 或者 mLightState 不等于 STATE_ACTIVE！</span></span><br><span class="line">    <span class="keyword">if</span> (mState != STATE_ACTIVE || mLightState != STATE_ACTIVE) &#123;</span><br><span class="line">        EventLogTags.writeDeviceIdle(STATE_ACTIVE, activeReason);</span><br><span class="line">        EventLogTags.writeDeviceIdleLight(LIGHT_STATE_ACTIVE, activeReason);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【2.2.1】调用了 scheduleReportActiveLocked，退出 doze 模式，恢复 active 状态！</span></span><br><span class="line">        scheduleReportActiveLocked(activeReason, activeUid);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 重置关键变量！</span></span><br><span class="line">        mState = STATE_ACTIVE;</span><br><span class="line">        mLightState = LIGHT_STATE_ACTIVE;</span><br><span class="line">        mInactiveTimeout = mConstants.INACTIVE_TIMEOUT;</span><br><span class="line">        mCurIdleBudget = <span class="number">0</span>;</span><br><span class="line">        mMaintenanceStartTime = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【5.1】重置 deep idle 模式</span></span><br><span class="line">        resetIdleManagementLocked();</span><br><span class="line">        <span class="comment">//【5.2】重置 light idle 模式</span></span><br><span class="line">        resetLightIdleManagementLocked();</span><br><span class="line">        addEvent(EVENT_NORMAL);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先判断了下状态：</p>
<ul>
<li>如果 mState 不等于 STATE_ACTIVE 或者 mLightState 不等于 STATE_ACTIVE，执行退出操作！</li>
<li>设置 mState 为 STATE_ACTIVE；</li>
<li>设置 mLightState 为 LIGHT_STATE_ACTIVE；</li>
</ul>
<h3 id="2-2-1-scheduleReportActiveLocked"><a href="#2-2-1-scheduleReportActiveLocked" class="headerlink" title="2.2.1 scheduleReportActiveLocked"></a>2.2.1 scheduleReportActiveLocked</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleReportActiveLocked</span><span class="params">(String activeReason, <span class="keyword">int</span> activeUid)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【4.4】发送 MSG_REPORT_ACTIVE 给 MyHandler，退出 doze 模式！</span></span><br><span class="line">    Message msg = mHandler.obtainMessage(MSG_REPORT_ACTIVE, activeUid, <span class="number">0</span>, activeReason);</span><br><span class="line">    mHandler.sendMessage(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-Doze-模式状态处理"><a href="#3-Doze-模式状态处理" class="headerlink" title="3 Doze 模式状态处理"></a>3 Doze 模式状态处理</h1><h2 id="3-1-DeviceIdleC-stepIdleStateLocked"><a href="#3-1-DeviceIdleC-stepIdleStateLocked" class="headerlink" title="3.1 DeviceIdleC.stepIdleStateLocked"></a>3.1 DeviceIdleC.stepIdleStateLocked</h2><p>对于 deep idle 模式来说，是通过 stepIdleStateLocked 方法处理每个阶段的状态的！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stepIdleStateLocked</span><span class="params">(String reason)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">"stepIdleStateLocked: mState="</span> + mState);</span><br><span class="line">    EventLogTags.writeDeviceIdleStep();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.elapsedRealtime();</span><br><span class="line">    <span class="comment">//【1】如果在 1 小时之内有会在 idle 状态下唤醒设备的 Alarm，那么我们不会进入 idle 状态！</span></span><br><span class="line">    <span class="keyword">if</span> ((now + mConstants.MIN_TIME_TO_ALARM) &gt; mAlarmManager.getNextWakeFromIdleTime()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mState != STATE_ACTIVE) &#123;</span><br><span class="line">            <span class="comment">//【1.1】退出 doze 模式！</span></span><br><span class="line">            becomeActiveLocked(<span class="string">"alarm"</span>, Process.myUid());</span><br><span class="line">            <span class="comment">//【2.1】再次调用 becomeInactiveIfAppropriateLocked 重新从第一阶段开始处理！</span></span><br><span class="line">            becomeInactiveIfAppropriateLocked();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】下面进入状态的判断！</span></span><br><span class="line">    <span class="keyword">switch</span> (mState) &#123;</span><br><span class="line">        <span class="keyword">case</span> STATE_INACTIVE:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">case</span> STATE_IDLE_PENDING:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">case</span> STATE_SENSING:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> STATE_LOCATING:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> STATE_IDLE_MAINTENANCE:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> STATE_IDLE:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来重点看看，deep idle 状态处理如下：</p>
<h3 id="3-1-1-状态：STATE-INACTIVE"><a href="#3-1-1-状态：STATE-INACTIVE" class="headerlink" title="3.1.1 状态：STATE_INACTIVE"></a>3.1.1 状态：STATE_INACTIVE</h3><p>此时，设备已经在熄屏且为充电的状态下 30mins 了，这个时候，准备进入第二阶段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//【1.4】启动传感器监听，判断设备是否有移动！</span></span><br><span class="line">startMonitoringMotionLocked();</span><br><span class="line"><span class="comment">//【2.1.1.2】启动下一个阶段的 alarm 触发！</span></span><br><span class="line">scheduleAlarmLocked(mConstants.IDLE_AFTER_INACTIVE_TIMEOUT, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reset the upcoming idle delays.</span></span><br><span class="line">mNextIdlePendingDelay = mConstants.IDLE_PENDING_TIMEOUT;</span><br><span class="line">mNextIdleDelay = mConstants.IDLE_TIMEOUT;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置状态为 STATE_IDLE_PENDING</span></span><br><span class="line">mState = STATE_IDLE_PENDING;</span><br></pre></td></tr></table></figure>
<ul>
<li>流程分析：</li>
</ul>
<p>通过 startMonitoringMotionLocked 启动了传感器监听，监听设备是否运动！</p>
<p>又<strong>设置了一个时间间隔为 mConstants.IDLE_AFTER_INACTIVE_TIMEOUT 30mins 的 Alarm</strong>，触发的仍然是 mDeepAlarmListener！</p>
<p><strong>mState 状态被设置为了 STATE_IDLE_PENDING</strong>！</p>
<ul>
<li>第二阶段条件：</li>
</ul>
<p><strong>这里我们看到了第二阶段条件：熄屏且不充电，同时设备不移动 30mins 后</strong>！</p>
<p>条件满足后，依然会调用 stepIdleStateLocked 方法！</p>
<h3 id="3-1-2-状态：STATE-IDLE-PENDING"><a href="#3-1-2-状态：STATE-IDLE-PENDING" class="headerlink" title="3.1.2 状态：STATE_IDLE_PENDING"></a>3.1.2 状态：STATE_IDLE_PENDING</h3><p>此时，设备熄屏且不充电 60mins，同时设备不移动 30mins 了，这个时候，准备进入第三阶段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> STATE_IDLE_PENDING:</span><br><span class="line">    <span class="comment">//【2.2】熄屏且不充电 60mins，设备不移动 30mins 后，第二阶段条件满足，mState 为 STATE_IDLE_PENDING，</span></span><br><span class="line">    <span class="comment">// 那么我们会进入第三阶段！</span></span><br><span class="line">    mState = STATE_SENSING;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">"Moved from STATE_IDLE_PENDING to STATE_SENSING."</span>);</span><br><span class="line">    EventLogTags.writeDeviceIdle(mState, reason);</span><br><span class="line">    <span class="comment">//【3.1.2.1】启动角度监听！</span></span><br><span class="line">    scheduleSensingTimeoutAlarmLocked(mConstants.SENSING_TIMEOUT);</span><br><span class="line">    <span class="comment">//【1.1.1.1.3】取消定位监听，因为定位是下一个阶段的！</span></span><br><span class="line">    cancelLocatingLocked();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化一些变量！</span></span><br><span class="line">    mNotMoving = <span class="keyword">false</span>;</span><br><span class="line">    mLocated = <span class="keyword">false</span>;</span><br><span class="line">    mLastGenericLocation = <span class="keyword">null</span>;</span><br><span class="line">    mLastGpsLocation = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1.5】启动角度变化监听！</span></span><br><span class="line">    mAnyMotionDetector.checkForAnyMotion();</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>流程分析：</li>
</ul>
<p>通过 startMonitoringMotionLocked 启动了传感器监听，监听设备是否运动！</p>
<p>又<strong>设置了一个时间间隔为 mConstants.IDLE_AFTER_INACTIVE_TIMEOUT 30mins 的 Alarm，触发的仍然是 mDeepAlarmListener</strong>！</p>
<p><strong>mState 状态被设置为了 STATE_SENSING</strong>！</p>
<ul>
<li>第三阶段条件：</li>
</ul>
<p><strong>熄屏且不充电，设备不移动，设备没发生角度变化 4 mins</strong>，以后！</p>
<h4 id="3-1-2-1-DeviceIdleC-scheduleSensingTimeoutAlarmLocked"><a href="#3-1-2-1-DeviceIdleC-scheduleSensingTimeoutAlarmLocked" class="headerlink" title="3.1.2.1 DeviceIdleC.scheduleSensingTimeoutAlarmLocked"></a>3.1.2.1 DeviceIdleC.scheduleSensingTimeoutAlarmLocked</h4><p>接着设置第三阶段的 Alarm，参数传入的是 mConstants.SENSING_TIMEOUT 4mins：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleSensingTimeoutAlarmLocked</span><span class="params">(<span class="keyword">long</span> delay)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">"scheduleSensingAlarmLocked("</span> + delay + <span class="string">")"</span>);</span><br><span class="line"></span><br><span class="line">    mNextSensingTimeoutAlarmTime = SystemClock.elapsedRealtime() + delay;</span><br><span class="line">    <span class="comment">//【3.1.2.2】4mins 后触发 mSensingTimeoutAlarmListener！</span></span><br><span class="line">    mAlarmManager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP, mNextSensingTimeoutAlarmTime,</span><br><span class="line">        <span class="string">"DeviceIdleController.sensing"</span>, mSensingTimeoutAlarmListener, mHandler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接着，设置了一个新的 Alarm，Alarm 触发后，会执行 mSensingTimeoutAlarmListener.onAlarm 方法！</p>
<h4 id="3-1-2-2-mSensingTimeoutAlarmListener-onAlarm"><a href="#3-1-2-2-mSensingTimeoutAlarmListener-onAlarm" class="headerlink" title="3.1.2.2 mSensingTimeoutAlarmListener.onAlarm"></a>3.1.2.2 mSensingTimeoutAlarmListener.onAlarm</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AlarmManager.OnAlarmListener mSensingTimeoutAlarmListener</span><br><span class="line">        = <span class="keyword">new</span> AlarmManager.OnAlarmListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAlarm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mState == STATE_SENSING) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (DeviceIdleController.<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="comment">//【2.1】进入下一个阶段！</span></span><br><span class="line">                becomeInactiveIfAppropriateLocked();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当 mSensingTimeoutAlarmListener 触发后，继续进入了 becomeInactiveIfAppropriateLocked 方法！</p>
<h3 id="3-1-3-状态：STATE-SENSING-and-STATE-LOCATING-and-STATE-IDLE-MAINTENANCE"><a href="#3-1-3-状态：STATE-SENSING-and-STATE-LOCATING-and-STATE-IDLE-MAINTENANCE" class="headerlink" title="3.1.3 状态：STATE_SENSING and STATE_LOCATING and STATE_IDLE_MAINTENANCE"></a>3.1.3 状态：STATE_SENSING and STATE_LOCATING and STATE_IDLE_MAINTENANCE</h3><p>接下来，我们把 STATE_SENSING 和 STATE_LOCATING 和 STATE_IDLE_MAINTENANCE 放在一起看，因为这几个有关联！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> STATE_SENSING:</span><br><span class="line">    <span class="comment">//【2.3】熄屏且不充电，设备不移动，没发生角度变化 4 mins 后，第三阶段条件满足，</span></span><br><span class="line">    <span class="comment">// 此时 mState 为 STATE_SENSING，</span></span><br><span class="line">    <span class="comment">// 那么我们会进入第四阶段！</span></span><br><span class="line">    <span class="comment">//【1.1.1.1.2】取消 mSensingTimeoutAlarmListener！</span></span><br><span class="line">    cancelSensingTimeoutAlarmLocked();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置 mState 为 STATE_LOCATING！</span></span><br><span class="line">    mState = STATE_LOCATING;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">"Moved from STATE_SENSING to STATE_LOCATING."</span>);</span><br><span class="line">    EventLogTags.writeDeviceIdle(mState, reason);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【2.1.1.2】设置该阶段的 Alarm，时间间隔为 mConstants.LOCATING_TIMEOUT 30s！</span></span><br><span class="line">    scheduleAlarmLocked(mConstants.LOCATING_TIMEOUT, <span class="keyword">false</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注册定位监听器，如果注册成功，mLocating 为 true！</span></span><br><span class="line">    <span class="keyword">if</span> (mLocationManager != <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; mLocationManager.getProvider(LocationManager.NETWORK_PROVIDER) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mLocationManager.requestLocationUpdates(mLocationRequest,</span><br><span class="line">                mGenericLocationListener, mHandler.getLooper());</span><br><span class="line">        mLocating = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mHasNetworkLocation = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mLocationManager != <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; mLocationManager.getProvider(LocationManager.GPS_PROVIDER) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mHasGps = <span class="keyword">true</span>;</span><br><span class="line">        mLocationManager.requestLocationUpdates(LocationManager.GPS_PROVIDER, <span class="number">1000</span>, <span class="number">5</span>,</span><br><span class="line">                mGpsLocationListener, mHandler.getLooper());</span><br><span class="line">        mLocating = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mHasGps = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果注册成功， mLocating 为 true，那么就等定位的结果返回</span></span><br><span class="line">    <span class="comment">// 如果注册失败，系统中没有 location provider，那就直接进入 STATE_LOCATING 状态！</span></span><br><span class="line">    <span class="keyword">if</span> (mLocating) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> STATE_LOCATING:</span><br><span class="line">    <span class="comment">//【2.4】处理状态 STATE_LOCATING，这里会取消 Alarm，然后会直接进入 STATE_IDLE_MAINTENANCE</span></span><br><span class="line">    <span class="comment">//【5.1.1】取消 mDeepAlarmListener；</span></span><br><span class="line">    cancelAlarmLocked();</span><br><span class="line">    <span class="comment">//【5.1.3】取消 mGenericLocationListener，mGpsLocationListener；</span></span><br><span class="line">    cancelLocatingLocked();</span><br><span class="line">    <span class="comment">// 停止监听角度变化！</span></span><br><span class="line">    mAnyMotionDetector.stop();</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> STATE_IDLE_MAINTENANCE:</span><br><span class="line">    <span class="comment">//【2.5】处理状态 STATE_IDLE_MAINTENANCE，这里设置新的 Alarm，用于进入下一个 STATE_IDLE_MAINTENANCE；</span></span><br><span class="line">    <span class="comment">// 时间检测是 mNextIdleDelay，注意这里第二个参数是 true，会触发 mAlarmManager.setIdleUntil 方法！</span></span><br><span class="line">    scheduleAlarmLocked(mNextIdleDelay, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">"Moved to STATE_IDLE. Next alarm in "</span> + mNextIdleDelay +</span><br><span class="line">            <span class="string">" ms."</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算下一个 mNextIdleDelay 时间间隔，在当前的 mNextIdleDelay 基础上，乘以时间因子！</span></span><br><span class="line">    <span class="comment">// 然后在 mNextIdleDelay 和 mConstants.MAX_IDLE_TIMEOUT(6h) 中选择最小的值</span></span><br><span class="line">    <span class="comment">// 最后，在 mNextIdleDelay 和 mConstants.IDLE_TIMEOUT(60min) 中选择最大值</span></span><br><span class="line">    mNextIdleDelay = (<span class="keyword">long</span>)(mNextIdleDelay * mConstants.IDLE_FACTOR);</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">"Setting mNextIdleDelay = "</span> + mNextIdleDelay);</span><br><span class="line">    mNextIdleDelay = Math.min(mNextIdleDelay, mConstants.MAX_IDLE_TIMEOUT);</span><br><span class="line">    <span class="keyword">if</span> (mNextIdleDelay &lt; mConstants.IDLE_TIMEOUT) &#123;</span><br><span class="line">        mNextIdleDelay = mConstants.IDLE_TIMEOUT;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 同时，设置状态为 STATE_IDLE</span></span><br><span class="line">    mState = STATE_IDLE;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果此时 light idle 的状态，不为 LIGHT_STATE_OVERRIDE，由于现在要进入 deep idle 状态了</span></span><br><span class="line">    <span class="comment">// 所以 light idle 会失效，这里会取消 light idle 的 Alarm！</span></span><br><span class="line">    <span class="keyword">if</span> (mLightState != LIGHT_STATE_OVERRIDE) &#123;</span><br><span class="line">        mLightState = LIGHT_STATE_OVERRIDE;</span><br><span class="line">        cancelLightAlarmLocked();</span><br><span class="line">    &#125;</span><br><span class="line">    EventLogTags.writeDeviceIdle(mState, reason);</span><br><span class="line">    addEvent(EVENT_DEEP_IDLE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【4.1】进入 idle 状态！</span></span><br><span class="line">    mHandler.sendEmptyMessage(MSG_REPORT_IDLE_ON);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>1. STATE_SENSING</strong></li>
</ul>
<p>当熄屏且不充电，设备不移动，没发生角度变化 4 mins 后，就会进入 STATE_SENSING 阶段！</p>
<p>接着，会<strong>设置 mState 为 STATE_LOCATING</strong>，然后设置一个 30s 的 Alarm，如果在 30s 内，条件没有发生变化，那么会进入 STATE_LOCATING 阶段！</p>
<p>接着会注册定位监听器，如果注册成功，那就等待 30s 的 Alarm 触发；如果注册失败，那就直接进入 STATE_LOCATING；</p>
<p>所以该阶段设置的条件是：</p>
<ul>
<li>熄屏且不充电，设备不移动，没发生角度变化后，开始定位，保持 30s 以后；</li>
<li><p>熄屏且不充电，设备不移动，没发生角度变化后，直接进入下一个条件；</p>
</li>
<li><p><strong>2. STATE_LOCATING</strong></p>
</li>
</ul>
<p>该状态会直接取消 mDeepAlarmListener，mGenericLocationListener，mGpsLocationListener，同时停止监听角度变化！</p>
<p>然后会立刻进入 STATE_IDLE_MAINTENANCE 状态！</p>
<ul>
<li><strong>3. STATE_IDLE_MAINTENANCE</strong></li>
</ul>
<p>进入该阶段后，我们就即将进入 deep idle 状态了，接下来，如果所有条件都满足，那么，设备的状态将会在 STATE_IDLE_MAINTENANCE 和 STATE_IDLE 直接切换！</p>
<p>在 STATE_IDLE_MAINTENANCE 阶段，我们设置了一个 Alarm，时间间隔是 mNextIdleDelay, 在 STATE_INACTIVE 阶段 mNextIdleDelay 初始化为了</p>
<p>mConstants.IDLE_TIMEOUT(60mins)</p>
<p>第一次进入 STATE_IDLE_MAINTENANCE 阶段，我们的 Alarm 的时间间隔为 mConstants.IDLE_TIMEOUT(60mins)，接着对时间间隔 mNextIdleDelay 进行了调整，用于下一次设置 Alarm！</p>
<p>计算下一个 mNextIdleDelay 时间间隔，在当前的 mNextIdleDelay 基础上，乘以时间因子；然后在 mNextIdleDelay 和 mConstants.MAX_IDLE_TIMEOUT(6h) 中选择最小的值；在 mNextIdleDelay 和 mConstants.IDLE_TIMEOUT(60min) 中选择最大值<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mNextIdleDelay = (<span class="keyword">long</span>)(mNextIdleDelay * mConstants.IDLE_FACTOR);</span><br><span class="line">mNextIdleDelay = Math.min(mNextIdleDelay, mConstants.MAX_IDLE_TIMEOUT);</span><br><span class="line"><span class="keyword">if</span> (mNextIdleDelay &lt; mConstants.IDLE_TIMEOUT) &#123;</span><br><span class="line">    mNextIdleDelay = mConstants.IDLE_TIMEOUT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么，这个时间间隔为 mNextIdleDelay 的 Alarm 作用是什么呢？我们知道，当设备进入 doze 模式后，隔一段时间后，会进入一个 maintenance window 时间窗，这时，设备会从 idle 状态暂时恢复，集中处理任务！</p>
<p>所以这个时间间隔 mNextIdleDelay，既是 doze 模式的时间间隔，又是进入 maintenance window 的时间间隔！</p>
<p><strong>设置 mState 为 STATE_IDLE</strong>！</p>
<p>此时，设备已经进入了 idle 状态！</p>
<p>如果此时 light idle 的状态，不为 LIGHT_STATE_OVERRIDE，由于现在要进入 deep idle 状态了，所以 light idle 会失效，这里会取消 light idle 的 Alarm！</p>
<p>最后发送 MSG_REPORT_IDLE_ON 给 MyHandler，通知其他服务，设备进入了 idle 状态！</p>
<p>注意这里会调用 scheduleAlarmLocked 方法，但是第二个参数传入的是 true：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleAlarmLocked</span><span class="params">(<span class="keyword">long</span> delay, <span class="keyword">boolean</span> idleUntil)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (idleUntil) &#123;</span><br><span class="line">        <span class="comment">//【1】执行 setIdleUntil 方法！</span></span><br><span class="line">        mAlarmManager.setIdleUntil(AlarmManager.ELAPSED_REALTIME_WAKEUP,</span><br><span class="line">                mNextAlarmTime, <span class="string">"DeviceIdleController.deep"</span>, mDeepAlarmListener, mHandler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析 AlarmManagerService 的时候，我们又说过 setIdleUntil，该方法会让 AlarmManagerService 进入 doze 模式，直到该 Alarm 触发！该 Alarm 触发后，状态会变为 STATE_IDLE_MAINTENANCE，也就是进入时间窗，同时 Alarm 恢复了！</p>
<h3 id="3-1-4-状态：STATE-IDLE"><a href="#3-1-4-状态：STATE-IDLE" class="headerlink" title="3.1.4 状态：STATE_IDLE"></a>3.1.4 状态：STATE_IDLE</h3><p>当 mNextIdleDelay 时间间隔的 Alarm 触发后，设备会暂时退出 doze 模式，进入 maintenance window，集中处理任务！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> STATE_IDLE:</span><br><span class="line">    <span class="comment">//【2.5】处理状态 STATE_IDLE，这里会设置新的 Alarm，用于进入下一次 STATE_IDLE 状态！</span></span><br><span class="line">    <span class="comment">// 同时更新状态为 STATE_IDLE_MAINTENANCE，进入 maintenance window！</span></span><br><span class="line">    mActiveIdleOpCount = <span class="number">1</span>; <span class="comment">// 计数设置为 1；</span></span><br><span class="line">    mActiveIdleWakeLock.acquire();</span><br><span class="line">    scheduleAlarmLocked(mNextIdlePendingDelay, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">"Moved from STATE_IDLE to STATE_IDLE_MAINTENANCE. "</span> +</span><br><span class="line">            <span class="string">"Next alarm in "</span> + mNextIdlePendingDelay + <span class="string">" ms."</span>);</span><br><span class="line">            </span><br><span class="line">    <span class="comment">//【1】计算进入 maintenance window 的时间点！</span></span><br><span class="line">    mMaintenanceStartTime = SystemClock.elapsedRealtime();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【2】计算下一次进入 deep idle 状态的 Alarm 时间间隔！</span></span><br><span class="line">    mNextIdlePendingDelay = Math.min(mConstants.MAX_IDLE_PENDING_TIMEOUT,</span><br><span class="line">            (<span class="keyword">long</span>)(mNextIdlePendingDelay * mConstants.IDLE_PENDING_FACTOR));</span><br><span class="line">    <span class="keyword">if</span> (mNextIdlePendingDelay &lt; mConstants.IDLE_PENDING_TIMEOUT) &#123;</span><br><span class="line">        mNextIdlePendingDelay = mConstants.IDLE_PENDING_TIMEOUT;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【3】设置状态为 STATE_IDLE_MAINTENANCE！</span></span><br><span class="line">    mState = STATE_IDLE_MAINTENANCE;</span><br><span class="line">    EventLogTags.writeDeviceIdle(mState, reason);</span><br><span class="line">    addEvent(EVENT_DEEP_MAINTENANCE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【4.1】退出 idle 状态！</span></span><br><span class="line">    mHandler.sendEmptyMessage(MSG_REPORT_IDLE_OFF);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>进入该阶段后，我们就即将进入 maintenance window 了！</p>
<p>mActiveIdleOpCount 用于统计进入 maintenance window 的次数！</p>
<p>在 STATE_IDLE 阶段，我们再次设置了一个 Alarm，时间间隔是 mNextIdlePendingDelay, 在 STATE_INACTIVE 阶段 mNextIdleDelay 初始化为了</p>
<p>mConstants.IDLE_TIMEOUT(60mins)</p>
<p>第一次进入 STATE_IDLE_MAINTENANCE 阶段，我们的 Alarm 的时间间隔为 mConstants.IDLE_PENDING_TIMEOUT(5mins)，接着对时间间隔 mNextIdlePendingDelay 进行了调整，用于下一次设置 Alarm！</p>
<ul>
<li>计算下一个 mNextIdlePendingDelay 时间间隔：</li>
</ul>
<p>在当前的 mNextIdlePendingDelay 基础上，乘以时间因子；然后在 mNextIdlePendingDelay 和 mConstants.MAX_IDLE_PENDING_TIMEOUT(10mins) 中选择最小的值；在 mNextIdlePendingDelay 和 mConstants.IDLE_PENDING_TIMEOUT(5mins) 中选择最大值：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mNextIdlePendingDelay = Math.min(mConstants.MAX_IDLE_PENDING_TIMEOUT,</span><br><span class="line">        (<span class="keyword">long</span>)(mNextIdlePendingDelay * mConstants.IDLE_PENDING_FACTOR));</span><br><span class="line"><span class="keyword">if</span> (mNextIdlePendingDelay &lt; mConstants.IDLE_PENDING_TIMEOUT) &#123;</span><br><span class="line">    mNextIdlePendingDelay = mConstants.IDLE_PENDING_TIMEOUT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么，这个时间间隔为 mNextIdlePendingDelay 的 Alarm 作用是什么呢？</p>
<ul>
<li>我们知道，当设备进入 maintenance window 时间窗后，会退出 idle 状态，这时，设备会集中处理任务，但是设备在 maintenance window 时间窗结束后，又要进入 deep idle 状态的！</li>
<li>所以这个时间间隔 mNextIdlePendingDelay，既是 deep idle 模式的maintenance window 时间窗长度，又是再次进入 idle 的时间间隔！</li>
</ul>
<p>最后发送 MSG_REPORT_IDLE_OFF 给 MyHandler，同时其他服务，设备退出了 idle 状态！</p>
<h2 id="3-2-DeviceIdleC-stepLightIdleStateLocked"><a href="#3-2-DeviceIdleC-stepLightIdleStateLocked" class="headerlink" title="3.2 DeviceIdleC.stepLightIdleStateLocked"></a>3.2 DeviceIdleC.stepLightIdleStateLocked</h2><p>看完了 deep idle 的状态调度，我们来看看 light idle 的状态调度！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stepLightIdleStateLocked</span><span class="params">(String reason)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】如果 mLightState 为 LIGHT_STATE_OVERRIDE，说明我们已经处于 deep idle 状态了！</span></span><br><span class="line">    <span class="comment">// 那么忽略 light idle！</span></span><br><span class="line">    <span class="keyword">if</span> (mLightState == LIGHT_STATE_OVERRIDE) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">"stepLightIdleStateLocked: mLightState="</span> + mLightState);</span><br><span class="line">    EventLogTags.writeDeviceIdleLightStep();</span><br><span class="line">    <span class="comment">//【2】处理 mLightState 的状态！</span></span><br><span class="line">    <span class="keyword">switch</span> (mLightState) &#123;</span><br><span class="line">        <span class="keyword">case</span> LIGHT_STATE_INACTIVE:</span><br><span class="line">            ... ... ...</span><br><span class="line">        <span class="keyword">case</span> LIGHT_STATE_PRE_IDLE:</span><br><span class="line">        <span class="keyword">case</span> LIGHT_STATE_IDLE_MAINTENANCE:</span><br><span class="line">            ... ... ...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">case</span> LIGHT_STATE_IDLE:</span><br><span class="line">        <span class="keyword">case</span> LIGHT_STATE_WAITING_FOR_NETWORK:</span><br><span class="line">            ... ... ...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续看！</p>
<h3 id="3-1-1-状态：LIGHT-STATE-INACTIVE"><a href="#3-1-1-状态：LIGHT-STATE-INACTIVE" class="headerlink" title="3.1.1 状态：LIGHT_STATE_INACTIVE"></a>3.1.1 状态：LIGHT_STATE_INACTIVE</h3><p>如果是熄屏并且没有充电的充电的情况下，或者是强制进入 idle 状态下，mLightState 会从 LIGHT_STATE_ACTIVE 变为 LIGHT_STATE_INACTIVE</p>
<p>同时会设置一个 Alarm，时间间隔为 mConstants.LIGHT_IDLE_AFTER_INACTIVE_TIMEOUT 为(5 mins)，Alarm 触发后 mLightAlarmListener.onAlarm 方法会被回调，进入 stepLightIdleStateLocked！</p>
<p>我们来看看 LIGHT_STATE_INACTIVE 状态的处理！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> LIGHT_STATE_INACTIVE:</span><br><span class="line">    mCurIdleBudget = mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】重置了 mNextLightIdleDelay 和 mMaintenanceStartTime</span></span><br><span class="line">    <span class="comment">// 后面设置时间窗会用到！</span></span><br><span class="line">    mNextLightIdleDelay = mConstants.LIGHT_IDLE_TIMEOUT;</span><br><span class="line">    mMaintenanceStartTime = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【2】判断当前设备是否还有任务和操作要执行！</span></span><br><span class="line">    <span class="keyword">if</span> (!isOpsInactiveLocked()) &#123;</span><br><span class="line">        <span class="comment">// 如果还有任务要执行，那就不能直接进入 LIGHT_STATE_PRE_IDLE 状态</span></span><br><span class="line">        <span class="comment">// 而是设置了一个 Alarm，等待任务执行完！</span></span><br><span class="line">        <span class="comment">//【2.1】设置 mLightState 为 LIGHT_STATE_PRE_IDLE！</span></span><br><span class="line">        mLightState = LIGHT_STATE_PRE_IDLE;</span><br><span class="line">        EventLogTags.writeDeviceIdleLight(mLightState, reason);</span><br><span class="line">        <span class="comment">//【2.1.2.1】设置 Alarm！</span></span><br><span class="line">        scheduleLightAlarmLocked(mConstants.LIGHT_PRE_IDLE_TIMEOUT);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【3】没有任务在做，直接进入下一阶段！</span></span><br><span class="line"><span class="keyword">case</span> LIGHT_STATE_PRE_IDLE:</span><br></pre></td></tr></table></figure></p>
<p>这里调用了 isOpsInactiveLocked 方法，用于判断当前设备是否还有任务和操作要执行！</p>
<ul>
<li><p>当其返回 false 时，说明当前设备还有任务和操作要执行！</p>
<ul>
<li>那么就不能直接进入 LIGHT_STATE_IDLE 状态，这里先设置为 LIGHT_STATE_PRE_IDLE，可以看作是 idle 前的一个临时状态！</li>
<li>同时 scheduleLightAlarmLocked 设置了一个时间间隔为 mConstants.LIGHT_PRE_IDLE_TIMEOUT(10mins) 的 Alarm，等待那些要执行的工作执行完成，然后进入下一个阶段的处理！</li>
</ul>
</li>
</ul>
<ul>
<li><p>当其返回 true 时，说明当前设备没有任务和操作要执行了！</p>
<ul>
<li>那么这种情况，直接进入 idle 状态，具体的逻辑处理是在 3.1.2 LIGHT_STATE_PRE_IDLE/LIGHT_STATE_IDLE_MAINTENANCE 里！</li>
</ul>
</li>
</ul>
<h3 id="3-1-2-状态：LIGHT-STATE-PRE-IDLE-and-LIGHT-STATE-IDLE-MAINTENANCE"><a href="#3-1-2-状态：LIGHT-STATE-PRE-IDLE-and-LIGHT-STATE-IDLE-MAINTENANCE" class="headerlink" title="3.1.2 状态：LIGHT_STATE_PRE_IDLE and LIGHT_STATE_IDLE_MAINTENANCE"></a>3.1.2 状态：LIGHT_STATE_PRE_IDLE and LIGHT_STATE_IDLE_MAINTENANCE</h3><p>进入该阶段有两种情况：</p>
<ul>
<li>设备没有任务和操作要执行，从 LIGHT_STATE_INACTIVE 直接进入；</li>
<li>设备没有任务和操作要执行，Alarm 触发后，从 LIGHT_STATE_PRE_IDLE 进入；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Nothing active, fall through to immediately idle.</span></span><br><span class="line"><span class="keyword">case</span> LIGHT_STATE_PRE_IDLE:</span><br><span class="line"><span class="keyword">case</span> LIGHT_STATE_IDLE_MAINTENANCE:</span><br><span class="line">    <span class="comment">//【1】根据 mMaintenanceStartTime 调整 mCurIdleBudget！</span></span><br><span class="line">    <span class="keyword">if</span> (mMaintenanceStartTime != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">long</span> duration = SystemClock.elapsedRealtime() - mMaintenanceStartTime;</span><br><span class="line">        <span class="keyword">if</span> (duration &lt; mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET) &#123;</span><br><span class="line">            <span class="comment">// We didn't use up all of our minimum budget; add this to the reserve.</span></span><br><span class="line">            mCurIdleBudget += (mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET-duration);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// We used more than our minimum budget; this comes out of the reserve.</span></span><br><span class="line">            mCurIdleBudget -= (duration-mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mMaintenanceStartTime = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】设置一个新的 Alarm，时间间隔为 mNextLightIdleDelay，mNextLightIdleDelay 默认为</span></span><br><span class="line">    <span class="comment">// mConstants.LIGHT_IDLE_TIMEOUT(5mins)</span></span><br><span class="line">    scheduleLightAlarmLocked(mNextLightIdleDelay);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【3】计算下一次 Alarm 的时间间隔！</span></span><br><span class="line">    mNextLightIdleDelay = Math.min(mConstants.LIGHT_MAX_IDLE_TIMEOUT,</span><br><span class="line">            (<span class="keyword">long</span>)(mNextLightIdleDelay * mConstants.LIGHT_IDLE_FACTOR));</span><br><span class="line">    <span class="keyword">if</span> (mNextLightIdleDelay &lt; mConstants.LIGHT_IDLE_TIMEOUT) &#123;</span><br><span class="line">        mNextLightIdleDelay = mConstants.LIGHT_IDLE_TIMEOUT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">"Moved to LIGHT_STATE_IDLE."</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【4】设置 mLightState 为 LIGHT_STATE_IDLE，进入 light idle 状态！</span></span><br><span class="line">    mLightState = LIGHT_STATE_IDLE;</span><br><span class="line">    EventLogTags.writeDeviceIdleLight(mLightState, reason);</span><br><span class="line">    addEvent(EVENT_LIGHT_IDLE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【4.2】发送 MSG_REPORT_IDLE_ON_LIGHT 给 MyHandler，进入 light idle 状态！</span></span><br><span class="line">    mHandler.sendEmptyMessage(MSG_REPORT_IDLE_ON_LIGHT);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>该阶段，我们将 mLightState 设置为了 LIGHT_STATE_IDLE，表示已经进入了 light idle 状态！</p>
<p>接着，设置一个 Alarm，时间间隔为 mNextLightIdleDelay，第一次设置的时候 mNextLightIdleDelay 使用的默认值 mConstants.LIGHT_IDLE_TIMEOUT(5mins)！</p>
<p>然后计算下一个 mNextLightIdleDelay 时间间隔：</p>
<ul>
<li>在当前的 mNextLightIdleDelay 基础上，乘以时间因子；</li>
<li>然后在 mNextLightIdleDelay 和 mConstants.LIGHT_MAX_IDLE_TIMEOUT(15mins) 中选择最小的值；</li>
<li>在 mNextIdleDelay 和 mConstants.LIGHT_IDLE_TIMEOUT(5mins) 中选择最大值：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mNextLightIdleDelay = Math.min(mConstants.LIGHT_MAX_IDLE_TIMEOUT,</span><br><span class="line">        (<span class="keyword">long</span>)(mNextLightIdleDelay * mConstants.LIGHT_IDLE_FACTOR));</span><br><span class="line"><span class="keyword">if</span> (mNextLightIdleDelay &lt; mConstants.LIGHT_IDLE_TIMEOUT) &#123;</span><br><span class="line">    mNextLightIdleDelay = mConstants.LIGHT_IDLE_TIMEOUT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个时间间隔 mNextLightIdleDelay，既是 light idle 模式的 idle 状态时间间隔，又是进入 maintenance window 的时间间隔！</p>
<p>等待 alarm 触发，进入下一阶段！</p>
<h3 id="3-1-3-状态：LIGHT-STATE-IDLE-and-LIGHT-STATE-WAITING-FOR-NETWORK"><a href="#3-1-3-状态：LIGHT-STATE-IDLE-and-LIGHT-STATE-WAITING-FOR-NETWORK" class="headerlink" title="3.1.3 状态：LIGHT_STATE_IDLE and LIGHT_STATE_WAITING_FOR_NETWORK"></a>3.1.3 状态：LIGHT_STATE_IDLE and LIGHT_STATE_WAITING_FOR_NETWORK</h3><p>接着我们来看下对于 LIGHT_STATE_IDLE 和 LIGHT_STATE_WAITING_FOR_NETWORK 的处理，当 light idle 时间间隔过去后，会进入 maintenance window，执行任务！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> LIGHT_STATE_IDLE:</span><br><span class="line"><span class="keyword">case</span> LIGHT_STATE_WAITING_FOR_NETWORK:</span><br><span class="line">    <span class="keyword">if</span> (mNetworkConnected || mLightState == LIGHT_STATE_WAITING_FOR_NETWORK) &#123;</span><br><span class="line">        <span class="comment">//【1】如果此时网络连接，或者 mLightState 的状态为 LIGHT_STATE_WAITING_FOR_NETWORK</span></span><br><span class="line">        <span class="comment">// 此时 Alarm 已经触发，进入 maintenance window 时间窗，执行任务！</span></span><br><span class="line">        mActiveIdleOpCount = <span class="number">1</span>; <span class="comment">// mActiveIdleOpCount 置为 1；</span></span><br><span class="line">        mActiveIdleWakeLock.acquire();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【2】计算当前的 maintenance window 的开始时间</span></span><br><span class="line">        mMaintenanceStartTime = SystemClock.elapsedRealtime();</span><br><span class="line">        <span class="keyword">if</span> (mCurIdleBudget &lt; mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET) &#123;</span><br><span class="line">            mCurIdleBudget = mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mCurIdleBudget &gt; mConstants.LIGHT_IDLE_MAINTENANCE_MAX_BUDGET) &#123;</span><br><span class="line">            mCurIdleBudget = mConstants.LIGHT_IDLE_MAINTENANCE_MAX_BUDGET;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【3】再次设置 Alarm，时间间隔为 mCurIdleBudget，该 Alarm 用于再次进入 idle 状态！</span></span><br><span class="line">        scheduleLightAlarmLocked(mCurIdleBudget);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (DEBUG) Slog.d(TAG,</span><br><span class="line">                <span class="string">"Moved from LIGHT_STATE_IDLE to LIGHT_STATE_IDLE_MAINTENANCE."</span>);</span><br><span class="line">                </span><br><span class="line">        <span class="comment">// 设置 mLightState 为 LIGHT_STATE_IDLE_MAINTENANCE，表示此时处于时间窗中！</span></span><br><span class="line">        mLightState = LIGHT_STATE_IDLE_MAINTENANCE;</span><br><span class="line"></span><br><span class="line">        EventLogTags.writeDeviceIdleLight(mLightState, reason);</span><br><span class="line">        addEvent(EVENT_LIGHT_MAINTENANCE);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【4.3】发送 MSG_REPORT_IDLE_OFF 给 MyHandler，通知其他服务，退出 idle 状态！</span></span><br><span class="line">        mHandler.sendEmptyMessage(MSG_REPORT_IDLE_OFF);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//【2】此时本应该进入 maintenance window，执行任务，但是由于没有网络连接，那么需要等待网络连接</span></span><br><span class="line">        <span class="comment">// 设置一个 Alarm，时间间隔为 mNextLightIdleDelay，等待网络连接！</span></span><br><span class="line">        <span class="comment">// 如果在 Alarm 触发之前，网络连接了，那么会再次触发 stepLightIdleStateLocked 方法！</span></span><br><span class="line">        <span class="comment">// 如果在 Alarm 触发时，网络仍然没有连接，那就会直接进入 maintenance window 时间窗，执行任务！</span></span><br><span class="line">        scheduleLightAlarmLocked(mNextLightIdleDelay);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">"Moved to LIGHT_WAITING_FOR_NETWORK."</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置 mLightState 为 LIGHT_STATE_WAITING_FOR_NETWORK</span></span><br><span class="line">        mLightState = LIGHT_STATE_WAITING_FOR_NETWORK;</span><br><span class="line">        EventLogTags.writeDeviceIdleLight(mLightState, reason);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></p>
<p>我们分析下流程：</p>
<p>此时 idle 状态时间到了，需要进入时间窗执行任务，这里会对 network state 和 mLightState 进行一个判断：</p>
<ul>
<li>如果 mNetworkConnected 为 true 或者 mLightState == LIGHT_STATE_WAITING_FOR_NETWOR：<ul>
<li>表示当前网络已经连接，或者当前网络没有连接但是 light idle 正在等待网络，那么就进入 maintenance window 时间窗，执行任务！</li>
<li>同时设置 mLightState 为 LIGHT_STATE_IDLE_MAINTENANCE；</li>
<li>接着设置了一个 再次设置 Alarm，时间间隔为 mCurIdleBudget，该 Alarm 用于再次进入 idle 状态！时间间隔 mCurIdleBudget 取值在 [mConstants.LIGHT_IDLE_MAINTENANCE_MIN_BUDGET(1mins), mConstants.LIGHT_IDLE_MAINTENANCE_MAX_BUDGET(5mins)] 之间！</li>
<li>最后发送 MSG_REPORT_IDLE_OFF 给 MyHandler，通知其他服务，退出 idle 状态！！</li>
</ul>
</li>
</ul>
<p><br></p>
<ul>
<li>如果 mNetworkConnected 为 false 且 mLightState != LIGHT_STATE_WAITING_FOR_NETWOR:<ul>
<li>那么这个时候，light idle 状态不会立刻进入 maintenance window 时间窗；</li>
<li>会设置一个时间间隔 mNextLightIdleDelay 的 Alarm，等待网络连接；</li>
<li>同时设置 mLightState 为 LIGHT_STATE_WAITING_FOR_NETWORK；<ul>
<li>如果在 Alarm 触发之前，网络连接了，那么会再次触发 stepLightIdleStateLocked 方法，进入 if 分支！</li>
<li>如果在 Alarm 触发时，网络仍然没有连接，那就会直接进入 if 分支！ </li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="4-MyHandler-逻辑分析"><a href="#4-MyHandler-逻辑分析" class="headerlink" title="4 MyHandler 逻辑分析"></a>4 MyHandler 逻辑分析</h1><p>我们来看下 MyHandler 逻辑分析：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    MyHandler(Looper looper) &#123;</span><br><span class="line">        <span class="keyword">super</span>(looper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">"handleMessage("</span> + msg.what + <span class="string">")"</span>);</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="keyword">case</span> MSG_WRITE_CONFIG: &#123;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">case</span> MSG_REPORT_IDLE_ON:</span><br><span class="line">            <span class="keyword">case</span> MSG_REPORT_IDLE_ON_LIGHT: &#123;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">case</span> MSG_REPORT_IDLE_OFF: &#123;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">case</span> MSG_REPORT_ACTIVE: &#123;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">case</span> MSG_TEMP_APP_WHITELIST_TIMEOUT: &#123;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">case</span> MSG_REPORT_MAINTENANCE_ACTIVITY: &#123;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">case</span> MSG_FINISH_IDLE_OP: &#123;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面分析下每个消息的具体处理！</p>
<h2 id="4-1-消息：MSG-WRITE-CONFIG"><a href="#4-1-消息：MSG-WRITE-CONFIG" class="headerlink" title="4.1 消息：MSG_WRITE_CONFIG"></a>4.1 消息：MSG_WRITE_CONFIG</h2><p>更新本地持久化文件：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> MSG_WRITE_CONFIG: &#123;</span><br><span class="line">    <span class="comment">//【4.1.1】持久化文件！</span></span><br><span class="line">    handleWriteConfigFile();</span><br><span class="line">&#125; <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="4-1-1-handleWriteConfigFile"><a href="#4-1-1-handleWriteConfigFile" class="headerlink" title="4.1.1 handleWriteConfigFile"></a>4.1.1 handleWriteConfigFile</h3><p>更新本地持久化文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleWriteConfigFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ByteArrayOutputStream memStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            XmlSerializer out = <span class="keyword">new</span> FastXmlSerializer();</span><br><span class="line">            out.setOutput(memStream, StandardCharsets.UTF_8.name());</span><br><span class="line">            writeConfigFileLocked(out);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mConfigFile) &#123;</span><br><span class="line">        FileOutputStream stream = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stream = mConfigFile.startWrite();</span><br><span class="line">            memStream.writeTo(stream);</span><br><span class="line">            stream.flush();</span><br><span class="line">            FileUtils.sync(stream);</span><br><span class="line">            stream.close();</span><br><span class="line">            mConfigFile.finishWrite(stream);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Error writing config file"</span>, e);</span><br><span class="line">            mConfigFile.failWrite(stream);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后调用 writeConfigFileLocked 方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeConfigFileLocked</span><span class="params">(XmlSerializer out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    out.startDocument(<span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">    out.startTag(<span class="keyword">null</span>, <span class="string">"config"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;mPowerSaveWhitelistUserApps.size(); i++) &#123;</span><br><span class="line">        String name = mPowerSaveWhitelistUserApps.keyAt(i);</span><br><span class="line">        out.startTag(<span class="keyword">null</span>, <span class="string">"wl"</span>);</span><br><span class="line">        out.attribute(<span class="keyword">null</span>, <span class="string">"n"</span>, name);</span><br><span class="line">        out.endTag(<span class="keyword">null</span>, <span class="string">"wl"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    out.endTag(<span class="keyword">null</span>, <span class="string">"config"</span>);</span><br></pre></td></tr></table></figure></p>
<p>每一个白名单都是以 wl 标签开始和结束，n 属性为包名！</p>
<h2 id="4-2-消息：MSG-REPORT-IDLE-ON-and-MSG-REPORT-IDLE-ON-LIGHT"><a href="#4-2-消息：MSG-REPORT-IDLE-ON-and-MSG-REPORT-IDLE-ON-LIGHT" class="headerlink" title="4.2 消息：MSG_REPORT_IDLE_ON and MSG_REPORT_IDLE_ON_LIGHT"></a>4.2 消息：MSG_REPORT_IDLE_ON and MSG_REPORT_IDLE_ON_LIGHT</h2><p>进入 doze 模式，MSG_REPORT_IDLE_ON 表示的是 deep idle，而 MSG_REPORT_IDLE_ON_LIGHT 而是 light idle！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> MSG_REPORT_IDLE_ON:</span><br><span class="line"><span class="keyword">case</span> MSG_REPORT_IDLE_ON_LIGHT: &#123; <span class="comment">// 进入 idle 状态！</span></span><br><span class="line">    EventLogTags.writeDeviceIdleOnStart();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> deepChanged;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> lightChanged;</span><br><span class="line">    <span class="comment">//【1】针对于 deep 和 light，PowerManager 做不同的处理！</span></span><br><span class="line">    <span class="keyword">if</span> (msg.what == MSG_REPORT_IDLE_ON) &#123;</span><br><span class="line">        <span class="comment">//【1.1】进入 deep idle！</span></span><br><span class="line">        deepChanged = mLocalPowerManager.setDeviceIdleMode(<span class="keyword">true</span>);</span><br><span class="line">        lightChanged = mLocalPowerManager.setLightDeviceIdleMode(<span class="keyword">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//【1.2】进入 light idle！</span></span><br><span class="line">        deepChanged = mLocalPowerManager.setDeviceIdleMode(<span class="keyword">false</span>);</span><br><span class="line">        lightChanged = mLocalPowerManager.setLightDeviceIdleMode(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【2】NetworkPolicy 和 BatteryStats 设置不同的状态；</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mNetworkPolicyManager.setDeviceIdleMode(<span class="keyword">true</span>);</span><br><span class="line">        mBatteryStats.noteDeviceIdleMode(msg.what == MSG_REPORT_IDLE_ON</span><br><span class="line">                ? BatteryStats.DEVICE_IDLE_MODE_DEEP</span><br><span class="line">                : BatteryStats.DEVICE_IDLE_MODE_LIGHT, <span class="keyword">null</span>, Process.myUid());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【3】发送广播，给监听 doze 模式的进程！</span></span><br><span class="line">    <span class="keyword">if</span> (deepChanged) &#123;</span><br><span class="line">        getContext().sendBroadcastAsUser(mIdleIntent, UserHandle.ALL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (lightChanged) &#123;</span><br><span class="line">        getContext().sendBroadcastAsUser(mLightIdleIntent, UserHandle.ALL);</span><br><span class="line">    &#125;</span><br><span class="line">    EventLogTags.writeDeviceIdleOnComplete();</span><br><span class="line">&#125; <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>在进入 idle 状态的时候，我们会发送相应的广播！！</p>
<h2 id="4-3-消息：MSG-REPORT-IDLE-OFF"><a href="#4-3-消息：MSG-REPORT-IDLE-OFF" class="headerlink" title="4.3 消息：MSG_REPORT_IDLE_OFF"></a>4.3 消息：MSG_REPORT_IDLE_OFF</h2><p>MSG_REPORT_IDLE_OFF 表示暂时退出 idle 状态，进入了时间窗，执行任务！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> MSG_REPORT_IDLE_OFF: &#123;</span><br><span class="line">    EventLogTags.writeDeviceIdleOffStart(<span class="string">"unknown"</span>);</span><br><span class="line">    <span class="comment">//【1】退出 deep idle 和 light idle 模式，更新 PowerManager 状态！</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> deepChanged = mLocalPowerManager.setDeviceIdleMode(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> lightChanged = mLocalPowerManager.setLightDeviceIdleMode(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mNetworkPolicyManager.setDeviceIdleMode(<span class="keyword">false</span>);</span><br><span class="line">        mBatteryStats.noteDeviceIdleMode(BatteryStats.DEVICE_IDLE_MODE_OFF,</span><br><span class="line">                <span class="keyword">null</span>, Process.myUid());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】如果 deep idle(light idle) 状态发生了变化，那就更新 mActiveIdleOpCount 计数；</span></span><br><span class="line">    <span class="comment">// 同时有序发送通知广播，最后自身也会接受广播！</span></span><br><span class="line">    <span class="keyword">if</span> (deepChanged) &#123;</span><br><span class="line">        <span class="comment">//【4.3.1】增加引用计数 mActiveIdleOpCount！</span></span><br><span class="line">        incActiveIdleOps();</span><br><span class="line">        <span class="comment">//【4.3.2】自身也会监听 doze 模式变化的广播！</span></span><br><span class="line">        getContext().sendOrderedBroadcastAsUser(mIdleIntent, UserHandle.ALL,</span><br><span class="line">                <span class="keyword">null</span>, mIdleStartedDoneReceiver, <span class="keyword">null</span>, <span class="number">0</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (lightChanged) &#123;</span><br><span class="line">        incActiveIdleOps(); <span class="comment">// 同上！</span></span><br><span class="line">        getContext().sendOrderedBroadcastAsUser(mLightIdleIntent, UserHandle.ALL,</span><br><span class="line">                <span class="keyword">null</span>, mIdleStartedDoneReceiver, <span class="keyword">null</span>, <span class="number">0</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【4.3.3】减少 mActiveIdleOpCount 计数，尝试提前退出时间窗！</span></span><br><span class="line">    decActiveIdleOps();</span><br><span class="line"></span><br><span class="line">    EventLogTags.writeDeviceIdleOffComplete();</span><br><span class="line">&#125; <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>处理 MSG_REPORT_IDLE_OFF 消息比较特殊，这里我们是有序的发送广播，同时在发送 mIdleIntent 或者 mLightIdleIntent 广播的时候，我们额外传入了 mIdleStartedDoneReceiver，是最后有序队列中的最后一个接收者：</p>
<h3 id="4-3-1-IdleStartedDoneReceiver"><a href="#4-3-1-IdleStartedDoneReceiver" class="headerlink" title="4.3.1 IdleStartedDoneReceiver"></a>4.3.1 IdleStartedDoneReceiver</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BroadcastReceiver mIdleStartedDoneReceiver = <span class="keyword">new</span> BroadcastReceiver() &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED.equals(intent.getAction())) &#123;</span><br><span class="line">            <span class="comment">//【4.7】如果是 deep idle 模式发生了变化，延迟 mConstants.MIN_DEEP_MAINTENANCE_TIME(30s)</span></span><br><span class="line">            <span class="comment">// 发送 MSG_FINISH_IDLE_OP 消息！</span></span><br><span class="line">            mHandler.sendEmptyMessageDelayed(MSG_FINISH_IDLE_OP,</span><br><span class="line">                    mConstants.MIN_DEEP_MAINTENANCE_TIME);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//【4.7】如果是 light idle 模式发生了变化，延迟 mConstants.MIN_LIGHT_MAINTENANCE_TIME(5s) </span></span><br><span class="line">            <span class="comment">// 发送 MSG_FINISH_IDLE_OP 消息！</span></span><br><span class="line">            mHandler.sendEmptyMessageDelayed(MSG_FINISH_IDLE_OP,</span><br><span class="line">                    mConstants.MIN_LIGHT_MAINTENANCE_TIME);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于暂时退出 idle 状态来说，mIdleIntent 或者 mLightIdleIntent 广播的时候，除了要发送给其他服务，DeviceIdleController 自身作为最后一个接收者，也会接受该广播！</p>
<p>当 DeviceIdleController 接收到广播后，会判断下是退出 deep idle 还是 light idle 状态！</p>
<ul>
<li>如果退出 deep idle，延迟延迟 mConstants.MIN_DEEP_MAINTENANCE_TIME (30s)，发送 MSG_FINISH_IDLE_OP 消息给 MyHandler；</li>
<li>如果退出 light idle，延迟延迟  mConstants.MIN_LIGHT_MAINTENANCE_TIME (5s)，发送 MSG_FINISH_IDLE_OP 消息给 MyHandler；</li>
</ul>
<p>MyHandler 在接收到 MSG_FINISH_IDLE_OP 消息后，会减少 mActiveIdleOpCount 计数，同时会尝试提前退出时间窗！</p>
<h3 id="4-3-2-incActiveIdleOps"><a href="#4-3-2-incActiveIdleOps" class="headerlink" title="4.3.2 incActiveIdleOps"></a>4.3.2 incActiveIdleOps</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">incActiveIdleOps</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        mActiveIdleOpCount++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>incActiveIdleOps 主要是将 mActiveIdleOpCount 加 1，表示此时我们进入时间窗，执行相关的操作；</p>
<h3 id="4-3-3-decActiveIdleOps"><a href="#4-3-3-decActiveIdleOps" class="headerlink" title="4.3.3 decActiveIdleOps"></a>4.3.3 decActiveIdleOps</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decActiveIdleOps</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        mActiveIdleOpCount--;</span><br><span class="line">        <span class="keyword">if</span> (mActiveIdleOpCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//【4.3.2.1】尝试提前退出时间窗！</span></span><br><span class="line">            exitMaintenanceEarlyIfNeededLocked();</span><br><span class="line">            mActiveIdleWakeLock.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>decActiveIdleOps 方法会先将 mActiveIdleOpCount 减 1；如果此时 mActiveIdleOpCount &lt;= 0，那么会尝试提前退出时间窗：</p>
<h4 id="4-3-2-1-exitMaintenanceEarlyIfNeededLocked-提前退出时间窗"><a href="#4-3-2-1-exitMaintenanceEarlyIfNeededLocked-提前退出时间窗" class="headerlink" title="4.3.2.1 exitMaintenanceEarlyIfNeededLocked - 提前退出时间窗"></a>4.3.2.1 exitMaintenanceEarlyIfNeededLocked - 提前退出时间窗</h4><p>我们来看尝试提前退出时间窗的逻辑！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exitMaintenanceEarlyIfNeededLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】首先，对状态做一个判断！</span></span><br><span class="line">    <span class="keyword">if</span> (mState == STATE_IDLE_MAINTENANCE || mLightState == LIGHT_STATE_IDLE_MAINTENANCE</span><br><span class="line">            || mLightState == LIGHT_STATE_PRE_IDLE) &#123;</span><br><span class="line">        <span class="comment">//【4.3.2.2】判断时间窗内是否还有任务执行，如果返回 true，表明可以提前退出时间窗！</span></span><br><span class="line">        <span class="keyword">if</span> (isOpsInactiveLocked()) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.elapsedRealtime();</span><br><span class="line">            <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">                StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                sb.append(<span class="string">"Exit: start="</span>);</span><br><span class="line">                TimeUtils.formatDuration(mMaintenanceStartTime, sb);</span><br><span class="line">                sb.append(<span class="string">" now="</span>);</span><br><span class="line">                TimeUtils.formatDuration(now, sb);</span><br><span class="line">                Slog.d(TAG, sb.toString());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【2】如果是 deep idle 模式，且状态为 STATE_IDLE_MAINTENANCE，调用 stepIdleStateLocked</span></span><br><span class="line">            <span class="comment">// 提前退出时间窗，如果是 light idle 模式，调用 stepLightIdleStateLocked 退出时间窗！</span></span><br><span class="line">            <span class="keyword">if</span> (mState == STATE_IDLE_MAINTENANCE) &#123;</span><br><span class="line">                stepIdleStateLocked(<span class="string">"s:early"</span>); <span class="comment">//【3.1】</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mLightState == LIGHT_STATE_PRE_IDLE) &#123;</span><br><span class="line">                stepLightIdleStateLocked(<span class="string">"s:predone"</span>);<span class="comment">//【3.2】</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stepLightIdleStateLocked(<span class="string">"s:early"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>提前退出时间窗的意义在于，很可能在很短的时间内，时间窗内的工作已经完成了，我们就没有必要等到时间窗结束了！</p>
<p>首先对状态做了判断：</p>
<ul>
<li>deep idle 为 STATE_IDLE_MAINTENANCE；light idle 为 LIGHT_STATE_IDLE_MAINTENANCE/LIGHT_STATE_PRE_IDLE</li>
</ul>
<p>然后调用 isOpsInactiveLocked 方法，判断此时是否没有 active op，avtive job 和 active alarm！</p>
<h4 id="4-3-2-2-isOpsInactiveLocked"><a href="#4-3-2-2-isOpsInactiveLocked" class="headerlink" title="4.3.2.2 isOpsInactiveLocked"></a>4.3.2.2 isOpsInactiveLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isOpsInactiveLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mActiveIdleOpCount &lt;= <span class="number">0</span> &amp;&amp; !mJobsActive &amp;&amp; !mAlarmsActive;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法用于判断时间窗内是否还有任务执行：</p>
<p>如果 mActiveIdleOpCount &lt;= 0，同时没有 JobService，Alarms 处于活跃状态，那么 isOpsInactiveLocked 就返回 true！</p>
<h2 id="4-4-消息：MSG-REPORT-ACTIVE"><a href="#4-4-消息：MSG-REPORT-ACTIVE" class="headerlink" title="4.4 消息：MSG_REPORT_ACTIVE"></a>4.4 消息：MSG_REPORT_ACTIVE</h2><p>当 idle 状态的条件不满足后，会退出 doze 模式，恢复 STATE_ACTIVE 状态，发送 MSG_REPORT_ACTIVE 给 MyHandler！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> MSG_REPORT_ACTIVE: &#123;</span><br><span class="line">    String activeReason = (String)msg.obj;</span><br><span class="line">    <span class="keyword">int</span> activeUid = msg.arg1;</span><br><span class="line">    EventLogTags.writeDeviceIdleOffStart(</span><br><span class="line">            activeReason != <span class="keyword">null</span> ? activeReason : <span class="string">"unknown"</span>);</span><br><span class="line">    <span class="comment">//【1】通知 PowerManager 退出 deep idle 和 light idle 状态！</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> deepChanged = mLocalPowerManager.setDeviceIdleMode(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> lightChanged = mLocalPowerManager.setLightDeviceIdleMode(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//【2】通知 NetworkPolicy 和 BatteryStats 退出 idle 状态！</span></span><br><span class="line">        mNetworkPolicyManager.setDeviceIdleMode(<span class="keyword">false</span>);</span><br><span class="line">        mBatteryStats.noteDeviceIdleMode(BatteryStats.DEVICE_IDLE_MODE_OFF,</span><br><span class="line">                activeReason, activeUid);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【3】如果是退出 deep idle，发送广播通知其他服务！ </span></span><br><span class="line">    <span class="keyword">if</span> (deepChanged) &#123;</span><br><span class="line">        getContext().sendBroadcastAsUser(mIdleIntent, UserHandle.ALL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【4】如果是退出 light idle，发送广播通知其他服务！ </span></span><br><span class="line">    <span class="keyword">if</span> (lightChanged) &#123;</span><br><span class="line">        getContext().sendBroadcastAsUser(mLightIdleIntent, UserHandle.ALL);</span><br><span class="line">    &#125;</span><br><span class="line">    EventLogTags.writeDeviceIdleOffComplete();</span><br><span class="line">&#125; <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>方法很简单，不多说了！</p>
<h2 id="4-5-消息：MSG-TEMP-APP-WHITELIST-TIMEOUT"><a href="#4-5-消息：MSG-TEMP-APP-WHITELIST-TIMEOUT" class="headerlink" title="4.5 消息：MSG_TEMP_APP_WHITELIST_TIMEOUT"></a>4.5 消息：MSG_TEMP_APP_WHITELIST_TIMEOUT</h2><p>我们可以将用户应用程序动态添加到 doze 模式的用户白名单中，使得应用可以在 doze 模式下运行，这种方式一旦添加，就一直生效，因为他会持久化到本地文件；</p>
<p>同时，我们还可以动态添加应用到临时缓存白名单中，使得该应用能够临时获得 doze 模式下的 network 和 wakelocks 访问，在添加时要指定临时的访问截至时间。时间过后，名单失效！！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 临时缓存白名单，在该名单中的 uid 被临时标记为在 doze 模式下允许访问网络并获取唤醒锁；</span></span><br><span class="line"><span class="comment">// MutableLong 用于指定临时时间！</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> SparseArray&lt;Pair&lt;MutableLong, String&gt;&gt; mTempWhitelistAppIdEndTimes</span><br><span class="line">        = <span class="keyword">new</span> SparseArray&lt;&gt;();</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 当 mTempWhitelistAppIdEndTimes 发生变化后，用于通知 NetworkPolicyManagerService 执行任务！</span></span><br><span class="line">Runnable mNetworkPolicyTempWhitelistCallback;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于记录缓存 mTempWhitelistAppIdEndTimes 中的所有应用的 uid；</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] mTempWhitelistAppIdArray = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<p>那么 MSG_TEMP_APP_WHITELIST_TIMEOUT 消息的所用是什么呢？就是不断的检查 mTempWhitelistAppIdEndTimes，mTempWhitelistAppIdArray，如果有过期名单，移除！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> MSG_TEMP_APP_WHITELIST_TIMEOUT: &#123;</span><br><span class="line">    <span class="keyword">int</span> uid = msg.arg1;</span><br><span class="line">    <span class="comment">//【4.5.1】调用 checkTempAppWhitelistTimeout 方法！</span></span><br><span class="line">    checkTempAppWhitelistTimeout(uid);</span><br><span class="line">&#125; <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>核心方法在 checkTempAppWhitelistTimeout 中！</p>
<h3 id="4-5-1-checkTempAppWhitelistTimeout"><a href="#4-5-1-checkTempAppWhitelistTimeout" class="headerlink" title="4.5.1 checkTempAppWhitelistTimeout"></a>4.5.1 checkTempAppWhitelistTimeout</h3><p>检查缓存白名单中是否有应用过期！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkTempAppWhitelistTimeout</span><span class="params">(<span class="keyword">int</span> uid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> timeNow = SystemClock.elapsedRealtime();</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">        Slog.d(TAG, <span class="string">"checkTempAppWhitelistTimeout: uid="</span> + uid + <span class="string">", timeNow="</span> + timeNow);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">//【1】判断临时缓存白名单中是否有该 uid！</span></span><br><span class="line">        Pair&lt;MutableLong, String&gt; entry = mTempWhitelistAppIdEndTimes.get(uid);</span><br><span class="line">        <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (timeNow &gt;= entry.first.value) &#123;</span><br><span class="line">            <span class="comment">//【2】当前时间 timeNow 超过了白名单中应用的有效期时间；</span></span><br><span class="line">            <span class="comment">// 将该应用从白名单中删除！</span></span><br><span class="line">            mTempWhitelistAppIdEndTimes.delete(uid);</span><br><span class="line">            <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">                Slog.d(TAG, <span class="string">"Removing UID "</span> + uid + <span class="string">" from temp whitelist"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//【4.5.2.1】更新 PowerManager 中缓存白名单！</span></span><br><span class="line">            updateTempWhitelistAppIdsLocked();</span><br><span class="line">            <span class="keyword">if</span> (mNetworkPolicyTempWhitelistCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mHandler.post(mNetworkPolicyTempWhitelistCallback); <span class="comment">// 更新 NetworkPolicy 内部名单！</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//【4.5.2.2】通知其他服务，缓存白名单发生了变化！</span></span><br><span class="line">            reportTempWhitelistChangedLocked();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mBatteryStats.noteEvent(BatteryStats.HistoryItem.EVENT_TEMP_WHITELIST_FINISH,</span><br><span class="line">                        entry.second, uid);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//【3】如果当前时间 timeNow 还没有超过白名单中应用的有效期时间；</span></span><br><span class="line">            <span class="comment">// 延迟 entry.first.value - timeNow 时间间隔再次发送 MSG_TEMP_APP_WHITELIST_TIMEOUT 消息！</span></span><br><span class="line">            <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">                Slog.d(TAG, <span class="string">"Time to remove UID "</span> + uid + <span class="string">": "</span> + entry.first.value);</span><br><span class="line">            &#125;</span><br><span class="line">            postTempActiveTimeoutMessage(uid, entry.first.value - timeNow);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="4-5-2-1-updateTempWhitelistAppIdsLocked"><a href="#4-5-2-1-updateTempWhitelistAppIdsLocked" class="headerlink" title="4.5.2.1 updateTempWhitelistAppIdsLocked"></a>4.5.2.1 updateTempWhitelistAppIdsLocked</h4><p>更新缓存白名单 mTempWhitelistAppIdEndTimes！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateTempWhitelistAppIdsLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】获得最新的 mTempWhitelistAppIdEndTimes 记录，更新 mTempWhitelistAppIdArray！</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> size = mTempWhitelistAppIdEndTimes.size();</span><br><span class="line">    <span class="keyword">if</span> (mTempWhitelistAppIdArray.length != size) &#123;</span><br><span class="line">        mTempWhitelistAppIdArray = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        mTempWhitelistAppIdArray[i] = mTempWhitelistAppIdEndTimes.keyAt(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【2】将最新的 mTempWhitelistAppIdArray 添加到 PowerManager 中！</span></span><br><span class="line">    <span class="keyword">if</span> (mLocalPowerManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">            Slog.d(TAG, <span class="string">"Setting wakelock temp whitelist to "</span></span><br><span class="line">                    + Arrays.toString(mTempWhitelistAppIdArray));</span><br><span class="line">        &#125;</span><br><span class="line">        mLocalPowerManager.setDeviceIdleTempWhitelist(mTempWhitelistAppIdArray);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>mTempWhitelistAppIdArray 数组中用来保存缓存白名单的应用的 uid，和 mTempWhitelistAppIdEndTimes 是不同的描述角度！</p>
<h4 id="4-5-2-2-reportTempWhitelistChangedLocked"><a href="#4-5-2-2-reportTempWhitelistChangedLocked" class="headerlink" title="4.5.2.2 reportTempWhitelistChangedLocked"></a>4.5.2.2 reportTempWhitelistChangedLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reportTempWhitelistChangedLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent(PowerManager.ACTION_POWER_SAVE_TEMP_WHITELIST_CHANGED);</span><br><span class="line">    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);</span><br><span class="line">    getContext().sendBroadcastAsUser(intent, UserHandle.SYSTEM);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实就是发送了 PowerManager.ACTION_POWER_SAVE_TEMP_WHITELIST_CHANGED 广播！</p>
<h2 id="4-6-消息：MSG-REPORT-MAINTENANCE-ACTIVITY"><a href="#4-6-消息：MSG-REPORT-MAINTENANCE-ACTIVITY" class="headerlink" title="4.6 消息：MSG_REPORT_MAINTENANCE_ACTIVITY"></a>4.6 消息：MSG_REPORT_MAINTENANCE_ACTIVITY</h2><p>当设备退出了 idle 状态后，系统中的 JobService 会开始执行，JobSchedulerService 会调用 DeviceIdleC.setJobsActive(true) 方法，将 JobService 的状态保存到 DeviceIdleController 中去！</p>
<h3 id="4-6-1-DeviceIdleC-setJobsActive"><a href="#4-6-1-DeviceIdleC-setJobsActive" class="headerlink" title="4.6.1 DeviceIdleC.setJobsActive"></a>4.6.1 DeviceIdleC.setJobsActive</h3><p>setJobsActive 用于设置 JobService 的活跃状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setJobsActive</span><span class="params">(<span class="keyword">boolean</span> active)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">//【1】将 mJobsActive 为 active 的值！</span></span><br><span class="line">        mJobsActive = active;</span><br><span class="line">        <span class="comment">//【4.6.1.1】JobService 的活跃状态发生了变化！</span></span><br><span class="line">        reportMaintenanceActivityIfNeededLocked();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【2】如果 active 为 false，说明此时没有 JobService 活跃了，</span></span><br><span class="line">        <span class="comment">// 那就尝试提前退出时间窗；</span></span><br><span class="line">        <span class="keyword">if</span> (!active) &#123;</span><br><span class="line">            exitMaintenanceEarlyIfNeededLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-6-1-1-DeviceIdleC-reportMaintenanceActivityIfNeededLocked"><a href="#4-6-1-1-DeviceIdleC-reportMaintenanceActivityIfNeededLocked" class="headerlink" title="4.6.1.1 DeviceIdleC.reportMaintenanceActivityIfNeededLocked"></a>4.6.1.1 DeviceIdleC.reportMaintenanceActivityIfNeededLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reportMaintenanceActivityIfNeededLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> active = mJobsActive;</span><br><span class="line">    <span class="keyword">if</span> (active == mReportedMaintenanceActivity) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mReportedMaintenanceActivity = active;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】发送 MSG_REPORT_MAINTENANCE_ACTIVITY 给 MyHandler！</span></span><br><span class="line">    Message msg = mHandler.obtainMessage(MSG_REPORT_MAINTENANCE_ACTIVITY,</span><br><span class="line">            mReportedMaintenanceActivity ? <span class="number">1</span> : <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    mHandler.sendMessage(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看下 MyHandler 对于 MSG_REPORT_MAINTENANCE_ACTIVITY 消息的处理：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> MSG_REPORT_MAINTENANCE_ACTIVITY: &#123;</span><br><span class="line">    <span class="keyword">boolean</span> active = (msg.arg1 == <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> size = mMaintenanceActivityListeners.beginBroadcast();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mMaintenanceActivityListeners.getBroadcastItem(i)</span><br><span class="line">                        .onMaintenanceActivityChanged(active);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException ignored) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mMaintenanceActivityListeners.finishBroadcast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="4-7-消息：MSG-FINISH-IDLE-OP"><a href="#4-7-消息：MSG-FINISH-IDLE-OP" class="headerlink" title="4.7 消息：MSG_FINISH_IDLE_OP"></a>4.7 消息：MSG_FINISH_IDLE_OP</h2><p>对于 MSG_FINISH_IDLE_OP 消息的处理很简单，就是调用 decActiveIdleOps 减少 mActiveIdleOpCount 引用计数！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> MSG_FINISH_IDLE_OP: &#123;</span><br><span class="line">    <span class="comment">//【4.7.1】减少 </span></span><br><span class="line">    decActiveIdleOps();</span><br><span class="line">&#125; <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<h3 id="4-7-1-decActiveIdleOps"><a href="#4-7-1-decActiveIdleOps" class="headerlink" title="4.7.1 decActiveIdleOps"></a>4.7.1 decActiveIdleOps</h3><p>我们来看看 decActiveIdleOps 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decActiveIdleOps</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">//【1】减少 mActiveIdleOpCount 计数；</span></span><br><span class="line">        mActiveIdleOpCount--;</span><br><span class="line">        <span class="keyword">if</span> (mActiveIdleOpCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//【4.3.2.1】尝试提前退出时间窗！</span></span><br><span class="line">            exitMaintenanceEarlyIfNeededLocked();</span><br><span class="line">            mActiveIdleWakeLock.release();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的逻辑我们之前见过！</p>
<p>进入时间窗的时候 mActiveIdleOpCount 会被加 1，退出时间窗的时候，mActiveIdleOpCount 会被减 1；</p>
<h1 id="5-重置操作"><a href="#5-重置操作" class="headerlink" title="5 重置操作"></a>5 重置操作</h1><p>对于重置操作，我们放到这里来一起分析下；</p>
<p>然后，重置 deep idle 逻辑相关的变量，取消 Alarm 和监控器！！</p>
<h2 id="5-1-resetIdleManagementLocked"><a href="#5-1-resetIdleManagementLocked" class="headerlink" title="5.1 resetIdleManagementLocked"></a>5.1 resetIdleManagementLocked</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resetIdleManagementLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mNextIdlePendingDelay = <span class="number">0</span>;</span><br><span class="line">    mNextIdleDelay = <span class="number">0</span>;</span><br><span class="line">    mNextLightIdleDelay = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//【1.1.1.1.1】取消 mDeepAlarmListener</span></span><br><span class="line">    cancelAlarmLocked();</span><br><span class="line">    <span class="comment">//【1.1.1.1.2】取消 mSensingTimeoutAlarmListener</span></span><br><span class="line">    cancelSensingTimeoutAlarmLocked();</span><br><span class="line">    <span class="comment">//【1.1.1.1.3】取消 mGenericLocationListener，mGpsLocationListener</span></span><br><span class="line">    cancelLocatingLocked();</span><br><span class="line">    <span class="comment">//【1.1.1.1.4】取消 mMotionListener</span></span><br><span class="line">    stopMonitoringMotionLocked();</span><br><span class="line">    mAnyMotionDetector.stop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-1-1-cancelAlarmLocked"><a href="#5-1-1-cancelAlarmLocked" class="headerlink" title="5.1.1 cancelAlarmLocked"></a>5.1.1 cancelAlarmLocked</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cancelAlarmLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mNextAlarmTime != <span class="number">0</span>) &#123;</span><br><span class="line">        mNextAlarmTime = <span class="number">0</span>;</span><br><span class="line">        mAlarmManager.cancel(mDeepAlarmListener);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>取消 mDeepAlarmListener！</p>
<p>该 mDeepAlarmListener 触发后会执行 stepIdleStateLocked 方法！</p>
<h3 id="5-1-2-cancelSensingTimeoutAlarmLocked"><a href="#5-1-2-cancelSensingTimeoutAlarmLocked" class="headerlink" title="5.1.2 cancelSensingTimeoutAlarmLocked"></a>5.1.2 cancelSensingTimeoutAlarmLocked</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cancelSensingTimeoutAlarmLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mNextSensingTimeoutAlarmTime != <span class="number">0</span>) &#123;</span><br><span class="line">        mNextSensingTimeoutAlarmTime = <span class="number">0</span>;</span><br><span class="line">        mAlarmManager.cancel(mSensingTimeoutAlarmListener);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>取消 mSensingTimeoutAlarmListener！</p>
<p>mSensingTimeoutAlarmListener 触发后，如果 mState 为 STATE_SENSING，这时会执行 1.1：becomeInactiveIfAppropriateLocked 方法！</p>
<h3 id="5-1-3-cancelLocatingLocked"><a href="#5-1-3-cancelLocatingLocked" class="headerlink" title="5.1.3 cancelLocatingLocked"></a>5.1.3 cancelLocatingLocked</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cancelLocatingLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mLocating) &#123;</span><br><span class="line">        mLocationManager.removeUpdates(mGenericLocationListener);</span><br><span class="line">        mLocationManager.removeUpdates(mGpsLocationListener);</span><br><span class="line">        mLocating = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>取消 mGenericLocationListener，mGpsLocationListener！</p>
<ul>
<li><p>mGenericLocationListener 触发后，会执行 receivedGenericLocationLocked 方法；</p>
</li>
<li><p>mGpsLocationListener 触发后，会执行 receivedGpsLocationLocked 方法；</p>
</li>
</ul>
<h3 id="5-1-4-stopMonitoringMotionLocked"><a href="#5-1-4-stopMonitoringMotionLocked" class="headerlink" title="5.1.4 stopMonitoringMotionLocked"></a>5.1.4 stopMonitoringMotionLocked</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stopMonitoringMotionLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">"stopMonitoringMotionLocked()"</span>);</span><br><span class="line">    <span class="keyword">if</span> (mMotionSensor != <span class="keyword">null</span> &amp;&amp; mMotionListener.active) &#123;</span><br><span class="line">        mMotionListener.unregisterLocked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>取消 mMotionListener！</p>
<h2 id="5-2-resetLightIdleManagementLocked"><a href="#5-2-resetLightIdleManagementLocked" class="headerlink" title="5.2 resetLightIdleManagementLocked"></a>5.2 resetLightIdleManagementLocked</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resetLightIdleManagementLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1.1.2.1.1】取消之前设置的 light idle alarm！</span></span><br><span class="line">    cancelLightAlarmLocked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>light idle 模式的重置相关变量过程很简单，只是取消 mLightAlarmListener！</p>
<h3 id="5-2-1-cancelLightAlarmLocked"><a href="#5-2-1-cancelLightAlarmLocked" class="headerlink" title="5.2.1 cancelLightAlarmLocked"></a>5.2.1 cancelLightAlarmLocked</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cancelLightAlarmLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mNextLightAlarmTime != <span class="number">0</span>) &#123;</span><br><span class="line">        mNextLightAlarmTime = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//【1】取消 mLightAlarmListener！</span></span><br><span class="line">        mAlarmManager.cancel(mLightAlarmListener);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>取消 mLightAlarmListener！</p>
<h1 id="6-提前退出时间窗"><a href="#6-提前退出时间窗" class="headerlink" title="6 提前退出时间窗"></a>6 提前退出时间窗</h1><h1 id="7-总结"><a href="#7-总结" class="headerlink" title="7 总结"></a>7 总结</h1><p>我们来看看 doze 模式下的监听器有哪些，下图是 doze 模式的所有监听器，监听不同的条件是否满足：</p>
<h2 id="7-1-状态监听器"><a href="#7-1-状态监听器" class="headerlink" title="7.1 状态监听器"></a>7.1 状态监听器</h2><p>下面的几张图是监听手机状态的监听器的逻辑：</p>
<h2 id="7-2-deep-idle"><a href="#7-2-deep-idle" class="headerlink" title="7.2 deep idle"></a>7.2 deep idle</h2><p>我们来总结下 deep idle 状态的流程：</p>
<p><img src="http://static.zybuluo.com/Coolqi/z8dwe5k2u6l2j81acr8alj32/deep%20idle%20%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90.png" alt="deep idle 流程分析.png-269.1kB"></p>
<h2 id="7-3-light-idle"><a href="#7-3-light-idle" class="headerlink" title="7.3 light idle"></a>7.3 light idle</h2><p>我们来总结下 light idle 状态的流程：</p>
<p><img src="http://static.zybuluo.com/Coolqi/6lrmy3lq61spwiqi9k04r2za/light%20idle%20%E6%B5%81%E7%A8%8B.png" alt="light idle 流程.png-281.7kB"></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Coolqi.Li</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://coolqi.top/2017/11/25/Doze2-deviceIdleControllerDynamic/">https://coolqi.top/2017/11/25/Doze2-deviceIdleControllerDynamic/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://coolqi.top">Coolqi`s Blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Doze假寐模式/">Doze假寐模式</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="/img/zfb.jpg"><div class="post-qr-code__desc">支付宝打赏</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="/img/wechat.jpg"><div class="post-qr-code__desc">微信打赏</div></div></div><div class="social-share"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2018/01/03/PMS1-PackageManagerServiceInit/"><i class="fa fa-chevron-left">  </i><span>PMS 第 1 篇 - PackageManagerService 初始化</span></a></div><div class="next-post pull-right"><a href="/2017/10/01/Doze1-deviceIdleControllerStartProcess/"><span>Doze模式第 1 篇 - DeviceIdleController 的启动</span><i class="fa fa-chevron-right"></i></a></div></nav><div class="post-adv"><a href="https://www.vultr.com/?ref=7231808"><img src="https://www.vultr.com/media/banner_1.png" width="728" height="90"></a></div><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '0b2bcefa98cd2ef1a87c',
  clientSecret: '8d6fc25cc2643889493c0406c9a7cb0f1663b5c2',
  repo: 'git-single-lee.github.io',
  owner: 'git-single-lee',
  admin: 'git-single-lee',
  id: md5(location.pathname),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2015 - 2019 By Coolqi.Li</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://coolqi.top/">blog</a>!</div><div class="busuanzi"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.6"></script><script src="/js/fancybox.js?version=1.5.6"></script><script src="/js/sidebar.js?version=1.5.6"></script><script src="/js/copy.js?version=1.5.6"></script><script src="/js/fireworks.js?version=1.5.6"></script><script src="/js/transition.js?version=1.5.6"></script><script src="/js/scroll.js?version=1.5.6"></script><script src="/js/head.js?version=1.5.6"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="/js/search/local-search.js"></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"live2d-widget-model-hijiki"},"display":{"position":"right","width":110,"height":220},"mobile":{"show":false},"log":false});</script></body></html>