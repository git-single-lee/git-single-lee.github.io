<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="AlarmManager第 2 篇 - set Alarm 流程分析"><meta name="keywords" content="AlarmManager闹钟管理"><meta name="author" content="Coolqi.Li,undefined"><meta name="copyright" content="Coolqi.Li"><title>AlarmManager第 2 篇 - set Alarm 流程分析 | Coolqi`s Blog</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.5.6"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css?version=1.5.6"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#0-综述"><span class="toc-text">0 综述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-AlarmManager-setAlarm"><span class="toc-text">1 AlarmManager.setAlarm</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-AlarmManager-set"><span class="toc-text">1.1 AlarmManager.set</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-AlarmManager-setExact"><span class="toc-text">1.2 AlarmManager.setExact</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-AlarmManager-setWindow"><span class="toc-text">1.3 AlarmManager.setWindow</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-AlarmManager-setXXXRepeating"><span class="toc-text">1.4 AlarmManager.setXXXRepeating</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-AlarmManager-setAlarmClock"><span class="toc-text">1.5 AlarmManager.setAlarmClock</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-6-AlarmManager-setIdleUntil"><span class="toc-text">1.6 AlarmManager.setIdleUntil</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-7-AlarmManager-setXXXAndAllowWhileIdle"><span class="toc-text">1.7 AlarmManager.setXXXAndAllowWhileIdle</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-AlarmManager-setImpl"><span class="toc-text">2 AlarmManager.setImpl</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-new-ListenerWrapper"><span class="toc-text">2.1 new ListenerWrapper</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-ListenerWrapper-doAlarm"><span class="toc-text">2.1.1 ListenerWrapper.doAlarm</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-AlarmManagerService"><span class="toc-text">3 AlarmManagerService</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-AlarmMS-mService-set"><span class="toc-text">3.1 AlarmMS.mService.set</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-AlarmMS-setImpl"><span class="toc-text">3.2 AlarmMS.setImpl</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-AlarmMS-convertToElapsed"><span class="toc-text">3.2.1 AlarmMS.convertToElapsed</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-AlarmMS-maxTriggerTime"><span class="toc-text">3.2.2 AlarmMS.maxTriggerTime</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-AlarmMS-setImplLocked-15"><span class="toc-text">3.3 AlarmMS.setImplLocked[15]</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-1-AlarmMS-Alarm"><span class="toc-text">3.3.1 AlarmMS.Alarm</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-1-Alarm-make"><span class="toc-text">3.3.1.1 Alarm.make</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-2-Alarm-matches"><span class="toc-text">3.3.1.2 Alarm.matches</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-2-AlarmMS-removeLocked"><span class="toc-text">3.3.2 AlarmMS.removeLocked</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-1-AlarmMS-Batch-remove"><span class="toc-text">3.3.2.1 AlarmMS.Batch.remove</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-2-AlarmMS-rebatchAllAlarmsLocked"><span class="toc-text">3.3.2.2 AlarmMS.rebatchAllAlarmsLocked</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-2-2-1-AlarmManagerService-reAddAlarmLocked"><span class="toc-text">3.3.2.2.1 AlarmManagerService.reAddAlarmLocked</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-3-AlarmMS-restorePendingWhileIdleAlarmsLocked"><span class="toc-text">3.3.2.3 AlarmMS.restorePendingWhileIdleAlarmsLocked</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-AlarmMS-setImplLocked-3"><span class="toc-text">3.4 AlarmMS.setImplLocked[3]</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-1-AlarmMS-fuzzForDuration"><span class="toc-text">3.4.1 AlarmMS.fuzzForDuration</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-2-AlarmMS-attemptCoalesceLocked"><span class="toc-text">3.4.2 AlarmMS.attemptCoalesceLocked</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-2-1-AlarmMS-Batch-canHold"><span class="toc-text">3.4.2.1 AlarmMS.Batch.canHold</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-3-AlarmMS-addBatchLocked"><span class="toc-text">3.4.3 AlarmMS.addBatchLocked</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-3-1-AlarmMS-Batch-Batch"><span class="toc-text">3.4.3.1 AlarmMS.Batch.Batch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-3-2-AlarmMS-Batch-add"><span class="toc-text">3.4.3.2 AlarmMS.Batch.add</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-4-AlarmMS-rescheduleKernelAlarmsLocked"><span class="toc-text">3.4.4 AlarmMS.rescheduleKernelAlarmsLocked</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-4-1-AlarmMS-findFirstWakeupBatchLocked"><span class="toc-text">3.4.4.1 AlarmMS.findFirstWakeupBatchLocked</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-4-1-1-AlarmMS-Batch-hasWakeups"><span class="toc-text">3.4.4.1.1 AlarmMS.Batch.hasWakeups</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-4-2-AlarmMS-setLocked"><span class="toc-text">3.4.4.2 AlarmMS.setLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-4-3-AlarmMS-updateNextAlarmInfoForUserLocked"><span class="toc-text">3.4.4.3 AlarmMS.updateNextAlarmInfoForUserLocked</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-5-AlarmMS-updateNextAlarmClockLocked"><span class="toc-text">3.4.5 AlarmMS.updateNextAlarmClockLocked</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-5-1-AlarmMS-updateNextAlarmInfoForUserLocked"><span class="toc-text">3.4.5.1 AlarmMS.updateNextAlarmInfoForUserLocked</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-5-1-1-AlarmMS-AlarmHandler-SEND-NEXT-ALARM-CLOCK-CHANGED"><span class="toc-text">3.4.5.1.1 AlarmMS.AlarmHandler[SEND_NEXT_ALARM_CLOCK_CHANGED]</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-5-1-2-AlarmMS-sendNextAlarmClockChanged"><span class="toc-text">3.4.5.1.2 AlarmMS.sendNextAlarmClockChanged</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-阶段总结"><span class="toc-text">3.5 阶段总结</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Coolqi.Li</div><div class="author-info__description text-center">“你好，我是李帅奇，Android 系统工程师，MineCraft 忠实玩家，设计和绘画爱好者，缺妹纸晚期患者，熬夜星人。”</div><div class="follow-button"><a href="https://github.com/li-coolqi">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">66</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">14</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">15</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="https://molunerfinn.com">AndroidDe</a><a class="author-info-links__name text-center" href="https://www.jianshu.com/u/123a20a96441">简书</a><a class="author-info-links__name text-center" href="https://piegg.cn">微博</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://ws1.sinaimg.cn/large/8700af19ly1fvpabr30o6j22yo1o0q7i.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Coolqi`s Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/about">About</a><a class="site-page" href="/archives">Archives</a></span></div><div id="post-info"><div id="post-title">AlarmManager第 2 篇 - set Alarm 流程分析</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-07-25</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/AndroidFramework源码分析/">AndroidFramework源码分析</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/AndroidFramework源码分析/AlarmManager闹钟管理/">AlarmManager闹钟管理</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">10.7k</span><span class="post-meta__separator">|</span><span>阅读时长: 47 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>[toc]</p>
<p>基于 Android 7.1.1 源码，分析 AlarmManagerService 的机制</p>
<h1 id="0-综述"><a href="#0-综述" class="headerlink" title="0 综述"></a>0 综述</h1><p>下面是设置精确 alarm 的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setGlobalNoticeDialogForceShowAlarm</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent(<span class="string">"com.coolqi.alarm_start"</span>);</span><br><span class="line">    PendingIntent pi = PendingIntent.getBroadcast(context, <span class="number">0</span>, intent, <span class="number">0</span>);</span><br><span class="line">    AlarmManager alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);</span><br><span class="line">    alarmManager.cancel(pi);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> timeHour = <span class="number">2</span>*<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>;<span class="comment">// two days</span></span><br><span class="line"></span><br><span class="line">    OppoLog.d(TAG, <span class="string">"show global time: "</span> + timeHour);</span><br><span class="line">    <span class="keyword">long</span> triggerTime = CommonUtil.getTriggerTime(System.currentTimeMillis(), timeHour);</span><br><span class="line">    alarmManager.setExact(AlarmManager.RTC_WAKEUP, triggerTime, pi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="1-AlarmManager-setAlarm"><a href="#1-AlarmManager-setAlarm" class="headerlink" title="1 AlarmManager.setAlarm"></a>1 AlarmManager.setAlarm</h1><p>AlarmManagerSerivce 提供了很丰富的接口来设置不同类型的 alarm，可以通过 AlarmManager.java 来看到所有的接口：</p>
<h2 id="1-1-AlarmManager-set"><a href="#1-1-AlarmManager-set" class="headerlink" title="1.1 AlarmManager.set"></a>1.1 AlarmManager.set</h2><p>set 接口用于设置一个一次性的闹钟，该闹钟是非精确的，我们需要传入一个 triggerAtMillis 毫秒值被表示闹钟触发的时间点！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(@AlarmType <span class="keyword">int</span> type, <span class="keyword">long</span> triggerAtMillis, PendingIntent operation)</span> </span>&#123;</span><br><span class="line">    setImpl(type, triggerAtMillis, legacyExactLength(), <span class="number">0</span>, <span class="number">0</span>, operation, <span class="keyword">null</span>, <span class="keyword">null</span>,</span><br><span class="line">            <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 set 方法最常用：第一个参数是 alarm 的类型，第二个是触发时间，第三个是 PendingIntent，用于启动 Service，activity，或者是 broadcastReceiver！</p>
<p>可以实现跨进程，即：设置该 alarm 的进程和处理 alarm 触发的进程可以不是同一个！</p>
<p><strong>参数传递</strong>：</p>
<ul>
<li><strong>int type</strong>：闹钟类型 type；</li>
<li><strong>long triggerAtMillis</strong>：触发时间，单位毫秒；</li>
<li><strong>long windowMillis</strong>：legacyExactLength()，API 19 以后返回值为 WINDOW_HEURISTIC，即 -1；</li>
<li><strong>long intervalMillis</strong>：0；</li>
<li><strong>int flags</strong>：0；</li>
<li><strong>PendingIntent operation</strong>：operation；</li>
<li><strong>final OnAlarmListener listener</strong>：null；</li>
<li><strong>String listenerTag</strong>：null；</li>
<li><strong>Handler targetHandler</strong>：null；</li>
<li><strong>WorkSource workSource</strong>：null；</li>
<li><strong>AlarmClockInfo alarmCloc</strong>：null；</li>
</ul>
<p><br></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(@AlarmType <span class="keyword">int</span> type, <span class="keyword">long</span> triggerAtMillis, String tag, OnAlarmListener listener,</span></span></span><br><span class="line"><span class="function"><span class="params">        Handler targetHandler)</span> </span>&#123;</span><br><span class="line">    setImpl(type, triggerAtMillis, legacyExactLength(), <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">null</span>, listener, tag,</span><br><span class="line">            targetHandler, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 set 方法并不适用于跨进程通信，其需要传入一个实现了 OnAlarmListener 接口的对象用于监听 alarm 的触发，当 alarm 触发后，OnAlarmListener 的会被 onAlarm() 执行！</p>
<p>targetHandler 表示的是 OnAlarmListener.onAlarm 执行时，目标线程的 handler 对象！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line"><span class="meta">@SystemApi</span></span><br><span class="line"><span class="meta">@RequiresPermission</span>(android.Manifest.permission.UPDATE_DEVICE_STATS)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(@AlarmType <span class="keyword">int</span> type, <span class="keyword">long</span> triggerAtMillis, <span class="keyword">long</span> windowMillis,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span> intervalMillis, PendingIntent operation, WorkSource workSource)</span> </span>&#123;</span><br><span class="line">    setImpl(type, triggerAtMillis, windowMillis, intervalMillis, <span class="number">0</span>, operation, <span class="keyword">null</span>, <span class="keyword">null</span>,</span><br><span class="line">            <span class="keyword">null</span>, workSource, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(@AlarmType <span class="keyword">int</span> type, <span class="keyword">long</span> triggerAtMillis, <span class="keyword">long</span> windowMillis,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span> intervalMillis, String tag, OnAlarmListener listener, Handler targetHandler,</span></span></span><br><span class="line"><span class="function"><span class="params">        WorkSource workSource)</span> </span>&#123;</span><br><span class="line">    setImpl(type, triggerAtMillis, windowMillis, intervalMillis, <span class="number">0</span>, <span class="keyword">null</span>, listener, tag,</span><br><span class="line">            targetHandler, workSource, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SystemApi</span></span><br><span class="line"><span class="meta">@RequiresPermission</span>(android.Manifest.permission.UPDATE_DEVICE_STATS)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(@AlarmType <span class="keyword">int</span> type, <span class="keyword">long</span> triggerAtMillis, <span class="keyword">long</span> windowMillis,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span> intervalMillis, OnAlarmListener listener, Handler targetHandler,</span></span></span><br><span class="line"><span class="function"><span class="params">        WorkSource workSource)</span> </span>&#123;</span><br><span class="line">    setImpl(type, triggerAtMillis, windowMillis, intervalMillis, <span class="number">0</span>, <span class="keyword">null</span>, listener, <span class="keyword">null</span>,</span><br><span class="line">            targetHandler, workSource, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>set 方法设置的 alarm <strong>是非精确的</strong>！</p>
<h2 id="1-2-AlarmManager-setExact"><a href="#1-2-AlarmManager-setExact" class="headerlink" title="1.2 AlarmManager.setExact"></a>1.2 AlarmManager.setExact</h2><p>用于设置一个精确的闹钟，该方法是相对于 set 方法的，参数和 set 方法一样，不多说，也有 2 个方法！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setExact</span><span class="params">(@AlarmType <span class="keyword">int</span> type, <span class="keyword">long</span> triggerAtMillis, PendingIntent operation)</span> </span>&#123;</span><br><span class="line">    setImpl(type, triggerAtMillis, WINDOW_EXACT, <span class="number">0</span>, <span class="number">0</span>, operation, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>,</span><br><span class="line">            <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setExact</span><span class="params">(@AlarmType <span class="keyword">int</span> type, <span class="keyword">long</span> triggerAtMillis, String tag,</span></span></span><br><span class="line"><span class="function"><span class="params">        OnAlarmListener listener, Handler targetHandler)</span> </span>&#123;</span><br><span class="line">    setImpl(type, triggerAtMillis, WINDOW_EXACT, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">null</span>, listener, tag,</span><br><span class="line">            targetHandler, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不多说了！！</p>
<h2 id="1-3-AlarmManager-setWindow"><a href="#1-3-AlarmManager-setWindow" class="headerlink" title="1.3 AlarmManager.setWindow"></a>1.3 AlarmManager.setWindow</h2><p>用于设置一个在给定的时间窗触发的闹钟。该方法允许应用程序精确地控制操作系统调整闹钟触发时间的程度。</p>
<p>其中，windowStartMillis 表示时间窗的起始时间！windowStartMillis 表示时间窗的长度，其他参数和 set 方法一样！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWindow</span><span class="params">(@AlarmType <span class="keyword">int</span> type, <span class="keyword">long</span> windowStartMillis, <span class="keyword">long</span> windowLengthMillis,</span></span></span><br><span class="line"><span class="function"><span class="params">        PendingIntent operation)</span> </span>&#123;</span><br><span class="line">    setImpl(type, windowStartMillis, windowLengthMillis, <span class="number">0</span>, <span class="number">0</span>, operation,</span><br><span class="line">            <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWindow</span><span class="params">(@AlarmType <span class="keyword">int</span> type, <span class="keyword">long</span> windowStartMillis, <span class="keyword">long</span> windowLengthMillis,</span></span></span><br><span class="line"><span class="function"><span class="params">        String tag, OnAlarmListener listener, Handler targetHandler)</span> </span>&#123;</span><br><span class="line">    setImpl(type, windowStartMillis, windowLengthMillis, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">null</span>, listener, tag,</span><br><span class="line">            targetHandler, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>setWindow 设置的是<strong>非精确</strong>的闹钟！</p>
<h2 id="1-4-AlarmManager-setXXXRepeating"><a href="#1-4-AlarmManager-setXXXRepeating" class="headerlink" title="1.4 AlarmManager.setXXXRepeating"></a>1.4 AlarmManager.setXXXRepeating</h2><p>setRepeating 和 setInexactRepeating 用于设置一个可重复触发的闹钟，但是二者却有着不同：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRepeating</span><span class="params">(@AlarmType <span class="keyword">int</span> type, <span class="keyword">long</span> triggerAtMillis,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span> intervalMillis, PendingIntent operation)</span> </span>&#123;</span><br><span class="line">    setImpl(type, triggerAtMillis, legacyExactLength(), intervalMillis, <span class="number">0</span>, operation,</span><br><span class="line">            <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>setRepeating 方法在 API19 以前是精确的，其时间间隔是固定的，但是在 API19 以后则是<strong>非精确闹钟</strong>，其等价于 setInexactRepeating 方法！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInexactRepeating</span><span class="params">(@AlarmType <span class="keyword">int</span> type, <span class="keyword">long</span> triggerAtMillis,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span> intervalMillis, PendingIntent operation)</span> </span>&#123;</span><br><span class="line">    setImpl(type, triggerAtMillis, WINDOW_HEURISTIC, intervalMillis, <span class="number">0</span>, operation, <span class="keyword">null</span>,</span><br><span class="line">            <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>setInexactRepeating 则是<strong>非精确闹钟</strong>，间隔时间不固定！</p>
<h2 id="1-5-AlarmManager-setAlarmClock"><a href="#1-5-AlarmManager-setAlarmClock" class="headerlink" title="1.5 AlarmManager.setAlarmClock"></a>1.5 AlarmManager.setAlarmClock</h2><p>setAlarmClock 方法用于通过 AlarmClockInfo 来设置一个<strong>精确闹钟</strong>！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAlarmClock</span><span class="params">(AlarmClockInfo info, PendingIntent operation)</span> </span>&#123;</span><br><span class="line">    setImpl(RTC_WAKEUP, info.getTriggerTime(), WINDOW_EXACT, <span class="number">0</span>, <span class="number">0</span>, operation,</span><br><span class="line">            <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, info);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-6-AlarmManager-setIdleUntil"><a href="#1-6-AlarmManager-setIdleUntil" class="headerlink" title="1.6 AlarmManager.setIdleUntil"></a>1.6 AlarmManager.setIdleUntil</h2><p>setIdleUntil 方法会将 alarm manager service 置为 idle 状态，并设置一个精确闹钟，当该闹钟触发后 alarm manager service 才会退出 idle 状态！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIdleUntil</span><span class="params">(@AlarmType <span class="keyword">int</span> type, <span class="keyword">long</span> triggerAtMillis, String tag,</span></span></span><br><span class="line"><span class="function"><span class="params">        OnAlarmListener listener, Handler targetHandler)</span> </span>&#123;</span><br><span class="line">    setImpl(type, triggerAtMillis, WINDOW_EXACT, <span class="number">0</span>, FLAG_IDLE_UNTIL, <span class="keyword">null</span>,</span><br><span class="line">            listener, tag, targetHandler, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，其调用 setImpl 方法的时候，传入了一个 flag，表示要将 AlarmManagerService 置为 idle 状态！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAG_IDLE_UNTIL = <span class="number">1</span>&lt;&lt;<span class="number">4</span>;</span><br></pre></td></tr></table></figure>
<p>该方法只能是系统调用！</p>
<h2 id="1-7-AlarmManager-setXXXAndAllowWhileIdle"><a href="#1-7-AlarmManager-setXXXAndAllowWhileIdle" class="headerlink" title="1.7 AlarmManager.setXXXAndAllowWhileIdle"></a>1.7 AlarmManager.setXXXAndAllowWhileIdle</h2><p>setAndAllowWhileIdle 和 setExactAndAllowWhileIdle 方法用于设置在设备处于 idle 状态下，仍然能够触发的 alarm，但是二者有不同之处：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAndAllowWhileIdle</span><span class="params">(@AlarmType <span class="keyword">int</span> type, <span class="keyword">long</span> triggerAtMillis,</span></span></span><br><span class="line"><span class="function"><span class="params">        PendingIntent operation)</span> </span>&#123;</span><br><span class="line">    setImpl(type, triggerAtMillis, WINDOW_HEURISTIC, <span class="number">0</span>, FLAG_ALLOW_WHILE_IDLE,</span><br><span class="line">            operation, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>setAndAllowWhileIdle 方法设置的是<strong>非精确闹钟</strong>！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setExactAndAllowWhileIdle</span><span class="params">(@AlarmType <span class="keyword">int</span> type, <span class="keyword">long</span> triggerAtMillis,</span></span></span><br><span class="line"><span class="function"><span class="params">        PendingIntent operation)</span> </span>&#123;</span><br><span class="line">    setImpl(type, triggerAtMillis, WINDOW_EXACT, <span class="number">0</span>, FLAG_ALLOW_WHILE_IDLE, operation,</span><br><span class="line">            <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>setExactAndAllowWhileIdle 方法设置的是<strong>精确闹钟</strong>！</p>
<p>当 setXXXAndAllowWhileIdle 设置闹钟时候，会传入一个 flags，表示该闹钟在设别处于 idle 状态时依然可以触发！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FLAG_ALLOW_WHILE_IDLE = <span class="number">1</span>&lt;&lt;<span class="number">2</span>;</span><br></pre></td></tr></table></figure></p>
<h1 id="2-AlarmManager-setImpl"><a href="#2-AlarmManager-setImpl" class="headerlink" title="2 AlarmManager.setImpl"></a>2 AlarmManager.setImpl</h1><p>可以看到，最后都会调用 setImpl 接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setImpl</span><span class="params">(@AlarmType <span class="keyword">int</span> type, <span class="keyword">long</span> triggerAtMillis, <span class="keyword">long</span> windowMillis,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span> intervalMillis, <span class="keyword">int</span> flags, PendingIntent operation, <span class="keyword">final</span> OnAlarmListener listener,</span></span></span><br><span class="line"><span class="function"><span class="params">        String listenerTag, Handler targetHandler, WorkSource workSource,</span></span></span><br><span class="line"><span class="function"><span class="params">        AlarmClockInfo alarmClock)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 触发时间最小为 0；</span></span><br><span class="line">    <span class="keyword">if</span> (triggerAtMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        triggerAtMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListenerWrapper recipientWrapper = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 当传入的 listener 不为 null 时候，才会进入下面的逻辑！</span></span><br><span class="line">    <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (AlarmManager.class) &#123;</span><br><span class="line">            <span class="comment">// sWrappers 是一个 ArrayMap 集合，用于保存 OnAlarmListener 和 ListenerWrapper 的映射！</span></span><br><span class="line">            <span class="keyword">if</span> (sWrappers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                sWrappers = <span class="keyword">new</span> ArrayMap&lt;OnAlarmListener, ListenerWrapper&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果该 OnAlarmListener 已经有了 recipientWrapper 对象，那就复用该实例；</span></span><br><span class="line">            <span class="comment">// 如果没有那就创建一个新的 recipientWrapper 实例，并将应映射关系保存进 sWrappers！</span></span><br><span class="line">            recipientWrapper = sWrappers.get(listener);</span><br><span class="line">            <span class="comment">// no existing wrapper =&gt; build a new one</span></span><br><span class="line">            <span class="keyword">if</span> (recipientWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">                recipientWrapper = <span class="keyword">new</span> ListenerWrapper(listener);</span><br><span class="line">                sWrappers.put(listener, recipientWrapper);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化 targetHandler，如果没有设置 targetHandler 那就为主线程的 Handler！</span></span><br><span class="line">        <span class="keyword">final</span> Handler handler = (targetHandler != <span class="keyword">null</span>) ? targetHandler : mMainThreadHandler;</span><br><span class="line">        <span class="comment">// 设置 recipientWrapper 的 Handler 变量！</span></span><br><span class="line">        recipientWrapper.setHandler(handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//【3】调用 AlarmManagerService 的 set 方法，设置闹钟！</span></span><br><span class="line">        mService.set(mPackageName, type, triggerAtMillis, windowMillis, intervalMillis, flags,</span><br><span class="line">                operation, recipientWrapper, listenerTag, workSource, alarmClock);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-1-new-ListenerWrapper"><a href="#2-1-new-ListenerWrapper" class="headerlink" title="2.1 new ListenerWrapper"></a>2.1 new ListenerWrapper</h2><p>如果我们指定了 OnAlarmListener，那么就会创建对应的 ListenerWrapper 实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ListenerWrapper</span> <span class="keyword">extends</span> <span class="title">IAlarmListener</span>.<span class="title">Stub</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> OnAlarmListener mListener; </span><br><span class="line">    Handler mHandler;</span><br><span class="line">    IAlarmCompleteListener mCompletion;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ListenerWrapper</span><span class="params">(OnAlarmListener listener)</span> </span>&#123;</span><br><span class="line">        mListener = listener;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHandler</span><span class="params">(Handler h)</span> </span>&#123;</span><br><span class="line">       mHandler = h;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ... ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实 ListenerWrapper 是一个 Runnable 对象，其构造函数和 setHandler 都很简单，这里就不说了！</p>
<h3 id="2-1-1-ListenerWrapper-doAlarm"><a href="#2-1-1-ListenerWrapper-doAlarm" class="headerlink" title="2.1.1 ListenerWrapper.doAlarm"></a>2.1.1 ListenerWrapper.doAlarm</h3><p>这里先简单说一下，当闹钟触发后，会回调其 doAlarm 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAlarm</span><span class="params">(IAlarmCompleteListener alarmManager)</span> </span>&#123;</span><br><span class="line">    mCompletion = alarmManager;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从本地的 sWrappers 中移除映射关系！</span></span><br><span class="line">    <span class="keyword">synchronized</span> (AlarmManager.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sWrappers != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sWrappers.remove(mListener);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用 set alarm 是传入的 mHandler，执行任务!</span></span><br><span class="line">    mHandler.post(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的 IAlarmCompleteListener 是一个接口，支持 Binder 通信，当闹钟触发后，AlarmManagerService 会传递一个实现了 IAlarmCompleteListener 接口的对象给当前进程</p>
<p>然后会调用自身的 run 方法，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 执行 onAlarm 回调！</span></span><br><span class="line">        mListener.onAlarm();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// No catch -- make sure to report completion to the system process,</span></span><br><span class="line">        <span class="comment">// but continue to allow the exception to crash the app.</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mCompletion.alarmComplete(<span class="keyword">this</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">"Unable to report completion to Alarm Manager!"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>逻辑很简单，不多说了！</p>
<h1 id="3-AlarmManagerService"><a href="#3-AlarmManagerService" class="headerlink" title="3 AlarmManagerService"></a>3 AlarmManagerService</h1><p>我们知道 set 方法最后调用了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mService.set(mPackageName, type, triggerAtMillis, windowMillis, intervalMillis, flags,</span><br><span class="line">                   operation, recipientWrapper, listenerTag, workSource, alarmClock);</span><br></pre></td></tr></table></figure></p>
<p>这个 mService 是服务端的 proxy 对象！AlarmManager 框架实现了 Aidl 模板，实现跨进程通讯：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IAlarmManager</span> </span>&#123;</span><br><span class="line">	<span class="comment">/** windowLength == 0 means exact; windowLength &lt; 0 means the let the OS decide */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(String callingPackage, <span class="keyword">int</span> type, <span class="keyword">long</span> triggerAtTime, <span class="keyword">long</span> windowLength,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">long</span> interval, <span class="keyword">int</span> flags, in PendingIntent operation, in IAlarmListener listener,</span></span></span><br><span class="line"><span class="function"><span class="params">            String listenerTag, in WorkSource workSource, in AlarmManager.AlarmClockInfo alarmClock)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">setTime</span><span class="params">(<span class="keyword">long</span> millis)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setTimeZone</span><span class="params">(String zone)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(in PendingIntent operation, in IAlarmListener listener)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getNextWakeFromIdleTime</span><span class="params">()</span></span>;</span><br><span class="line">    AlarmManager.<span class="function">AlarmClockInfo <span class="title">getNextAlarmClock</span><span class="params">(<span class="keyword">int</span> userId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AlarmManagerService 内部有一个 IBinder 对象，是 IAlarmManager.Stub 的实现对象，作为服务端的 “桩”：</p>
<h2 id="3-1-AlarmMS-mService-set"><a href="#3-1-AlarmMS-mService-set" class="headerlink" title="3.1 AlarmMS.mService.set"></a>3.1 AlarmMS.mService.set</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> IBinder mService = <span class="keyword">new</span> IAlarmManager.Stub() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String callingPackage,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> type, <span class="keyword">long</span> triggerAtTime, <span class="keyword">long</span> windowLength, <span class="keyword">long</span> interval, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">            PendingIntent operation, IAlarmListener directReceiver, String listenerTag,</span></span></span><br><span class="line"><span class="function"><span class="params">            WorkSource workSource, AlarmManager.AlarmClockInfo alarmClock)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> callingUid = Binder.getCallingUid();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【1】通过 appOps 校验 uid 和包名是匹配的！</span></span><br><span class="line">        mAppOps.checkPackage(callingUid, callingPackage);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【2】重复 alarm 必须要使用 PendingIntent，不能使用 directReceiver，那就是异常！</span></span><br><span class="line">        <span class="keyword">if</span> (interval != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (directReceiver != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Repeating alarms cannot use AlarmReceivers"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【3】如果 workSource 不为 null，</span></span><br><span class="line">        <span class="comment">// 那就检查调用者是否具有 android.Manifest.permission.UPDATE_DEVICE_STATS 权限！</span></span><br><span class="line">        <span class="keyword">if</span> (workSource != <span class="keyword">null</span>) &#123;</span><br><span class="line">            getContext().enforcePermission(</span><br><span class="line">                    android.Manifest.permission.UPDATE_DEVICE_STATS,</span><br><span class="line">                    Binder.getCallingPid(), callingUid, <span class="string">"AlarmManager.set"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【4】清除 flags 中的 FLAG_WAKE_FROM_IDLE 和 FLAG_ALLOW_WHILE_IDLE_UNRESTRICTED 标志位</span></span><br><span class="line">        <span class="comment">// 后续会添加！</span></span><br><span class="line">        flags &amp;= ~(AlarmManager.FLAG_WAKE_FROM_IDLE</span><br><span class="line">                | AlarmManager.FLAG_ALLOW_WHILE_IDLE_UNRESTRICTED);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【5】如果调用者不是 system 进程，那么其不能调用 setIdleUntil 方法设置闹钟，</span></span><br><span class="line">        <span class="comment">// 所以 flags 需要去掉 FLAG_IDLE_UNTIL 位！这个标志位是告诉 AlarmManagerService 什么时候退出 idle 状态！</span></span><br><span class="line">        <span class="comment">// 被 DeviceIdleController 调用！</span></span><br><span class="line">        <span class="keyword">if</span> (callingUid != Process.SYSTEM_UID) &#123;</span><br><span class="line">            flags &amp;= ~AlarmManager.FLAG_IDLE_UNTIL;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【6】如果闹钟的精确闹钟，那就设置 FLAG_STANDALONE 标志位，精确闹钟不会和其他闹钟进行批处理！</span></span><br><span class="line">        <span class="comment">// Flags 设置 FLAG_STANDALONE 标志位！</span></span><br><span class="line">        <span class="keyword">if</span> (windowLength == AlarmManager.WINDOW_EXACT) &#123;</span><br><span class="line">            flags |= AlarmManager.FLAG_STANDALONE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【7】如果是通过 setAlarmClock 方法设置的闹钟，那么其是精确的并且是 idle 状态依然生效的</span></span><br><span class="line">        <span class="comment">// flags 设置 FLAG_WAKE_FROM_IDLE 和 FLAG_STANDALONE！</span></span><br><span class="line">        <span class="keyword">if</span> (alarmClock != <span class="keyword">null</span>) &#123;</span><br><span class="line">            flags |= AlarmManager.FLAG_WAKE_FROM_IDLE | AlarmManager.FLAG_STANDALONE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【7】如果不是调用 setAlarmClock 方法设置 alarm，进入下面的分支！</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (workSource == <span class="keyword">null</span> &amp;&amp; (callingUid &lt; Process.FIRST_APPLICATION_UID</span><br><span class="line">                || Arrays.binarySearch(mDeviceIdleUserWhitelist,</span><br><span class="line">                        UserHandle.getAppId(callingUid)) &gt;= <span class="number">0</span>)) &#123;</span><br><span class="line">                        </span><br><span class="line">            <span class="comment">// 如果 workSource 为 null，且调用者是系统应用，或者调用者在 doze 模式白名单中</span></span><br><span class="line">            <span class="comment">// 那么该 alarm 在 idle 状态下，不受限制，flags 设置 FLAG_ALLOW_WHILE_IDLE_UNRESTRICTED！</span></span><br><span class="line">            <span class="comment">// 取消 FLAG_ALLOW_WHILE_IDLE 标志位！</span></span><br><span class="line">            flags |= AlarmManager.FLAG_ALLOW_WHILE_IDLE_UNRESTRICTED;</span><br><span class="line">            flags &amp;= ~AlarmManager.FLAG_ALLOW_WHILE_IDLE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【3.2】调用 AlarmManagerService 的 setImpl 方法继续设置闹钟！</span></span><br><span class="line">        setImpl(type, triggerAtTime, windowLength, interval, operation, directReceiver,</span><br><span class="line">                listenerTag, flags, workSource, alarmClock, callingUid, callingPackage);</span><br><span class="line">    &#125;</span><br><span class="line">    ... ... ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>标志位</strong>：</p>
<ul>
<li>AlarmManager.FLAG_WAKE_FROM_IDLE: <ul>
<li>如果设备处于 idle 状态，该类型的 alarm 会将设别唤醒！</li>
<li>AlarmClock 默认就是 FLAG_WAKE_FROM_IDLE 类型的！</li>
</ul>
</li>
</ul>
<p><br></p>
<ul>
<li>AlarmManager.FLAG_IDLE_UNTIL: <ul>
<li>doze 模式的闹钟，只能由系统通过 setIdleUtil 来设置，这个方法会使得系统进入 idle 状态，直到这个 alarm 触发；如果系统中已经有 FLAG_WAKE_FROM_IDLE 类型的 alarm，那么 FLAG_IDLE_UNTIL 类型的 alarm 的触发事件会提前！</li>
</ul>
</li>
</ul>
<p><br></p>
<ul>
<li>AlarmManager.FLAG_STANDALONE: <ul>
<li>精确闹钟，如果设置 alarm 时，指定了闹钟为精确闹钟：WINDOW_EXACT，那么该 flags 会被设置 FLAG_STANDALONE 标志位</li>
</ul>
</li>
</ul>
<p><br></p>
<ul>
<li>AlarmManager.FLAG_ALLOW_WHILE_IDLE：<ul>
<li>即使设备处于 idle 状态，该 alarm 也能触发，通过 setAndAllowWhileIdle 和 setExactAndAllowWhileIdle 设置！</li>
</ul>
</li>
</ul>
<p><br></p>
<ul>
<li>AlarmManager.FLAG_ALLOW_WHILE_IDLE_UNRESTRICTED<ul>
<li>如果是系统应用， 或者调用者在 doze 模式的白名单中，那么会设置 FLAG_ALLOW_WHILE_IDLE_UNRESTRICTED 标志位，而不是 FLAG_ALLOW_WHILE_IDLE 标志位！</li>
</ul>
</li>
</ul>
<p><strong>方法流程总结</strong>：</p>
<ul>
<li>通过 appOps 校验，uid 和包名是否一致；</li>
<li>重复触发的 alarm 必须要使用 PendingIntent，不能使用 directReceiver！</li>
<li>如果 workSource 不为 null，调用者必须有 android.Manifest.permission.UPDATE_DEVICE_STATS 的权限！</li>
<li>非 system uid 的调用者，其不能调用 setIdleUntil 方法设置 FLAG_IDLE_UNTIL！</li>
<li>如果是精确闹钟，那就设置 AlarmManager.FLAG_STANDALONE 标志位！</li>
<li>如果是 alarmClock，那就设置 AlarmManager.FLAG_WAKE_FROM_IDLE 和 AlarmManager.FLAG_STANDALONE！</li>
<li>如果是系统应用， 或者调用者在 doze 模式的白名单中，那么会设置 FLAG_ALLOW_WHILE_IDLE_UNRESTRICTED 标志位，而不是 FLAG_ALLOW_WHILE_IDLE 标志位！</li>
<li>最后，调用 setImpl 方法继续设置！</li>
</ul>
<p>可以看到，我们在 AlarmManager 中调用的 set 接口，会调用该“桩”对象的 set 方法，桩对象的 set 最后会调用 AlarmManagerService 的 setImpl 方法！</p>
<h2 id="3-2-AlarmMS-setImpl"><a href="#3-2-AlarmMS-setImpl" class="headerlink" title="3.2 AlarmMS.setImpl"></a>3.2 AlarmMS.setImpl</h2><p>setImpl 方法中，首先会做一些参数校验！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setImpl</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">long</span> triggerAtTime, <span class="keyword">long</span> windowLength, <span class="keyword">long</span> interval,</span></span></span><br><span class="line"><span class="function"><span class="params">        PendingIntent operation, IAlarmListener directReceiver, String listenerTag,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> flags, WorkSource workSource, AlarmManager.AlarmClockInfo alarmClock,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> callingUid, String callingPackage)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】校验 PendingIntent 和 directReceiver 是否设置正确！</span></span><br><span class="line">    <span class="keyword">if</span> ((operation == <span class="keyword">null</span> &amp;&amp; directReceiver == <span class="keyword">null</span>)</span><br><span class="line">            || (operation != <span class="keyword">null</span> &amp;&amp; directReceiver != <span class="keyword">null</span>)) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"Alarms must either supply a PendingIntent or an AlarmReceiver"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】校验时间窗的长度</span></span><br><span class="line">    <span class="comment">// 如果时间窗长度超过 12h，那就设置为 1h</span></span><br><span class="line">    <span class="keyword">if</span> (windowLength &gt; AlarmManager.INTERVAL_HALF_DAY) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"Window length "</span> + windowLength</span><br><span class="line">                + <span class="string">"ms suspiciously long; limiting to 1 hour"</span>);</span><br><span class="line">        windowLength = AlarmManager.INTERVAL_HOUR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【3】校验重复触发的时间间隔，最小的重复触发的时间间隔为 1min!</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> minInterval = mConstants.MIN_INTERVAL;</span><br><span class="line">    <span class="keyword">if</span> (interval &gt; <span class="number">0</span> &amp;&amp; interval &lt; minInterval) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"Suspiciously short interval "</span> + interval</span><br><span class="line">                + <span class="string">" millis; expanding to "</span> + (minInterval/<span class="number">1000</span>)</span><br><span class="line">                + <span class="string">" seconds"</span>);</span><br><span class="line">        interval = minInterval;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【4】校验闹钟的类型 type 是否设置的正确！</span></span><br><span class="line">    <span class="keyword">if</span> (type &lt; RTC_WAKEUP || type &gt; ELAPSED_REALTIME) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Invalid alarm type "</span> + type);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【5】校验触发时间是否正确！</span></span><br><span class="line">    <span class="keyword">if</span> (triggerAtTime &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> what = Binder.getCallingPid();</span><br><span class="line">        Slog.w(TAG, <span class="string">"Invalid alarm trigger time! "</span> + triggerAtTime + <span class="string">" from uid="</span> + callingUid</span><br><span class="line">                + <span class="string">" pid="</span> + what);</span><br><span class="line">        triggerAtTime = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【3.2.1】计算触发时间，根据闹钟是否是 RTC 类型的，进行调整！</span></span><br><span class="line">    <span class="comment">// 如果是 RTC 格式，就将其转换成 elapsedRealtime 格式的触发时间！</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> nowElapsed = SystemClock.elapsedRealtime();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> nominalTrigger = convertToElapsed(triggerAtTime, type);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【7】校验触发时间是否大于最低触发时间，默认是 5s，防止 alarm 频繁触发！</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> minTrigger = nowElapsed + mConstants.MIN_FUTURITY;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> triggerElapsed = (nominalTrigger &gt; minTrigger) ? nominalTrigger : minTrigger;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【8】根据时间窗取值，设置最晚触发时间！</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> maxElapsed;</span><br><span class="line">    <span class="keyword">if</span> (windowLength == AlarmManager.WINDOW_EXACT) &#123;</span><br><span class="line">        <span class="comment">//【8.1】如果取值为 WINDOW_EXACT，那就为精确闹钟，最晚触发时间和设置的时间一样！</span></span><br><span class="line">        maxElapsed = triggerElapsed;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (windowLength &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//【3.2.2】如果取值小于 0，其为非精确闹钟，那么这里会计算最晚触发时间！</span></span><br><span class="line">        <span class="comment">// 并根据最晚触发时间重新计算时间窗！</span></span><br><span class="line">        maxElapsed = maxTriggerTime(nowElapsed, triggerElapsed, interval);</span><br><span class="line">        windowLength = maxElapsed - triggerElapsed;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//【8.3】其他情况，也是非精确闹钟，说明用户显示指定了时间窗，那就依此计算最晚触发时间！</span></span><br><span class="line">        maxElapsed = triggerElapsed + windowLength;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_BATCH) &#123;</span><br><span class="line">            Slog.v(TAG, <span class="string">"set("</span> + operation + <span class="string">") : type="</span> + type</span><br><span class="line">                    + <span class="string">" triggerAtTime="</span> + triggerAtTime + <span class="string">" win="</span> + windowLength</span><br><span class="line">                    + <span class="string">" tElapsed="</span> + triggerElapsed + <span class="string">" maxElapsed="</span> + maxElapsed</span><br><span class="line">                    + <span class="string">" interval="</span> + interval + <span class="string">" flags=0x"</span> + Integer.toHexString(flags));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【3.1】调用 setImplLocked 继续设置 alarm！</span></span><br><span class="line">        setImplLocked(type, triggerAtTime, triggerElapsed, windowLength, maxElapsed,</span><br><span class="line">                interval, operation, directReceiver, listenerTag, flags, <span class="keyword">true</span>, workSource,</span><br><span class="line">                alarmClock, callingUid, callingPackage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看看这个过程：</p>
<ul>
<li>校验 PendingIntent 和 directReceiver 是否设置正确，二者只能设置一个！</li>
<li>检验时间窗，如果 windowLength 超过 12h，那就设置为 1h！</li>
<li>校验重复触发的时间间隔，最小的重复触发的时间间隔为 1min!</li>
<li><p>调整触发时间</p>
<ul>
<li>如果是 RTC 类型的闹钟，将触发事件转为相对于开机的时间！</li>
<li>触发时间最短是 5s</li>
</ul>
</li>
<li><p>调整最晚触发时间和时间窗</p>
<ul>
<li>精确闹钟，最晚触发时间和设置的时间一样，无时间窗！</li>
<li>非精确闹钟，如果没有显式设置时间窗，那么就根据 triggerElapsed，nowElapsed 和 interval 计算合适的最晚触发时间和时间窗！</li>
<li>非精确闹钟，如果显式设置了时间窗。那么最晚触发时间为：triggerElapsed + windowLength！</li>
</ul>
</li>
<li><p>最后，调用 setImplLocked 进一步设置 alarm！</p>
</li>
</ul>
<h3 id="3-2-1-AlarmMS-convertToElapsed"><a href="#3-2-1-AlarmMS-convertToElapsed" class="headerlink" title="3.2.1 AlarmMS.convertToElapsed"></a>3.2.1 AlarmMS.convertToElapsed</h3><p>对于触发事件，要根据闹钟的类型，来修正：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">convertToElapsed</span><span class="params">(<span class="keyword">long</span> when, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】判断是否是 RTC 闹钟类型！</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isRtc = (type == RTC || type == RTC_WAKEUP);</span><br><span class="line">    <span class="comment">//【2】如果是 RTC 类型的，就将其转为相对于开机的时间点！</span></span><br><span class="line">    <span class="keyword">if</span> (isRtc) &#123;</span><br><span class="line">        when -= System.currentTimeMillis() - SystemClock.elapsedRealtime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> when;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>计算结果：<br>when = when - System.currentTimeMillis() + SystemClock.elapsedRealtime();</p>
<p>如果是 rtc 类型，那就将其转为了相对于开机的时间！</p>
<h3 id="3-2-2-AlarmMS-maxTriggerTime"><a href="#3-2-2-AlarmMS-maxTriggerTime" class="headerlink" title="3.2.2 AlarmMS.maxTriggerTime"></a>3.2.2 AlarmMS.maxTriggerTime</h3><p>接着是计算最大的触发时间，这里的 MIN_FUZZABLE_INTERVAL 表示的是最小的时间窗间隔！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// minimum recurrence period or alarm futurity for us to be able to fuzz it</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> MIN_FUZZABLE_INTERVAL = <span class="number">10000</span>;</span><br></pre></td></tr></table></figure>
<p>继续来看：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">long</span> <span class="title">maxTriggerTime</span><span class="params">(<span class="keyword">long</span> now, <span class="keyword">long</span> triggerAtTime, <span class="keyword">long</span> interval)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】如果没有设置重复的时间间隔 interval，那么时间间隔为触发时间 triggerAtTime - 当前时间 now！</span></span><br><span class="line">    <span class="comment">// 否则，时间间隔为 interval！</span></span><br><span class="line">    <span class="keyword">long</span> futurity = (interval == <span class="number">0</span>)</span><br><span class="line">            ? (triggerAtTime - now)</span><br><span class="line">            : interval;</span><br><span class="line">    <span class="comment">//【2】如果计算出的时间间隔 futurity 小于 10s，那么设置其为 0；</span></span><br><span class="line">    <span class="keyword">if</span> (futurity &lt; MIN_FUZZABLE_INTERVAL) &#123;</span><br><span class="line">        futurity = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【3】最后，最大的触发时间点为：开始触发时间点 + 0.75 倍的时间间隔 futurity！</span></span><br><span class="line">    <span class="keyword">return</span> triggerAtTime + (<span class="keyword">long</span>)(.<span class="number">75</span> * futurity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于非精确的 alarm，这里通过 maxTriggerTime 方法计算其批处理的时间窗为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.75</span> * (interval or triggerAtTime - now)</span><br></pre></td></tr></table></figure></p>
<p>如果计算出的时间窗小于 10 s，那么就不设置最晚执行时间！</p>
<h2 id="3-3-AlarmMS-setImplLocked-15"><a href="#3-3-AlarmMS-setImplLocked-15" class="headerlink" title="3.3 AlarmMS.setImplLocked[15]"></a>3.3 AlarmMS.setImplLocked[15]</h2><p><strong>参数传递</strong>：</p>
<ul>
<li><strong>int type</strong>：闹钟的类型</li>
<li><strong>long when</strong>: 触发时间点；</li>
<li><strong>long whenElapsed</strong>：触发时间点，相对于开机时间；</li>
<li><strong>long windowLength</strong>：时间窗；</li>
<li><strong>long maxWhen</strong>：最晚触发的时间点，触发时间点，相对于开机时间！</li>
<li><strong>long interval</strong>：重复触发的时间间隔；</li>
<li><strong>PendingIntent operation</strong>：这个很简单，不多说！</li>
<li><strong>IAlarmListener directReceiver</strong>：这个很简单，也不多说！</li>
<li><strong>String listenerTag</strong>：AlarmListener 的字符串描述信息！</li>
<li><strong>int flags</strong>：alarm 属性标志位！</li>
<li><strong>boolean doValidate</strong>：传入 true！</li>
<li><strong>WorkSource workSource</strong>：工作源对象！</li>
<li><strong>AlarmManager.AlarmClockInfo alarmClock</strong>：通过 setAlarmClock 方法设置才不为 null；</li>
<li><strong>int callingUid</strong>：调用者的 uid；</li>
<li><strong>String callingPackage</strong>：调用者的 package name；</li>
</ul>
<p>对于参数，就简单的介绍到这里！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setImplLocked</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">long</span> when, <span class="keyword">long</span> whenElapsed, <span class="keyword">long</span> windowLength,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span> maxWhen, <span class="keyword">long</span> interval, PendingIntent operation, IAlarmListener directReceiver,</span></span></span><br><span class="line"><span class="function"><span class="params">        String listenerTag, <span class="keyword">int</span> flags, <span class="keyword">boolean</span> doValidate, WorkSource workSource,</span></span></span><br><span class="line"><span class="function"><span class="params">        AlarmManager.AlarmClockInfo alarmClock, <span class="keyword">int</span> callingUid, String callingPackage)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【3.3.1】创建一个 Alarm 对象！</span></span><br><span class="line">    Alarm a = <span class="keyword">new</span> Alarm(type, when, whenElapsed, windowLength, maxWhen, interval,</span><br><span class="line">            operation, directReceiver, listenerTag, workSource, flags, alarmClock,</span><br><span class="line">            callingUid, callingPackage);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果不允许设置 alarm，就退出！</span></span><br><span class="line">        <span class="keyword">if</span> (ActivityManagerNative.getDefault().getAppStartMode(callingUid, callingPackage)</span><br><span class="line">                == ActivityManager.APP_START_MODE_DISABLED) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Not setting alarm from "</span> + callingUid + <span class="string">":"</span> + a</span><br><span class="line">                    + <span class="string">" -- package not allowed to start"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【3.3.2】移除已经设置的相同的 alarm！</span></span><br><span class="line">    removeLocked(operation, directReceiver);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【3.3.3】进一步设置 alarm！</span></span><br><span class="line">    setImplLocked(a, <span class="keyword">false</span>, doValidate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-1-AlarmMS-Alarm"><a href="#3-3-1-AlarmMS-Alarm" class="headerlink" title="3.3.1 AlarmMS.Alarm"></a>3.3.1 AlarmMS.Alarm</h3><p>下面是会创建一个 Alarm 对象，保存本次 set 的 alarm 的信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Alarm</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> type;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> origWhen;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> wakeup;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> PendingIntent operation;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> IAlarmListener listener;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String listenerTag;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String statsTag;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> WorkSource workSource;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> AlarmManager.AlarmClockInfo alarmClock;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> uid;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> creatorUid;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String packageName;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> when;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> windowLength;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> whenElapsed;    <span class="comment">// 'when' in the elapsed time base</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> maxWhenElapsed; <span class="comment">// also in the elapsed time base</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> repeatInterval;</span><br><span class="line">    <span class="keyword">public</span> PriorityClass priorityClass;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Alarm</span><span class="params">(<span class="keyword">int</span> _type, <span class="keyword">long</span> _when, <span class="keyword">long</span> _whenElapsed, <span class="keyword">long</span> _windowLength, <span class="keyword">long</span> _maxWhen,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">long</span> _interval, PendingIntent _op, IAlarmListener _rec, String _listenerTag,</span></span></span><br><span class="line"><span class="function"><span class="params">            WorkSource _ws, <span class="keyword">int</span> _flags, AlarmManager.AlarmClockInfo _info,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> _uid, String _pkgName)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        type = _type; <span class="comment">// 闹钟类型，对应的是 AlarmManager 中的四种类型！</span></span><br><span class="line">        origWhen = _when; <span class="comment">// 触发时间点！</span></span><br><span class="line">        wakeup = _type == AlarmManager.ELAPSED_REALTIME_WAKEUP <span class="comment">// 是否是 wake up 类型的！</span></span><br><span class="line">                || _type == AlarmManager.RTC_WAKEUP;</span><br><span class="line">        when = _when; <span class="comment">// 触发事件点！</span></span><br><span class="line">        whenElapsed = _whenElapsed; <span class="comment">// 触发时间点，相对于开机时间！</span></span><br><span class="line">        windowLength = _windowLength; <span class="comment">// 时间窗；</span></span><br><span class="line">        maxWhenElapsed = _maxWhen; <span class="comment">// 最晚触发的时间点，触发时间点，相对于开机时间！</span></span><br><span class="line">        repeatInterval = _interval; <span class="comment">// 重复触发的时间间隔！</span></span><br><span class="line">        operation = _op;</span><br><span class="line">        listener = _rec;</span><br><span class="line">        listenerTag = _listenerTag;</span><br><span class="line">        statsTag = makeTag(_op, _listenerTag, _type);</span><br><span class="line">        workSource = _ws;</span><br><span class="line">        flags = _flags; <span class="comment">// 闹钟属性的标志位！</span></span><br><span class="line">        alarmClock = _info;</span><br><span class="line">        uid = _uid;</span><br><span class="line">        packageName = _pkgName;</span><br><span class="line">        creatorUid = (operation != <span class="keyword">null</span>) ? operation.getCreatorUid() : uid; <span class="comment">// 创建 intent 的 uid</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">makeTag</span><span class="params">(PendingIntent pi, String tag, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> String alarmString = type == ELAPSED_REALTIME_WAKEUP || type == RTC_WAKEUP</span><br><span class="line">                ? <span class="string">"*walarm*:"</span> : <span class="string">"*alarm*:"</span>;</span><br><span class="line">        <span class="keyword">return</span> (pi != <span class="keyword">null</span>) ? pi.getTag(alarmString) : (alarmString + tag);</span><br><span class="line">    &#125;</span><br><span class="line">    ... ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Alarm 有几个方法，我们来看下：</p>
<h4 id="3-3-1-1-Alarm-make"><a href="#3-3-1-1-Alarm-make" class="headerlink" title="3.3.1.1 Alarm.make"></a>3.3.1.1 Alarm.make</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> WakeupEvent <span class="title">makeWakeupEvent</span><span class="params">(<span class="keyword">long</span> nowRTC)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> WakeupEvent(nowRTC, creatorUid,</span><br><span class="line">            (operation != <span class="keyword">null</span>)</span><br><span class="line">                ? operation.getIntent().getAction()</span><br><span class="line">                : (<span class="string">"&lt;listener&gt;:"</span> + listenerTag));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法是用来创建一个 wake up event！</p>
<h4 id="3-3-1-2-Alarm-matches"><a href="#3-3-1-2-Alarm-matches" class="headerlink" title="3.3.1.2 Alarm.matches"></a>3.3.1.2 Alarm.matches</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns true if either matches</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(PendingIntent pi, IAlarmListener rec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (operation != <span class="keyword">null</span>)</span><br><span class="line">            ? operation.equals(pi)</span><br><span class="line">            : rec != <span class="keyword">null</span> &amp;&amp; listener.asBinder().equals(rec.asBinder());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(String packageName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (operation != <span class="keyword">null</span>)</span><br><span class="line">            ? packageName.equals(operation.getTargetPackage())</span><br><span class="line">            : packageName.equals(<span class="keyword">this</span>.packageName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法是用来匹配 Alarm 的，代码逻辑很简单，使用 packageName 或者 PendingIntent，AlarmListener 进行匹配！</p>
<p>我们继续来看：</p>
<h3 id="3-3-2-AlarmMS-removeLocked"><a href="#3-3-2-AlarmMS-removeLocked" class="headerlink" title="3.3.2 AlarmMS.removeLocked"></a>3.3.2 AlarmMS.removeLocked</h3><p>removeLocked 方法用于移除一个已经存在的 alarm！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeLocked</span><span class="params">(PendingIntent operation, IAlarmListener directReceiver)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> didRemove = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//【1】遍历 mAlarmBatches 中所有的 Batch 批处理对象，从 Batch 中移除该 alarm！</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mAlarmBatches.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        Batch b = mAlarmBatches.get(i);</span><br><span class="line">        <span class="comment">//【3.3.2.1】匹配并移除成功会返回 true！</span></span><br><span class="line">        didRemove |= b.remove(operation, directReceiver);</span><br><span class="line">        <span class="keyword">if</span> (b.size() == <span class="number">0</span>) &#123; <span class="comment">// 如果该 Batch 中没有了其他的 alarm，就移除这个 Batch！</span></span><br><span class="line">            mAlarmBatches.remove(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】遍历 mPendingWhileIdleAlarms 中所有因为进入 idle 状态而等待执行的 Alarm 对象！</span></span><br><span class="line">    <span class="comment">// 移除和本次 alarm 匹配的 alarm！</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mPendingWhileIdleAlarms.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mPendingWhileIdleAlarms.get(i).matches(operation, directReceiver)) &#123;</span><br><span class="line">            mPendingWhileIdleAlarms.remove(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【3】如果 didRemove 为 true，表示确实是移除了一个相同的 alarm！</span></span><br><span class="line">    <span class="keyword">if</span> (didRemove) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_BATCH) &#123;</span><br><span class="line">            Slog.v(TAG, <span class="string">"remove(operation) changed bounds; rebatching"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> restorePending = <span class="keyword">false</span>; <span class="comment">// 表示是否恢复正在等待中的 alarm</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 mPendingIdleUntil 不为 null，且移除的 alarm 和 mPendingIdleUntil 匹配，那就说明</span></span><br><span class="line">        <span class="comment">// 要退出 idle 状态！</span></span><br><span class="line">        <span class="keyword">if</span> (mPendingIdleUntil != <span class="keyword">null</span> &amp;&amp; mPendingIdleUntil.matches(operation, directReceiver)) &#123;</span><br><span class="line">            <span class="comment">// 那就设置 mPendingIdleUntil 为 null，同时设置 restorePending 为 true！</span></span><br><span class="line">            mPendingIdleUntil = <span class="keyword">null</span>;</span><br><span class="line">            restorePending = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果 mNextWakeFromIdle 不为 null，且移除的 alarm 和 mPendingIdleUntil 匹配，</span></span><br><span class="line">        <span class="comment">// 那就设置 mNextWakeFromIdle 为 null！！</span></span><br><span class="line">        <span class="keyword">if</span> (mNextWakeFromIdle != <span class="keyword">null</span> &amp;&amp; mNextWakeFromIdle.matches(operation, directReceiver)) &#123;</span><br><span class="line">            mNextWakeFromIdle = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【3.3.2.2】对其他的 alarm 重新进行批处理分配！</span></span><br><span class="line">        rebatchAllAlarmsLocked(<span class="keyword">true</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【3.3.2.3】如果 restorePending 为 true，说明从 idle 状态恢复了，那就要恢复 mPendingWhileIdleAlarms</span></span><br><span class="line">        <span class="comment">// 中所有 alarm！</span></span><br><span class="line">        <span class="keyword">if</span> (restorePending) &#123;</span><br><span class="line">            restorePendingWhileIdleAlarmsLocked();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【3.4.5】更新下一个 AlarmClock 的时间！</span></span><br><span class="line">        updateNextAlarmClockLocked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这边是匹配到和本次设置的 alarm 相同的 alarm，然后做移除操作，然后恢复一些需要执行的 alarm！</p>
<h4 id="3-3-2-1-AlarmMS-Batch-remove"><a href="#3-3-2-1-AlarmMS-Batch-remove" class="headerlink" title="3.3.2.1 AlarmMS.Batch.remove"></a>3.3.2.1 AlarmMS.Batch.remove</h4><p>从一个 Batch 中移除一个 alarm，Batch 中的非精确 alarm 是按照触发事件排序的，同时 Batch 也有一个 start 变量，表示批处理内部所有 alarm 的时间点！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(<span class="keyword">final</span> PendingIntent operation, <span class="keyword">final</span> IAlarmListener listener)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (operation == <span class="keyword">null</span> &amp;&amp; listener == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (localLOGV) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"requested remove() of null operation"</span>,</span><br><span class="line">                    <span class="keyword">new</span> RuntimeException(<span class="string">"here"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> didRemove = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">long</span> newStart = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> newEnd = Long.MAX_VALUE;</span><br><span class="line">    <span class="keyword">int</span> newFlags = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; alarms.size(); ) &#123;</span><br><span class="line">        Alarm alarm = alarms.get(i);</span><br><span class="line">        <span class="comment">//【3.3.1.2】这里用到了 alarm 的 matches 匹配方法，前面有说过！</span></span><br><span class="line">        <span class="keyword">if</span> (alarm.matches(operation, listener)) &#123;</span><br><span class="line">            alarms.remove(i);</span><br><span class="line">            <span class="comment">//【1】设置 didRemove 为 true；</span></span><br><span class="line">            didRemove = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【2】如果匹配的 alarm 是通过 setAlarmClock 设置的，就设置 mNextAlarmClockMayChange 为 true！</span></span><br><span class="line">            <span class="keyword">if</span> (alarm.alarmClock != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mNextAlarmClockMayChange = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (alarm.whenElapsed &gt; newStart) &#123; <span class="comment">// 更新 newStart 时间点！</span></span><br><span class="line">                newStart = alarm.whenElapsed;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (alarm.maxWhenElapsed &lt; newEnd) &#123; <span class="comment">// 更新 newStart 时间点！</span></span><br><span class="line">                newEnd = alarm.maxWhenElapsed;</span><br><span class="line">            &#125;</span><br><span class="line">            newFlags |= alarm.flags; <span class="comment">// 获得该 Batch 中所有 Alarm 的标志位！</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【3】如果移除了，那就更新 Batch 的 start 和 end 时间点！</span></span><br><span class="line">    <span class="keyword">if</span> (didRemove) &#123;</span><br><span class="line">        start = newStart;</span><br><span class="line">        end = newEnd;</span><br><span class="line">        flags = newFlags;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> didRemove;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到：</p>
<ul>
<li><p>从这个 batch 移除 operation 或者 listener 匹配的 alarm，并更新 batch 的 start， end 和 flags 对象！</p>
</li>
<li><p>如果被移除的 alarm 是通过 setAlarmClock 设置的，那么 mNextAlarmClockMayChange 为 true，后面系统会调用指定方法来更新下一个 AlarmClock！</p>
</li>
</ul>
<p>我们可以看到，当我们从 Batch 中移除一个 Alarm 后，Batch 的 start 和 end 时间点发生了变化，这样会导致 Batch 在 mAlarmBatches 中的顺序发生变化！</p>
<h4 id="3-3-2-2-AlarmMS-rebatchAllAlarmsLocked"><a href="#3-3-2-2-AlarmMS-rebatchAllAlarmsLocked" class="headerlink" title="3.3.2.2 AlarmMS.rebatchAllAlarmsLocked"></a>3.3.2.2 AlarmMS.rebatchAllAlarmsLocked</h4><p>该方法用于重新对所有的 alarm 进行 batch 批处理！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rebatchAllAlarmsLocked</span><span class="params">(<span class="keyword">boolean</span> doValidate)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】将 mAlarmBatches 拷贝一份到 oldSet 中，并清空 mAlarmBatches！</span></span><br><span class="line">    ArrayList&lt;Batch&gt; oldSet = (ArrayList&lt;Batch&gt;) mAlarmBatches.clone();</span><br><span class="line">    mAlarmBatches.clear();</span><br><span class="line"></span><br><span class="line">    Alarm oldPendingIdleUntil = mPendingIdleUntil;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> nowElapsed = SystemClock.elapsedRealtime();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> oldBatches = oldSet.size();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】遍历每一个 Batch 的中 Alarm，重新进行批处理分配！</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> batchNum = <span class="number">0</span>; batchNum &lt; oldBatches; batchNum++) &#123;</span><br><span class="line">        Batch batch = oldSet.get(batchNum);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N = batch.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="comment">//【3.3.2.1.1】重新添加 Alarm！</span></span><br><span class="line">            reAddAlarmLocked(batch.get(i), nowElapsed, doValidate);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【3】如果 oldPendingIdleUntil 不为 null，而 mPendingIdleUntil 为 null</span></span><br><span class="line">    <span class="comment">// 说明，此时推出了 idle 状态，那就恢复那些因为 idle 状态而等待的 alarm！</span></span><br><span class="line">    <span class="comment">// × 这里感觉是为了解决 bug，因为看逻辑，不会进入这里</span></span><br><span class="line">    <span class="keyword">if</span> (oldPendingIdleUntil != <span class="keyword">null</span> &amp;&amp; oldPendingIdleUntil != mPendingIdleUntil) &#123;</span><br><span class="line">        Slog.wtf(TAG, <span class="string">"Rebatching: idle until changed from "</span> + oldPendingIdleUntil</span><br><span class="line">                + <span class="string">" to "</span> + mPendingIdleUntil);</span><br><span class="line">        <span class="keyword">if</span> (mPendingIdleUntil == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//【3.3.2.3】恢复等待中的 alarm！</span></span><br><span class="line">            restorePendingWhileIdleAlarmsLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【3.4.4】重新调度并设置下一个 alarm！</span></span><br><span class="line">    rescheduleKernelAlarmsLocked();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【3.4.5】更新下一个 AlarmClock 闹钟！</span></span><br><span class="line">    updateNextAlarmClockLocked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-3-2-2-1-AlarmManagerService-reAddAlarmLocked"><a href="#3-3-2-2-1-AlarmManagerService-reAddAlarmLocked" class="headerlink" title="3.3.2.2.1 AlarmManagerService.reAddAlarmLocked"></a>3.3.2.2.1 AlarmManagerService.reAddAlarmLocked</h5><p>该方法用于重新添加 alarm！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reAddAlarmLocked</span><span class="params">(Alarm a, <span class="keyword">long</span> nowElapsed, <span class="keyword">boolean</span> doValidate)</span> </span>&#123;</span><br><span class="line">    a.when = a.origWhen;</span><br><span class="line">    <span class="keyword">long</span> whenElapsed = convertToElapsed(a.when, a.type);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> maxElapsed;</span><br><span class="line">    <span class="keyword">if</span> (a.windowLength == AlarmManager.WINDOW_EXACT) &#123; <span class="comment">// 根据类型的不同，计算最大触发时间！</span></span><br><span class="line">        maxElapsed = whenElapsed; <span class="comment">// 精确闹钟！</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//【3.2.2】非精确闹钟！</span></span><br><span class="line">        maxElapsed = (a.windowLength &gt; <span class="number">0</span>)</span><br><span class="line">                ? (whenElapsed + a.windowLength)</span><br><span class="line">                : maxTriggerTime(nowElapsed, whenElapsed, a.repeatInterval);</span><br><span class="line">    &#125;</span><br><span class="line">    a.whenElapsed = whenElapsed;</span><br><span class="line">    a.maxWhenElapsed = maxElapsed;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【3.4】调用 setImplLocked 方法重新设置 alarm，注意这里的 rebatching 值为 true！</span></span><br><span class="line">    setImplLocked(a, <span class="keyword">true</span>, doValidate);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这里调用了 setImplLocked 三参数方法，重新设置该 alarm！</p>
<p>在 setImplLocked 方法中，会重新为 Alarm 分配 Batch，并对 mAlarmBatches 中的所有 Batch 重新排序，后面我们能够看到对该方法的分析，在第 3.4 节！</p>
<h4 id="3-3-2-3-AlarmMS-restorePendingWhileIdleAlarmsLocked"><a href="#3-3-2-3-AlarmMS-restorePendingWhileIdleAlarmsLocked" class="headerlink" title="3.3.2.3 AlarmMS.restorePendingWhileIdleAlarmsLocked"></a>3.3.2.3 AlarmMS.restorePendingWhileIdleAlarmsLocked</h4><p>接着，当系统退出 idle 状态后，要恢复那些因为 idle 状态而等待触发的 alarm！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">restorePendingWhileIdleAlarmsLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (RECORD_DEVICE_IDLE_ALARMS) &#123; <span class="comment">// RECORD_DEVICE_IDLE_ALARMS 默认为 false，用于 dump 不处理；</span></span><br><span class="line">        IdleDispatchEntry ent = <span class="keyword">new</span> IdleDispatchEntry();</span><br><span class="line">        ent.uid = <span class="number">0</span>;</span><br><span class="line">        ent.pkg = <span class="string">"FINISH IDLE"</span>;</span><br><span class="line">        ent.elapsedRealtime = SystemClock.elapsedRealtime();</span><br><span class="line">        mAllowWhileIdleDispatches.add(ent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果此时 mPendingWhileIdleAlarms 不为 empty，那就说明有等待触发的 alarm！</span></span><br><span class="line">    <span class="comment">// 将其重新进行批处理分配！</span></span><br><span class="line">    <span class="keyword">if</span> (mPendingWhileIdleAlarms.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ArrayList&lt;Alarm&gt; alarms = mPendingWhileIdleAlarms;</span><br><span class="line">        mPendingWhileIdleAlarms = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> nowElapsed = SystemClock.elapsedRealtime();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=alarms.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            Alarm a = alarms.get(i);</span><br><span class="line">            <span class="comment">//【3.3.2.1.1】这里调用了 reAddAlarmLocked 方法，重新批处理 alarm，该方法上面有说过！</span></span><br><span class="line">            reAddAlarmLocked(a, nowElapsed, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新 ALLOW_WHILE_IDLE 最小时间！</span></span><br><span class="line">    mConstants.updateAllowWhileIdleMinTimeLocked();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【3.3.2.4】重新调度，设置 alarm！</span></span><br><span class="line">    rescheduleKernelAlarmsLocked();</span><br><span class="line">    <span class="comment">//【3.3.2.5】更新下一个 Alarm 的触发时间！</span></span><br><span class="line">    updateNextAlarmClockLocked();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送一个时间改变的广播，用于更新 ui！</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mTimeTickSender.send();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (PendingIntent.CanceledException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续看！</p>
<h2 id="3-4-AlarmMS-setImplLocked-3"><a href="#3-4-AlarmMS-setImplLocked-3" class="headerlink" title="3.4 AlarmMS.setImplLocked[3]"></a>3.4 AlarmMS.setImplLocked[3]</h2><p>接下来，我们来看一个非常重要的方法 setImplLocked！，第二个参数 rebatching 表示是否是 rebatch，正常流程下，rebatching 是为 false；</p>
<p>但是，当我们 rebatch 或者 restore 其他 alarm 时，rebatching 传入的是 true！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setImplLocked</span><span class="params">(Alarm a, <span class="keyword">boolean</span> rebatching, <span class="keyword">boolean</span> doValidate)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】如果 alarm 设置了 AlarmManager.FLAG_IDLE_UNTIL 标志位，说明是 setIdleUtil 方法设置的！</span></span><br><span class="line">    <span class="comment">// 这是一种很特殊的闹钟，用于将系统设置为 idle 状态，但其触发后退出 idle 状态！</span></span><br><span class="line">    <span class="comment">// 如果有其他 alarm 会将系统从 idle 状态唤醒的话，并且其触发事件比 setIdleUtil 更早的的话，我们需要将</span></span><br><span class="line">    <span class="comment">// setIdleUtil 闹钟的时间提前！</span></span><br><span class="line">    <span class="keyword">if</span> ((a.flags&amp;AlarmManager.FLAG_IDLE_UNTIL) != <span class="number">0</span>) &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 如果 mNextWakeFromIdle 不为 null，说明有 alarm 会在设备处于 idle 的状态下唤醒设备</span></span><br><span class="line">        <span class="comment">// 如果 mNextWakeFromIdle 的触发时间更早，那么需要调整 setIdleUtil 的时间为 mNextWakeFromIdle 的触发时间！</span></span><br><span class="line">        <span class="keyword">if</span> (mNextWakeFromIdle != <span class="keyword">null</span> &amp;&amp; a.whenElapsed &gt; mNextWakeFromIdle.whenElapsed) &#123;</span><br><span class="line">            <span class="comment">// 因为是精确闹钟，所以所有时间相同！</span></span><br><span class="line">            a.when = a.whenElapsed = a.maxWhenElapsed = mNextWakeFromIdle.whenElapsed;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【3.4.1】接着对 setIdleUtil 闹钟的触发时间做一个细微调整，将前面设置的触发时间提前一个时间段！</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> nowElapsed = SystemClock.elapsedRealtime();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> fuzz = fuzzForDuration(a.whenElapsed-nowElapsed);</span><br><span class="line">        <span class="keyword">if</span> (fuzz &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mRandom == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mRandom = <span class="keyword">new</span> Random();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 可以看到，最后进一步调整的提前时间间隔为 0 到 fuzz 的一个随机整数时间，单位是分钟！</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> delta = mRandom.nextInt(fuzz);</span><br><span class="line">            a.whenElapsed -= delta;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;</span><br><span class="line">                Slog.d(TAG, <span class="string">"Alarm when: "</span> + a.whenElapsed);</span><br><span class="line">                Slog.d(TAG, <span class="string">"Delta until alarm: "</span> + (a.whenElapsed-nowElapsed));</span><br><span class="line">                Slog.d(TAG, <span class="string">"Applied fuzz: "</span> + fuzz);</span><br><span class="line">                Slog.d(TAG, <span class="string">"Final delta: "</span> + delta);</span><br><span class="line">                Slog.d(TAG, <span class="string">"Final when: "</span> + a.whenElapsed);</span><br><span class="line">            &#125;</span><br><span class="line">            a.when = a.maxWhenElapsed = a.whenElapsed;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mPendingIdleUntil != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果没有设置 FLAG_IDLE_UNTIL 标志位，那么就要判断下 mPendingIdleUntil 是否为 null；</span></span><br><span class="line">        <span class="comment">// 其不为 null，说明系统现在处于 idle 状态，如果 alarm 没有设置一下的几种标志位的话，</span></span><br><span class="line">        <span class="comment">// 那就将其加入到 mPendingWhileIdleAlarms 列表中，等到系统退出 idle 状态后，再设置这些闹钟！</span></span><br><span class="line">        <span class="keyword">if</span> ((a.flags&amp;(AlarmManager.FLAG_ALLOW_WHILE_IDLE</span><br><span class="line">                | AlarmManager.FLAG_ALLOW_WHILE_IDLE_UNRESTRICTED</span><br><span class="line">                | AlarmManager.FLAG_WAKE_FROM_IDLE))</span><br><span class="line">                == <span class="number">0</span>) &#123;</span><br><span class="line">            mPendingWhileIdleAlarms.add(a);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RECORD_DEVICE_IDLE_ALARMS 变量默认为 false，如果为 true，那么系统会记录那些在 idle 状态下能够触发的 alarm！</span></span><br><span class="line">    <span class="comment">// 保存到 mAllowWhileIdleDispatches 中，我们在 dumpsys alarm 的时候能看到！</span></span><br><span class="line">    <span class="keyword">if</span> (RECORD_DEVICE_IDLE_ALARMS) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((a.flags &amp; AlarmManager.FLAG_ALLOW_WHILE_IDLE) != <span class="number">0</span>) &#123;</span><br><span class="line">            IdleDispatchEntry ent = <span class="keyword">new</span> IdleDispatchEntry();</span><br><span class="line">            ent.uid = a.uid;</span><br><span class="line">            ent.pkg = a.operation.getCreatorPackage();</span><br><span class="line">            ent.tag = a.operation.getTag(<span class="string">""</span>);</span><br><span class="line">            ent.op = <span class="string">"SET"</span>;</span><br><span class="line">            ent.elapsedRealtime = SystemClock.elapsedRealtime();</span><br><span class="line">            ent.argRealtime = a.whenElapsed;</span><br><span class="line">            mAllowWhileIdleDispatches.add(ent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【3.4.2】为新的 alarm 选择一个合适的 Batch，</span></span><br><span class="line">    <span class="comment">// 如果闹钟的 alarm 的 flags 设置了 AlarmManager.FLAG_STANDALONE 标志</span></span><br><span class="line">    <span class="comment">// 那么其为精确闹钟，那么必须单独在一个 Batch 中！</span></span><br><span class="line">    <span class="keyword">int</span> whichBatch = ((a.flags&amp;AlarmManager.FLAG_STANDALONE) != <span class="number">0</span>)</span><br><span class="line">            ? -<span class="number">1</span> : attemptCoalesceLocked(a.whenElapsed, a.maxWhenElapsed);</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">if</span> (whichBatch &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//【3.4.3】创建一个新的 Batch，并添加到 mAlarmBatch，并对 mAlarmBatches 按开始时间升序排列！</span></span><br><span class="line">        Batch batch = <span class="keyword">new</span> Batch(a);</span><br><span class="line">        addBatchLocked(mAlarmBatches, batch);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//【3.4.3】如果 whichBatch &gt;= 0，说明已经找到合适的 Batch 了，那我们就将其添加进去</span></span><br><span class="line">        Batch batch = mAlarmBatches.get(whichBatch);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前 alarm 的加入使得了 batch 开始时间和结束时间的改变，则 add 返回 true</span></span><br><span class="line">        <span class="comment">// 那么此时，我们需要对 mAlarmBatches 重新排序！</span></span><br><span class="line">        <span class="keyword">if</span> (batch.add(a)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 排序方法很简单，先移除这个 Batch，再重新添加！</span></span><br><span class="line">            mAlarmBatches.remove(whichBatch);</span><br><span class="line">            addBatchLocked(mAlarmBatches, batch);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 a.alarmClock 不为 null，则是通过 setAlarmClock 设置的，那就设置 mNextAlarmClockMayChange 为 true！</span></span><br><span class="line">    <span class="comment">// 下面会根据这个变量更新 AlarmClock！</span></span><br><span class="line">    <span class="keyword">if</span> (a.alarmClock != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mNextAlarmClockMayChange = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> needRebatch = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是通过 setIdleUtil 设置的闹钟，系统此时将进入 idle 状态！</span></span><br><span class="line">    <span class="keyword">if</span> ((a.flags&amp;AlarmManager.FLAG_IDLE_UNTIL) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (RECORD_DEVICE_IDLE_ALARMS) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mPendingIdleUntil == <span class="keyword">null</span>) &#123;</span><br><span class="line">                IdleDispatchEntry ent = <span class="keyword">new</span> IdleDispatchEntry();</span><br><span class="line">                ent.uid = <span class="number">0</span>;</span><br><span class="line">                ent.pkg = <span class="string">"START IDLE"</span>;</span><br><span class="line">                ent.elapsedRealtime = SystemClock.elapsedRealtime();</span><br><span class="line">                mAllowWhileIdleDispatches.add(ent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置 mPendingIdleUntil，更新 allow while idle 最小时间！</span></span><br><span class="line">        <span class="comment">// 因为此时系统进入了 idle 状态，需要 rebatch 其他的闹钟，needRebatch 置为 true！</span></span><br><span class="line">        mPendingIdleUntil = a;</span><br><span class="line">        mConstants.updateAllowWhileIdleMinTimeLocked();</span><br><span class="line">        needRebatch = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((a.flags&amp;AlarmManager.FLAG_WAKE_FROM_IDLE) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果该 alarm 是会在 idle 状态下唤醒，如果此时 mNextWakeFromIdle 为 null，或者</span></span><br><span class="line">        <span class="comment">// mNextWakeFromIdle 的触发时间晚，那就更新 mNextWakeFromIdle 为本次设置的新的 alarm！</span></span><br><span class="line">        <span class="keyword">if</span> (mNextWakeFromIdle == <span class="keyword">null</span> || mNextWakeFromIdle.whenElapsed &gt; a.whenElapsed) &#123;</span><br><span class="line">            mNextWakeFromIdle = a;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If this wake from idle is earlier than whatever was previously scheduled,</span></span><br><span class="line">            <span class="comment">// and we are currently idling, then we need to rebatch alarms in case the idle</span></span><br><span class="line">            <span class="comment">// until time needs to be updated.</span></span><br><span class="line">            <span class="comment">// 如果此时</span></span><br><span class="line">            <span class="keyword">if</span> (mPendingIdleUntil != <span class="keyword">null</span>) &#123;</span><br><span class="line">                needRebatch = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果 rebatching 为 true，表示本次是 rebatch 恢复操作，那么就不会进入下面的分支，原因很简单</span></span><br><span class="line">    <span class="comment">// 因为 rebatch 在前面就已经执行的相应的操作了！</span></span><br><span class="line">    <span class="keyword">if</span> (!rebatching) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_VALIDATE) &#123; <span class="comment">// 用于 debug。</span></span><br><span class="line">            <span class="keyword">if</span> (doValidate &amp;&amp; !validateConsistencyLocked()) &#123;</span><br><span class="line">                Slog.v(TAG, <span class="string">"Tipping-point operation: type="</span> + a.type + <span class="string">" when="</span> + a.when</span><br><span class="line">                        + <span class="string">" when(hex)="</span> + Long.toHexString(a.when)</span><br><span class="line">                        + <span class="string">" whenElapsed="</span> + a.whenElapsed</span><br><span class="line">                        + <span class="string">" maxWhenElapsed="</span> + a.maxWhenElapsed</span><br><span class="line">                        + <span class="string">" interval="</span> + a.repeatInterval + <span class="string">" op="</span> + a.operation</span><br><span class="line">                        + <span class="string">" flags=0x"</span> + Integer.toHexString(a.flags));</span><br><span class="line">                rebatchAllAlarmsLocked(<span class="keyword">false</span>);</span><br><span class="line">                needRebatch = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (needRebatch) &#123; <span class="comment">// 如果 needRebatch 为 true，那么我们要重新批处理所有的 alarm！</span></span><br><span class="line">            rebatchAllAlarmsLocked(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调度 kernel 设置 alarm！</span></span><br><span class="line">        rescheduleKernelAlarmsLocked();</span><br><span class="line">        <span class="comment">// 更新下一个 AlarmClock！</span></span><br><span class="line">        updateNextAlarmClockLocked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法的主要逻辑如下：</p>
<h3 id="3-4-1-AlarmMS-fuzzForDuration"><a href="#3-4-1-AlarmMS-fuzzForDuration" class="headerlink" title="3.4.1 AlarmMS.fuzzForDuration"></a>3.4.1 AlarmMS.fuzzForDuration</h3><p>我们来看看 fuzzForDuration 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fuzzForDuration</span><span class="params">(<span class="keyword">long</span> duration)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (duration &lt; <span class="number">15</span>*<span class="number">60</span>*<span class="number">1000</span>) &#123;</span><br><span class="line">        <span class="comment">//【1】如果 duration 小于 15 分钟，那么我们要调整的时间间隔为 duration</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)duration;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (duration &lt; <span class="number">90</span>*<span class="number">60</span>*<span class="number">1000</span>) &#123;</span><br><span class="line">        <span class="comment">//【2】如果 duration 大于等于 15 分钟，小于 1 小时 30 分钟，那么我们要调整的时间间隔为 15 分钟！</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">15</span>*<span class="number">60</span>*<span class="number">1000</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//【2】如果 duration 大于等于 1 小时 30 分钟，那调整的时间间隔为 30 分钟！</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">30</span>*<span class="number">60</span>*<span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-4-2-AlarmMS-attemptCoalesceLocked"><a href="#3-4-2-AlarmMS-attemptCoalesceLocked" class="headerlink" title="3.4.2 AlarmMS.attemptCoalesceLocked"></a>3.4.2 AlarmMS.attemptCoalesceLocked</h3><p>通过非精确闹钟的触发时间，找到一个合适的 Batch ！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">attemptCoalesceLocked</span><span class="params">(<span class="keyword">long</span> whenElapsed, <span class="keyword">long</span> maxWhen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> N = mAlarmBatches.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        Batch b = mAlarmBatches.get(i);</span><br><span class="line">        <span class="comment">// 匹配到合适的 Batch，那就返回该 Batch 下标！</span></span><br><span class="line">        <span class="keyword">if</span> ((b.flags&amp;AlarmManager.FLAG_STANDALONE) == <span class="number">0</span> &amp;&amp; b.canHold(whenElapsed, maxWhen)) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 无法找到一个合适的，就返回 -1，创建一个新的！</span></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，一个合适的 Batch 满足的条件如下：</p>
<ul>
<li>Batch 的 flags 没有 AlarmManager.FLAG_STANDALONE 标志位，即该 Batch 是只能用于保存非精确闹钟！</li>
<li>canHold 方法返回 true，即：这个 Batch 能够容纳这个 Alarm！</li>
</ul>
<p>下面，我们来看看 canHold 方法的逻辑：</p>
<h4 id="3-4-2-1-AlarmMS-Batch-canHold"><a href="#3-4-2-1-AlarmMS-Batch-canHold" class="headerlink" title="3.4.2.1 AlarmMS.Batch.canHold"></a>3.4.2.1 AlarmMS.Batch.canHold</h4><p>canHold 方法用来判断，该 alarm 是否可以加入到这个 Batch 中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">canHold</span><span class="params">(<span class="keyword">long</span> whenElapsed, <span class="keyword">long</span> maxWhen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (end &gt;= whenElapsed) &amp;&amp; (start &lt;= maxWhen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从方法中可以看出，可以容纳的依据是：</p>
<ul>
<li>batch.end &gt;= alarm.whenElapsed</li>
<li>batch.start &lt;= alarm.maxWhen</li>
</ul>
<p>即：batch 的时间间隔和 alarm 的触发时间间隔必须有交集！！</p>
<h3 id="3-4-3-AlarmMS-addBatchLocked"><a href="#3-4-3-AlarmMS-addBatchLocked" class="headerlink" title="3.4.3 AlarmMS.addBatchLocked"></a>3.4.3 AlarmMS.addBatchLocked</h3><p>我们来看看 addBatchLocked 方法的逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">addBatchLocked</span><span class="params">(ArrayList&lt;Batch&gt; list, Batch newBatch)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】其实就是根据 Batch 的 start 时间，查找到一个更合适的 index！</span></span><br><span class="line">    <span class="keyword">int</span> index = Collections.binarySearch(list, newBatch, sBatchOrder);</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        index = <span class="number">0</span> - index - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【2】插入 index 位置处！</span></span><br><span class="line">    list.add(index, newBatch);</span><br><span class="line">    <span class="comment">//【3】如果返回 true，表示 Batch 处于 list 的开头位置！</span></span><br><span class="line">    <span class="keyword">return</span> (index == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 sBatchOrder 是一个 BatchTimeOrder 实例，实现了 Comparator 接口，用来比较两个 Batch 的 start 时间的大小！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> BatchTimeOrder sBatchOrder = <span class="keyword">new</span> BatchTimeOrder();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BatchTimeOrder</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Batch</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Batch b1, Batch b2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">long</span> when1 = b1.start;</span><br><span class="line">            <span class="keyword">long</span> when2 = b2.start;</span><br><span class="line">            <span class="keyword">if</span> (when1 &gt; when2) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (when1 &lt; when2) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，mAlarmBatches 中的 Batch 是按照开始时间从小到大排序的！！</p>
<p>下面我们来看看 Batch 的相关方法：</p>
<h4 id="3-4-3-1-AlarmMS-Batch-Batch"><a href="#3-4-3-1-AlarmMS-Batch-Batch" class="headerlink" title="3.4.3.1 AlarmMS.Batch.Batch"></a>3.4.3.1 AlarmMS.Batch.Batch</h4><p>当我们要将一个 Alarm 添加到新创建的 Batch 中的时候，会对 Batch 进行初始化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Batch() &#123;</span><br><span class="line">    start = <span class="number">0</span>;</span><br><span class="line">    end = Long.MAX_VALUE;</span><br><span class="line">    flags = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Batch(Alarm seed) &#123;</span><br><span class="line">    <span class="comment">// 初始化 start 为 alarm 的开始触发时间，end 为 alarm 的最大开始触发时间</span></span><br><span class="line">    start = seed.whenElapsed;</span><br><span class="line">    end = seed.maxWhenElapsed;</span><br><span class="line">    flags = seed.flags;</span><br><span class="line">    alarms.add(seed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不多说了，继续看！</p>
<h4 id="3-4-3-2-AlarmMS-Batch-add"><a href="#3-4-3-2-AlarmMS-Batch-add" class="headerlink" title="3.4.3.2 AlarmMS.Batch.add"></a>3.4.3.2 AlarmMS.Batch.add</h4><p>将一个 Alarm 添加到已存在的一个 Batch，通过 add 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(Alarm alarm)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> newStart = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//【1】按照开始触发时间递增的顺序，给这个 alarm 找到合适的位置！</span></span><br><span class="line">    <span class="keyword">int</span> index = Collections.binarySearch(alarms, alarm, sIncreasingTimeOrder);</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        index = <span class="number">0</span> - index - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【2】添加到指定的位置！</span></span><br><span class="line">    alarms.add(index, alarm);</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_BATCH) &#123;</span><br><span class="line">        Slog.v(TAG, <span class="string">"Adding "</span> + alarm + <span class="string">" to "</span> + <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【3】更改 Batch 的 start 和 end 时间！</span></span><br><span class="line">    <span class="keyword">if</span> (alarm.whenElapsed &gt; start) &#123;</span><br><span class="line">        start = alarm.whenElapsed;</span><br><span class="line">        newStart = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (alarm.maxWhenElapsed &lt; end) &#123;</span><br><span class="line">        end = alarm.maxWhenElapsed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【4】更新 Batch 的 flags！</span></span><br><span class="line">    flags |= alarm.flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG_BATCH) &#123;</span><br><span class="line">        Slog.v(TAG, <span class="string">"    =&gt; now "</span> + <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newStart;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，如果 Batch 的 start 时间发生变化，那么 add 会返回 true！</p>
<p>这里用到了一个比较器对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> IncreasingTimeOrder sIncreasingTimeOrder = <span class="keyword">new</span> IncreasingTimeOrder();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IncreasingTimeOrder</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Alarm</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Alarm a1, Alarm a2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">long</span> when1 = a1.whenElapsed;</span><br><span class="line">            <span class="keyword">long</span> when2 = a2.whenElapsed;</span><br><span class="line">            <span class="keyword">if</span> (when1 &gt; when2) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (when1 &lt; when2) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>sIncreasingTimeOrder 是用来对 Batch 中的 alarm 进行排序的，规则是按照开始时间递增的顺序！</p>
<h3 id="3-4-4-AlarmMS-rescheduleKernelAlarmsLocked"><a href="#3-4-4-AlarmMS-rescheduleKernelAlarmsLocked" class="headerlink" title="3.4.4 AlarmMS.rescheduleKernelAlarmsLocked"></a>3.4.4 AlarmMS.rescheduleKernelAlarmsLocked</h3><p>该方法用于设置下一个 alarm！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rescheduleKernelAlarmsLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> nextNonWakeup = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 设置最早的 ELAPSED_REALTIME_WAKEUP 类型的 alarm！</span></span><br><span class="line">    <span class="keyword">if</span> (mAlarmBatches.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【3.4.4.1】从 mAlarmBatches 中找到第一个包含 wake up 类型 alarm 的 Batch！</span></span><br><span class="line">        <span class="keyword">final</span> Batch firstWakeup = findFirstWakeupBatchLocked();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【2】从 mAlarmBatches 中找到第一个的 Batch！</span></span><br><span class="line">        <span class="keyword">final</span> Batch firstBatch = mAlarmBatches.get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【3】如果 firstWakeup 不为 null，且 firstWakeup 中的开始触发时间 start，不等于 mNextWakeup！</span></span><br><span class="line">        <span class="comment">// 那就要更新 mNextWakeup，调整下一个 wake up alarm 的触发时间！</span></span><br><span class="line">        <span class="keyword">if</span> (firstWakeup != <span class="keyword">null</span> &amp;&amp; mNextWakeup != firstWakeup.start) &#123;</span><br><span class="line">            <span class="comment">// 更新 mNextWakeup 和 mLastWakeupSet！</span></span><br><span class="line">            mNextWakeup = firstWakeup.start;</span><br><span class="line">            mLastWakeupSet = SystemClock.elapsedRealtime();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//【3.4.4.2】设置下一个要触发的 wake up 类型的 alarm！</span></span><br><span class="line">            setLocked(ELAPSED_REALTIME_WAKEUP, firstWakeup.start);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【4】如果 firstBatch 不等于 firstWakeup，说明 firstBatch 中不包含 wake up 类型的 alarm！</span></span><br><span class="line">        <span class="comment">// 那就设置下一个非 wake up alarm 的触发时间！</span></span><br><span class="line">        <span class="keyword">if</span> (firstBatch != firstWakeup) &#123;</span><br><span class="line">            nextNonWakeup = firstBatch.start;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// mPendingNonWakeupAlarms 不为 empty，说明系统中存在处于等待状态的 no wakeup 类型的 alarm！</span></span><br><span class="line">    <span class="comment">// 那么如果 nextNonWakeup 为 0，或者 mNextNonWakeupDeliveryTime 小于 nextNonWakeup！</span></span><br><span class="line">    <span class="comment">// 那么更新 nextNonWakeup 为 mNextNonWakeupDeliveryTime 的值！</span></span><br><span class="line">    <span class="keyword">if</span> (mPendingNonWakeupAlarms.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextNonWakeup == <span class="number">0</span> || mNextNonWakeupDeliveryTime &lt; nextNonWakeup) &#123;</span><br><span class="line">            nextNonWakeup = mNextNonWakeupDeliveryTime;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最后如果，本次计算的下一个要触发的 no wake up alarm 的时间和之前的不同，更新 mNextNonWakeup 的值</span></span><br><span class="line">    <span class="comment">// 并设置下一个 no wake up 的 alarm！</span></span><br><span class="line">    <span class="keyword">if</span> (nextNonWakeup != <span class="number">0</span> &amp;&amp; mNextNonWakeup != nextNonWakeup) &#123;</span><br><span class="line">        mNextNonWakeup = nextNonWakeup;</span><br><span class="line">        <span class="comment">//【3.4.4.2】设置下一个要触发的 no wake up 类型的 alarm！</span></span><br><span class="line">        setLocked(ELAPSED_REALTIME, nextNonWakeup);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>变量解释：</strong></p>
<ul>
<li>mNextWakeup 表示下一个最早的 wake up 类型 alarm 的触发时间；</li>
<li>mLastWakeupSet 表示上一次设置 wake up 类型 alarm 的时间，取值为 SystemClock.elapsedRealtime()；</li>
<li>mNextNonWakeup 表示的是下一个最早的 no wake up 类型 alarm 的触发时间；</li>
</ul>
<p>通常，二者是一起设置的！</p>
<p><strong>逻辑梳理</strong>：</p>
<ul>
<li>该方法首先是确定下一个要触发的 wake up 和非 wake up 类型的 alarm 的触发时间：mNextWakeup 和 mNextNonWakeup！<ul>
<li>对于 wake up 类型，那就在所有的 Batch 中找到第一个持有 wake up 类型 alarm 的 Batch，其 Batch.start 就是 mNextWakeup！</li>
<li>对于非 wake up 类型，确定 mNextNonWakeup 要分为以下几步：<ul>
<li>如果第一个持有 wake up 类型 alarm 的 Batch 不是 first batch，那么 firstBatch.Start 为可选值，保存到 nextNonWakeup 中！</li>
<li>如果此时 mPendingNonWakeupAlarms 不为 empty，说明系统中有正在等待的 no wake up 类型的闹钟，如果此时 nextNonWakeup 为 0，或者 mNextNonWakeupDeliveryTime 小于 nextNonWakeup，那么 mNextNonWakeupDeliveryTime 就是一个更优的选择，保存到 nextNonWakeup 中；</li>
<li>最后，如果 nextNonWakeup 和 mNextNonWakeup 不相等，那就使用 nextNonWakeup 更新 mNextNonWakeup！</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><br></p>
<ul>
<li>然后，分别设置两种闹钟！</li>
</ul>
<h4 id="3-4-4-1-AlarmMS-findFirstWakeupBatchLocked"><a href="#3-4-4-1-AlarmMS-findFirstWakeupBatchLocked" class="headerlink" title="3.4.4.1 AlarmMS.findFirstWakeupBatchLocked"></a>3.4.4.1 AlarmMS.findFirstWakeupBatchLocked</h4><p>findFirstWakeupBatchLocked 方法在所有的 Batch 中找到第一个包含 wake up 类型 alarm 的 Batch，然后返回！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Batch <span class="title">findFirstWakeupBatchLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> N = mAlarmBatches.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        Batch b = mAlarmBatches.get(i);</span><br><span class="line">        <span class="keyword">if</span> (b.hasWakeups()) &#123; <span class="comment">// 判断该 Batch 是否包含 wake up 类型的 alarm！</span></span><br><span class="line">            <span class="keyword">return</span> b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里调用了 Batch 的 hasWakeups 接口：</p>
<h5 id="3-4-4-1-1-AlarmMS-Batch-hasWakeups"><a href="#3-4-4-1-1-AlarmMS-Batch-hasWakeups" class="headerlink" title="3.4.4.1.1 AlarmMS.Batch.hasWakeups"></a>3.4.4.1.1 AlarmMS.Batch.hasWakeups</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">hasWakeups</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> N = alarms.size();</span><br><span class="line">    <span class="comment">// 遍历其内部的所有的 Alarm！</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        Alarm a = alarms.get(i);</span><br><span class="line">        <span class="comment">// 这里的 type 取值为 AlarmManager 中的四种</span></span><br><span class="line">        <span class="keyword">if</span> ((a.type &amp; TYPE_NONWAKEUP_MASK) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-4-4-2-AlarmMS-setLocked"><a href="#3-4-4-2-AlarmMS-setLocked" class="headerlink" title="3.4.4.2 AlarmMS.setLocked"></a>3.4.4.2 AlarmMS.setLocked</h4><p>用于设置一个 alarm！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setLocked</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mNativeData != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 记录秒和纳秒！</span></span><br><span class="line">        <span class="keyword">long</span> alarmSeconds, alarmNanoseconds;</span><br><span class="line">        <span class="keyword">if</span> (when &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            alarmSeconds = <span class="number">0</span>;</span><br><span class="line">            alarmNanoseconds = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            alarmSeconds = when / <span class="number">1000</span>;</span><br><span class="line">            alarmNanoseconds = (when % <span class="number">1000</span>) * <span class="number">1000</span> * <span class="number">1000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置 alarm！</span></span><br><span class="line">        set(mNativeData, type, alarmSeconds, alarmNanoseconds);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Message msg = Message.obtain();</span><br><span class="line">        msg.what = ALARM_EVENT;</span><br><span class="line">        </span><br><span class="line">        mHandler.removeMessages(ALARM_EVENT);</span><br><span class="line">        mHandler.sendMessageAtTime(msg, when);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到，这里使用了 2 中方式来设置闹钟！</p>
<p><strong>第一种</strong>：通过 Alarm 驱动来设置</p>
<p>mNativeData 不为 0，表示 Alarm 驱动存在，就直接调用 set 方法，通过 Alarm 驱动设置这个 alarm！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">long</span> nativeData, <span class="keyword">int</span> type, <span class="keyword">long</span> seconds, <span class="keyword">long</span> nanoseconds)</span></span>;</span><br></pre></td></tr></table></figure>
<p>当然，正常情况，是通过 Alarm 驱动来设置的，因为这样能够实现休眠唤醒！</p>
<p>除非找不到 Alarm 驱动</p>
<p>mNativeData 为 0，说明 Alarm 驱动不存在，那就通过 Timer 定时器设置，这里通过发送一个 ALARM_EVENT 给 AlarmHandler，然后处理消息，设置 alarm！</p>
<h4 id="3-4-4-3-AlarmMS-updateNextAlarmInfoForUserLocked"><a href="#3-4-4-3-AlarmMS-updateNextAlarmInfoForUserLocked" class="headerlink" title="3.4.4.3 AlarmMS.updateNextAlarmInfoForUserLocked"></a>3.4.4.3 AlarmMS.updateNextAlarmInfoForUserLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateNextAlarmInfoForUserLocked</span><span class="params">(<span class="keyword">int</span> userId,</span></span></span><br><span class="line"><span class="function"><span class="params">        AlarmManager.AlarmClockInfo alarmClock)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (alarmClock != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_ALARM_CLOCK) &#123;</span><br><span class="line">            Log.v(TAG, <span class="string">"Next AlarmClockInfoForUser("</span> + userId + <span class="string">"): "</span> +</span><br><span class="line">                    formatNextAlarm(getContext(), alarmClock, userId));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【1】更新 alarmClock！</span></span><br><span class="line">        mNextAlarmClockForUser.put(userId, alarmClock);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_ALARM_CLOCK) &#123;</span><br><span class="line">            Log.v(TAG, <span class="string">"Next AlarmClockInfoForUser("</span> + userId + <span class="string">"): None"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【1】移除指定的 userId 信息！</span></span><br><span class="line">        mNextAlarmClockForUser.remove(userId);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将 mPendingSendNextAlarmClockChangedForUser 中 userId 对应的置为 true！</span></span><br><span class="line">    mPendingSendNextAlarmClockChangedForUser.put(userId, <span class="keyword">true</span>);</span><br><span class="line">    </span><br><span class="line">    mHandler.removeMessages(AlarmHandler.SEND_NEXT_ALARM_CLOCK_CHANGED);</span><br><span class="line">    <span class="comment">// 发送 SEND_NEXT_ALARM_CLOCK_CHANGED 给 AlarmHandler！</span></span><br><span class="line">    mHandler.sendEmptyMessage(AlarmHandler.SEND_NEXT_ALARM_CLOCK_CHANGED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于 AlarmHandler 我们后面会提到！</p>
<h3 id="3-4-5-AlarmMS-updateNextAlarmClockLocked"><a href="#3-4-5-AlarmMS-updateNextAlarmClockLocked" class="headerlink" title="3.4.5 AlarmMS.updateNextAlarmClockLocked"></a>3.4.5 AlarmMS.updateNextAlarmClockLocked</h3><p>该方法用于更新下一个 AlarmClock 的时间，当我们触发或者移除了一个 setAlarmClock 设置的 alarm 后，需要更新下一个 AlarmClock 的触发！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateNextAlarmClockLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】如果 mNextAlarmClockMayChange 为 false，表示并没有移除或者触发一个 AlarmClock 闹钟，那就返回！</span></span><br><span class="line">    <span class="keyword">if</span> (!mNextAlarmClockMayChange) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【2】设置 mNextAlarmClockMayChange 为 false；</span></span><br><span class="line">    mNextAlarmClockMayChange = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【3】用于缓存更新后的所有的 AlarmClock，用于后续更新 mNextAlarmClockForUser！</span></span><br><span class="line">    SparseArray&lt;AlarmManager.AlarmClockInfo&gt; nextForUser = mTmpSparseAlarmClockArray;</span><br><span class="line">    nextForUser.clear();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【4】遍历所有的 Alarm Batch，找到所有的 AlarmClock 闹钟！</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> N = mAlarmBatches.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        ArrayList&lt;Alarm&gt; alarms = mAlarmBatches.get(i).alarms;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> M = alarms.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M; j++) &#123;</span><br><span class="line">            Alarm a = alarms.get(j);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【4.1】a.alarmClock 不为 null，说明这是一个 AlarmClock 类型的闹钟！ </span></span><br><span class="line">            <span class="keyword">if</span> (a.alarmClock != <span class="keyword">null</span>) &#123;</span><br><span class="line">            </span><br><span class="line">                <span class="comment">// 获得 AlarmClock 所属的 userId！</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> userId = UserHandle.getUserId(a.uid);</span><br><span class="line">                <span class="comment">// 获得该 userId 下的当前 AlarmClock！</span></span><br><span class="line">                AlarmManager.AlarmClockInfo current = mNextAlarmClockForUser.get(userId);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (DEBUG_ALARM_CLOCK) &#123;</span><br><span class="line">                    Log.v(TAG, <span class="string">"Found AlarmClockInfo "</span> + a.alarmClock + <span class="string">" at "</span> +</span><br><span class="line">                            formatNextAlarm(getContext(), a.alarmClock, userId) +</span><br><span class="line">                            <span class="string">" for user "</span> + userId);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Alarms 和 Batches 是通过时间排序的，所以这需要比较时间！</span></span><br><span class="line">                <span class="keyword">if</span> (nextForUser.get(userId) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 如果缓存中的 userId 是第一次添加，那将 a.alarmClock 添加到缓存中，不考虑 current！</span></span><br><span class="line">                    nextForUser.put(userId, a.alarmClock); </span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a.alarmClock.equals(current)</span><br><span class="line">                        &amp;&amp; current.getTriggerTime() &lt;= nextForUser.get(userId).getTriggerTime()) &#123;</span><br><span class="line">                     <span class="comment">// nextForUser.get(userId) 不等于 null，说明该 userId 在缓存中已经有 AlarmClock 了！</span></span><br><span class="line">                    <span class="comment">// 相同 userId，alarmClock 相同，但是 current 触发时间比缓存中的更早，那就用 current 替换缓存中！</span></span><br><span class="line">                    nextForUser.put(userId, current);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【5】通过上面的预处理，缓存 nextForUser 中存储的是每个 userId 下最早触发的 alarmClock！</span></span><br><span class="line">    <span class="comment">// 接着是用缓存 nextForUser 更新 mNextAlarmClockForUser！</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> NN = nextForUser.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NN; i++) &#123;</span><br><span class="line">        AlarmManager.AlarmClockInfo newAlarm = nextForUser.valueAt(i);</span><br><span class="line">        <span class="keyword">int</span> userId = nextForUser.keyAt(i);</span><br><span class="line">        AlarmManager.AlarmClockInfo currentAlarm = mNextAlarmClockForUser.get(userId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【4.1】相同 userId，但是 AlarmClockInfo 不相等，那就更新 mNextAlarmClockForUser！</span></span><br><span class="line">        <span class="keyword">if</span> (!newAlarm.equals(currentAlarm)) &#123;</span><br><span class="line">            updateNextAlarmInfoForUserLocked(userId, newAlarm);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【6】移除 mNextAlarmClockForUser 已经触发的 AlarmClock！</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> NNN = mNextAlarmClockForUser.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = NNN - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">int</span> userId = mNextAlarmClockForUser.keyAt(i);</span><br><span class="line">        <span class="keyword">if</span> (nextForUser.get(userId) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">//【3.4.5.1】调用 updateNextAlarmInfoForUserLocked</span></span><br><span class="line">            updateNextAlarmInfoForUserLocked(userId, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>变量说明</strong>：</p>
<p>mNextAlarmClockForUser 用于保存每个 userId 下即将出发的下一个 AlarmClock！</p>
<p><strong>方法的流程总结</strong>：</p>
<ul>
<li>获得当前系统中最新的 AlarmClock 信息，保存到缓存 nextForUser 中；<ul>
<li>如果缓存 nextForUser 中 userId 下还没有 AlarmClock，那就将该 AlarmClock 添加到缓存中！</li>
<li>如果缓存 nextForUser 中 userId 下已经有某个 AlarmClock，那就进一步比较：<ul>
<li>只有当该 userId 下的缓存 AlarmClock 和 mNextAlarmClockForUser 中对应的 AlarmClock 相等，且 mNextAlarmClockForUser 中对应的 AlarmClock 触发时间更早，才会替换缓存；否则，保留缓存！</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><br></p>
<ul>
<li>用缓存 nextForUser 来更新 mNextAlarmClockForUser 列表；<ul>
<li>再次比较缓存 nextForUser 和 mNextAlarmClockForUser 中 userId 相同的 AlarmClock，如果二者不相同，用缓存更新 mNextAlarmClockForUser！</li>
</ul>
</li>
</ul>
<p><br></p>
<ul>
<li>删除 mNextAlarmClockForUser 中某些 userId 下已经无效的 Alarm；</li>
</ul>
<h4 id="3-4-5-1-AlarmMS-updateNextAlarmInfoForUserLocked"><a href="#3-4-5-1-AlarmMS-updateNextAlarmInfoForUserLocked" class="headerlink" title="3.4.5.1 AlarmMS.updateNextAlarmInfoForUserLocked"></a>3.4.5.1 AlarmMS.updateNextAlarmInfoForUserLocked</h4><p>为指定 userId 更新 AlarmClock</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateNextAlarmInfoForUserLocked</span><span class="params">(<span class="keyword">int</span> userId,</span></span></span><br><span class="line"><span class="function"><span class="params">        AlarmManager.AlarmClockInfo alarmClock)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】如果传入的 alarmClock 不为 null，那就替换 userId 下已有的 alarmClock！</span></span><br><span class="line">    <span class="comment">// 如果传入的 alarmClock 为 null，那就移除 userId 和对应的 alarmClock！</span></span><br><span class="line">    <span class="keyword">if</span> (alarmClock != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_ALARM_CLOCK) &#123;</span><br><span class="line">            Log.v(TAG, <span class="string">"Next AlarmClockInfoForUser("</span> + userId + <span class="string">"): "</span> +</span><br><span class="line">                    formatNextAlarm(getContext(), alarmClock, userId));</span><br><span class="line">        &#125;</span><br><span class="line">        mNextAlarmClockForUser.put(userId, alarmClock);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_ALARM_CLOCK) &#123;</span><br><span class="line">            Log.v(TAG, <span class="string">"Next AlarmClockInfoForUser("</span> + userId + <span class="string">"): None"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mNextAlarmClockForUser.remove(userId);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【2】当某个 userId 下的 AlarmClock 发生了变化，我们会将其记录到 mPendingSendNextAlarmClockChangedForUser 列表中！</span></span><br><span class="line">    mPendingSendNextAlarmClockChangedForUser.put(userId, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【3】发送 SEND_NEXT_ALARM_CLOCK_CHANGED 给 AlarmHandler，AlarmHandler 会处理该消息！</span></span><br><span class="line">    mHandler.removeMessages(AlarmHandler.SEND_NEXT_ALARM_CLOCK_CHANGED);</span><br><span class="line">    mHandler.sendEmptyMessage(AlarmHandler.SEND_NEXT_ALARM_CLOCK_CHANGED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mPendingSendNextAlarmClockChangedForUser 列表用来记录某个 userId 下的 AlarmClock 发生了变化，如果发生了变化，他会用 userId -&gt; true 的映射关系保存！</p>
<p>最后会发送 AlarmHandler.SEND_NEXT_ALARM_CLOCK_CHANGED 给 AlarmHandler 来处理，我们去看看：</p>
<h5 id="3-4-5-1-1-AlarmMS-AlarmHandler-SEND-NEXT-ALARM-CLOCK-CHANGED"><a href="#3-4-5-1-1-AlarmMS-AlarmHandler-SEND-NEXT-ALARM-CLOCK-CHANGED" class="headerlink" title="3.4.5.1.1 AlarmMS.AlarmHandler[SEND_NEXT_ALARM_CLOCK_CHANGED]"></a>3.4.5.1.1 AlarmMS.AlarmHandler[SEND_NEXT_ALARM_CLOCK_CHANGED]</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> SEND_NEXT_ALARM_CLOCK_CHANGED:</span><br><span class="line">    sendNextAlarmClockChanged();</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>AlarmHandler 会调用 sendNextAlarmClockChanged 来处理消息：</p>
<h5 id="3-4-5-1-2-AlarmMS-sendNextAlarmClockChanged"><a href="#3-4-5-1-2-AlarmMS-sendNextAlarmClockChanged" class="headerlink" title="3.4.5.1.2 AlarmMS.sendNextAlarmClockChanged"></a>3.4.5.1.2 AlarmMS.sendNextAlarmClockChanged</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendNextAlarmClockChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】创建了一个 SparseArray 数组，用于保存要处理的 userId 和其 AlarmClock！</span></span><br><span class="line">    SparseArray&lt;AlarmManager.AlarmClockInfo&gt; pendingUsers = mHandlerSparseAlarmClockArray;</span><br><span class="line">    pendingUsers.clear();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】将 mPendingSendNextAlarmClockChangedForUser 的 user Id 和对应的 AlarmClock 保存到 pendingUsers 中！</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N  = mPendingSendNextAlarmClockChangedForUser.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> userId = mPendingSendNextAlarmClockChangedForUser.keyAt(i);</span><br><span class="line">            pendingUsers.append(userId, mNextAlarmClockForUser.get(userId));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 清空 mPendingSendNextAlarmClockChangedForUser！</span></span><br><span class="line">        mPendingSendNextAlarmClockChangedForUser.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【3】保存 AlarmClock 信息，并发送广播！</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> N = pendingUsers.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> userId = pendingUsers.keyAt(i);</span><br><span class="line">        AlarmManager.AlarmClockInfo alarmClock = pendingUsers.valueAt(i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将这个 AlarmClock 的信息保存到 Settings 数据库中！</span></span><br><span class="line">        Settings.System.putStringForUser(getContext().getContentResolver(),</span><br><span class="line">                Settings.System.NEXT_ALARM_FORMATTED,</span><br><span class="line">                formatNextAlarm(getContext(), alarmClock, userId),</span><br><span class="line">                userId);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 发送 NEXT_ALARM_CLOCK_CHANGED_INTENT 给指定的 userId！</span></span><br><span class="line">        getContext().sendBroadcastAsUser(NEXT_ALARM_CLOCK_CHANGED_INTENT,</span><br><span class="line">                <span class="keyword">new</span> UserHandle(userId));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mHandlerSparseAlarmClockArray 是一个预先创建的 SparseArray，没有很特殊的用途！</p>
<p>在 sendNextAlarmClockChanged 方法中，我们会处理前面的 mPendingSendNextAlarmClockChangedForUser！</p>
<h2 id="3-5-阶段总结"><a href="#3-5-阶段总结" class="headerlink" title="3.5 阶段总结"></a>3.5 阶段总结</h2><p>到这里，我们 setAlarm 的整个流程就分析完成了，下面，我们来总结一下整个过程！</p>
<p>… … …</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Coolqi.Li</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2017/07/25/AlarmManager第 2 篇 - set Alarm 流程分析/">http://yoursite.com/2017/07/25/AlarmManager第 2 篇 - set Alarm 流程分析/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com">Coolqi`s Blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/AlarmManager闹钟管理/">AlarmManager闹钟管理</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="/img/zfb.jpg"><div class="post-qr-code__desc">支付宝打赏</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="/img/wechat.jpg"><div class="post-qr-code__desc">微信打赏</div></div></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2017/08/01/AppOps 第 1 篇 - AppOpsService 的启动/"><i class="fa fa-chevron-left">  </i><span>AppOps 第 1 篇 - AppOpsService 的启动</span></a></div><div class="next-post pull-right"><a href="/2017/07/06/Permission第 3 篇 - checkPermissions 权限检查/"><span>Permission第 3 篇 - checkPermissions 权限检查</span><i class="fa fa-chevron-right"></i></a></div></nav><div class="post-adv"><a href="https://www.vultr.com/?ref=7231808"><img src="https://www.vultr.com/media/banner_1.png" width="728" height="90"></a></div></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2015 - 2019 By Coolqi.Li</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://coolqi.top/">blog</a>!</div><div class="busuanzi"><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.6"></script><script src="/js/fancybox.js?version=1.5.6"></script><script src="/js/sidebar.js?version=1.5.6"></script><script src="/js/copy.js?version=1.5.6"></script><script src="/js/fireworks.js?version=1.5.6"></script><script src="/js/transition.js?version=1.5.6"></script><script src="/js/scroll.js?version=1.5.6"></script><script src="/js/head.js?version=1.5.6"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="/js/search/local-search.js"></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"live2d-widget-model-tororo"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script></body></html>