<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="UsageStats 第 3 篇 - UserUsageStatsService 逻辑分析"><meta name="keywords" content="UsageStats使用状态管理"><meta name="author" content="Coolqi.Li,undefined"><meta name="copyright" content="Coolqi.Li"><title>UsageStats 第 3 篇 - UserUsageStatsService 逻辑分析 | Coolqi`s Blog</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.5.6"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css?version=1.5.6"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#0-综述"><span class="toc-text">0 综述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-new-UserUsageStatsService-创建"><span class="toc-text">1 new UserUsageStatsService - 创建</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-new-UnixCalendar"><span class="toc-text">1.1 new UnixCalendar</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-new-UsageStatsDatabase"><span class="toc-text">1.2 new UsageStatsDatabase</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-new-IntervalStats"><span class="toc-text">1.3 new IntervalStats</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-UserUsageStatsService-init-初始化操作"><span class="toc-text">2 UserUsageStatsService.init - 初始化操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-UsageStatsDatabase-init"><span class="toc-text">2.1 UsageStatsDatabase.init</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-UsageStatsDatabase-checkVersionAndBuildLocked"><span class="toc-text">2.1.1 UsageStatsDatabase.checkVersionAndBuildLocked</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-1-UsageStatsDatabase-doUpgradeLocked"><span class="toc-text">2.1.1.1 UsageStatsDatabase.doUpgradeLocked</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-UsageStatsDatabase-indexFilesLocked"><span class="toc-text">2.1.2 UsageStatsDatabase.indexFilesLocked</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-1-UsageStatsXml-parseBeginTime"><span class="toc-text">2.1.2.1 UsageStatsXml.parseBeginTime</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-UsageStatsDatabase-getLatestUsageStats-获得最新的使用信息"><span class="toc-text">2.2 UsageStatsDatabase.getLatestUsageStats - 获得最新的使用信息</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-UsageStatsXml-read"><span class="toc-text">2.2.1 UsageStatsXml.read</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-UsageStatsXml-read"><span class="toc-text">2.2.2 UsageStatsXml.read</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-3-UsageStatsXmlV1-read"><span class="toc-text">2.2.3 UsageStatsXmlV1.read</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3-1-UsageStatsXmlV1-loadUsageStats-读取-UsageStats"><span class="toc-text">2.2.3.1 UsageStatsXmlV1.loadUsageStats - 读取 UsageStats</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-3-1-1-IntervalStats-getOrCreateUsageStats"><span class="toc-text">2.2.3.1.1 IntervalStats.getOrCreateUsageStats</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3-2-UsageStatsXmlV1-loadConfigStats-读取-ConfigStats"><span class="toc-text">2.2.3.2 UsageStatsXmlV1.loadConfigStats - 读取 ConfigStats</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-3-2-1-IntervalStats-getOrCreateConfigurationStats"><span class="toc-text">2.2.3.2.1 IntervalStats.getOrCreateConfigurationStats</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3-3-UsageStatsXmlV1-loadEvent-读取-Event"><span class="toc-text">2.2.3.3 UsageStatsXmlV1.loadEvent - 读取 Event</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-3-3-1-IntervalStats-buildEvent"><span class="toc-text">2.2.3.3.1 IntervalStats.buildEvent</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-UserUsageStatsService-loadActiveStats"><span class="toc-text">2.3 UserUsageStatsService.loadActiveStats</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-UsageStatsService-onStatsReloaded-回调"><span class="toc-text">2.3.1 UsageStatsService.onStatsReloaded - 回调</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-UserUsageStatsService-updateRolloverDeadline"><span class="toc-text">2.4 UserUsageStatsService.updateRolloverDeadline</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-IntervalStats-update"><span class="toc-text">2.5 IntervalStats.update</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-1-IntervalStats-isStatefulEvent"><span class="toc-text">2.5.1 IntervalStats.isStatefulEvent</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-UserUsageStatsService-notifyStatsChanged"><span class="toc-text">2.6 UserUsageStatsService.notifyStatsChanged</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-1-UsageStatsService-onStatsUpdated-回调"><span class="toc-text">2.6.1 UsageStatsService.onStatsUpdated - 回调</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-7-IntervalStats-updateConfigurationStats"><span class="toc-text">2.7 IntervalStats.updateConfigurationStats</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-8-UserUsageStatsService-notifyNewUpdate"><span class="toc-text">2.8 UserUsageStatsService.notifyNewUpdate</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-8-1-UsageStatsService-onNewUpdate-回调"><span class="toc-text">2.8.1 UsageStatsService.onNewUpdate - 回调</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-9-流程总结"><span class="toc-text">2.9 流程总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-UserUsageStatsService-onTimeChanged-处理时间变化"><span class="toc-text">3 UserUsageStatsService.onTimeChanged - 处理时间变化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-0-调用时机"><span class="toc-text">3.0 调用时机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-UserUsageStatsService-persistActiveStats"><span class="toc-text">3.1 UserUsageStatsService.persistActiveStats</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1-UsageStatsDatabase-putUsageStats"><span class="toc-text">3.1.1 UsageStatsDatabase.putUsageStats</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2-UsageStatsXml-write"><span class="toc-text">3.1.2 UsageStatsXml.write</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-3-UsageStatsXmlV1-write"><span class="toc-text">3.1.3 UsageStatsXmlV1.write</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-3-1-UsageStatsXmlV1-writeUsageStats"><span class="toc-text">3.1.3.1 UsageStatsXmlV1.writeUsageStats</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-3-2-UsageStatsXmlV1-writeConfigStats"><span class="toc-text">3.1.3.2 UsageStatsXmlV1.writeConfigStats</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-3-3-UsageStatsXmlV1-writeEvent"><span class="toc-text">3.1.3.3 UsageStatsXmlV1.writeEvent</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-UsageStatsDatabase-onTimeChanged"><span class="toc-text">3.2 UsageStatsDatabase.onTimeChanged</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-流程总结"><span class="toc-text">3.3 流程总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-UserUsageStatsService-rolloverStats-数据回滚"><span class="toc-text">4 UserUsageStatsService.rolloverStats - 数据回滚</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-IntervalStats-update"><span class="toc-text">4.1 IntervalStats.update</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-IntervalStats-updateConfigurationStats"><span class="toc-text">4.2 IntervalStats.updateConfigurationStats</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-UsageStatsDatabase-prune"><span class="toc-text">4.3 UsageStatsDatabase.prune</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-1-UsageStatsDatabase-pruneFilesOlderThan"><span class="toc-text">4.3.1 UsageStatsDatabase.pruneFilesOlderThan</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-流程总结"><span class="toc-text">4.4 流程总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-UserUsageStatsService-reportEvent-上报事件"><span class="toc-text">5 UserUsageStatsService.reportEvent - 上报事件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-UserUsageStatsService-query-查询"><span class="toc-text">6 UserUsageStatsService.query - 查询</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-UserUsageStatsService-queryEvents"><span class="toc-text">6.1 UserUsageStatsService.queryEvents</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-UserUsageStatsService-queryUsageStats"><span class="toc-text">6.2 UserUsageStatsService.queryUsageStats</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-UserUsageStatsService-queryStats"><span class="toc-text">6.3 UserUsageStatsService.queryStats</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Coolqi.Li</div><div class="author-info__description text-center">“你好，我是李帅奇，Android 系统工程师，MineCraft 忠实玩家，设计和绘画爱好者，缺妹纸晚期患者，熬夜星人。”</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">64</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">14</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">15</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="https://developer.android.google.cn/">AndroidDeveloper</a><a class="author-info-links__name text-center" href="http://www.android-studio.org/">AndroidStudio</a><a class="author-info-links__name text-center" href="https://www.jianshu.com/u/123a20a96441">简书</a><a class="author-info-links__name text-center" href="https://weibo.com/coolqiLi">微博</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://ws1.sinaimg.cn/large/8700af19ly1fvpabr30o6j22yo1o0q7i.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Coolqi`s Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/about">About</a><a class="site-page" href="/archives">Archives</a></span></div><div id="post-info"><div id="post-title">UsageStats 第 3 篇 - UserUsageStatsService 逻辑分析</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-05-03</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/AndroidFramework源码分析/">AndroidFramework源码分析</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/AndroidFramework源码分析/UsageStats使用状态管理/">UsageStats使用状态管理</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">11.4k</span><span class="post-meta__separator">|</span><span>阅读时长: 50 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>[toc]</p>
<p>基于 Android7.1.1 源码分析 UsageStatsService 的架构和原理！</p>
<h1 id="0-综述"><a href="#0-综述" class="headerlink" title="0 综述"></a>0 综述</h1><p>UserUsageStatsService 用于保存每个设备用户下的数据信息！每一个 UserUsageStatsService 内部都会有一个 UsageStatsDatabase 对象用于访问本地持久化文件！</p>
<p>本文主要分析 UserUsageStatsService 相关的接口，为 UsageStatsService 的分析提供帮助！</p>
<h1 id="1-new-UserUsageStatsService-创建"><a href="#1-new-UserUsageStatsService-创建" class="headerlink" title="1 new UserUsageStatsService - 创建"></a>1 new UserUsageStatsService - 创建</h1><p>参数 File usageStatsDir 传入的是 new File(mUsageStatsDir, Integer.toString(userId))。</p>
<p>mUsageStatsDir 就是 /data/system/usagestats，这里我们不考虑多用户，在默认用户下 usageStatsDir 为 /data/system/usagestats/0</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">UserUsageStatsService(Context context, <span class="keyword">int</span> userId, File usageStatsDir,</span><br><span class="line">        StatsUpdatedListener listener) &#123;</span><br><span class="line">    mContext = context;</span><br><span class="line">    <span class="comment">//【1.1】用于日期的计算；</span></span><br><span class="line">    mDailyExpiryDate = <span class="keyword">new</span> UnixCalendar(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//【1.2】数据库对象，用于加载和更新持久化文件；</span></span><br><span class="line">    mDatabase = <span class="keyword">new</span> UsageStatsDatabase(usageStatsDir);</span><br><span class="line">    <span class="comment">//【1.3】创建一个 IntervalStats 数组，大小为 4，用于加载每个时间类别的最新数据到内存中！        </span></span><br><span class="line">    mCurrentStats = <span class="keyword">new</span> IntervalStats[UsageStatsManager.INTERVAL_COUNT];</span><br><span class="line">    mListener  = listener;</span><br><span class="line">    mLogPrefix = <span class="string">"User["</span> + Integer.toString(userId) + <span class="string">"] "</span>;</span><br><span class="line">    mUserId = userId; <span class="comment">// 对应的 userId</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 mListener 就是 UsageStatsService，前面我们知道 UsageStatsService 实现了 UserUsageStatsService.StatsUpdatedListener：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> StatsUpdatedListener mListener;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">StatsUpdatedListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onStatsUpdated</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onStatsReloaded</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onNewUpdate</span><span class="params">(<span class="keyword">int</span> mUserId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，当 UserUsageStatsService 中的数据发生更新后，会通过 StatsUpdatedListener 的接口通知 UsageStatsService！</p>
<ul>
<li><strong>onStatsUpdated</strong>：当使用信息被更新后，触发该回调；</li>
<li><strong>onStatsReloaded</strong>：当使用信息重新加载后，触发该回调；</li>
<li><strong>onNewUpdate</strong>：当系统发生了升级后，触发该回调；</li>
</ul>
<h2 id="1-1-new-UnixCalendar"><a href="#1-1-new-UnixCalendar" class="headerlink" title="1.1 new UnixCalendar"></a>1.1 new UnixCalendar</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnixCalendar</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> DAY_IN_MILLIS = <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> WEEK_IN_MILLIS = <span class="number">7</span> * DAY_IN_MILLIS;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> MONTH_IN_MILLIS = <span class="number">30</span> * DAY_IN_MILLIS;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> YEAR_IN_MILLIS = <span class="number">365</span> * DAY_IN_MILLIS;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> mTime;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UnixCalendar</span><span class="params">(<span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        mTime = time;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addDays</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        mTime += val * DAY_IN_MILLIS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addWeeks</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        mTime += val * WEEK_IN_MILLIS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMonths</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        mTime += val * MONTH_IN_MILLIS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addYears</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        mTime += val * YEAR_IN_MILLIS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTimeInMillis</span><span class="params">(<span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        mTime = time;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getTimeInMillis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mTime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>UnixCalendar 用于计算日期的变化，代码很简单，不多说了！</p>
<h2 id="1-2-new-UsageStatsDatabase"><a href="#1-2-new-UsageStatsDatabase" class="headerlink" title="1.2 new UsageStatsDatabase"></a>1.2 new UsageStatsDatabase</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">UsageStatsDatabase</span><span class="params">(File dir)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】创建了一个文件夹数组，对应了本地的四个不同的目录；</span></span><br><span class="line">    mIntervalDirs = <span class="keyword">new</span> File[] &#123;</span><br><span class="line">            <span class="keyword">new</span> File(dir, <span class="string">"daily"</span>),</span><br><span class="line">            <span class="keyword">new</span> File(dir, <span class="string">"weekly"</span>),</span><br><span class="line">            <span class="keyword">new</span> File(dir, <span class="string">"monthly"</span>),</span><br><span class="line">            <span class="keyword">new</span> File(dir, <span class="string">"yearly"</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//【2】创建版本信息文件！</span></span><br><span class="line">    mVersionFile = <span class="keyword">new</span> File(dir, <span class="string">"version"</span>);</span><br><span class="line">    <span class="comment">//【3】创建一个 TimeSparseArray，长度为 4，用于对不同目录下的文件根据时间排序！</span></span><br><span class="line">    mSortedStatFiles = <span class="keyword">new</span> TimeSparseArray[mIntervalDirs.length];</span><br><span class="line">    mCal = <span class="keyword">new</span> UnixCalendar(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在默认用户下，这里的 dir 对应的目录是 /data/system/usagestats/0。</p>
<p>同时创建了一个文件夹数组，其实这里可以知道，数据是按 daily，monthly，weekly，yearly 四个文件夹存储的，而每个文件夹中又包含若干个以一个时间戳为名称的文件！</p>
<ul>
<li>/data/system/usagestats/0/daily；</li>
<li>/data/system/usagestats/0/weekly；</li>
<li>/data/system/usagestats/0/monthly；</li>
<li>/data/system/usagestats/0/yearly；</li>
</ul>
<p>同时，又创建了数据库对应的 version 文件：</p>
<ul>
<li>/data/system/usagestats/0/version；</li>
</ul>
<p>我们来看看 daily，monthly，weekly，yearly 四个文件夹中存储的是什么文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/data/system/usagestats/<span class="number">0</span>/daily  ls</span><br><span class="line"><span class="number">1526928050937</span>  <span class="number">1527014648681</span>  <span class="number">1527101544569</span>  <span class="number">1527188059056</span>  <span class="number">1527277127932</span>  <span class="number">1527364251915</span>  <span class="number">1527450652825</span></span><br></pre></td></tr></table></figure>
<p>可以看到，每一个文件的名字都是一个时间戳，这个时间戳的表示的是该文件开始记录的时间节点！</p>
<p>我们来看下，这些文件内部的数据结构：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">'1.0'</span> encoding=<span class="string">'utf-8'</span> standalone=<span class="string">'yes'</span> ?&gt;</span><br><span class="line">&lt;usagestats version=<span class="string">"1"</span> endTime=<span class="string">"62979335"</span>&gt;</span><br><span class="line">    &lt;packages&gt;</span><br><span class="line">        &lt;<span class="keyword">package</span> lastTimeActive=<span class="string">"1104580"</span> <span class="keyword">package</span>=<span class="string">"com.github.shadowsocks"</span> timeActive=<span class="string">"119959"</span> lastEvent=<span class="string">"2"</span> /&gt;</span><br><span class="line">    &lt;/packages&gt;</span><br><span class="line">    &lt;configurations&gt;</span><br><span class="line">        &lt;config lastTimeActive=<span class="string">"60709298"</span> timeActive=<span class="string">"60690625"</span> count=<span class="string">"3"</span> active=<span class="string">"true"</span> fs=<span class="string">"1065353216"</span> mcc=<span class="string">"460"</span> </span><br><span class="line">                mnc=<span class="string">"65535"</span> locales=<span class="string">"zh-CN"</span> touch=<span class="string">"3"</span> key=<span class="string">"1"</span> keyHid=<span class="string">"1"</span> hardKeyHid=<span class="string">"2"</span> nav=<span class="string">"1"</span> navHid=<span class="string">"2"</span> </span><br><span class="line">                ori=<span class="string">"1"</span> scrLay=<span class="string">"268435810"</span> clrMod=<span class="string">"5"</span> ui=<span class="string">"17"</span> width=<span class="string">"360"</span> height=<span class="string">"685"</span> sw=<span class="string">"360"</span> </span><br><span class="line">                density=<span class="string">"480"</span> app_bounds=<span class="string">"0 0 1080 2136"</span> /&gt;</span><br><span class="line">    &lt;/configurations&gt;</span><br><span class="line">    &lt;event-log&gt;</span><br><span class="line">        &lt;event time=<span class="string">"1104580"</span> <span class="keyword">package</span>=<span class="string">"com.github.shadowsocks"</span> </span><br><span class="line">               <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.github.shadowsocks.MainActivity"</span> flags=<span class="string">"0"</span> type=<span class="string">"2"</span> /&gt;</span><br><span class="line">    &lt;/event-log&gt;</span><br><span class="line">&lt;/usagestats&gt;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，一个文件主要包含三方面的内容：</p>
<ul>
<li><strong>packages</strong>：应用的使用信息；</li>
<li><strong>configurations</strong>：配置的使用信息；</li>
<li><strong>event-log</strong>：时间上报的历史记录；</li>
</ul>
<p>下面，会分析到解析过程！</p>
<h2 id="1-3-new-IntervalStats"><a href="#1-3-new-IntervalStats" class="headerlink" title="1.3 new IntervalStats"></a>1.3 new IntervalStats</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntervalStats</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> beginTime; <span class="comment">// 开始记录的时间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> endTime; <span class="comment">// 当前记录的最大时间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> lastTimeSaved; <span class="comment">// 最后一次将数据保存到持久化文件的时间！</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存中的 UsageStats 数据！</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> ArrayMap&lt;String, UsageStats&gt; packageStats = <span class="keyword">new</span> ArrayMap&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 内存中的 ConfigurationStats 数据！</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> ArrayMap&lt;Configuration, ConfigurationStats&gt; configurations = <span class="keyword">new</span> ArrayMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> Configuration activeConfiguration;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内存中的 Event 数据！</span></span><br><span class="line">    <span class="keyword">public</span> TimeSparseArray&lt;UsageEvents.Event&gt; events;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ArraySet&lt;String&gt; mStringCache = <span class="keyword">new</span> ArraySet&lt;&gt;(); <span class="comment">// 用于缓存包名！</span></span><br><span class="line">    ... ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>IntervalStats 用于将持久化数据缓存到内存中，加快访问效率！</p>
<ul>
<li>应用的数据以 UsageStats 的形式保存在 packageStats 中；</li>
<li>配置的数据以 ConfigurationStats 的形式保存在 configurations 中；</li>
</ul>
<p>IntervalStats 内部也提供了一些 get，udpate 等等的方法，我们后面分析的时候再说！</p>
<p>IntervalStats 数组的长度为 4 ，和 UsageStatsDatabase 中的四个文件一一对应，分别用于保存对应文件的缓存数据！</p>
<p><strong>每一个 IntervalStats 都对应着一个名字为时间戳的文件</strong>！</p>
<h1 id="2-UserUsageStatsService-init-初始化操作"><a href="#2-UserUsageStatsService-init-初始化操作" class="headerlink" title="2 UserUsageStatsService.init - 初始化操作"></a>2 UserUsageStatsService.init - 初始化操作</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> currentTimeMillis)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【×2.1】初始化 UsageStatsDatabase 实例！</span></span><br><span class="line">    mDatabase.init(currentTimeMillis);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】加载本地持久化文件，初始化缓存数据：mCurrentStats！</span></span><br><span class="line">    <span class="keyword">int</span> nullCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mCurrentStats.length; i++) &#123;</span><br><span class="line">        <span class="comment">//【×2.2】将持久化文件的数据加载到内存中！</span></span><br><span class="line">        mCurrentStats[i] = mDatabase.getLatestUsageStats(i);</span><br><span class="line">        <span class="keyword">if</span> (mCurrentStats[i] == <span class="keyword">null</span>) &#123;</span><br><span class="line">            nullCount++; <span class="comment">// 统计没有对应数据的类别！</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nullCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果 nullCount 大于 0，说明 daily，monthly，weekly，yearly 这四个数据类型，至少有一个没有对应的数据！</span></span><br><span class="line">        <span class="keyword">if</span> (nullCount != mCurrentStats.length) &#123;</span><br><span class="line">            <span class="comment">// 说明某个类别没有数据！</span></span><br><span class="line">            Slog.w(TAG, mLogPrefix + <span class="string">"Some stats have no latest available"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 第一次启动的情况！</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//【×2.3】加载最新的使用信息！</span></span><br><span class="line">        loadActiveStats(currentTimeMillis);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//【×2.4】设置回滚日期！</span></span><br><span class="line">        updateRolloverDeadline();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now close off any events that were open at the time this was saved.</span></span><br><span class="line">    <span class="comment">//【2】初始化到这里，mCurrentStats 已经保存了每个时间类别下，对应的最新的使用信息！</span></span><br><span class="line">    <span class="comment">// 接着，对 package 的 UsageStats.mLastEvent 取值做一个特殊处理！</span></span><br><span class="line">    <span class="keyword">for</span> (IntervalStats stat : mCurrentStats) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> pkgCount = stat.packageStats.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pkgCount; i++) &#123;</span><br><span class="line">            UsageStats pkgStats = stat.packageStats.valueAt(i);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//【2.1】如果该 package 的最后一个 event 是 MOVE_TO_FOREGROUND 或者 CONTINUE_PREVIOUS_DAY</span></span><br><span class="line">            <span class="comment">// 更新其为 END_OF_DAY！</span></span><br><span class="line">            <span class="keyword">if</span> (pkgStats.mLastEvent == UsageEvents.Event.MOVE_TO_FOREGROUND ||</span><br><span class="line">                    pkgStats.mLastEvent == UsageEvents.Event.CONTINUE_PREVIOUS_DAY) &#123;</span><br><span class="line">                    </span><br><span class="line">                <span class="comment">//【×2.5】更新所属 IntervalStats 的属性！</span></span><br><span class="line">                stat.update(pkgStats.mPackageName, stat.lastTimeSaved,</span><br><span class="line">                        UsageEvents.Event.END_OF_DAY);</span><br><span class="line">                        </span><br><span class="line">                <span class="comment">//【×2.6】延迟 20mins 通知 UsageStatsService 使用信息发生变化！</span></span><br><span class="line">                <span class="comment">// 通知一次！</span></span><br><span class="line">                notifyStatsChanged();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【×2.7】更新配置信息！</span></span><br><span class="line">        stat.updateConfigurationStats(<span class="keyword">null</span>, stat.lastTimeSaved);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【×2.8】如果发生了系统升级，isNewUpdate 返回 true！</span></span><br><span class="line">    <span class="keyword">if</span> (mDatabase.isNewUpdate()) &#123;</span><br><span class="line">        notifyNewUpdate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-1-UsageStatsDatabase-init"><a href="#2-1-UsageStatsDatabase-init" class="headerlink" title="2.1 UsageStatsDatabase.init"></a>2.1 UsageStatsDatabase.init</h2><p>init 方法用于初始化 database，我们来看看具体的流程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">long</span> currentTimeMillis)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="comment">//【1】创建 daily，monthly，weekly，yearly 四个文件夹！</span></span><br><span class="line">        <span class="keyword">for</span> (File f : mIntervalDirs) &#123;</span><br><span class="line">            f.mkdirs();</span><br><span class="line">            <span class="keyword">if</span> (!f.exists()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Failed to create directory "</span></span><br><span class="line">                        + f.getAbsolutePath());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【2.1.1】检查 version 变化！</span></span><br><span class="line">        checkVersionAndBuildLocked();</span><br><span class="line">        <span class="comment">//【2.1.2】加载每个时间类别文件夹中的文件到 mSortedStatFiles 中！</span></span><br><span class="line">        indexFilesLocked();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【3】删除那些日期在当前时间以后的文件！</span></span><br><span class="line">        <span class="keyword">for</span> (TimeSparseArray&lt;AtomicFile&gt; files : mSortedStatFiles) &#123;</span><br><span class="line">            <span class="comment">//【3.1】根据当前时间确定删除文件的参考点！</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> startIndex = files.closestIndexOnOrAfter(currentTimeMillis);</span><br><span class="line">            <span class="keyword">if</span> (startIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//【3.2】移除那些日期在当前时间之后的文件！</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> fileCount = files.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &lt; fileCount; i++) &#123;</span><br><span class="line">                files.valueAt(i).delete();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = startIndex; i &lt; fileCount; i++) &#123;</span><br><span class="line">                files.removeAt(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法很简单，不多说了！</p>
<h3 id="2-1-1-UsageStatsDatabase-checkVersionAndBuildLocked"><a href="#2-1-1-UsageStatsDatabase-checkVersionAndBuildLocked" class="headerlink" title="2.1.1 UsageStatsDatabase.checkVersionAndBuildLocked"></a>2.1.1 UsageStatsDatabase.checkVersionAndBuildLocked</h3><p>checkVersionAndBuildLocked 用于检查版本变化！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkVersionAndBuildLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> version;</span><br><span class="line">    String buildFingerprint;</span><br><span class="line">    <span class="comment">// 获得当前系统的 Fingerprint！</span></span><br><span class="line">    String currentFingerprint = getBuildFingerprint();</span><br><span class="line">    mFirstUpdate = <span class="keyword">true</span>;</span><br><span class="line">    mNewUpdate = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> (BufferedReader reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(mVersionFile))) &#123;</span><br><span class="line">        version = Integer.parseInt(reader.readLine());</span><br><span class="line">        <span class="comment">//【1】从 /data/system/usagestats/0version 中读取数据库中记录的Fingerprint！</span></span><br><span class="line">        <span class="comment">// 如果可以读取掉，说明不是第一次更新，那么 mFirstUpdate 为 false；</span></span><br><span class="line">        <span class="comment">// 如果当前系统的 Fingerprint 和数据库中的 Fingerprint 一样，说没有发生系统更新，mNewUpdate 为 false；</span></span><br><span class="line">        buildFingerprint = reader.readLine();</span><br><span class="line">        <span class="keyword">if</span> (buildFingerprint != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mFirstUpdate = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (currentFingerprint.equals(buildFingerprint)) &#123;</span><br><span class="line">            mNewUpdate = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException | IOException e) &#123;</span><br><span class="line">        version = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【2】如果 version 不等于 3，说明存在数据库升级！</span></span><br><span class="line">    <span class="keyword">if</span> (version != CURRENT_VERSION) &#123;</span><br><span class="line">        Slog.i(TAG, <span class="string">"Upgrading from version "</span> + version + <span class="string">" to "</span> + CURRENT_VERSION);</span><br><span class="line">        <span class="comment">//【2.1.1.1】升级数据库，删除旧文件！</span></span><br><span class="line">        doUpgradeLocked(version);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【3】当 如果 version 不等于 3 或者发生了系统更新，那就需要更新本地文件中的 Fingerprint！</span></span><br><span class="line">    <span class="keyword">if</span> (version != CURRENT_VERSION || mNewUpdate) &#123;</span><br><span class="line">        <span class="keyword">try</span> (BufferedWriter writer = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(mVersionFile))) &#123;</span><br><span class="line">            writer.write(Integer.toString(CURRENT_VERSION));</span><br><span class="line">            writer.write(<span class="string">"\n"</span>);</span><br><span class="line">            writer.write(currentFingerprint);</span><br><span class="line">            writer.write(<span class="string">"\n"</span>);</span><br><span class="line">            writer.flush();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            Slog.e(TAG, <span class="string">"Failed to write new version"</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里我们不过多关注！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CURRENT_VERSION = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>我们可以看到 UsageStatsDatabase 中定义了 CURRENT_VERSION 值为 3，表示当前版本号！</p>
<h4 id="2-1-1-1-UsageStatsDatabase-doUpgradeLocked"><a href="#2-1-1-1-UsageStatsDatabase-doUpgradeLocked" class="headerlink" title="2.1.1.1 UsageStatsDatabase.doUpgradeLocked"></a>2.1.1.1 UsageStatsDatabase.doUpgradeLocked</h4><p>处理数据库升级！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doUpgradeLocked</span><span class="params">(<span class="keyword">int</span> thisVersion)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (thisVersion &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 删除掉 version 小于 2 的数据库！</span></span><br><span class="line">        Slog.i(TAG, <span class="string">"Deleting all usage stats files"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mIntervalDirs.length; i++) &#123;</span><br><span class="line">            File[] files = mIntervalDirs[i].listFiles();</span><br><span class="line">            <span class="keyword">if</span> (files != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">                    f.delete();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其实就是删除本地持久化文件！</p>
<h3 id="2-1-2-UsageStatsDatabase-indexFilesLocked"><a href="#2-1-2-UsageStatsDatabase-indexFilesLocked" class="headerlink" title="2.1.2 UsageStatsDatabase.indexFilesLocked"></a>2.1.2 UsageStatsDatabase.indexFilesLocked</h3><p>indexFilesLocked 方法用于列出时间类别文件夹中的所有文件，并按照时间升序排序！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">indexFilesLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】创建一个文件过滤器，过滤掉那些文件后缀是 .bak 的备份文件！</span></span><br><span class="line">    <span class="keyword">final</span> FilenameFilter backupFileFilter = <span class="keyword">new</span> FilenameFilter() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> !name.endsWith(BAK_SUFFIX);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】遍历四个时间类别的文件夹，获得那个类别文件夹下，除去后缀为 .bak 的所有文件，</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mSortedStatFiles.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mSortedStatFiles[i] == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mSortedStatFiles[i] = <span class="keyword">new</span> TimeSparseArray&lt;&gt;();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mSortedStatFiles[i].clear();</span><br><span class="line">        &#125;</span><br><span class="line">        File[] files = mIntervalDirs[i].listFiles(backupFileFilter);</span><br><span class="line">        <span class="keyword">if</span> (files != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">                Slog.d(TAG, <span class="string">"Found "</span> + files.length + <span class="string">" stat files for interval "</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">                <span class="keyword">final</span> AtomicFile af = <span class="keyword">new</span> AtomicFile(f);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//【2.1.2.1】调用 UsageStatsXml.parseBeginTime 计算文件的创建时间，然后</span></span><br><span class="line">                    <span class="comment">// 通过 time —&gt; AtomicFile 映射关系，保存到对应类别的 mSortedStatFiles[i] 中去！</span></span><br><span class="line">                    mSortedStatFiles[i].put(UsageStatsXml.parseBeginTime(af), af);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    Slog.e(TAG, <span class="string">"failed to index file: "</span> + f, e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里设置到了一个文件后缀：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BAK_SUFFIX = <span class="string">".bak"</span>;</span><br></pre></td></tr></table></figure></p>
<p>UsageStatsDatabase 会自动过滤掉 .bak 结尾的文件，因为 .bak 是备份文件！！</p>
<h4 id="2-1-2-1-UsageStatsXml-parseBeginTime"><a href="#2-1-2-1-UsageStatsXml-parseBeginTime" class="headerlink" title="2.1.2.1 UsageStatsXml.parseBeginTime"></a>2.1.2.1 UsageStatsXml.parseBeginTime</h4><p>这里用到了 UsageStatsXml，他是用来专门解析 usage 文件的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">parseBeginTime</span><span class="params">(AtomicFile file)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> parseBeginTime(file.getBaseFile());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>继续调用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">parseBeginTime</span><span class="params">(File file)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    String name = file.getName();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】如果文件名以 -c 结尾，返回去掉 -c 剩余的内容：</span></span><br><span class="line">    <span class="keyword">while</span> (name.endsWith(CHECKED_IN_SUFFIX)) &#123; </span><br><span class="line">        name = name.substring(<span class="number">0</span>, name.length() - CHECKED_IN_SUFFIX.length());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Long.parseLong(name);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里我们可以看到，其实每一个时间类别的文件夹中的所有文件都是以其创建日期来命名的！</p>
<h2 id="2-2-UsageStatsDatabase-getLatestUsageStats-获得最新的使用信息"><a href="#2-2-UsageStatsDatabase-getLatestUsageStats-获得最新的使用信息" class="headerlink" title="2.2 UsageStatsDatabase.getLatestUsageStats - 获得最新的使用信息"></a>2.2 UsageStatsDatabase.getLatestUsageStats - 获得最新的使用信息</h2><p>返回指定时间类别 intervalType 的最新的使用状态信息！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IntervalStats <span class="title">getLatestUsageStats</span><span class="params">(<span class="keyword">int</span> intervalType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="comment">//【1】校验 intervalType 的取值范围！</span></span><br><span class="line">        <span class="keyword">if</span> (intervalType &lt; <span class="number">0</span> || intervalType &gt;= mIntervalDirs.length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Bad interval type "</span> + intervalType);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> fileCount = mSortedStatFiles[intervalType].size();</span><br><span class="line">        <span class="keyword">if</span> (fileCount == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//【2】因为 mSortedStatFiles[intervalType] 是按照时间顺序排序的，所以最新的状态信息文件</span></span><br><span class="line">            <span class="comment">// 一定是 fileCount - 1 对应的 AtomicFile!</span></span><br><span class="line">            <span class="keyword">final</span> AtomicFile f = mSortedStatFiles[intervalType].valueAt(fileCount - <span class="number">1</span>);</span><br><span class="line">            IntervalStats stats = <span class="keyword">new</span> IntervalStats();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//【2.2.1.1】调用 UsageStatsXml.read 从本地文件中读取信息，初始化 IntervalStats 对象！</span></span><br><span class="line">            UsageStatsXml.read(f, stats);</span><br><span class="line">            <span class="keyword">return</span> stats;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            Slog.e(TAG, <span class="string">"Failed to read usage stats file"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-2-1-UsageStatsXml-read"><a href="#2-2-1-UsageStatsXml-read" class="headerlink" title="2.2.1 UsageStatsXml.read"></a>2.2.1 UsageStatsXml.read</h3><p>read 读取文件！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(AtomicFile file, IntervalStats statsOut)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        FileInputStream in = file.openRead();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//【2.1.2.1】调用 parseBeginTime 方法，初始化 statsOut.beginTime，可以看到</span></span><br><span class="line">            <span class="comment">// 文件名的时间戳，就是 statsOut.beginTime 的值！</span></span><br><span class="line">            statsOut.beginTime = parseBeginTime(file);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【2.2.2】调用自身的 read 方法，继续解析；</span></span><br><span class="line">            read(in, statsOut);</span><br><span class="line">            <span class="comment">// 获得文件上一次被更新的时间 statsOut.lastTimeSaved</span></span><br><span class="line">            statsOut.lastTimeSaved = file.getLastModifiedTime();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                in.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="comment">// Empty</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        Slog.e(TAG, <span class="string">"UsageStats Xml"</span>, e);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过这个阶段，我们获得了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">statsOut.beginTime; <span class="comment">// 文件开始记录的时间</span></span><br><span class="line">statsOut.lastTimeSaved; <span class="comment">// 文件最新修改的时间</span></span><br></pre></td></tr></table></figure>
<p>以上两个属性！</p>
<h3 id="2-2-2-UsageStatsXml-read"><a href="#2-2-2-UsageStatsXml-read" class="headerlink" title="2.2.2 UsageStatsXml.read"></a>2.2.2 UsageStatsXml.read</h3><p>继续解析：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(InputStream in, IntervalStats statsOut)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    XmlPullParser parser = Xml.newPullParser();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        parser.setInput(in, <span class="string">"utf-8"</span>);</span><br><span class="line">        XmlUtils.beginDocument(parser, USAGESTATS_TAG); <span class="comment">// 解析 usagestats 标签</span></span><br><span class="line">        String versionStr = parser.getAttributeValue(<span class="keyword">null</span>, VERSION_ATTR); <span class="comment">// 解析 version 属性</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">switch</span> (Integer.parseInt(versionStr)) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    <span class="comment">//【2.2.3】调用 UsageStatsXmlV1.read 继续解析</span></span><br><span class="line">                    <span class="comment">// 只有 version 置为 1 时才会继续解析；</span></span><br><span class="line">                    UsageStatsXmlV1.read(parser, statsOut);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    Slog.e(TAG, <span class="string">"Unrecognized version "</span> + versionStr);</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Unrecognized version "</span> + versionStr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">            Slog.e(TAG, <span class="string">"Bad version"</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (XmlPullParserException e) &#123;</span><br><span class="line">        Slog.e(TAG, <span class="string">"Failed to parse Xml"</span>, e);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第二个 read 方法更像是 version 校验！</p>
<p>这里对应的数据是：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">usagestats</span> <span class="attr">version</span>=<span class="string">"1"</span> <span class="attr">endTime</span>=<span class="string">"62979335"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">usagestats</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-2-3-UsageStatsXmlV1-read"><a href="#2-2-3-UsageStatsXmlV1-read" class="headerlink" title="2.2.3 UsageStatsXmlV1.read"></a>2.2.3 UsageStatsXmlV1.read</h3><p>最后，调用了 UsageStatsXmlV1 的 read 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(XmlPullParser parser, IntervalStats statsOut)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> XmlPullParserException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">//【1】清空 IntervalStats 的内部的集合！</span></span><br><span class="line">    statsOut.packageStats.clear();</span><br><span class="line">    statsOut.configurations.clear();</span><br><span class="line">    statsOut.activeConfiguration = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (statsOut.events != <span class="keyword">null</span>) &#123;</span><br><span class="line">        statsOut.events.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【2】计算 statsOut.endTime，等于 statsOut.beginTime 加上 endTime 的值！</span></span><br><span class="line">    statsOut.endTime = statsOut.beginTime + XmlUtils.readLongAttribute(parser, END_TIME_ATTR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> eventCode;</span><br><span class="line">    <span class="keyword">int</span> outerDepth = parser.getDepth();</span><br><span class="line">    <span class="comment">//【3】接下来，根据使用信息的类别，进行不同的处理！</span></span><br><span class="line">    <span class="keyword">while</span> ((eventCode = parser.next()) != XmlPullParser.END_DOCUMENT</span><br><span class="line">            &amp;&amp; (eventCode != XmlPullParser.END_TAG || parser.getDepth() &gt; outerDepth)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (eventCode != XmlPullParser.START_TAG) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> String tag = parser.getName();</span><br><span class="line">        <span class="keyword">switch</span> (tag) &#123;</span><br><span class="line">            <span class="keyword">case</span> PACKAGE_TAG: <span class="comment">// package 标签</span></span><br><span class="line">                <span class="comment">//【2.2.3.1】如果该使用信息是 package 的，调用 loadUsageStats 解析！</span></span><br><span class="line">                loadUsageStats(parser, statsOut);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> CONFIG_TAG: <span class="comment">// config 标签</span></span><br><span class="line">                <span class="comment">//【2.2.3.2】如果该使用信息是 config 的，调用 loadConfigStats 解析！</span></span><br><span class="line">                loadConfigStats(parser, statsOut);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> EVENT_TAG: <span class="comment">// event 标签</span></span><br><span class="line">                <span class="comment">//【2.2.3.3】如果该使用信息是 event 的，调用 loadEvent 解析！</span></span><br><span class="line">                loadEvent(parser, statsOut);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该阶段，我们得到了如下的属性：</p>
<ul>
<li>statsOut.endTime，表示该使用信息文件记录的截至时间点，取值为 statsOut.beginTime + XmlUtils.readLongAttribute(parser, END_TIME_ATTR)；</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">usagestats</span> <span class="attr">version</span>=<span class="string">"1"</span> <span class="attr">endTime</span>=<span class="string">"62979335"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">usagestats</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>END_TIME_ATTR 对应着属性：endTime 属性，endTime 其实是一个时间间隔，距离 statsOut.beginTime 的时间间隔，statsOut.beginTime 和 statsOut.endTime 的时间段就是该文件能够记录的数据范围！</p>
<p>接着，解析 package，config 和 event 相关的使用信息！</p>
<h4 id="2-2-3-1-UsageStatsXmlV1-loadUsageStats-读取-UsageStats"><a href="#2-2-3-1-UsageStatsXmlV1-loadUsageStats-读取-UsageStats" class="headerlink" title="2.2.3.1 UsageStatsXmlV1.loadUsageStats - 读取 UsageStats"></a>2.2.3.1 UsageStatsXmlV1.loadUsageStats - 读取 UsageStats</h4><p>我们来看 package 标签和其属性：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">packages</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">lastTimeActive</span>=<span class="string">"1104580"</span> <span class="attr">package</span>=<span class="string">"com.github.shadowsocks"</span> <span class="attr">timeActive</span>=<span class="string">"119959"</span> <span class="attr">lastEvent</span>=<span class="string">"2"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">packages</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>下面看看 解析 package 的使用信息！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadUsageStats</span><span class="params">(XmlPullParser parser, IntervalStats statsOut)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String pkg = parser.getAttributeValue(<span class="keyword">null</span>, PACKAGE_ATTR);</span><br><span class="line">    <span class="keyword">if</span> (pkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(<span class="string">"no "</span> + PACKAGE_ATTR + <span class="string">" attribute present"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【2.2.3.1.1】根据给定的 package，创建对应的 UsageStats！</span></span><br><span class="line">    <span class="keyword">final</span> UsageStats stats = statsOut.getOrCreateUsageStats(pkg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】解析 lastTimeActive 属性，表示的是距离 beginTime 的时间间隔，</span></span><br><span class="line">    <span class="comment">// 初始化 stats.mLastTimeUsed，表示该 package 最后是使用的时间；</span></span><br><span class="line">    stats.mLastTimeUsed = statsOut.beginTime + XmlUtils.readLongAttribute(</span><br><span class="line">            parser, LAST_TIME_ACTIVE_ATTR);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】解析 timeActive 属性，获得 package 在前台的总时间，初始化 stats.mTotalTimeInForeground！</span></span><br><span class="line">    stats.mTotalTimeInForeground = XmlUtils.readLongAttribute(parser, TOTAL_TIME_ACTIVE_ATTR);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【3】解析 lastEvent 属性，获得 package 在最后一次触发的 event，保存到 stats.mLastEvent 中！</span></span><br><span class="line">    stats.mLastEvent = XmlUtils.readIntAttribute(parser, LAST_EVENT_ATTR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先获得 pkg 对应的 UsageStats 对象，然后解析相关属性！</p>
<ul>
<li>lastTimeActive 属性用于计算最后一次处于 activie 的时间，它是一个距离 statsOut.beginTime 的时间间隔！</li>
</ul>
<p>通过 lastTimeActive + statsOut.beginTime，就能够计算出上一次使用的时间 stats.mLastTimeUsed！</p>
<ul>
<li><p>timeActive 属性表示其在处于 active 总时间，用于计算 stats.mTotalTimeInForeground；</p>
</li>
<li><p>lastEvent 属性表示上一次该 package 上报的时间类型，用于初始化 stats.mLastEvent；</p>
</li>
</ul>
<h5 id="2-2-3-1-1-IntervalStats-getOrCreateUsageStats"><a href="#2-2-3-1-1-IntervalStats-getOrCreateUsageStats" class="headerlink" title="2.2.3.1.1 IntervalStats.getOrCreateUsageStats"></a>2.2.3.1.1 IntervalStats.getOrCreateUsageStats</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">UsageStats <span class="title">getOrCreateUsageStats</span><span class="params">(String packageName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】先从 packageStats 中获取 package 对应的 UsageStats！</span></span><br><span class="line">    UsageStats usageStats = packageStats.get(packageName);</span><br><span class="line">    <span class="keyword">if</span> (usageStats == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//【2】创建一个 UsageStats 对象！</span></span><br><span class="line">        usageStats = <span class="keyword">new</span> UsageStats();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获得包名</span></span><br><span class="line">        usageStats.mPackageName = getCachedStringRef(packageName);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【3】很显然，该 package 的 usageStats.mBeginTimeStamp 和 usageStats.mEndTimeStamp </span></span><br><span class="line">        <span class="comment">// 和其所属的 IntervalStats 是一样的！</span></span><br><span class="line">        usageStats.mBeginTimeStamp = beginTime;</span><br><span class="line">        usageStats.mEndTimeStamp = endTime;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【4】将其添加到 packageStats 中去！</span></span><br><span class="line">        packageStats.put(usageStats.mPackageName, usageStats);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回</span></span><br><span class="line">    <span class="keyword">return</span> usageStats;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们知道 IntervalStats.packageStats 中保存的是应用的使用信息！</p>
<p>getCachedStringRef 优先从 IntervalStats.mStringCache 内部缓存中获取！</p>
<ul>
<li><p>创建了一个 UsageStats 对象，封装该 package 的使用信息！</p>
</li>
<li><p>计算 usageStats.mBeginTimeStamp 和 usageStats.mEndTimeStamp，等于所属 IntervalStats.beginTime 和 IntervalStats.beginTime！</p>
</li>
<li><p>将新创建的 UsageStats 添加到 packageStats 中！</p>
</li>
</ul>
<h4 id="2-2-3-2-UsageStatsXmlV1-loadConfigStats-读取-ConfigStats"><a href="#2-2-3-2-UsageStatsXmlV1-loadConfigStats-读取-ConfigStats" class="headerlink" title="2.2.3.2 UsageStatsXmlV1.loadConfigStats - 读取 ConfigStats"></a>2.2.3.2 UsageStatsXmlV1.loadConfigStats - 读取 ConfigStats</h4><p>我们来看看 config 的使用信息：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;configurations&gt;</span><br><span class="line">    &lt;config lastTimeActive=<span class="string">"60709298"</span> timeActive=<span class="string">"60690625"</span> count=<span class="string">"3"</span> active=<span class="string">"true"</span></span><br><span class="line">            fs=<span class="string">"1065353216"</span> mcc=<span class="string">"460"</span> mnc=<span class="string">"65535"</span> </span><br><span class="line">locales=<span class="string">"zh-CN"</span> touch=<span class="string">"3"</span> key=<span class="string">"1"</span> keyHid=<span class="string">"1"</span></span><br><span class="line">hardKeyHid=<span class="string">"2"</span> nav=<span class="string">"1"</span> navHid=<span class="string">"2"</span> ori=<span class="string">"1"</span> scrLay=<span class="string">"268435810"</span> </span><br><span class="line">clrMod=<span class="string">"5"</span> ui=<span class="string">"17"</span> width=<span class="string">"360"</span> height=<span class="string">"685"</span> sw=<span class="string">"360"</span></span><br><span class="line">density=<span class="string">"480"</span> app_bounds=<span class="string">"0 0 1080 2136"</span> /&gt;</span><br><span class="line">&lt;/configurations&gt;</span><br></pre></td></tr></table></figure></p>
<p>下面我们来出解析 Configuration 的使用信息！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadConfigStats</span><span class="params">(XmlPullParser parser, IntervalStats statsOut)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> XmlPullParserException, IOException </span>&#123;</span><br><span class="line">    <span class="comment">//【1】创建了一个 Configuration 对象，并 readXmlAttrs 解析和配置文件相关的信息！</span></span><br><span class="line">    <span class="keyword">final</span> Configuration config = <span class="keyword">new</span> Configuration();</span><br><span class="line">    Configuration.readXmlAttrs(parser, config);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2.2.3.1.1】根据给定的 Configuration，创建对应的 ConfigurationStats！</span></span><br><span class="line">    <span class="keyword">final</span> ConfigurationStats configStats = statsOut.getOrCreateConfigurationStats(config);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】解析 lastTimeActive 属性，表示的是距离 beginTime 的时间间隔，</span></span><br><span class="line">    <span class="comment">// 初始化 stats.mLastTimeUsed，表示该 package 最后是使用的时间；</span></span><br><span class="line">    configStats.mLastTimeActive = statsOut.beginTime + XmlUtils.readLongAttribute(</span><br><span class="line">            parser, LAST_TIME_ACTIVE_ATTR);</span><br><span class="line">            </span><br><span class="line">    <span class="comment">//【2】解析 timeActive 属性，获得 Configuration 活跃的总时间，初始化 stats.mTotalTimeActive！</span></span><br><span class="line">    configStats.mTotalTimeActive = XmlUtils.readLongAttribute(parser, TOTAL_TIME_ACTIVE_ATTR);</span><br><span class="line">    <span class="comment">//【3】解析 count 属性，获得 Configuration 活跃的次数，初始化 stats.mActivationCount！</span></span><br><span class="line">    configStats.mActivationCount = XmlUtils.readIntAttribute(parser, COUNT_ATTR);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【4】解析 active 属性，判断该 Configuration 是否是活跃状态！</span></span><br><span class="line">    <span class="comment">// 初始化 statsOut.activeConfiguration！</span></span><br><span class="line">    <span class="keyword">if</span> (XmlUtils.readBooleanAttribute(parser, ACTIVE_ATTR)) &#123;</span><br><span class="line">        statsOut.activeConfiguration = configStats.mConfiguration;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于 Configuration，由于其属性配置很多，所以这里我们只关注和 UsageStats 相关的属性！</p>
<p>创建了一个 Configuration 对象，表示该配置信息对象，用于保存配置相关的属性！</p>
<p>创建该 config 对象的 ConfigurationStats 对象！</p>
<h5 id="2-2-3-2-1-IntervalStats-getOrCreateConfigurationStats"><a href="#2-2-3-2-1-IntervalStats-getOrCreateConfigurationStats" class="headerlink" title="2.2.3.2.1 IntervalStats.getOrCreateConfigurationStats"></a>2.2.3.2.1 IntervalStats.getOrCreateConfigurationStats</h5><p>获取或者创建 Configuration 对应的 ConfigurationStats 对象！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ConfigurationStats <span class="title">getOrCreateConfigurationStats</span><span class="params">(Configuration config)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】先从 configurations 中获取 package 对应的 ConfigurationStats！</span></span><br><span class="line">    ConfigurationStats configStats = configurations.get(config);</span><br><span class="line">    <span class="keyword">if</span> (configStats == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//【2】如果没有，就创建一个 ConfigurationStats 对象！</span></span><br><span class="line">        configStats = <span class="keyword">new</span> ConfigurationStats();</span><br><span class="line">        <span class="comment">//【3】很显然，该 package 的 usageStats.mBeginTimeStamp 和 usageStats.mEndTimeStamp </span></span><br><span class="line">        <span class="comment">// 和其所属的 IntervalStats 是一样的！</span></span><br><span class="line">        configStats.mBeginTimeStamp = beginTime;</span><br><span class="line">        configStats.mEndTimeStamp = endTime;</span><br><span class="line">        <span class="comment">//【4】设置 configStats.mConfiguration；</span></span><br><span class="line">        configStats.mConfiguration = config;</span><br><span class="line">        <span class="comment">//【5】将其添加到 configurations 中！</span></span><br><span class="line">        configurations.put(config, configStats);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回</span></span><br><span class="line">    <span class="keyword">return</span> configStats;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="2-2-3-3-UsageStatsXmlV1-loadEvent-读取-Event"><a href="#2-2-3-3-UsageStatsXmlV1-loadEvent-读取-Event" class="headerlink" title="2.2.3.3 UsageStatsXmlV1.loadEvent - 读取 Event"></a>2.2.3.3 UsageStatsXmlV1.loadEvent - 读取 Event</h4><p>我们来看看 event 相关的数据</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;event-log&gt;</span><br><span class="line">    &lt;event time=<span class="string">"5852614"</span> <span class="keyword">package</span>=<span class="string">"com.tencent.mobileqq"</span></span><br><span class="line">           <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.tencent.mobileqq.activity.QQLSActivity"</span> flags=<span class="string">"0"</span> type=<span class="string">"1"</span> /&gt;</span><br><span class="line">    &lt;event time=<span class="string">"5852617"</span> <span class="keyword">package</span>=<span class="string">"com.tencent.mobileqq"</span> </span><br><span class="line">           <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.tencent.mobileqq.activity.QQLSActivity"</span> flags=<span class="string">"0"</span> type=<span class="string">"2"</span> /&gt;</span><br><span class="line">&lt;/event-log&gt;</span><br></pre></td></tr></table></figure>
<p>注意：只有 daily 类别的文件才有 event！</p>
<p>解析 UsageEvents 的使用信息！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">private static void loadEvent(XmlPullParser parser, IntervalStats statsOut)</span><br><span class="line">        throws XmlPullParserException, IOException &#123;</span><br><span class="line">    //【1】解析 package 属性，获得该 event 所属的 pacakge！</span><br><span class="line">    final String packageName = XmlUtils.readStringAttribute(parser, PACKAGE_ATTR);</span><br><span class="line">    if (packageName == null) &#123;</span><br><span class="line">        throw new ProtocolException(&quot;no &quot; + PACKAGE_ATTR + &quot; attribute present&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    //【2】解析 class 属性，获得该 event 所属的 pacakge</span><br><span class="line">    final String className = XmlUtils.readStringAttribute(parser, CLASS_ATTR);</span><br><span class="line"></span><br><span class="line">    //【2.2.3.3.1】根据给定的 packageName 和 className，创建对应的 Event！</span><br><span class="line">    final UsageEvents.Event event = statsOut.buildEvent(packageName, className);</span><br><span class="line"></span><br><span class="line">    //【3】解析 lastTimeActive 属性，表示的是距离 statsOut.beginTime 的时间间隔，</span><br><span class="line">    // 初始化 event.mTimeStamp，表示该 event 的上报时间；</span><br><span class="line">    event.mTimeStamp = statsOut.beginTime + XmlUtils.readLongAttribute(parser, TIME_ATTR);</span><br><span class="line">    </span><br><span class="line">    //【4】解析 type 属性，初始化 event.mEventType，表示该 event 的类型；</span><br><span class="line">    event.mEventType = XmlUtils.readIntAttribute(parser, TYPE_ATTR);</span><br><span class="line">    </span><br><span class="line">    //【5】如果 event type 类型为 CONFIGURATION_CHANGE 或者 SHORTCUT_INVOCATION</span><br><span class="line">    // 还要解析其对应的 Configuration 和 shortcutId 属性！</span><br><span class="line">    switch (event.mEventType) &#123;</span><br><span class="line">        case UsageEvents.Event.CONFIGURATION_CHANGE:</span><br><span class="line">            event.mConfiguration = new Configuration();</span><br><span class="line">            Configuration.readXmlAttrs(parser, event.mConfiguration);</span><br><span class="line">            break;</span><br><span class="line"></span><br><span class="line">        case UsageEvents.Event.SHORTCUT_INVOCATION:</span><br><span class="line">            final String id = XmlUtils.readStringAttribute(parser, SHORTCUT_ID_ATTR);</span><br><span class="line">            event.mShortcutId = (id != null) ? id.intern() : null;</span><br><span class="line">            break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (statsOut.events == null) &#123; // 如果 IntervalStats.events 为 null，初始化！</span><br><span class="line">        statsOut.events = new TimeSparseArray&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //【6】将该 UsageEvents.Event 添加到 IntervalStats.events 中！</span><br><span class="line">    statsOut.events.put(event.mTimeStamp, event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="2-2-3-3-1-IntervalStats-buildEvent"><a href="#2-2-3-3-1-IntervalStats-buildEvent" class="headerlink" title="2.2.3.3.1 IntervalStats.buildEvent"></a>2.2.3.3.1 IntervalStats.buildEvent</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">UsageEvents.<span class="function">Event <span class="title">buildEvent</span><span class="params">(String packageName, String className)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】创建一个 UsageEvents.Event 对象！</span></span><br><span class="line">    UsageEvents.Event event = <span class="keyword">new</span> UsageEvents.Event();</span><br><span class="line">    <span class="comment">//【2】初始化 event.mPackage 和 event.mClass 属性！</span></span><br><span class="line">    event.mPackage = getCachedStringRef(packageName);</span><br><span class="line">    <span class="keyword">if</span> (className != <span class="keyword">null</span>) &#123;</span><br><span class="line">        event.mClass = getCachedStringRef(className);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> event;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法只是创建 UsageEvents.Event 对象，但是其并没有将其添加到对应的集合中！</p>
<h2 id="2-3-UserUsageStatsService-loadActiveStats"><a href="#2-3-UserUsageStatsService-loadActiveStats" class="headerlink" title="2.3 UserUsageStatsService.loadActiveStats"></a>2.3 UserUsageStatsService.loadActiveStats</h2><p>loadActiveStats 用于给没有最新使用信息的时间类别创建新的 IntervalStats！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadActiveStats</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> currentTimeMillis)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】mCurrentStats 用于保存每个时间类别对应的最新的使用信息，这里开始遍历时间类别！</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> intervalType = <span class="number">0</span>; intervalType &lt; mCurrentStats.length; intervalType++) &#123;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//【2.2】通过 getLatestUsageStats 方法获得时间类别的最新使用信息！</span></span><br><span class="line">        <span class="keyword">final</span> IntervalStats stats = mDatabase.getLatestUsageStats(intervalType);</span><br><span class="line">        <span class="keyword">if</span> (stats != <span class="keyword">null</span> &amp;&amp; currentTimeMillis - <span class="number">500</span> &gt;= stats.endTime &amp;&amp;</span><br><span class="line">                currentTimeMillis &lt; stats.beginTime + INTERVAL_LENGTH[intervalType]) &#123;</span><br><span class="line">            <span class="comment">//【2】判断下当前时间是否在时间范围之内，如果是，该 IntervalStats 依然可以记录使用信息！</span></span><br><span class="line">            <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">                Slog.d(TAG, mLogPrefix + <span class="string">"Loading existing stats @ "</span> +</span><br><span class="line">                        sDateFormat.format(stats.beginTime) + <span class="string">"("</span> + stats.beginTime +</span><br><span class="line">                        <span class="string">") for interval "</span> + intervalType);</span><br><span class="line">            &#125;</span><br><span class="line">            mCurrentStats[intervalType] = stats;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//【3】当前时间已经超过最新的 IntervalStats 能够记录的时间范围！</span></span><br><span class="line">            <span class="comment">// 或者某个时间类别没有对应的使用信息！</span></span><br><span class="line">            <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">                Slog.d(TAG, <span class="string">"Creating new stats @ "</span> +</span><br><span class="line">                        sDateFormat.format(currentTimeMillis) + <span class="string">"("</span> +</span><br><span class="line">                        currentTimeMillis + <span class="string">") for interval "</span> + intervalType);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 创建一个新的 IntervalStats 对象，初始化 beginTime 为当前时间，endTime 为当前时间 + 1</span></span><br><span class="line">            mCurrentStats[intervalType] = <span class="keyword">new</span> IntervalStats();</span><br><span class="line">            mCurrentStats[intervalType].beginTime = currentTimeMillis;</span><br><span class="line">            mCurrentStats[intervalType].endTime = currentTimeMillis + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【2.3】将 mStatsChanged 置为 false；</span></span><br><span class="line">    mStatsChanged = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2.4】更新回滚时间！</span></span><br><span class="line">    updateRolloverDeadline();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【×2.3.1】通知 UsageStatsService 该 userId 的最新使用信息重新加载了！</span></span><br><span class="line">    mListener.onStatsReloaded();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>UserUsageStatsService 内部有一个数组，用于表示每个时间类别对应的时间间隔长度：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span>[] INTERVAL_LENGTH = <span class="keyword">new</span> <span class="keyword">long</span>[] &#123;</span><br><span class="line">        UnixCalendar.DAY_IN_MILLIS, UnixCalendar.WEEK_IN_MILLIS,</span><br><span class="line">        UnixCalendar.MONTH_IN_MILLIS, UnixCalendar.YEAR_IN_MILLIS</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>UnixCalendar 我们在 1.1 有分析过，这里就不在多说了！</p>
<p>举个简单的例子，比如我们指定的时间类别是 daily，那么该 daily 类别下的最新数据要满足要求，当前时间必满足以下条件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">currentTimeMillis &gt;= stats.endTime + <span class="number">500</span></span><br><span class="line"></span><br><span class="line">currentTimeMillis &lt; stats.beginTime + <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>stats.beginTime 表示的是该 IntervalStats 的创建时间，那么其最多能记录的信息是：stats.beginTime + 24 <em> 60 </em> 60 * 1000 之前的信息！</p>
</li>
<li><p>stats.endTime 表示的是该 IntervalStats 的目前已经记录的时间，那么如果该使用信息能够继续被更新，则有 currentTimeMillis - 500 &gt;= stats.endTime！</p>
</li>
</ul>
<p>其他类别的信息是同样的道理，所以 [stats.endTime + 500, stats.beginTime + 24 <em> 60 </em> 60 * 1000) 就是该 IntervalStats 还可以记录的时间范围！</p>
<h3 id="2-3-1-UsageStatsService-onStatsReloaded-回调"><a href="#2-3-1-UsageStatsService-onStatsReloaded-回调" class="headerlink" title="2.3.1 UsageStatsService.onStatsReloaded - 回调"></a>2.3.1 UsageStatsService.onStatsReloaded - 回调</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStatsReloaded</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    postOneTimeCheckIdleStates();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>loadActiveStats 方法根据当前时间，重新加载最新的数据，然后触发 UsageStatsService.onStatsReloaded 回调！</p>
<p>该方法会调用 postOneTimeCheckIdleStates 检查一次 idle 状态！</p>
<h2 id="2-4-UserUsageStatsService-updateRolloverDeadline"><a href="#2-4-UserUsageStatsService-updateRolloverDeadline" class="headerlink" title="2.4 UserUsageStatsService.updateRolloverDeadline"></a>2.4 UserUsageStatsService.updateRolloverDeadline</h2><p>更新回滚时间！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateRolloverDeadline</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】首先设置 mDailyExpiryDate 为 daily 时间类别下的最新日期的使用信息的开始记录时间点</span></span><br><span class="line">    mDailyExpiryDate.setTimeInMillis(</span><br><span class="line">            mCurrentStats[UsageStatsManager.INTERVAL_DAILY].beginTime);</span><br><span class="line">    <span class="comment">//【2】然后再加一天时间！</span></span><br><span class="line">    mDailyExpiryDate.addDays(<span class="number">1</span>);</span><br><span class="line">    Slog.i(TAG, mLogPrefix + <span class="string">"Rollover scheduled @ "</span> +</span><br><span class="line">            sDateFormat.format(mDailyExpiryDate.getTimeInMillis()) + <span class="string">"("</span> +</span><br><span class="line">            mDailyExpiryDate.getTimeInMillis() + <span class="string">")"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>updateRolloverDeadline 方法中，将 mDailyExpiryDate 先设置为了 mCurrentStats[UsageStatsManager.INTERVAL_DAILY].beginTime，然后再加了一天！</p>
<p>所以 updateRolloverDeadline 计算的是下一天使用信息的开始记录时间！mDailyExpiryDate 可以看作是否超过一天的临界时间点！</p>
<h2 id="2-5-IntervalStats-update"><a href="#2-5-IntervalStats-update" class="headerlink" title="2.5 IntervalStats.update"></a>2.5 IntervalStats.update</h2><p>我们看到，在 init 方法中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pkgStats.mLastEvent == UsageEvents.Event.MOVE_TO_FOREGROUND ||</span><br><span class="line">        pkgStats.mLastEvent == UsageEvents.Event.CONTINUE_PREVIOUS_DAY) &#123;</span><br><span class="line">    ... ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>只有满足以上条件，才会进入 IntervalStats.update 方法中！</p>
<p>update 用于跟更新 packageName 对应的 UsageStats 相关属性！</p>
<ul>
<li><strong>long timeStamp 传入的是 IntervalStats.lastTimeSaved，表示 IntervalStats 最后被修改/更新的时间点</strong>；</li>
<li>int eventType 传入的是 UsageEvents.Event.END_OF_DAY，表示本次要设置的 eventType；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(String packageName, <span class="keyword">long</span> timeStamp, <span class="keyword">int</span> eventType)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【2.2.3.1.1】获得该 packageName 对应的 UsageStats 实例！</span></span><br><span class="line">    UsageStats usageStats = getOrCreateUsageStats(packageName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】如果本次的 eventType 为  MOVE_TO_BACKGROUND 或者 END_OF_DAY，进入这个 if 条件！</span></span><br><span class="line">    <span class="keyword">if</span> (eventType == UsageEvents.Event.MOVE_TO_BACKGROUND ||</span><br><span class="line">            eventType == UsageEvents.Event.END_OF_DAY) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【1.1】并且 UsageStats.mLastEvent 的取值为 MOVE_TO_FOREGROUND 或者 CONTINUE_PREVIOUS_DAY</span></span><br><span class="line">        <span class="comment">// 的话，才修改 package 的 mTotalTimeInForeground！</span></span><br><span class="line">        <span class="keyword">if</span> (usageStats.mLastEvent == UsageEvents.Event.MOVE_TO_FOREGROUND ||</span><br><span class="line">                usageStats.mLastEvent == UsageEvents.Event.CONTINUE_PREVIOUS_DAY) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【1.1.1】更新 package 在前台的总时间 mTotalTimeInForeground 为：</span></span><br><span class="line">            <span class="comment">// 在已有基础上再加上 timeStamp  - usageStats.mLastTimeUsed</span></span><br><span class="line">            usageStats.mTotalTimeInForeground += timeStamp - usageStats.mLastTimeUsed;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2.5.1】如果 eventType 属于 Stateful Event</span></span><br><span class="line">    <span class="comment">// 那就更新该 pacakge 的 usageStats.mLastEvent（上一次事件）为 eventType；</span></span><br><span class="line">    <span class="keyword">if</span> (isStatefulEvent(eventType)) &#123;</span><br><span class="line">        usageStats.mLastEvent = eventType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【3】如果 eventType 不是 UsageEvents.Event.SYSTEM_INTERACTION，更新上次使用时间 </span></span><br><span class="line">    <span class="comment">// usageStats.mLastTimeUsed 为 timeStamp！</span></span><br><span class="line">    <span class="comment">// 因为 SYSTEM_INTERACTION 本质上是系统对 package 的操作，不会统计进去！</span></span><br><span class="line">    <span class="keyword">if</span> (eventType != UsageEvents.Event.SYSTEM_INTERACTION) &#123;</span><br><span class="line">        usageStats.mLastTimeUsed = timeStamp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【4】更新该 package 的 usageStats.mEndTimeStamp 为 timeStamp；</span></span><br><span class="line">    usageStats.mEndTimeStamp = timeStamp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【5】如果 eventType 为 MOVE_TO_FOREGROUND，该 package 的 usageStats.mLaunchCount（启动次数）加一；</span></span><br><span class="line">    <span class="keyword">if</span> (eventType == UsageEvents.Event.MOVE_TO_FOREGROUND) &#123;</span><br><span class="line">        usageStats.mLaunchCount += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【6】同时修改 IntervalStats.endTime 也为 timeStamp；</span></span><br><span class="line">    endTime = timeStamp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个过程如下：</p>
<ul>
<li>获得该 package 的 UsageStats 对象！</li>
</ul>
<p><br></p>
<ul>
<li>如果本次要更新的 eventType 为  <strong>MOVE_TO_BACKGROUND</strong> / <strong>END_OF_DAY</strong>，并且该 package 的 LastEvent 为 <strong>MOVE_TO_FOREGROUND</strong> / <strong>CONTINUE_PREVIOUS_DAY</strong><ul>
<li>这种情况是 package 从前台退到了后台，</li>
<li>这是我们会更新 package 的在前台的总时间 mTotalTimeInForeground = mTotalTimeInForeground + timeStamp - mLastTimeUsed；</li>
</ul>
</li>
</ul>
<p><br></p>
<ul>
<li>如果本次要更新的 eventType 为 Stateful Event，我们也会更新 package 的 mLastEvent 为 eventType；</li>
</ul>
<p><br></p>
<ul>
<li>如果本次要更新的 eventType 不是 SYSTEM_INTERACTION，那么我们会更新 package 的 mLastTimeUsed 为 timeStamp；</li>
</ul>
<p><br></p>
<ul>
<li>更新 package 的 mEndTimeStamp 为 timeStamp；同时更新对应的 IntervalStats 的 endTime 也为 timeStamp；</li>
</ul>
<p><br></p>
<ul>
<li>如果本次要更新的 eventType 不是 SYSTEM_INTERACTION，那么我们会更新 package 的 mLastTimeUsed 为 timeStamp；同时更新对应的 IntervalStats 的 endTime 也为 timeStamp；</li>
</ul>
<h3 id="2-5-1-IntervalStats-isStatefulEvent"><a href="#2-5-1-IntervalStats-isStatefulEvent" class="headerlink" title="2.5.1 IntervalStats.isStatefulEvent"></a>2.5.1 IntervalStats.isStatefulEvent</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isStatefulEvent</span><span class="params">(<span class="keyword">int</span> eventType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (eventType) &#123;</span><br><span class="line">        <span class="keyword">case</span> UsageEvents.Event.MOVE_TO_FOREGROUND:</span><br><span class="line">        <span class="keyword">case</span> UsageEvents.Event.MOVE_TO_BACKGROUND:</span><br><span class="line">        <span class="keyword">case</span> UsageEvents.Event.END_OF_DAY:</span><br><span class="line">        <span class="keyword">case</span> UsageEvents.Event.CONTINUE_PREVIOUS_DAY:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断 eventType 是否是 stateful event！</p>
<h2 id="2-6-UserUsageStatsService-notifyStatsChanged"><a href="#2-6-UserUsageStatsService-notifyStatsChanged" class="headerlink" title="2.6 UserUsageStatsService.notifyStatsChanged"></a>2.6 UserUsageStatsService.notifyStatsChanged</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyStatsChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】只有 mStatsChanged 为 false 时，才通知 UsageStatsService！</span></span><br><span class="line">    <span class="keyword">if</span> (!mStatsChanged) &#123;</span><br><span class="line">        <span class="comment">//【1.1】设置 mStatsChanged 为 true；</span></span><br><span class="line">        mStatsChanged = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//【1.2】通知 UsageStatsService，IntervalStats 数据发生了变化！</span></span><br><span class="line">        mListener.onStatsUpdated();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mStatsChanged 表示的是使用信息是否发生变化！</p>
<p>当 IntervalStats 的数据发生变化后，会触发 notifyStatsChanged 方法！</p>
<h3 id="2-6-1-UsageStatsService-onStatsUpdated-回调"><a href="#2-6-1-UsageStatsService-onStatsUpdated-回调" class="headerlink" title="2.6.1 UsageStatsService.onStatsUpdated - 回调"></a>2.6.1 UsageStatsService.onStatsUpdated - 回调</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStatsUpdated</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mHandler.sendEmptyMessageDelayed(MSG_FLUSH_TO_DISK, FLUSH_INTERVAL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>UsageStatsService 的 onStatsUpdated 方法触发后，会延迟 20mins 后发送 MSG_FLUSH_TO_DISK 给 H！</p>
<p>这样也保证了不会频繁的通知和保存！！</p>
<h2 id="2-7-IntervalStats-updateConfigurationStats"><a href="#2-7-IntervalStats-updateConfigurationStats" class="headerlink" title="2.7 IntervalStats.updateConfigurationStats"></a>2.7 IntervalStats.updateConfigurationStats</h2><p>更新指定配置的信息！</p>
<ul>
<li>Configuration confi： 是要成为 active config 的配置对象，这里传入的是 null；</li>
<li>long timeStamp：传入的是 stat.lastTimeSaved（IntervalStats 自身上一次被更新的时间）；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateConfigurationStats</span><span class="params">(Configuration config, <span class="keyword">long</span> timeStamp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】如果 activeConfiguration 不为 null，说明已经有配置信息处于 active 状态！</span></span><br><span class="line">    <span class="comment">// 那就更新其时间信息！</span></span><br><span class="line">    <span class="keyword">if</span> (activeConfiguration != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ConfigurationStats activeStats = configurations.get(activeConfiguration);</span><br><span class="line">        <span class="comment">//【1.1】更新 active config 总的活跃时间 mTotalTimeActive 为：在其基础上加上</span></span><br><span class="line">        <span class="comment">// timeStamp 减去上一次活跃时间（mLastTimeActive）</span></span><br><span class="line">        activeStats.mTotalTimeActive += timeStamp - activeStats.mLastTimeActive;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【1.2】更新上次活跃时间 mLastTimeActive 为上次被更新的时间（timeStamp）减去 1；</span></span><br><span class="line">        activeStats.mLastTimeActive = timeStamp - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】更新 config 指定的配置的信息。因为我们这里传入的是 null，所以不会进入；</span></span><br><span class="line">    <span class="keyword">if</span> (config != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ConfigurationStats configStats = getOrCreateConfigurationStats(config);</span><br><span class="line">        <span class="comment">//【2.1】更新 config 上次活跃时间 mLastTimeActive 为 timeStamp</span></span><br><span class="line">        configStats.mLastTimeActive = timeStamp;</span><br><span class="line">        <span class="comment">//【2.2】更新 config 的活跃次数；</span></span><br><span class="line">        configStats.mActivationCount += <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【2.3】更新 IntervalStats.activeConfiguration 为指定的 config！</span></span><br><span class="line">        activeConfiguration = configStats.mConfiguration;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【3】更新 IntervalStats.endTime 为上一次被更新的时间 ！timeStamp</span></span><br><span class="line">    endTime = timeStamp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为这里我们传入的是 Configuration config 为 null，所以只会尝试更新 activeConfiguration 的时间信息！</p>
<h2 id="2-8-UserUsageStatsService-notifyNewUpdate"><a href="#2-8-UserUsageStatsService-notifyNewUpdate" class="headerlink" title="2.8 UserUsageStatsService.notifyNewUpdate"></a>2.8 UserUsageStatsService.notifyNewUpdate</h2><p>当系统发生了升级后，UserUsageStatsService 会调用 notifyNewUpdate 通知 UsageStatsService!<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyNewUpdate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【*2.8.1】这里的 mListener 就是 UsageStatsService！</span></span><br><span class="line">    mListener.onNewUpdate(mUserId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里就不多说了！</p>
<h3 id="2-8-1-UsageStatsService-onNewUpdate-回调"><a href="#2-8-1-UsageStatsService-onNewUpdate-回调" class="headerlink" title="2.8.1 UsageStatsService.onNewUpdate - 回调"></a>2.8.1 UsageStatsService.onNewUpdate - 回调</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNewUpdate</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    initializeDefaultsForSystemApps(userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果出现了系统升级的情况，那么 UsageStatsService 的 onNewUpdate 方法会调用，然后执行 initializeDefaultsForSystemApps 方法，对系统 App 的信息做初始化！</p>
<h2 id="2-9-流程总结"><a href="#2-9-流程总结" class="headerlink" title="2.9 流程总结"></a>2.9 流程总结</h2><h1 id="3-UserUsageStatsService-onTimeChanged-处理时间变化"><a href="#3-UserUsageStatsService-onTimeChanged-处理时间变化" class="headerlink" title="3 UserUsageStatsService.onTimeChanged - 处理时间变化"></a>3 UserUsageStatsService.onTimeChanged - 处理时间变化</h1><p>处理时间改变的情况！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onTimeChanged</span><span class="params">(<span class="keyword">long</span> oldTime, <span class="keyword">long</span> newTime)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【×3.1】持久化处于内存中的最新数据！</span></span><br><span class="line">    persistActiveStats();</span><br><span class="line">    <span class="comment">//【×3.2】通知数据库时间发生了变化！</span></span><br><span class="line">    mDatabase.onTimeChanged(newTime - oldTime);</span><br><span class="line">    <span class="comment">//【×2.3】再次加载最新日期的数据！</span></span><br><span class="line">    loadActiveStats(newTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个方法的逻辑如下：</p>
<ul>
<li>先将内存中的数据持久化到本地文件中；</li>
<li>然后处理下时间变化；</li>
<li>再次加载本地数据到内存中；</li>
</ul>
<p>对于 loadActiveStats 方法，我们在前面是有分析过的，该过程的主要逻辑如下：</p>
<ul>
<li>先将最新日期的内存数据写回本地持久化文件；</li>
<li>处理时间变化后，持久化文件的名称修改，然后对改名后的文件重新排序，加载到内存中；</li>
<li>重新加载最新日期的使用数据！</li>
</ul>
<h2 id="3-0-调用时机"><a href="#3-0-调用时机" class="headerlink" title="3.0 调用时机"></a>3.0 调用时机</h2><p>在 UsageStatsService 的 checkAndGetTimeLocked 会计算当前的实际时间，判断是否有调时发生！</p>
<p>如果有的话，会触发 UserUsageStatsService.onTimeChanged 方法！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">checkAndGetTimeLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> actualSystemTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> actualRealtime = SystemClock.elapsedRealtime();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> expectedSystemTime = (actualRealtime - mRealTimeSnapshot) + mSystemTimeSnapshot;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> diffSystemTime = actualSystemTime - expectedSystemTime;</span><br><span class="line">    <span class="keyword">if</span> (Math.abs(diffSystemTime) &gt; TIME_CHANGE_THRESHOLD_MILLIS) &#123;</span><br><span class="line">        <span class="comment">// The time has changed.</span></span><br><span class="line">        Slog.i(TAG, <span class="string">"Time changed in UsageStats by "</span> + (diffSystemTime / <span class="number">1000</span>) + <span class="string">" seconds"</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> userCount = mUserState.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; userCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> UserUsageStatsService service = mUserState.valueAt(i);</span><br><span class="line">            <span class="comment">//【×3】会触发 onTimeChanged 方法！</span></span><br><span class="line">            service.onTimeChanged(expectedSystemTime, actualSystemTime);</span><br><span class="line">        &#125;</span><br><span class="line">        mRealTimeSnapshot = actualRealtime;</span><br><span class="line">        mSystemTimeSnapshot = actualSystemTime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> actualSystemTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 checkAndGetTimeLocked 的逻辑，这里不再多说！</p>
<h2 id="3-1-UserUsageStatsService-persistActiveStats"><a href="#3-1-UserUsageStatsService-persistActiveStats" class="headerlink" title="3.1 UserUsageStatsService.persistActiveStats"></a>3.1 UserUsageStatsService.persistActiveStats</h2><p>persistActiveStats 将最新的缓存数据保存到本地文件中！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">persistActiveStats</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】只有当 mStatsChanged 为 true 是才会更新本地文件！</span></span><br><span class="line">    <span class="keyword">if</span> (mStatsChanged) &#123;</span><br><span class="line">        Slog.i(TAG, mLogPrefix + <span class="string">"Flushing usage stats to disk"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//【×3.1.1】更新数据到本地文件！</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mCurrentStats.length; i++) &#123;</span><br><span class="line">                mDatabase.putUsageStats(i, mCurrentStats[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//【2】更新完成后会将 mStatsChanged 置为 false！</span></span><br><span class="line">            mStatsChanged = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            Slog.e(TAG, mLogPrefix + <span class="string">"Failed to persist active stats"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行 persistActiveStats 前，会先做一次判断，如果时间发生了变化，并且内存中的使用信息有更新过，即 mStatsChanged 为 true，才会触发回写本地文件的操作！</p>
<p>mCurrentStats 数组中保存的是当前最新的数据！</p>
<h3 id="3-1-1-UsageStatsDatabase-putUsageStats"><a href="#3-1-1-UsageStatsDatabase-putUsageStats" class="headerlink" title="3.1.1 UsageStatsDatabase.putUsageStats"></a>3.1.1 UsageStatsDatabase.putUsageStats</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putUsageStats</span><span class="params">(<span class="keyword">int</span> intervalType, IntervalStats stats)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (stats == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="comment">//【1】校验 intervalType 的取值范围！</span></span><br><span class="line">        <span class="keyword">if</span> (intervalType &lt; <span class="number">0</span> || intervalType &gt;= mIntervalDirs.length) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Bad interval type "</span> + intervalType);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【2】获得 IntervalStats 对应的本地文件 AtomicFile 对象！</span></span><br><span class="line">        <span class="comment">// 如果没有找到，就创建一个新的 AtomicFile，并添加到 mSortedStatFiles 中！</span></span><br><span class="line">        AtomicFile f = mSortedStatFiles[intervalType].get(stats.beginTime);</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="keyword">null</span>) &#123;</span><br><span class="line">            f = <span class="keyword">new</span> AtomicFile(<span class="keyword">new</span> File(mIntervalDirs[intervalType],</span><br><span class="line">                    Long.toString(stats.beginTime)));</span><br><span class="line">            mSortedStatFiles[intervalType].put(stats.beginTime, f);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【3.1.2】调用 UsageStatsXml 的 write 方法将数据写到本地文件中！</span></span><br><span class="line">        UsageStatsXml.write(f, stats);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【4】更新 stats.lastTimeSaved</span></span><br><span class="line">        stats.lastTimeSaved = f.getLastModifiedTime();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-1-2-UsageStatsXml-write"><a href="#3-1-2-UsageStatsXml-write" class="headerlink" title="3.1.2 UsageStatsXml.write"></a>3.1.2 UsageStatsXml.write</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(AtomicFile file, IntervalStats stats)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    FileOutputStream fos = file.startWrite();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用另外一个 write 方法！</span></span><br><span class="line">        write(fos, stats);</span><br><span class="line">        file.finishWrite(fos);</span><br><span class="line">        fos = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// When fos is null (successful write), this will no-op</span></span><br><span class="line">        file.failWrite(fos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用了另外一个 write 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(OutputStream out, IntervalStats stats)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    FastXmlSerializer xml = <span class="keyword">new</span> FastXmlSerializer();</span><br><span class="line">    xml.setOutput(out, <span class="string">"utf-8"</span>);</span><br><span class="line">    xml.startDocument(<span class="string">"utf-8"</span>, <span class="keyword">true</span>);</span><br><span class="line">    xml.setFeature(<span class="string">"http://xmlpull.org/v1/doc/features.html#indent-output"</span>, <span class="keyword">true</span>);</span><br><span class="line">    xml.startTag(<span class="keyword">null</span>, USAGESTATS_TAG); <span class="comment">// 处理 usagestats 标签</span></span><br><span class="line">    xml.attribute(<span class="keyword">null</span>, VERSION_ATTR, Integer.toString(CURRENT_VERSION)); <span class="comment">// 处理 version 属性，值为 1；</span></span><br><span class="line">    <span class="comment">// 继续调用 UsageStatsXmlV1.write 方法写入！</span></span><br><span class="line">    UsageStatsXmlV1.write(xml, stats);</span><br><span class="line"></span><br><span class="line">    xml.endTag(<span class="keyword">null</span>, USAGESTATS_TAG);</span><br><span class="line">    xml.endDocument();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-1-3-UsageStatsXmlV1-write"><a href="#3-1-3-UsageStatsXmlV1-write" class="headerlink" title="3.1.3 UsageStatsXmlV1.write"></a>3.1.3 UsageStatsXmlV1.write</h3><p>该方法最终写入本地文件！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(XmlSerializer xml, IntervalStats stats)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    XmlUtils.writeLongAttribute(xml, END_TIME_ATTR, stats.endTime - stats.beginTime);</span><br><span class="line"></span><br><span class="line">    xml.startTag(<span class="keyword">null</span>, PACKAGES_TAG); <span class="comment">// 写入 packages 标签</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> statsCount = stats.packageStats.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; statsCount; i++) &#123;</span><br><span class="line">        <span class="comment">//【3.1.3.1】写入 package 的使用信息；</span></span><br><span class="line">        writeUsageStats(xml, stats, stats.packageStats.valueAt(i));</span><br><span class="line">    &#125;</span><br><span class="line">    xml.endTag(<span class="keyword">null</span>, PACKAGES_TAG);</span><br><span class="line"></span><br><span class="line">    xml.startTag(<span class="keyword">null</span>, CONFIGURATIONS_TAG); <span class="comment">// 写入 configurations 标签</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> configCount = stats.configurations.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; configCount; i++) &#123;</span><br><span class="line">        <span class="comment">//【3.1.3.2】写入 Configuration 的使用信息；</span></span><br><span class="line">        <span class="keyword">boolean</span> active = stats.activeConfiguration.equals(stats.configurations.keyAt(i));</span><br><span class="line">        writeConfigStats(xml, stats, stats.configurations.valueAt(i), active);</span><br><span class="line">    &#125;</span><br><span class="line">    xml.endTag(<span class="keyword">null</span>, CONFIGURATIONS_TAG);</span><br><span class="line"></span><br><span class="line">    xml.startTag(<span class="keyword">null</span>, EVENT_LOG_TAG); <span class="comment">// 写入 event-log 标签</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> eventCount = stats.events != <span class="keyword">null</span> ? stats.events.size() : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; eventCount; i++) &#123;</span><br><span class="line">         <span class="comment">//【3.1.3.3】写入 Event 的上报信息；</span></span><br><span class="line">        writeEvent(xml, stats, stats.events.valueAt(i));</span><br><span class="line">    &#125;</span><br><span class="line">    xml.endTag(<span class="keyword">null</span>, EVENT_LOG_TAG);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该过程主要是写入 package，Configuration，Event 的相关信息！</p>
<h4 id="3-1-3-1-UsageStatsXmlV1-writeUsageStats"><a href="#3-1-3-1-UsageStatsXmlV1-writeUsageStats" class="headerlink" title="3.1.3.1 UsageStatsXmlV1.writeUsageStats"></a>3.1.3.1 UsageStatsXmlV1.writeUsageStats</h4><p>IntervalStats stats 是使用信息记录文件的缓存对象；UsageStats usageStats 是该 package 的缓存对象！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeUsageStats</span><span class="params">(XmlSerializer xml, <span class="keyword">final</span> IntervalStats stats,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> UsageStats usageStats)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    xml.startTag(<span class="keyword">null</span>, PACKAGE_TAG); <span class="comment">// 写入 package 标签；</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入 lastTimeActive 属性，取值为 usageStats.mLastTimeUsed - stats.beginTime；</span></span><br><span class="line">    XmlUtils.writeLongAttribute(xml, LAST_TIME_ACTIVE_ATTR,</span><br><span class="line">            usageStats.mLastTimeUsed - stats.beginTime);</span><br><span class="line">    <span class="comment">// 写入 package 属性，取值为 usageStats.mPackageName；</span></span><br><span class="line">    XmlUtils.writeStringAttribute(xml, PACKAGE_ATTR, usageStats.mPackageName);</span><br><span class="line">    <span class="comment">// 写入 timeActive 属性，取值为 usageStats.mTotalTimeInForeground；</span></span><br><span class="line">    XmlUtils.writeLongAttribute(xml, TOTAL_TIME_ACTIVE_ATTR, usageStats.mTotalTimeInForeground);</span><br><span class="line">    <span class="comment">// 写入 lastEvent 属性，取值为 usageStats.mLastEvent；</span></span><br><span class="line">    XmlUtils.writeIntAttribute(xml, LAST_EVENT_ATTR, usageStats.mLastEvent);</span><br><span class="line"></span><br><span class="line">    xml.endTag(<span class="keyword">null</span>, PACKAGE_TAG);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>写入 package 的使用信息：</p>
<ul>
<li>写入 lastTimeActive 属性，取值为 usageStats.mLastTimeUsed - stats.beginTime；</li>
<li>写入 package 属性，取值为 usageStats.mPackageName；</li>
<li>写入 timeActive 属性，取值为 usageStats.mTotalTimeInForeground；</li>
<li>写入 lastEvent 属性，取值为 usageStats.mLastEvent；</li>
</ul>
<h4 id="3-1-3-2-UsageStatsXmlV1-writeConfigStats"><a href="#3-1-3-2-UsageStatsXmlV1-writeConfigStats" class="headerlink" title="3.1.3.2 UsageStatsXmlV1.writeConfigStats"></a>3.1.3.2 UsageStatsXmlV1.writeConfigStats</h4><p>IntervalStats stats 是使用信息记录文件的缓存对象；ConfigurationStats configStats 是该 config 的缓存对象，boolean isActive 表示该 config 是否是处于活跃状态！！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeConfigStats</span><span class="params">(XmlSerializer xml, <span class="keyword">final</span> IntervalStats stats,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> ConfigurationStats configStats, <span class="keyword">boolean</span> isActive)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    xml.startTag(<span class="keyword">null</span>, CONFIG_TAG); <span class="comment">// 写入 configurations 标签</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入 lastTimeActive 属性，取值为 usageStats.mLastTimeUsed - stats.beginTime；</span></span><br><span class="line">    XmlUtils.writeLongAttribute(xml, LAST_TIME_ACTIVE_ATTR,</span><br><span class="line">            configStats.mLastTimeActive - stats.beginTime);</span><br><span class="line">    <span class="comment">// 写入 timeActive 属性，取值为 configStats.mTotalTimeActive；</span></span><br><span class="line">    XmlUtils.writeLongAttribute(xml, TOTAL_TIME_ACTIVE_ATTR, configStats.mTotalTimeActive);</span><br><span class="line">    <span class="comment">// 写入 count 属性，取值为 configStats.mActivationCount；</span></span><br><span class="line">    XmlUtils.writeIntAttribute(xml, COUNT_ATTR, configStats.mActivationCount);</span><br><span class="line">    <span class="comment">// 如果该 config 是当前处于 active 状态，写入 active 属性，true；</span></span><br><span class="line">    <span class="keyword">if</span> (isActive) &#123;</span><br><span class="line">        XmlUtils.writeBooleanAttribute(xml, ACTIVE_ATTR, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接着就是写入 Configuration 的配置信息了！</span></span><br><span class="line">    Configuration.writeXmlAttrs(xml, configStats.mConfiguration);</span><br><span class="line"></span><br><span class="line">    xml.endTag(<span class="keyword">null</span>, CONFIG_TAG);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>写入 Config 的使用信息：</p>
<ul>
<li>写入 lastTimeActive 属性，取值为 usageStats.mLastTimeUsed - stats.beginTime；</li>
<li>写入 timeActive 属性，取值为 configStats.mTotalTimeActive；</li>
<li>写入 count 属性，取值为 configStats.mActivationCount；</li>
<li>如果该 config 是当前处于 active 状态，写入 active 属性，true；</li>
<li>接着就是写入 Configuration 的配置信息了！</li>
</ul>
<h4 id="3-1-3-3-UsageStatsXmlV1-writeEvent"><a href="#3-1-3-3-UsageStatsXmlV1-writeEvent" class="headerlink" title="3.1.3.3 UsageStatsXmlV1.writeEvent"></a>3.1.3.3 UsageStatsXmlV1.writeEvent</h4><p>IntervalStats stats 是使用信息记录文件的缓存对象；UsageEvents.Event event 是该 event 的缓存对象！！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeEvent</span><span class="params">(XmlSerializer xml, <span class="keyword">final</span> IntervalStats stats,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> UsageEvents.Event event)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    xml.startTag(<span class="keyword">null</span>, EVENT_TAG); <span class="comment">// 写入 event 标签</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入 time 属性，取值为 event.mTimeStamp - stats.beginTime；</span></span><br><span class="line">    XmlUtils.writeLongAttribute(xml, TIME_ATTR, event.mTimeStamp - stats.beginTime);</span><br><span class="line">    <span class="comment">// 写入 package 属性和 class 属性，取值为 event.mPackage 和 event.mClass！</span></span><br><span class="line">    XmlUtils.writeStringAttribute(xml, PACKAGE_ATTR, event.mPackage);</span><br><span class="line">    <span class="keyword">if</span> (event.mClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">        XmlUtils.writeStringAttribute(xml, CLASS_ATTR, event.mClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 写入 type 属性，取值为 event.mEventType！</span></span><br><span class="line">    XmlUtils.writeIntAttribute(xml, TYPE_ATTR, event.mEventType);</span><br><span class="line">    <span class="comment">// 根据 EventType，写入额外的信息！</span></span><br><span class="line">    <span class="keyword">switch</span> (event.mEventType) &#123;</span><br><span class="line">        <span class="keyword">case</span> UsageEvents.Event.CONFIGURATION_CHANGE:</span><br><span class="line">            <span class="keyword">if</span> (event.mConfiguration != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Configuration.writeXmlAttrs(xml, event.mConfiguration);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> UsageEvents.Event.SHORTCUT_INVOCATION:</span><br><span class="line">            <span class="keyword">if</span> (event.mShortcutId != <span class="keyword">null</span>) &#123;</span><br><span class="line">                XmlUtils.writeStringAttribute(xml, SHORTCUT_ID_ATTR, event.mShortcutId);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    xml.endTag(<span class="keyword">null</span>, EVENT_TAG);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>写入 Event 的使用信息：</p>
<ul>
<li>写入 time 属性，取值为 event.mTimeStamp - stats.beginTime；</li>
<li>写入 package 属性和 class 属性，取值为 event.mPackage 和 event.mClass！</li>
<li>写入 type 属性，取值为 event.mEventType！</li>
<li>根据 EventType，写入额外的信息！<ul>
<li>Configuration 或者 SHORTCUT！</li>
</ul>
</li>
</ul>
<h2 id="3-2-UsageStatsDatabase-onTimeChanged"><a href="#3-2-UsageStatsDatabase-onTimeChanged" class="headerlink" title="3.2 UsageStatsDatabase.onTimeChanged"></a>3.2 UsageStatsDatabase.onTimeChanged</h2><p>long timeDiffMillis 表示时间调整后的差值，因为时间调整了，所以我们同步修改文件的名称，同时删除那些无效的文件！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTimeChanged</span><span class="params">(<span class="keyword">long</span> timeDiffMillis)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        StringBuilder logBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        logBuilder.append(<span class="string">"Time changed by "</span>);</span><br><span class="line">        TimeUtils.formatDuration(timeDiffMillis, logBuilder);</span><br><span class="line">        logBuilder.append(<span class="string">"."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> filesDeleted = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> filesMoved = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【1】处理 mSortedStatFiles 中所有的 AtomicFile 对象！</span></span><br><span class="line">        <span class="keyword">for</span> (TimeSparseArray&lt;AtomicFile&gt; files : mSortedStatFiles) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> fileCount = files.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fileCount; i++) &#123;</span><br><span class="line">                <span class="comment">//【1.1】通过 valueAt 获得要处理的 AtomicFile 文件，通过 keyAt 可以获得该文件的开始记录时间！</span></span><br><span class="line">                <span class="keyword">final</span> AtomicFile file = files.valueAt(i);</span><br><span class="line">                <span class="comment">//【1.2】计算时间改变后的新时间！</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> newTime = files.keyAt(i) + timeDiffMillis;</span><br><span class="line">                <span class="keyword">if</span> (newTime &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//【1.2.1】如果 newTime 小于 0，那么该文件无效，删除该文件！</span></span><br><span class="line">                    filesDeleted++;</span><br><span class="line">                    file.delete();</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//【1.2.2】这种情况，我们要修改文件的名字，因为文件的名字就是其开始记录时间，</span></span><br><span class="line">                    <span class="comment">// 我们会将文件名改为：newTime + "-c" 的形式！</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        file.openRead().close();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        <span class="comment">// Ignore, this is just to make sure there are no backups.</span></span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    String newName = Long.toString(newTime);</span><br><span class="line">                    <span class="keyword">if</span> (file.getBaseFile().getName().endsWith(CHECKED_IN_SUFFIX)) &#123;</span><br><span class="line">                        newName = newName + CHECKED_IN_SUFFIX;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">final</span> File newFile = <span class="keyword">new</span> File(file.getBaseFile().getParentFile(), newName);</span><br><span class="line">                    filesMoved++;</span><br><span class="line">                    file.getBaseFile().renameTo(newFile);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            files.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        logBuilder.append(<span class="string">" files deleted: "</span>).append(filesDeleted);</span><br><span class="line">        logBuilder.append(<span class="string">" files moved: "</span>).append(filesMoved);</span><br><span class="line">        Slog.i(TAG, logBuilder.toString());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【×2.1.2】然后再次调用 indexFilesLocked，对改名后的文件进行重新排序，再次添加到 mSortedStatFiles 中！</span></span><br><span class="line">        indexFilesLocked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>indexFilesLocked 方法我们有讲过，这里就不多说了！</p>
<h2 id="3-3-流程总结"><a href="#3-3-流程总结" class="headerlink" title="3.3 流程总结"></a>3.3 流程总结</h2><h1 id="4-UserUsageStatsService-rolloverStats-数据回滚"><a href="#4-UserUsageStatsService-rolloverStats-数据回滚" class="headerlink" title="4 UserUsageStatsService.rolloverStats - 数据回滚"></a>4 UserUsageStatsService.rolloverStats - 数据回滚</h1><p>当我们在 report event 的时候，会判断此时记录的时间点是否已经超过了 mDailyExpiryDate 指定的日期，mDailyExpiryDate 前面我们有说过，其作为是否超过一天的临界点！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (event.mTimeStamp &gt;= mDailyExpiryDate.getTimeInMillis()) &#123;</span><br><span class="line">    <span class="comment">// Need to rollover</span></span><br><span class="line">    rolloverStats(event.mTimeStamp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果超过了 1 天，那么我们要关闭当前最新的使用信息文件，这次的记录时间会做为今天的最后一个记录时间，然后下次 report event 时，会创建一个新的文件记录下一天的使用信息！</p>
<p>当我们发现本次记录的时间超过了 mDailyExpiryDate，那么我们要关闭当前最新日期的使用信息文件了，rolloverStats 就发生在此时 ！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rolloverStats</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> currentTimeMillis)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> startTime = SystemClock.elapsedRealtime();</span><br><span class="line">    Slog.i(TAG, mLogPrefix + <span class="string">"Rolling over usage stats"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【1】获得 dailay 时间类别使用信息中处于 active 状态的 config！ </span></span><br><span class="line">    <span class="keyword">final</span> Configuration previousConfig =</span><br><span class="line">            mCurrentStats[UsageStatsManager.INTERVAL_DAILY].activeConfiguration;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【2】continuePreviousDay 用于记录那些需要将设置为 CONTINUE_PREVIOUS_DAY 的 package</span></span><br><span class="line">    ArraySet&lt;String&gt; continuePreviousDay = <span class="keyword">new</span> ArraySet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【3】遍历当前每个时间类别下最新日期的使用信息！</span></span><br><span class="line">    <span class="keyword">for</span> (IntervalStats stat : mCurrentStats) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> pkgCount = stat.packageStats.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pkgCount; i++) &#123;</span><br><span class="line">            UsageStats pkgStats = stat.packageStats.valueAt(i);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【3.1】如果 package 的 mLastEvent 是 MOVE_TO_FOREGROUND 或者 CONTINUE_PREVIOUS_DAY！</span></span><br><span class="line">            <span class="comment">// 将其 event 改为 END_OF_DAY 表示一天的记录结束了！</span></span><br><span class="line">            <span class="keyword">if</span> (pkgStats.mLastEvent == UsageEvents.Event.MOVE_TO_FOREGROUND ||</span><br><span class="line">                    pkgStats.mLastEvent == UsageEvents.Event.CONTINUE_PREVIOUS_DAY) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//【3.1.1】那么将该 package 添加到 continuePreviousDay 中！</span></span><br><span class="line">                continuePreviousDay.add(pkgStats.mPackageName);</span><br><span class="line">                <span class="comment">//【×4.1】同时更新 pacakge 对应的 UsageStats 的信息！</span></span><br><span class="line">                stat.update(pkgStats.mPackageName, mDailyExpiryDate.getTimeInMillis() - <span class="number">1</span>,</span><br><span class="line">                        UsageEvents.Event.END_OF_DAY);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//【×2.6】延迟 20mins 通知 UsageStatsService 刷新本地数据，</span></span><br><span class="line">                <span class="comment">// mStatsChanged 会被设置为 true，只通知一次！</span></span><br><span class="line">                notifyStatsChanged();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【×4.2】更新 Configuration 的状态信息！</span></span><br><span class="line">        stat.updateConfigurationStats(<span class="keyword">null</span>, mDailyExpiryDate.getTimeInMillis() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【×3.1】将内存中的最新数据写回持久化文件！</span></span><br><span class="line">    <span class="comment">//【×2.6】会将 mStatsChanged 设置为 false；</span></span><br><span class="line">    persistActiveStats();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【×4.2】移除那些日期太旧的本地文件，然后重新加载文件到内存中！</span></span><br><span class="line">    mDatabase.prune(currentTimeMillis);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【×2.3】加载最新使用信息到内存中！</span></span><br><span class="line">    <span class="comment">// 对于 daily 时间类别，会创建一个新的 IntervalStats 对象！</span></span><br><span class="line">    <span class="comment">// 对于其他类别，可能会创建一个新的 IntervalStats 对象！</span></span><br><span class="line">    <span class="comment">// 这里也会将 mStatsChanged 设置为 false；</span></span><br><span class="line">    loadActiveStats(currentTimeMillis);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【4】处理之前收集到的 package，将其设置为 CONTINUE_PREVIOUS_DAY！</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> continueCount = continuePreviousDay.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; continueCount; i++) &#123;</span><br><span class="line">        String name = continuePreviousDay.valueAt(i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【4.1】这里的 beginTime 是 daily 时间类别的新创建的 IntervalStats 的 beginTime 时间；</span></span><br><span class="line">        <span class="comment">// 同时也是其他类别的更新时间点！</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> beginTime = mCurrentStats[UsageStatsManager.INTERVAL_DAILY].beginTime;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【4.2】遍历每个时间类别下的最新使用数据 IntervalStats！</span></span><br><span class="line">        <span class="comment">// 对于 daily 时间类别的数据，这里是将该 package 的使用信息更新到新创建的 IntervalStats！</span></span><br><span class="line">        <span class="comment">// 对于其他类别的数据，可能是更新到了新创建的 IntervalStats 中，也可能是修改已有的最新 IntervalStats！</span></span><br><span class="line">        <span class="keyword">for</span> (IntervalStats stat : mCurrentStats) &#123;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">//【4.2.1】这里再次调用了 update/updateConfigurationStats 方法更新 IntervalStats！</span></span><br><span class="line">            <span class="comment">// 设置其 event 为 CONTINUE_PREVIOUS_DAY，表示继续前一天的记录！</span></span><br><span class="line">            stat.update(name, beginTime, UsageEvents.Event.CONTINUE_PREVIOUS_DAY);</span><br><span class="line">            stat.updateConfigurationStats(previousConfig, beginTime);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//【×2.6】延迟 20mins 通知 UsageStatsService 刷新本地数据，</span></span><br><span class="line">            <span class="comment">// mStatsChanged 会被设置为 true，只通知一次！</span></span><br><span class="line">            notifyStatsChanged();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【×3.1】将内存中的最新数据写回持久化文件！</span></span><br><span class="line">    persistActiveStats();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> totalTime = SystemClock.elapsedRealtime() - startTime;</span><br><span class="line">    Slog.i(TAG, mLogPrefix + <span class="string">"Rolling over usage stats complete. Took "</span> + totalTime</span><br><span class="line">            + <span class="string">" milliseconds"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来分析下整个方法的逻辑：</p>
<p>我们来分析下一些细节处理：</p>
<p>这里要注意下 loadActiveStats：</p>
<ul>
<li>加载最新使用信息到内存中，在加载最新数据时，会判断当前的时间是否在最新文件可以记录的范围内，如果在的话，就直接加载最新文件的数据，如果不在的话，那就会创建一个新的 IntervalStats，记录下一个时间段的使用信息；</li>
</ul>
<p><br></p>
<ul>
<li>因为我们当前的时间已经超过了 mDailyExpiryDate，而 mDailyExpiryDate 是以一天为临界点的，所以对于 daily 类别的最新文件来说，已经超过了其能够记录的范围，那么会创建一个新的 IntervalStats 对象！</li>
</ul>
<p><br></p>
<ul>
<li>而对于 weekly，monthly，yearly 不一定超过了其最新文件能够记录的时间返回，所以可能返回的依然是当前最新文件的 IntervalStats 对象！</li>
</ul>
<p><br></p>
<ul>
<li>loadActiveStats 方法在加载完成数据后，会调用 updateRolloverDeadline 再次将 mDailyExpiryDate 设置到下一天！</li>
</ul>
<h2 id="4-1-IntervalStats-update"><a href="#4-1-IntervalStats-update" class="headerlink" title="4.1 IntervalStats.update"></a>4.1 IntervalStats.update</h2><p>这里再次调用了 IntervalStats.update 方法，更新 package 的信息！</p>
<p>同样的，必须满足一下条件才能进入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pkgStats.mLastEvent == UsageEvents.Event.MOVE_TO_FOREGROUND ||</span><br><span class="line">        pkgStats.mLastEvent == UsageEvents.Event.CONTINUE_PREVIOUS_DAY) &#123;</span><br><span class="line">    ... ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和 init 中传入的 timeStamp 不同，这里传入的是：</p>
<ul>
<li><strong>long timeStamp</strong>：  本次更新时间 mDailyExpiryDate.getTimeInMillis() - 1；            </li>
<li><strong>int eventType</strong>：   本次更新的事件 UsageEvents.Event.END_OF_DAY</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(String packageName, <span class="keyword">long</span> timeStamp, <span class="keyword">int</span> eventType)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【2.2.3.1.1】获得该 packageName 对应的 UsageStats 实例！</span></span><br><span class="line">    UsageStats usageStats = getOrCreateUsageStats(packageName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】如果 eventType 为  MOVE_TO_BACKGROUND 或者 END_OF_DAY，进入这个 if 条件！</span></span><br><span class="line">    <span class="keyword">if</span> (eventType == UsageEvents.Event.MOVE_TO_BACKGROUND ||</span><br><span class="line">            eventType == UsageEvents.Event.END_OF_DAY) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【1.1】这时判断如果 UsageStats.mLastEvent 的取值为 MOVE_TO_FOREGROUND 或者 CONTINUE_PREVIOUS_DAY</span></span><br><span class="line">        <span class="keyword">if</span> (usageStats.mLastEvent == UsageEvents.Event.MOVE_TO_FOREGROUND ||</span><br><span class="line">                usageStats.mLastEvent == UsageEvents.Event.CONTINUE_PREVIOUS_DAY) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【1.2】更新 package 在前台的总时间 mTotalTimeInForeground 为：</span></span><br><span class="line">            <span class="comment">// 在已有基础上再加上 timeStamp - usageStats.mLastTimeUsed</span></span><br><span class="line">            usageStats.mTotalTimeInForeground += timeStamp - usageStats.mLastTimeUsed;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2.5.1】如果 eventType 属于 Stateful Event</span></span><br><span class="line">    <span class="comment">// 那就更新该 pacakge 的 usageStats.mLastEvent（上一次事件）为 eventType；</span></span><br><span class="line">    <span class="keyword">if</span> (isStatefulEvent(eventType)) &#123;</span><br><span class="line">        usageStats.mLastEvent = eventType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【3】如果 eventType 不是 UsageEvents.Event.SYSTEM_INTERACTION，更新 usageStats.mLastTimeUsed</span></span><br><span class="line">    <span class="comment">// 上次使用时间为 timeStamp！</span></span><br><span class="line">    <span class="keyword">if</span> (eventType != UsageEvents.Event.SYSTEM_INTERACTION) &#123;</span><br><span class="line">        usageStats.mLastTimeUsed = timeStamp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【4】更新该 package 的 usageStats.mEndTimeStamp 为 timeStamp </span></span><br><span class="line">    usageStats.mEndTimeStamp = timeStamp;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【5】如果 eventType 为 MOVE_TO_FOREGROUND，该 package 的 usageStats.mLaunchCount（启动次数）加一；</span></span><br><span class="line">    <span class="keyword">if</span> (eventType == UsageEvents.Event.MOVE_TO_FOREGROUND) &#123;</span><br><span class="line">        usageStats.mLaunchCount += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【6】同时修改 IntervalStats.endTime 也为 timeStamp</span></span><br><span class="line">    endTime = timeStamp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数流程就不在分析了，我们直接看结论：</p>
<ul>
<li>usageStats.mTotalTimeInForeground += (mDailyExpiryDate.getTimeInMillis() - 1) - usageStats.mLastTimeUsed</li>
<li>usageStats.mLastEvent = UsageEvents.Event.END_OF_DAY</li>
<li>usageStats.mLastTimeUsed = (mDailyExpiryDate.getTimeInMillis() - 1)</li>
<li><p>usageStats.mEndTimeStamp = (mDailyExpiryDate.getTimeInMillis() - 1)</p>
</li>
<li><p>IntervalStats.endTime = (mDailyExpiryDate.getTimeInMillis() - 1)</p>
</li>
</ul>
<h2 id="4-2-IntervalStats-updateConfigurationStats"><a href="#4-2-IntervalStats-updateConfigurationStats" class="headerlink" title="4.2 IntervalStats.updateConfigurationStats"></a>4.2 IntervalStats.updateConfigurationStats</h2><p>再次调用 updateConfigurationStats 更新指定配置的信息！</p>
<ul>
<li><strong>Configuration config</strong>： 是要成为 active config 的配置对象，这里传入的是 null；</li>
<li><strong>long timeStamp</strong>：传入的是 mDailyExpiryDate.getTimeInMillis() - 1；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateConfigurationStats</span><span class="params">(Configuration config, <span class="keyword">long</span> timeStamp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】如果 activeConfiguration 不为 null，说明已经有配置信息处于 active 状态！</span></span><br><span class="line">    <span class="comment">// 那就更新其时间信息！</span></span><br><span class="line">    <span class="keyword">if</span> (activeConfiguration != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ConfigurationStats activeStats = configurations.get(activeConfiguration);</span><br><span class="line">        <span class="comment">//【1.1】更新 active config 总的活跃时间 mTotalTimeActive 为：在其基础上加上</span></span><br><span class="line">        <span class="comment">// timeStamp 减去上一次活跃时间 mLastTimeActive！</span></span><br><span class="line">        activeStats.mTotalTimeActive += timeStamp - activeStats.mLastTimeActive;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【1.2】更新上次活跃时间 mLastTimeActive 为 timeStamp 减去 1；</span></span><br><span class="line">        activeStats.mLastTimeActive = timeStamp - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】更新 config 指定的配置的信息。因为我们这里传入的是 null，所以不会进入；</span></span><br><span class="line">    <span class="keyword">if</span> (config != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ConfigurationStats configStats = getOrCreateConfigurationStats(config);</span><br><span class="line">        <span class="comment">//【2.1】更新 config 最新活跃时间 mLastTimeActive 为 timeStamp</span></span><br><span class="line">        configStats.mLastTimeActive = timeStamp;</span><br><span class="line">        <span class="comment">//【2.2】更新 config 的活跃次数；</span></span><br><span class="line">        configStats.mActivationCount += <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【2.3】更新 IntervalStats.activeConfiguration 为指定的 config！</span></span><br><span class="line">        activeConfiguration = configStats.mConfiguration;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【3】更新 IntervalStats.endTime 为上一次被更新的时间 ！timeStamp</span></span><br><span class="line">    endTime = timeStamp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为这里我们传入的是 Configuration config 为 null，所以只会尝试更新 activeConfiguration 的时间信息！</p>
<h2 id="4-3-UsageStatsDatabase-prune"><a href="#4-3-UsageStatsDatabase-prune" class="headerlink" title="4.3 UsageStatsDatabase.prune"></a>4.3 UsageStatsDatabase.prune</h2><p>prune 方法会移除那些日期太旧的本地文件！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prune</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> currentTimeMillis)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="comment">//【1】删除 3 年以前的使用信息文件！</span></span><br><span class="line">        mCal.setTimeInMillis(currentTimeMillis);</span><br><span class="line">        mCal.addYears(-<span class="number">3</span>);</span><br><span class="line">        pruneFilesOlderThan(mIntervalDirs[UsageStatsManager.INTERVAL_YEARLY],</span><br><span class="line">                mCal.getTimeInMillis());</span><br><span class="line">        <span class="comment">//【2】删除 6 个月以前的使用信息文件！</span></span><br><span class="line">        mCal.setTimeInMillis(currentTimeMillis);</span><br><span class="line">        mCal.addMonths(-<span class="number">6</span>);</span><br><span class="line">        pruneFilesOlderThan(mIntervalDirs[UsageStatsManager.INTERVAL_MONTHLY],</span><br><span class="line">                mCal.getTimeInMillis());</span><br><span class="line">        <span class="comment">//【3】删除 4 周以前的使用信息文件！</span></span><br><span class="line">        mCal.setTimeInMillis(currentTimeMillis);</span><br><span class="line">        mCal.addWeeks(-<span class="number">4</span>);</span><br><span class="line">        pruneFilesOlderThan(mIntervalDirs[UsageStatsManager.INTERVAL_WEEKLY],</span><br><span class="line">                mCal.getTimeInMillis());</span><br><span class="line">        <span class="comment">//【4】删除 7 天以前的使用信息文件！</span></span><br><span class="line">        mCal.setTimeInMillis(currentTimeMillis);</span><br><span class="line">        mCal.addDays(-<span class="number">7</span>);</span><br><span class="line">        pruneFilesOlderThan(mIntervalDirs[UsageStatsManager.INTERVAL_DAILY],</span><br><span class="line">                mCal.getTimeInMillis());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【2.1.2】然后重新加载文件到内存中！</span></span><br><span class="line">        indexFilesLocked();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>删除 3 年以前的使用信息文件！ </li>
<li>删除 6 个月以前的使用信息文件！ </li>
<li>删除 4 周以前的使用信息文件！ </li>
<li>删除 7 天以前的使用信息文件！</li>
<li>最后要重新加载最新文件到内存中，防止读取到已经被删除的文件！</li>
</ul>
<h3 id="4-3-1-UsageStatsDatabase-pruneFilesOlderThan"><a href="#4-3-1-UsageStatsDatabase-pruneFilesOlderThan" class="headerlink" title="4.3.1 UsageStatsDatabase.pruneFilesOlderThan"></a>4.3.1 UsageStatsDatabase.pruneFilesOlderThan</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pruneFilesOlderThan</span><span class="params">(File dir, <span class="keyword">long</span> expiryTime)</span> </span>&#123;</span><br><span class="line">    File[] files = dir.listFiles();</span><br><span class="line">    <span class="keyword">if</span> (files != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">            String path = f.getPath();</span><br><span class="line">            <span class="comment">//【1】如果文件名中有 .bak 那么属于备份文件，去掉 .bak 得到非备份文件！</span></span><br><span class="line">            <span class="keyword">if</span> (path.endsWith(BAK_SUFFIX)) &#123;</span><br><span class="line">                f = <span class="keyword">new</span> File(path.substring(<span class="number">0</span>, path.length() - BAK_SUFFIX.length()));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> beginTime;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//【2.1.2.1】调用 UsageStatsXml.parseBeginTime 获得文件的</span></span><br><span class="line">                beginTime = UsageStatsXml.parseBeginTime(f);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                beginTime = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//【2】当文件的开始记录时间早于 expiryTime，该文件过期了，删除！</span></span><br><span class="line">            <span class="keyword">if</span> (beginTime &lt; expiryTime) &#123;</span><br><span class="line">                <span class="keyword">new</span> AtomicFile(f).delete();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法流程简单，不多说了！</p>
<h2 id="4-4-流程总结"><a href="#4-4-流程总结" class="headerlink" title="4.4 流程总结"></a>4.4 流程总结</h2><h1 id="5-UserUsageStatsService-reportEvent-上报事件"><a href="#5-UserUsageStatsService-reportEvent-上报事件" class="headerlink" title="5 UserUsageStatsService.reportEvent - 上报事件"></a>5 UserUsageStatsService.reportEvent - 上报事件</h1><p>这里我们来看看上报时间的处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reportEvent</span><span class="params">(UsageEvents.Event event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">        Slog.d(TAG, mLogPrefix + <span class="string">"Got usage event for "</span> + event.mPackage</span><br><span class="line">                + <span class="string">"["</span> + event.mTimeStamp + <span class="string">"]: "</span></span><br><span class="line">                + eventToString(event.mEventType));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】当前记录超过了 mDailyExpiryDate，那么我们要判断下当前的时间点是否超过了每个时间类别下最新文件能够记录的</span></span><br><span class="line">    <span class="comment">// 时间范围，如果超过了，要创建新的 IntervalStats，用下一个阶段的记录！</span></span><br><span class="line">    <span class="keyword">if</span> (event.mTimeStamp &gt;= mDailyExpiryDate.getTimeInMillis()) &#123;</span><br><span class="line">        <span class="comment">//【×4】对于数据的处理，在 rolloverStats 中！</span></span><br><span class="line">        rolloverStats(event.mTimeStamp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】获得 daily 类别下的最新 IntervalStats，我们要将本次的数据写入到最新的 IntervalStats！！</span></span><br><span class="line">    <span class="keyword">final</span> IntervalStats currentDailyStats = mCurrentStats[UsageStatsManager.INTERVAL_DAILY];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【3】如果本次的 event 的类型为 CONFIGURATION_CHANGE，并且 currentDailyStats.activeConfiguration 不为 null</span></span><br><span class="line">    <span class="comment">// 那么调整该 event.mConfiguration！</span></span><br><span class="line">    <span class="keyword">final</span> Configuration newFullConfig = event.mConfiguration;</span><br><span class="line">    <span class="keyword">if</span> (event.mEventType == UsageEvents.Event.CONFIGURATION_CHANGE &amp;&amp;</span><br><span class="line">            currentDailyStats.activeConfiguration != <span class="keyword">null</span>) &#123;</span><br><span class="line">        event.mConfiguration = Configuration.generateDelta(</span><br><span class="line">                currentDailyStats.activeConfiguration, newFullConfig);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【4】将本次 event 添加到 daily 的最新 IntervalStats 中！</span></span><br><span class="line">    <span class="comment">// 如果 eventType 是 SYSTEM_INTERACTION，则不添加！</span></span><br><span class="line">    <span class="keyword">if</span> (currentDailyStats.events == <span class="keyword">null</span>) &#123;</span><br><span class="line">        currentDailyStats.events = <span class="keyword">new</span> TimeSparseArray&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (event.mEventType != UsageEvents.Event.SYSTEM_INTERACTION) &#123;</span><br><span class="line">        currentDailyStats.events.put(event.mTimeStamp, event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【5】遍历所有时间类别下的最新使用信息 IntervalStats！</span></span><br><span class="line">    <span class="comment">// 如果 event 类型为 CONFIGURATION_CHANGE，那就只更新 config</span></span><br><span class="line">    <span class="comment">// 如果是其他类型，只更新 UsageStats！</span></span><br><span class="line">    <span class="keyword">for</span> (IntervalStats stats : mCurrentStats) &#123;</span><br><span class="line">        <span class="keyword">if</span> (event.mEventType == UsageEvents.Event.CONFIGURATION_CHANGE) &#123;</span><br><span class="line">            stats.updateConfigurationStats(newFullConfig, event.mTimeStamp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stats.update(event.mPackage, event.mTimeStamp, event.mEventType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【×2.6】通知 UsageStatsService，使用信息发生了变化！</span></span><br><span class="line">    notifyStatsChanged();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实可以看到：event 相关的 log 只会记录到 daily 类别的文件中！</p>
<p>notifyStatsChanged 会将 mStatsChanged 置为 true，然后触发 mListener.onStatsUpdated 方法，UsageStatsService.onStatsUpdated 会回调 persistActiveStats 方法，将最新的使用信息保存到本地文件中，最后设置 mStatsChanged 为 false；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyStatsChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mStatsChanged) &#123;</span><br><span class="line">        mStatsChanged = <span class="keyword">true</span>;</span><br><span class="line">        mListener.onStatsUpdated();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个过程很简单，不多说了！</p>
<h1 id="6-UserUsageStatsService-query-查询"><a href="#6-UserUsageStatsService-query-查询" class="headerlink" title="6 UserUsageStatsService.query - 查询"></a>6 UserUsageStatsService.query - 查询</h1><p>UserUsageStatsService 提供了三个查询接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UserUsageStatsService.queryEvents</span><br><span class="line">UserUsageStatsService.queryUsageStats</span><br><span class="line">UserUsageStatsService.queryStats</span><br></pre></td></tr></table></figure>
<p>下面我们来分析下具体的查询过程！</p>
<h2 id="6-1-UserUsageStatsService-queryEvents"><a href="#6-1-UserUsageStatsService-queryEvents" class="headerlink" title="6.1 UserUsageStatsService.queryEvents"></a>6.1 UserUsageStatsService.queryEvents</h2><h2 id="6-2-UserUsageStatsService-queryUsageStats"><a href="#6-2-UserUsageStatsService-queryUsageStats" class="headerlink" title="6.2 UserUsageStatsService.queryUsageStats"></a>6.2 UserUsageStatsService.queryUsageStats</h2><h2 id="6-3-UserUsageStatsService-queryStats"><a href="#6-3-UserUsageStatsService-queryStats" class="headerlink" title="6.3 UserUsageStatsService.queryStats"></a>6.3 UserUsageStatsService.queryStats</h2></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Coolqi.Li</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://coolqi.top/2017/05/03/UsageStats 第 3 篇 - UserUsageStatsService 逻辑分析/">https://coolqi.top/2017/05/03/UsageStats 第 3 篇 - UserUsageStatsService 逻辑分析/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://coolqi.top">Coolqi`s Blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/UsageStats使用状态管理/">UsageStats使用状态管理</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="/img/zfb.jpg"><div class="post-qr-code__desc">支付宝打赏</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="/img/wechat.jpg"><div class="post-qr-code__desc">微信打赏</div></div></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2017/05/09/Permission第 1 篇 - Permission 配置和解析/"><i class="fa fa-chevron-left">  </i><span>Permission第 1 篇 - Permission 配置和解析</span></a></div><div class="next-post pull-right"><a href="/2017/04/03/UsageStats 第 2 篇 - UsageStatsService 消息处理/"><span>UsageStats 第 2 篇 - UsageStatsService 消息处理</span><i class="fa fa-chevron-right"></i></a></div></nav><div class="post-adv"><a href="https://www.vultr.com/?ref=7231808"><img src="https://www.vultr.com/media/banner_1.png" width="728" height="90"></a></div><div id="vcomment"></div><script src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = 'false' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = ''.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'eedJikU7JeDetXjbjw27DWBz-gzGzoHsz',
  appKey:'woFTBOpMKS9EASNUpbaA9Jvc',
  placeholder:'Just go go',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10',
  lang: 'zh-cn'
})</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2015 - 2019 By Coolqi.Li</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://coolqi.top/">blog</a>!</div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.6"></script><script src="/js/fancybox.js?version=1.5.6"></script><script src="/js/sidebar.js?version=1.5.6"></script><script src="/js/copy.js?version=1.5.6"></script><script src="/js/fireworks.js?version=1.5.6"></script><script src="/js/transition.js?version=1.5.6"></script><script src="/js/scroll.js?version=1.5.6"></script><script src="/js/head.js?version=1.5.6"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="/js/search/local-search.js"></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"right","width":110,"height":220},"mobile":{"show":false},"log":false});</script></body></html>