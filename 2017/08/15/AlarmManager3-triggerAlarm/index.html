<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="AlarmManager第 3 篇 - trigger Alarm 流程分析"><meta name="keywords" content="AlarmManager闹钟管理"><meta name="author" content="Coolqi.Li,undefined"><meta name="copyright" content="Coolqi.Li"><title>AlarmManager第 3 篇 - trigger Alarm 流程分析 | Coolqi`s Blog</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.5.6"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css?version=1.5.6"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?b7acef5306e54116ad8a99e8b753a92d";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#0-回顾"><span class="toc-text">0 回顾</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-AlarmThread-run"><span class="toc-text">1 AlarmThread.run</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-AlarmMS-waitForAlarm"><span class="toc-text">1.1 AlarmMS.waitForAlarm</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-AlarmMS-triggerAlarmsLocked"><span class="toc-text">1.2 AlarmMS.triggerAlarmsLocked</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1-AlarmMS-calculateDeliveryPriorities"><span class="toc-text">1.2.1 AlarmMS.calculateDeliveryPriorities</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-2-Collections-sort-triggerList-mAlarmDispatchComparator"><span class="toc-text">1.2.2 Collections.sort(triggerList, mAlarmDispatchComparator)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-AlarmMS-checkAllowNonWakeupDelayLocked"><span class="toc-text">1.3 AlarmMS.checkAllowNonWakeupDelayLocked</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-1-AlarmMS-currentNonWakeupFuzzLocked"><span class="toc-text">1.3.1 AlarmMS.currentNonWakeupFuzzLocked</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-AlarmMS-deliverAlarmsLocked"><span class="toc-text">1.4 AlarmMS.deliverAlarmsLocked</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-DeliveryTracker-deliverLocked"><span class="toc-text">1.5 DeliveryTracker.deliverLocked</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-1-new-InFlight"><span class="toc-text">1.5.1 new InFlight</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-5-1-1-AlarmMS-getStatsLocked"><span class="toc-text">1.5.1.1 AlarmMS.getStatsLocked</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-分发的流程"><span class="toc-text">2 分发的流程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-Alarm-PendingIntent-send"><span class="toc-text">2.1 Alarm.PendingIntent.send</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-new-FinishedDispatcher"><span class="toc-text">2.1.1 new FinishedDispatcher</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-ActivityMS-sendIntentSender"><span class="toc-text">2.1.2 ActivityMS.sendIntentSender</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-3-PendingIntentRecord-sendWithResult"><span class="toc-text">2.1.3 PendingIntentRecord.sendWithResult</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-4-PendingIntentRecord-sendInner"><span class="toc-text">2.1.4 PendingIntentRecord.sendInner</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-Alarm-Listener-doAlarm"><span class="toc-text">2.2 Alarm.Listener.doAlarm</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-特殊的触发路径"><span class="toc-text">3 特殊的触发路径</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-AlarmHandler-handleMessage-ALARM-EVENT"><span class="toc-text">3.1 AlarmHandler.handleMessage[ALARM_EVENT]</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.jpg"></div><div class="author-info__name text-center">Coolqi.Li</div><div class="author-info__description text-center">“Hi，我是李帅奇，Android 开发工程师，TeamLeader，熬夜星人，一个努力赚钱，积极向上的好人。”</div><div class="follow-button"><a href="https://github.com/single-li">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">86</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">21</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">26</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="https://developer.android.google.cn/">AndroidDeveloper</a><a class="author-info-links__name text-center" href="http://www.android-studio.org/">AndroidStudio</a><a class="author-info-links__name text-center" href="https://www.jianshu.com/u/123a20a96441">简书</a><a class="author-info-links__name text-center" href="https://weibo.com/coolqiLi">微博</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://ws1.sinaimg.cn/large/8700af19ly1fvpabr30o6j22yo1o0q7i.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Coolqi`s Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/about">About</a></span></div><div id="post-info"><div id="post-title">AlarmManager第 3 篇 - trigger Alarm 流程分析</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-08-15</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/AndroidFramework源码分析/">AndroidFramework源码分析</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/AndroidFramework源码分析/AlarmManager闹钟管理/">AlarmManager闹钟管理</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">6.7k</span><span class="post-meta__separator">|</span><span>阅读时长: 31 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>[toc]</p>
<p>基于 Android7.1.1 源码，分析 AlarmManagerService 的架构和逻辑，本篇文章来分析下 trigger Alarm 的流程！</p>
<h1 id="0-回顾"><a href="#0-回顾" class="headerlink" title="0 回顾"></a>0 回顾</h1><p>在上一篇 set Alarm 文章中，我们知道, set 方法会调用 AlarmMS.rescheduleKernelAlarmsLocked 方法来设置下一个 alarm！</p>
<p>该方法用于设置下一个 Alarm！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rescheduleKernelAlarmsLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> nextNonWakeup = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 设置最早的 ELAPSED_REALTIME_WAKEUP 类型的 alarm！</span></span><br><span class="line">    <span class="keyword">if</span> (mAlarmBatches.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【3.4.4.1】从 mAlarmBatches 中找到第一个包含 wake up 类型 alarm 的 Batch！</span></span><br><span class="line">        <span class="keyword">final</span> Batch firstWakeup = findFirstWakeupBatchLocked();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【2】从 mAlarmBatches 中找到第一个的 Batch！</span></span><br><span class="line">        <span class="keyword">final</span> Batch firstBatch = mAlarmBatches.get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【3】如果 firstWakeup 不为 null，且 firstWakeup 中的开始触发时间 start，不等于 mNextWakeup！</span></span><br><span class="line">        <span class="comment">// 那就要更新 mNextWakeup，调整下一个 wake up alarm 的触发时间！</span></span><br><span class="line">        <span class="keyword">if</span> (firstWakeup != <span class="keyword">null</span> &amp;&amp; mNextWakeup != firstWakeup.start) &#123;</span><br><span class="line">            <span class="comment">// 更新 mNextWakeup 和 mLastWakeupSet！</span></span><br><span class="line">            mNextWakeup = firstWakeup.start;</span><br><span class="line">            mLastWakeupSet = SystemClock.elapsedRealtime();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//【3.4.4.2】设置下一个要触发的 wake up 类型的 alarm！</span></span><br><span class="line">            setLocked(ELAPSED_REALTIME_WAKEUP, firstWakeup.start);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【4】如果 firstBatch 不等于 firstWakeup，说明 firstBatch 中不包含 wake up 类型的 alarm！</span></span><br><span class="line">        <span class="comment">// 那就设置下一个非 wake up alarm 的触发时间！</span></span><br><span class="line">        <span class="keyword">if</span> (firstBatch != firstWakeup) &#123;</span><br><span class="line">            nextNonWakeup = firstBatch.start;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// mPendingNonWakeupAlarms 不为 empty，说明系统中存在处于等待状态的 no wakeup 类型的 alarm！</span></span><br><span class="line">    <span class="comment">// 那么如果 nextNonWakeup 为 0，或者 mNextNonWakeupDeliveryTime 小于 nextNonWakeup！</span></span><br><span class="line">    <span class="comment">// 那么更新 nextNonWakeup 为 mNextNonWakeupDeliveryTime 的值！</span></span><br><span class="line">    <span class="keyword">if</span> (mPendingNonWakeupAlarms.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nextNonWakeup == <span class="number">0</span> || mNextNonWakeupDeliveryTime &lt; nextNonWakeup) &#123;</span><br><span class="line">            nextNonWakeup = mNextNonWakeupDeliveryTime;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最后如果，本次计算的下一个要触发的 no wake up alarm 的时间和之前的不同，更新 mNextNonWakeup 的值</span></span><br><span class="line">    <span class="comment">// 并设置下一个 no wake up 的 alarm！</span></span><br><span class="line">    <span class="keyword">if</span> (nextNonWakeup != <span class="number">0</span> &amp;&amp; mNextNonWakeup != nextNonWakeup) &#123;</span><br><span class="line">        mNextNonWakeup = nextNonWakeup;</span><br><span class="line">        <span class="comment">//【3.4.4.2】设置下一个要触发的 no wake up 类型的 alarm！</span></span><br><span class="line">        setLocked(ELAPSED_REALTIME, nextNonWakeup);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下一个要执行的 wake up alarm 和 no wake up alarm 最终会通过 setLocked 方法进行设置！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setLocked</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mNativeData != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// The kernel never triggers alarms with negative wakeup times</span></span><br><span class="line">        <span class="comment">// so we ensure they are positive.</span></span><br><span class="line">        <span class="keyword">long</span> alarmSeconds, alarmNanoseconds;</span><br><span class="line">        <span class="keyword">if</span> (when &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            alarmSeconds = <span class="number">0</span>;</span><br><span class="line">            alarmNanoseconds = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            alarmSeconds = when / <span class="number">1000</span>;</span><br><span class="line">            alarmNanoseconds = (when % <span class="number">1000</span>) * <span class="number">1000</span> * <span class="number">1000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        set(mNativeData, type, alarmSeconds, alarmNanoseconds);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Message msg = Message.obtain();</span><br><span class="line">        msg.what = ALARM_EVENT;</span><br><span class="line">        </span><br><span class="line">        mHandler.removeMessages(ALARM_EVENT);</span><br><span class="line">        mHandler.sendMessageAtTime(msg, when);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>setLocked 中提供了 2 种方法来设置 Alarm：</p>
<ul>
<li>一种是通过 Alarm 驱动来设置 Alarm，同时启动一个 AlarmThread 来监听 Alarm 驱动的消息，处理触发的 Alarm！</li>
<li>一种是通过自身的消息循环来设置和触发 Alarm；</li>
</ul>
<p>正常情况下，Alarm 驱动是存在的，那么，我们先来看看正常情况！</p>
<h1 id="1-AlarmThread-run"><a href="#1-AlarmThread-run" class="headerlink" title="1 AlarmThread.run"></a>1 AlarmThread.run</h1><p>AlarmThread 内部有一个 while 循环，条件为 true，通过不断循环，来处理来自 Kernel 的消息，下面我们来看卡 AlarmThread 的 run 方法！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Alarm&gt; triggerList = <span class="keyword">new</span> ArrayList&lt;Alarm&gt;();</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;   </span><br><span class="line">        <span class="comment">//【*1.1】waitForAlarm 最终会调用 native 层的方法，是同步阻塞的，如果该方法没有返回值</span></span><br><span class="line">        <span class="comment">// 那 AlarmThread 将一直阻塞在这里，当其返回，说明有 alarm 触发了！</span></span><br><span class="line">        <span class="keyword">int</span> result = waitForAlarm(mNativeData);</span><br><span class="line">        mLastWakeup = SystemClock.elapsedRealtime(); <span class="comment">// 更新上一次唤醒的时间</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【1】清空 triggerList，triggerList 用于保存已经触发的 Alarm！</span></span><br><span class="line">        triggerList.clear();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> nowRTC = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> nowELAPSED = SystemClock.elapsedRealtime();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【2】如果只是时间发生改变，而不是闹钟触发，进入这里！</span></span><br><span class="line">        <span class="keyword">if</span> ((result &amp; TIME_CHANGED_MASK) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//【2.1】由于内核内部的一些微小调整，其会返回给系统一些实际上并不是闹钟出发引起的时间变化通知</span></span><br><span class="line">            <span class="comment">// 这里会过滤掉这些时间变化！</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> lastTimeChangeClockTime;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> expectedClockTime;</span><br><span class="line">            <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">                lastTimeChangeClockTime = mLastTimeChangeClockTime;</span><br><span class="line">                expectedClockTime = lastTimeChangeClockTime</span><br><span class="line">                        + (nowELAPSED - mLastTimeChangeRealtime);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (lastTimeChangeClockTime == <span class="number">0</span> || nowRTC &lt; (expectedClockTime-<span class="number">500</span>)</span><br><span class="line">                    || nowRTC &gt; (expectedClockTime+<span class="number">500</span>)) &#123;</span><br><span class="line">                <span class="comment">// The change is by at least +/- 500 ms (or this is the first change),</span></span><br><span class="line">                <span class="comment">// let's do it!</span></span><br><span class="line">                <span class="comment">// </span></span><br><span class="line">                <span class="keyword">if</span> (DEBUG_BATCH) &#123;</span><br><span class="line">                    Slog.v(TAG, <span class="string">"Time changed notification from kernel; rebatching"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 从管理列表 mAlarmBatches 移除时间改变和日期改变的 Alarm 对象！</span></span><br><span class="line">                <span class="comment">// 该方法也会触发 rebatch 过程！</span></span><br><span class="line">                removeImpl(mTimeTickSender);</span><br><span class="line">                removeImpl(mDateChangeSender);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 重新对系统中所有的 Alarm 进行排序和批处理！</span></span><br><span class="line">                rebatchAllAlarms();</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 设置下一个发送 Intent.ACTION_TIME_TICK 和 Intent.ACTION_DATE_CHANGED 的 Alarm！</span></span><br><span class="line">                <span class="comment">// 该方法会调用 setImpl 方法！</span></span><br><span class="line">                mClockReceiver.scheduleTimeTickEvent();</span><br><span class="line">                mClockReceiver.scheduleDateChangedEvent();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">                    <span class="comment">// 记录时间改变的次数，同时记录上一次发生时间改变的时间点！</span></span><br><span class="line">                    mNumTimeChanged++;</span><br><span class="line">                    mLastTimeChangeClockTime = nowRTC;</span><br><span class="line">                    mLastTimeChangeRealtime = nowELAPSED;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 发送时间改变的广播给所有的 userId!</span></span><br><span class="line">                Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_TIME_CHANGED);</span><br><span class="line">                intent.addFlags(Intent.FLAG_RECEIVER_REPLACE_PENDING</span><br><span class="line">                        | Intent.FLAG_RECEIVER_REGISTERED_ONLY_BEFORE_BOOT);</span><br><span class="line">                getContext().sendBroadcastAsUser(intent, UserHandle.ALL);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// The world has changed on us, so we need to re-evaluate alarms</span></span><br><span class="line">                <span class="comment">// regardless of whether the kernel has told us one went off.</span></span><br><span class="line">                result |= IS_WAKEUP_MASK;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【4】闹钟触发，会进入这个流程！</span></span><br><span class="line">        <span class="keyword">if</span> (result != TIME_CHANGED_MASK) &#123;</span><br><span class="line">            <span class="comment">// If this was anything besides just a time change, then figure what if</span></span><br><span class="line">            <span class="comment">// anything to do about alarms.</span></span><br><span class="line">            <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">                <span class="keyword">if</span> (localLOGV) Slog.v(</span><br><span class="line">                    TAG, <span class="string">"Checking for alarms... rtc="</span> + nowRTC</span><br><span class="line">                    + <span class="string">", elapsed="</span> + nowELAPSED);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (WAKEUP_STATS) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((result &amp; IS_WAKEUP_MASK) != <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">long</span> newEarliest = nowRTC - RECENT_WAKEUP_PERIOD;</span><br><span class="line">                        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">                        <span class="keyword">for</span> (WakeupEvent event : mRecentWakeups) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (event.when &gt; newEarliest) <span class="keyword">break</span>;</span><br><span class="line">                            n++; <span class="comment">// number of now-stale entries at the list head</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                            mRecentWakeups.remove();</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        recordWakeupAlarms(mAlarmBatches, nowELAPSED, nowRTC);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//【4.1】收集那些触发时间已经到了的 Alarm，该函数返回值表示是否有 wake up 类型的 alarm！！</span></span><br><span class="line">                <span class="comment">// triggerAlarmsLocked 方法会将触发列表中的 alarm 排序！</span></span><br><span class="line">                <span class="keyword">boolean</span> hasWakeup = triggerAlarmsLocked(triggerList, nowELAPSED, nowRTC);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//【4.2】如果 hasWakeup 为 false，说明无 wake up 类型的 alarm ，</span></span><br><span class="line">                <span class="comment">// 如果 checkAllowNonWakeupDelayLocked 返回 true，说明该列表中的 alarm 要延迟发送！</span></span><br><span class="line">                <span class="keyword">if</span> (!hasWakeup &amp;&amp; checkAllowNonWakeupDelayLocked(nowELAPSED)) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 如果没有 no wake up alarms 要分发，如果此时处于 screen off 或者其他一些特殊的情况！</span></span><br><span class="line">                    <span class="comment">// 我们会将 triggerList 添加到延迟列表 mPendingNonWakeupAlarms 中延迟分发！</span></span><br><span class="line">                    <span class="keyword">if</span> (mPendingNonWakeupAlarms.size() == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 如果 mPendingNonWakeupAlarms 为 empty，初始化延迟分发时间！</span></span><br><span class="line">                        mStartCurrentDelayTime = nowELAPSED; <span class="comment">// 设置 delay 的时间点！</span></span><br><span class="line">                        mNextNonWakeupDeliveryTime = nowELAPSED</span><br><span class="line">                                + ((currentNonWakeupFuzzLocked(nowELAPSED)*<span class="number">3</span>)/<span class="number">2</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    mPendingNonWakeupAlarms.addAll(triggerList); <span class="comment">// 添加到延迟集合中</span></span><br><span class="line">                    mNumDelayedAlarms += triggerList.size(); <span class="comment">// 统计延迟分发的 Alarm 个数</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">//【4.2.1】rebatch 所有的 Alarm，更新下一个 AlarmClock！</span></span><br><span class="line">                    rescheduleKernelAlarmsLocked();</span><br><span class="line">                    updateNextAlarmClockLocked();</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//【4.3】进入这里的，就开始要分发 Alarm 了！</span></span><br><span class="line">                    <span class="comment">// now deliver the alarm intents; if there are pending non-wakeup</span></span><br><span class="line">                    <span class="comment">// alarms, we need to merge them in to the list.  note we don't</span></span><br><span class="line">                    <span class="comment">// just deliver them first because we generally want non-wakeup</span></span><br><span class="line">                    <span class="comment">// alarms delivered after wakeup alarms.</span></span><br><span class="line">                    <span class="comment">//【4.3.1】rebatch 所有的 Alarm，更新下一个 AlarmClock！</span></span><br><span class="line">                    rescheduleKernelAlarmsLocked();</span><br><span class="line">                    updateNextAlarmClockLocked();</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 如果 mPendingNonWakeupAlarms 不为 empty，那么，我们也要分发这些 Alarm！</span></span><br><span class="line">                    <span class="keyword">if</span> (mPendingNonWakeupAlarms.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//【1.2.1】这里对 mPendingNonWakeupAlarms 列表中的 Alarm 计算优先级！</span></span><br><span class="line">                        <span class="comment">// 然后将 alarms 添加到 triggerList 中，然后在进行排序！</span></span><br><span class="line">                        calculateDeliveryPriorities(mPendingNonWakeupAlarms);</span><br><span class="line">                        triggerList.addAll(mPendingNonWakeupAlarms);</span><br><span class="line">                        Collections.sort(triggerList, mAlarmDispatchComparator);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">long</span> thisDelayTime = nowELAPSED - mStartCurrentDelayTime;</span><br><span class="line">                        mTotalDelayTime += thisDelayTime; <span class="comment">// 累计延迟的时间段；</span></span><br><span class="line">                        <span class="keyword">if</span> (mMaxDelayTime &lt; thisDelayTime) &#123;</span><br><span class="line">                            mMaxDelayTime = thisDelayTime; <span class="comment">// 最大延迟的时间段；</span></span><br><span class="line">                        &#125;</span><br><span class="line">                        mPendingNonWakeupAlarms.clear(); <span class="comment">// 清空 mPendingNonWakeupAlarms！</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 分发本次要触发的 Alarm！</span></span><br><span class="line">                    deliverAlarmsLocked(triggerList, nowELAPSED);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Just in case -- even though no wakeup flag was set, make sure</span></span><br><span class="line">            <span class="comment">// we have updated the kernel to the next alarm time.</span></span><br><span class="line">            <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">                rescheduleKernelAlarmsLocked();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>waitForAlarm 会调用 static jint android_server_AlarmManagerService_waitForAlarm 这个 native 方法，对 /dev/alarm 驱动文件进行操作！</p>
<h2 id="1-1-AlarmMS-waitForAlarm"><a href="#1-1-AlarmMS-waitForAlarm" class="headerlink" title="1.1 AlarmMS.waitForAlarm"></a>1.1 AlarmMS.waitForAlarm</h2><p>waitForAlarm 方法用来等待 Alarm 驱动的返回，其实阻塞性的！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">waitForAlarm</span><span class="params">(<span class="keyword">long</span> nativeData)</span></span>;</span><br></pre></td></tr></table></figure>
<p>该方法最后会调用 navtive 的方法，位于 frameworks/base/services/core/jni/com_android_server_AlarmManagerService.cpp 文件中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="1-2-AlarmMS-triggerAlarmsLocked"><a href="#1-2-AlarmMS-triggerAlarmsLocked" class="headerlink" title="1.2 AlarmMS.triggerAlarmsLocked"></a>1.2 AlarmMS.triggerAlarmsLocked</h2><p>triggerAlarmsLocked 方法用于分发那些触发时间已到的 Alarm！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">triggerAlarmsLocked</span><span class="params">(ArrayList&lt;Alarm&gt; triggerList, <span class="keyword">final</span> <span class="keyword">long</span> nowELAPSED,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> <span class="keyword">long</span> nowRTC)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> hasWakeup = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】mAlarmBatches 中的 Batch 都是按照触发时间点升序排列，</span></span><br><span class="line">    <span class="comment">// 接下来会遍历 mAlarmBatches，分发那些触发时间已到的 Alarm！</span></span><br><span class="line">    <span class="keyword">while</span> (mAlarmBatches.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 获得触发事件最早的 Batch！</span></span><br><span class="line">        Batch batch = mAlarmBatches.get(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 如果时间最早的 Batch 的触发时间还没到，那就不作任何操作，退出循环！</span></span><br><span class="line">        <span class="keyword">if</span> (batch.start &gt; nowELAPSED) &#123;</span><br><span class="line">            <span class="comment">// Everything else is scheduled for the future</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【1.1】能够走到这里，说明 batch 的触发时间已经到了，那么我们要移除这个 Batch，防止重复分发！</span></span><br><span class="line">        mAlarmBatches.remove(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【1.2】分发这个 Batch 中的所有的 Alarm！</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N = batch.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            Alarm alarm = batch.get(i);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//【1.2.1】如果 Alarm 设置了 AlarmManager.FLAG_ALLOW_WHILE_IDLE 标志位，</span></span><br><span class="line">            <span class="comment">// 说明其在系统处于 idle 状态也可以触发！</span></span><br><span class="line">            <span class="keyword">if</span> ((alarm.flags&amp;AlarmManager.FLAG_ALLOW_WHILE_IDLE) != <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 对于 allow while idle 类型的 Alarm，我们要检验其触发时间，看其距离上次触发事件是否</span></span><br><span class="line">                <span class="comment">// 不小于规定的最小时间间隔：mAllowWhileIdleMinTime</span></span><br><span class="line">                <span class="keyword">long</span> lastTime = mLastAllowWhileIdleDispatch.get(alarm.uid, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">long</span> minTime = lastTime + mAllowWhileIdleMinTime;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 如果 nowELAPSED &lt; minTime，说明虽然该 alarm 的触发时间到了，但是时间小于规定的最小时间</span></span><br><span class="line">                <span class="comment">// 那么，按照最小时间重新设置 alarm！</span></span><br><span class="line">                <span class="keyword">if</span> (nowELAPSED &lt; minTime) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 设置 alarm 的触发时间为 minTime，最大触发时间至少为 minTime！</span></span><br><span class="line">                    alarm.whenElapsed = minTime;</span><br><span class="line">                    <span class="keyword">if</span> (alarm.maxWhenElapsed &lt; minTime) &#123;</span><br><span class="line">                        alarm.maxWhenElapsed = minTime;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (RECORD_DEVICE_IDLE_ALARMS) &#123;</span><br><span class="line">                        IdleDispatchEntry ent = <span class="keyword">new</span> IdleDispatchEntry();</span><br><span class="line">                        ent.uid = alarm.uid;</span><br><span class="line">                        ent.pkg = alarm.operation.getCreatorPackage();</span><br><span class="line">                        ent.tag = alarm.operation.getTag(<span class="string">""</span>);</span><br><span class="line">                        ent.op = <span class="string">"RESCHEDULE"</span>;</span><br><span class="line">                        ent.elapsedRealtime = nowELAPSED;</span><br><span class="line">                        ent.argRealtime = lastTime;</span><br><span class="line">                        mAllowWhileIdleDispatches.add(ent);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 按照最小时间，重新设置 alarm，然后继续处理下一个 alarm！！</span></span><br><span class="line">                    setImplLocked(alarm, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//【1.2.2】进入这里，说明 Alarm 此时需要被分发！</span></span><br><span class="line">            alarm.count = <span class="number">1</span>; <span class="comment">// Alarm 闹钟的触发次数初始化为 1；</span></span><br><span class="line">            </span><br><span class="line">            triggerList.add(alarm); <span class="comment">// 将这个 alarm 添加到 triggerList 中去！</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果 alarm 是 wake from idle 类型的，在 event log 文件中打印出来，方便调试！</span></span><br><span class="line">            <span class="keyword">if</span> ((alarm.flags&amp;AlarmManager.FLAG_WAKE_FROM_IDLE) != <span class="number">0</span>) &#123;</span><br><span class="line">                EventLogTags.writeDeviceIdleWakeFromIdle(mPendingIdleUntil != <span class="keyword">null</span> ? <span class="number">1</span> : <span class="number">0</span>,</span><br><span class="line">                        alarm.statsTag);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【1.2.3】如果此时要触发的 Alarm 是 mPendingIdleUntil，那么说明系统要从 idle 状态恢复了，那么</span></span><br><span class="line">            <span class="comment">// 设置 mPendingIdleUntil 为 null，同时 rebatch 其他的 alarm，恢复因为 idle 状态而处于等待状态的 alarm</span></span><br><span class="line">            <span class="keyword">if</span> (mPendingIdleUntil == alarm) &#123;</span><br><span class="line">                mPendingIdleUntil = <span class="keyword">null</span>;</span><br><span class="line">                rebatchAllAlarmsLocked(<span class="keyword">false</span>);</span><br><span class="line">                restorePendingWhileIdleAlarmsLocked();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【1.2.3】如果此时要触发的 Alarm 是 mNextWakeFromIdle，说明该 alarm 会将系统从 idle 状态唤醒！</span></span><br><span class="line">            <span class="comment">// 那么设置 mNextWakeFromIdle 为 null，同时 rebatch 其他的 alarm！</span></span><br><span class="line">            <span class="keyword">if</span> (mNextWakeFromIdle == alarm) &#123;</span><br><span class="line">                mNextWakeFromIdle = <span class="keyword">null</span>;</span><br><span class="line">                rebatchAllAlarmsLocked(<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【1.2.3】如果 alarm.repeatInterval 大于 0，说明该 alarm 是一个 repeating alarm！</span></span><br><span class="line">            <span class="comment">// 我们计算下一次触发的时间，再次设置 alarm！</span></span><br><span class="line">            <span class="comment">// 这里要注意一点，因为系统可能进入休眠或者关机，alarm 可能错过了多个周期时间的触发！</span></span><br><span class="line">            <span class="keyword">if</span> (alarm.repeatInterval &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 这里是计算，我们可能因为系统休眠或者关机，错过了几个周期，当然该结果是可以为 0 的；</span></span><br><span class="line">                <span class="comment">// 我们需要把错过的触发次数也统计进去！！</span></span><br><span class="line">                alarm.count += (nowELAPSED - alarm.whenElapsed) / alarm.repeatInterval;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 计算下次的触发时间！</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> delta = alarm.count * alarm.repeatInterval;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> nextElapsed = alarm.whenElapsed + delta;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 设置 alarm！</span></span><br><span class="line">                setImplLocked(alarm.type, alarm.when + delta, nextElapsed, alarm.windowLength,</span><br><span class="line">                        maxTriggerTime(nowELAPSED, nextElapsed, alarm.repeatInterval),</span><br><span class="line">                        alarm.repeatInterval, alarm.operation, <span class="keyword">null</span>, <span class="keyword">null</span>, alarm.flags, <span class="keyword">true</span>,</span><br><span class="line">                        alarm.workSource, alarm.alarmClock, alarm.uid, alarm.packageName);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果该 alarm 是 wake up 类型的，hasWakeup 为 true！</span></span><br><span class="line">            <span class="keyword">if</span> (alarm.wakeup) &#123;</span><br><span class="line">                hasWakeup = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 该 alarm 是通过 setAlarmClock 方法设置的，当该 alarm 触发后，我们会计算下一个 AlarmClock</span></span><br><span class="line">            <span class="keyword">if</span> (alarm.alarmClock != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mNextAlarmClockMayChange = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于记录分发次数。每分发一个新的 alarm 集，该值会加 1；</span></span><br><span class="line">    mCurrentSeq++;</span><br><span class="line">    <span class="comment">//【2】计算分发优先级！</span></span><br><span class="line">    calculateDeliveryPriorities(triggerList);</span><br><span class="line">    <span class="comment">//【3】对要分发的 alarm 进行排序，先依据优先级，优先级相同，按照时间升序排序！</span></span><br><span class="line">    Collections.sort(triggerList, mAlarmDispatchComparator);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (localLOGV) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;triggerList.size(); i++) &#123;</span><br><span class="line">            Slog.v(TAG, <span class="string">"Triggering alarm #"</span> + i + <span class="string">": "</span> + triggerList.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> hasWakeup;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-1-AlarmMS-calculateDeliveryPriorities"><a href="#1-2-1-AlarmMS-calculateDeliveryPriorities" class="headerlink" title="1.2.1 AlarmMS.calculateDeliveryPriorities"></a>1.2.1 AlarmMS.calculateDeliveryPriorities</h3><p>calculateDeliveryPriorities 方法用于计算分发的优先级！参数 alarms 表示所有需要触发的 alarm</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calculateDeliveryPriorities</span><span class="params">(ArrayList&lt;Alarm&gt; alarms)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> N = alarms.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        Alarm a = alarms.get(i);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【1】计算 alarm 优先级！</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> alarmPrio;</span><br><span class="line">        <span class="keyword">if</span> (a.operation != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; Intent.ACTION_TIME_TICK.equals(a.operation.getIntent().getAction())) &#123;</span><br><span class="line">            <span class="comment">//【1.1】如果该 alarm 是 Intent.ACTION_TIME_TICK，那么优先级为 PRIO_TICK</span></span><br><span class="line">            alarmPrio = PRIO_TICK;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a.wakeup) &#123;</span><br><span class="line">            <span class="comment">//【1.2】如果该 alarm 是 wake up 类型的，那么优先级为 PRIO_WAKEUP</span></span><br><span class="line">            alarmPrio = PRIO_WAKEUP;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//【1.3】其他类型的 alarm 优先级为 PRIO_NORMAL</span></span><br><span class="line">            alarmPrio = PRIO_NORMAL;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【2】获得 alarm 的优先级对象，和其发送者 packageName</span></span><br><span class="line">        PriorityClass packagePrio = a.priorityClass;</span><br><span class="line">        String alarmPackage = (a.operation != <span class="keyword">null</span>)</span><br><span class="line">                ? a.operation.getCreatorPackage()</span><br><span class="line">                : a.packageName;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 packagePrio 为 null，那就优先在缓存 mPriorities 中找，找不到；创建新的，并加入到缓存中！</span></span><br><span class="line">        <span class="keyword">if</span> (packagePrio == <span class="keyword">null</span>) packagePrio = mPriorities.get(alarmPackage);</span><br><span class="line">        <span class="keyword">if</span> (packagePrio == <span class="keyword">null</span>) &#123;</span><br><span class="line">            packagePrio = a.priorityClass = <span class="keyword">new</span> PriorityClass(); <span class="comment">// lowest prio &amp; stale sequence</span></span><br><span class="line">            mPriorities.put(alarmPackage, packagePrio);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新 alarm 的 priorityClass 优先级对象!</span></span><br><span class="line">        a.priorityClass = packagePrio;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【3】更新 alarm 优先级！</span></span><br><span class="line">        <span class="keyword">if</span> (packagePrio.seq != mCurrentSeq) &#123;</span><br><span class="line">            <span class="comment">//【3.1】如果 packagePrio.seq 不等于 mCurrentSeq，说明在本次的发送列表中，这是来自这个包的第一个 Alarm</span></span><br><span class="line">            <span class="comment">// 那么执行初始化操作！</span></span><br><span class="line">            packagePrio.priority = alarmPrio;</span><br><span class="line">            packagePrio.seq = mCurrentSeq;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//【3.2】如果 packagePrio.seq == mCurrentSeq，说明在发送列表中，有来自同一个 package 的多个 Alarm。</span></span><br><span class="line">            <span class="comment">// 那就调整优先级，规则： TICK &lt; WAKEUP &lt; NORMAL</span></span><br><span class="line">            <span class="keyword">if</span> (alarmPrio &lt; packagePrio.priority) &#123;</span><br><span class="line">                packagePrio.priority = alarmPrio;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里设置到了如下的几种 alarm 优先级，值越小，优先级越高！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PRIO_TICK = <span class="number">0</span>; <span class="comment">// 时间改变!</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PRIO_WAKEUP = <span class="number">1</span>; <span class="comment">// 唤醒!</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PRIO_NORMAL = <span class="number">2</span>; <span class="comment">// 正常!</span></span><br></pre></td></tr></table></figure>
<p>同时有一个集合 mPriorities，用于保存发送者的 package 和其对应 Alarm 优先级：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> seq;</span><br><span class="line">    <span class="keyword">int</span> priority;</span><br><span class="line"></span><br><span class="line">    PriorityClass() &#123;</span><br><span class="line">        seq = mCurrentSeq - <span class="number">1</span>;</span><br><span class="line">        priority = PRIO_NORMAL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> HashMap&lt;String, PriorityClass&gt; mPriorities = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">int</span> mCurrentSeq = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>PriorityClass 用于表示优先级别！</p>
<h3 id="1-2-2-Collections-sort-triggerList-mAlarmDispatchComparator"><a href="#1-2-2-Collections-sort-triggerList-mAlarmDispatchComparator" class="headerlink" title="1.2.2 Collections.sort(triggerList, mAlarmDispatchComparator)"></a>1.2.2 Collections.sort(triggerList, mAlarmDispatchComparator)</h3><p>接下来，对 triggerList 进行排序，这里用到了一个比较器 mAlarmDispatchComparator！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Comparator&lt;Alarm&gt; mAlarmDispatchComparator = <span class="keyword">new</span> Comparator&lt;Alarm&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Alarm lhs, Alarm rhs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// priority class trumps everything.  TICK &lt; WAKEUP &lt; NORMAL</span></span><br><span class="line">        <span class="keyword">if</span> (lhs.priorityClass.priority &lt; rhs.priorityClass.priority) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lhs.priorityClass.priority &gt; rhs.priorityClass.priority) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// within each class, sort by nominal delivery time</span></span><br><span class="line">        <span class="keyword">if</span> (lhs.whenElapsed &lt; rhs.whenElapsed) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lhs.whenElapsed &gt; rhs.whenElapsed) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// same priority class + same target delivery time</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>首先按照优先级从高到低进行排序，然后按照触发时间从小到大进行排序，如果优先级和时间相同，保持先后顺序不变！</p>
<h2 id="1-3-AlarmMS-checkAllowNonWakeupDelayLocked"><a href="#1-3-AlarmMS-checkAllowNonWakeupDelayLocked" class="headerlink" title="1.3 AlarmMS.checkAllowNonWakeupDelayLocked"></a>1.3 AlarmMS.checkAllowNonWakeupDelayLocked</h2><p>该方法用于检查是否需要延迟 no wake up 类型的 Alarm 的分发！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">checkAllowNonWakeupDelayLocked</span><span class="params">(<span class="keyword">long</span> nowELAPSED)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】如果此时处于亮屏状态，无需延迟！</span></span><br><span class="line">    <span class="keyword">if</span> (mInteractive) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【2】如果此时处于熄屏状态，但是我们还没有分发过任何 Alarm，无需延迟！</span></span><br><span class="line">    <span class="keyword">if</span> (mLastAlarmDeliveryTime &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【3】如果此时系统中有等待中的 no wake up 类型的 alarm，但是其分发时间 mNextNonWakeupDeliveryTime 已经过去了</span></span><br><span class="line">    <span class="comment">// 那就无需延迟（看注释是为了解决一个在 Looper 中卡住的 bugs）！</span></span><br><span class="line">    <span class="keyword">if</span> (mPendingNonWakeupAlarms.size() &gt; <span class="number">0</span> &amp;&amp; mNextNonWakeupDeliveryTime &lt; nowELAPSED) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算当前时间距离上次分发的时间间隔，比较其和熄屏时间间隔的大小！！</span></span><br><span class="line">    <span class="keyword">long</span> timeSinceLast = nowELAPSED - mLastAlarmDeliveryTime;</span><br><span class="line">    <span class="keyword">return</span> timeSinceLast &lt;= currentNonWakeupFuzzLocked(nowELAPSED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>规则如下：</p>
<ul>
<li>如果此时处于亮屏状态，无需延迟！</li>
<li>如果此时处于熄屏状态，但是我们还没有分发过任何 Alarm，无需延迟！</li>
<li>如果此时处于熄屏状态，我们之前也分发过 Alarm，那么如果 此时系统中有等待中的 no wake up 类型的 alarm，其分发时间已经过去了，无需延迟；</li>
<li>如果上面三个条件都不满足，那么如果距离上次分发 Alarm 的时间超过了 no wake up 类型 alarm 的最大延迟分发时间，那就无需延迟！</li>
</ul>
<p>currentNonWakeupFuzzLocked 用来计算了 no wake up 类型 alarm 的最大延迟分发时间</p>
<h3 id="1-3-1-AlarmMS-currentNonWakeupFuzzLocked"><a href="#1-3-1-AlarmMS-currentNonWakeupFuzzLocked" class="headerlink" title="1.3.1 AlarmMS.currentNonWakeupFuzzLocked"></a>1.3.1 AlarmMS.currentNonWakeupFuzzLocked</h3><p>该方法是用来计算熄屏幕的时长，然后根据时常，来确定 no wake up 类型的 alarm 的延迟触发的最长时间！！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">currentNonWakeupFuzzLocked</span><span class="params">(<span class="keyword">long</span> nowELAPSED)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> timeSinceOn = nowELAPSED - mNonInteractiveStartTime;</span><br><span class="line">    <span class="comment">//【1】如果熄屏时间小于 5 mins，那么延迟最多 2 mins</span></span><br><span class="line">    <span class="keyword">if</span> (timeSinceOn &lt; <span class="number">5</span>*<span class="number">60</span>*<span class="number">1000</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*<span class="number">60</span>*<span class="number">1000</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//【2】如果熄屏时间小于 30 mins，那么延迟最多 15 mins</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (timeSinceOn &lt; <span class="number">30</span>*<span class="number">60</span>*<span class="number">1000</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">15</span>*<span class="number">60</span>*<span class="number">1000</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//【3】其他情况，那么延迟最多 60 mins</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">60</span>*<span class="number">60</span>*<span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不多说了！</p>
<h2 id="1-4-AlarmMS-deliverAlarmsLocked"><a href="#1-4-AlarmMS-deliverAlarmsLocked" class="headerlink" title="1.4 AlarmMS.deliverAlarmsLocked"></a>1.4 AlarmMS.deliverAlarmsLocked</h2><p>deliverAlarmsLocked 方法用于分发已经出发的 Alarm！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deliverAlarmsLocked</span><span class="params">(ArrayList&lt;Alarm&gt; triggerList, <span class="keyword">long</span> nowELAPSED)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】设置上一次的发送时间点！</span></span><br><span class="line">    mLastAlarmDeliveryTime = nowELAPSED;</span><br><span class="line">    <span class="comment">//【2】遍历 triggerList，分发 Alarm！</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;triggerList.size(); i++) &#123;</span><br><span class="line">        Alarm alarm = triggerList.get(i);</span><br><span class="line">        <span class="comment">//【2.1】判断该 Alarm 是否是 allow while idle 的！</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> allowWhileIdle = (alarm.flags&amp;AlarmManager.FLAG_ALLOW_WHILE_IDLE) != <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (localLOGV) &#123;</span><br><span class="line">                Slog.v(TAG, <span class="string">"sending alarm "</span> + alarm);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (RECORD_ALARMS_IN_HISTORY) &#123; <span class="comment">// 用于系统记录信息！</span></span><br><span class="line">                <span class="keyword">if</span> (alarm.workSource != <span class="keyword">null</span> &amp;&amp; alarm.workSource.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> wi=<span class="number">0</span>; wi&lt;alarm.workSource.size(); wi++) &#123;</span><br><span class="line">                        ActivityManagerNative.noteAlarmStart(</span><br><span class="line">                                alarm.operation, alarm.workSource.get(wi), alarm.statsTag);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ActivityManagerNative.noteAlarmStart(</span><br><span class="line">                            alarm.operation, alarm.uid, alarm.statsTag);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//【1.5】调用 DeliveryTracker 的 deliverLocked 方法，分发 Alarm！</span></span><br><span class="line">            mDeliveryTracker.deliverLocked(alarm, nowELAPSED, allowWhileIdle);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Failure sending alarm."</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，我们去看看 DeliveryTracker：</p>
<h2 id="1-5-DeliveryTracker-deliverLocked"><a href="#1-5-DeliveryTracker-deliverLocked" class="headerlink" title="1.5 DeliveryTracker.deliverLocked"></a>1.5 DeliveryTracker.deliverLocked</h2><p>DeliveryTracker 用以监控和跟踪 Alarm 的分发！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeliveryTracker</span> <span class="keyword">extends</span> <span class="title">IAlarmCompleteListener</span>.<span class="title">Stub</span> <span class="keyword">implements</span> <span class="title">PendingIntent</span>.<span class="title">OnFinished</span> </span>&#123;</span><br><span class="line">    ... ... ... ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Deliver an alarm and set up the post-delivery handling appropriately</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deliverLocked</span><span class="params">(Alarm alarm, <span class="keyword">long</span> nowELAPSED, <span class="keyword">boolean</span> allowWhileIdle)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//【1】针对于 Alarm 的触发方式，做不同的处理！</span></span><br><span class="line">        <span class="keyword">if</span> (alarm.operation != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//【1.1】如果是通过 PendingIntent 触发，进入这里，这里会调用 PendingIntent 的 send 方法，将 Intent</span></span><br><span class="line">            <span class="comment">// 发送给接收方！</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                alarm.operation.send(getContext(), <span class="number">0</span>,</span><br><span class="line">                        mBackgroundIntent.putExtra(</span><br><span class="line">                                Intent.EXTRA_ALARM_COUNT, alarm.count),</span><br><span class="line">                                mDeliveryTracker, mHandler, <span class="keyword">null</span>,</span><br><span class="line">                                allowWhileIdle ? mIdleOptions : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (PendingIntent.CanceledException e) &#123;</span><br><span class="line">                <span class="comment">// 如果 send 出现异常，那么如果是重复闹钟，那就将这个 Alarm 移除；否则，直接 return 掉！</span></span><br><span class="line">                <span class="keyword">if</span> (alarm.repeatInterval &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    removeImpl(alarm.operation); <span class="comment">//  该方法会 rebatch 其他的 A</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//【1.2】如果是通过 onAlarmListener 接收，进入这里，调用其 doAlarm 方法！</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_LISTENER_CALLBACK) &#123;</span><br><span class="line">                    Slog.v(TAG, <span class="string">"Alarm to uid="</span> + alarm.uid</span><br><span class="line">                            + <span class="string">" listener="</span> + alarm.listener.asBinder());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 跨进程调用应用进程中的 onAlarmListener 的 doAlarm 方法！</span></span><br><span class="line">                alarm.listener.doAlarm(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 设置监听超时处理！</span></span><br><span class="line">                mHandler.sendMessageDelayed(</span><br><span class="line">                        mHandler.obtainMessage(AlarmHandler.LISTENER_TIMEOUT,</span><br><span class="line">                                alarm.listener.asBinder()),</span><br><span class="line">                        mConstants.LISTENER_TIMEOUT);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// 如果分发出现异常，那就 return，不做处理！！</span></span><br><span class="line">                <span class="keyword">if</span> (DEBUG_LISTENER_CALLBACK) &#123;</span><br><span class="line">                    Slog.i(TAG, <span class="string">"Alarm undeliverable to listener "</span></span><br><span class="line">                            + alarm.listener.asBinder(), e);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【2】alarm 要开始准备分发了，开始统计跟踪 wakelock 和 status！</span></span><br><span class="line">        <span class="keyword">if</span> (mBroadcastRefCount == <span class="number">0</span>) &#123;</span><br><span class="line">            setWakelockWorkSource(alarm.operation, alarm.workSource,</span><br><span class="line">                    alarm.type, alarm.statsTag, (alarm.operation == <span class="keyword">null</span>) ? alarm.uid : -<span class="number">1</span>,</span><br><span class="line">                    <span class="keyword">true</span>);</span><br><span class="line">            mWakeLock.acquire(); <span class="comment">// 申请 wakeLock 锁，防止分发过程睡下去！</span></span><br><span class="line">            <span class="comment">// 发送 REPORT_ALARMS_ACTIVE 给 AlarmHandler，AlarmHandler 会通知 DeviceIdleController</span></span><br><span class="line">            <span class="comment">//，有 alarm 处于 active 状态！</span></span><br><span class="line">            mHandler.obtainMessage(AlarmHandler.REPORT_ALARMS_ACTIVE, <span class="number">1</span>).sendToTarget();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【3】创建 InFlight 对象，表示该 Alarm 正在分发过程中！</span></span><br><span class="line">        <span class="keyword">final</span> InFlight inflight = <span class="keyword">new</span> InFlight(AlarmManagerService.<span class="keyword">this</span>,</span><br><span class="line">                alarm.operation, alarm.listener, alarm.workSource, alarm.uid,</span><br><span class="line">                alarm.packageName, alarm.type, alarm.statsTag, nowELAPSED);</span><br><span class="line">        mInFlight.add(inflight);</span><br><span class="line"></span><br><span class="line">        mBroadcastRefCount++; <span class="comment">// 引用计数加 1；</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//【4】如果这个 alarm 是 allow while idle 的，那就要记录下该 alarm 的上一次分发时间</span></span><br><span class="line">        <span class="comment">// 保存到 mLastAllowWhileIdleDispatch 中！</span></span><br><span class="line">        <span class="keyword">if</span> (allowWhileIdle) &#123;</span><br><span class="line">            mLastAllowWhileIdleDispatch.put(alarm.uid, nowELAPSED);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (RECORD_DEVICE_IDLE_ALARMS) &#123; <span class="comment">// 用于 dump 操作，不关注！</span></span><br><span class="line">                IdleDispatchEntry ent = <span class="keyword">new</span> IdleDispatchEntry();</span><br><span class="line">                ent.uid = alarm.uid;</span><br><span class="line">                ent.pkg = alarm.packageName;</span><br><span class="line">                ent.tag = alarm.statsTag;</span><br><span class="line">                ent.op = <span class="string">"DELIVER"</span>;</span><br><span class="line">                ent.elapsedRealtime = nowELAPSED;</span><br><span class="line">                mAllowWhileIdleDispatches.add(ent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【5】设置 alarm 状态！</span></span><br><span class="line">        <span class="keyword">final</span> BroadcastStats bs = inflight.mBroadcastStats;</span><br><span class="line">        bs.count++;</span><br><span class="line">        <span class="keyword">if</span> (bs.nesting == <span class="number">0</span>) &#123;</span><br><span class="line">            bs.nesting = <span class="number">1</span>;</span><br><span class="line">            bs.startTime = nowELAPSED;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            bs.nesting++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> FilterStats fs = inflight.mFilterStats;</span><br><span class="line">        fs.count++;</span><br><span class="line">        <span class="keyword">if</span> (fs.nesting == <span class="number">0</span>) &#123;</span><br><span class="line">            fs.nesting = <span class="number">1</span>;</span><br><span class="line">            fs.startTime = nowELAPSED;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fs.nesting++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【6】如果 alarm 是 wake up 类型的！</span></span><br><span class="line">        <span class="keyword">if</span> (alarm.type == ELAPSED_REALTIME_WAKEUP</span><br><span class="line">                || alarm.type == RTC_WAKEUP) &#123;</span><br><span class="line">            bs.numWakeup++; <span class="comment">// 更新 wake up 的次数！</span></span><br><span class="line">            fs.numWakeup++;</span><br><span class="line">            <span class="keyword">if</span> (alarm.workSource != <span class="keyword">null</span> &amp;&amp; alarm.workSource.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> wi=<span class="number">0</span>; wi&lt;alarm.workSource.size(); wi++) &#123;</span><br><span class="line">                    <span class="keyword">final</span> String wsName = alarm.workSource.getName(wi);</span><br><span class="line">                    ActivityManagerNative.noteWakeupAlarm(</span><br><span class="line">                            alarm.operation, alarm.workSource.get(wi),</span><br><span class="line">                            (wsName != <span class="keyword">null</span>) ? wsName : alarm.packageName,</span><br><span class="line">                            alarm.statsTag);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ActivityManagerNative.noteWakeupAlarm(</span><br><span class="line">                        alarm.operation, alarm.uid, alarm.packageName, alarm.statsTag);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mDeliveryTracker 是 AlarmManagerService 的内部变量，用于监控分发的过程！</p>
<p>这里我们看到，DeliveryTracker 继承了 IAlarmCompleteListener.Stub，这个是由 IAlarmCompleteListener.aidl 文件生成的一个服务端“桩”对象，作用很明显了，用于跨进程通信，即：系统进程和应用进程！</p>
<p>原因很简单，DeliveryTracker 用于监控 Alarm 的分发，所以系统需要知道客户端对 Alarm 的分发和处理结果，所以应用进程那边一定会有 DeliveryTracker 的代理对象的！</p>
<p>同时 DeliveryTracker 还实现了 PendingIntent.OnFinished 接口，用于另外一种分发方式！</p>
<p>我们继续看！</p>
<h3 id="1-5-1-new-InFlight"><a href="#1-5-1-new-InFlight" class="headerlink" title="1.5.1 new InFlight"></a>1.5.1 new InFlight</h3><p>系统会对每一个 Alarm 都创建其 InFlight 对象，并保存到 mInFlight！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InFlight</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> PendingIntent mPendingIntent;</span><br><span class="line">    <span class="keyword">final</span> IBinder mListener;</span><br><span class="line">    <span class="keyword">final</span> WorkSource mWorkSource;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> mUid;</span><br><span class="line">    <span class="keyword">final</span> String mTag;</span><br><span class="line">    <span class="keyword">final</span> BroadcastStats mBroadcastStats;</span><br><span class="line">    <span class="keyword">final</span> FilterStats mFilterStats;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> mAlarmType;</span><br><span class="line"></span><br><span class="line">    InFlight(AlarmManagerService service, PendingIntent pendingIntent, IAlarmListener listener,</span><br><span class="line">            WorkSource workSource, <span class="keyword">int</span> uid, String alarmPkg, <span class="keyword">int</span> alarmType, String tag,</span><br><span class="line">            <span class="keyword">long</span> nowELAPSED) &#123;</span><br><span class="line">        mPendingIntent = pendingIntent; <span class="comment">// PendingIntent 对象！</span></span><br><span class="line">        mListener = listener != <span class="keyword">null</span> ? listener.asBinder() : <span class="keyword">null</span>; <span class="comment">// AlarmListener 对象！</span></span><br><span class="line">        mWorkSource = workSource;</span><br><span class="line">        mUid = uid;</span><br><span class="line">        mTag = tag;</span><br><span class="line">        mBroadcastStats = (pendingIntent != <span class="keyword">null</span>)</span><br><span class="line">                ? service.getStatsLocked(pendingIntent)</span><br><span class="line">                : service.getStatsLocked(uid, alarmPkg);</span><br><span class="line">        FilterStats fs = mBroadcastStats.filterStats.get(mTag);</span><br><span class="line">        <span class="keyword">if</span> (fs == <span class="keyword">null</span>) &#123;</span><br><span class="line">            fs = <span class="keyword">new</span> FilterStats(mBroadcastStats, mTag);</span><br><span class="line">            mBroadcastStats.filterStats.put(mTag, fs);</span><br><span class="line">        &#125;</span><br><span class="line">        fs.lastTime = nowELAPSED;</span><br><span class="line">        mFilterStats = fs;</span><br><span class="line">        mAlarmType = alarmType; <span class="comment">// Alarm 的类型！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-5-1-1-AlarmMS-getStatsLocked"><a href="#1-5-1-1-AlarmMS-getStatsLocked" class="headerlink" title="1.5.1.1 AlarmMS.getStatsLocked"></a>1.5.1.1 AlarmMS.getStatsLocked</h4><p>getStatsLocked 用于获得 Alarm 对应的 BroadcastStats 对象！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> BroadcastStats <span class="title">getStatsLocked</span><span class="params">(PendingIntent pi)</span> </span>&#123;</span><br><span class="line">    String pkg = pi.getCreatorPackage();</span><br><span class="line">    <span class="keyword">int</span> uid = pi.getCreatorUid();</span><br><span class="line">    <span class="keyword">return</span> getStatsLocked(uid, pkg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> BroadcastStats <span class="title">getStatsLocked</span><span class="params">(<span class="keyword">int</span> uid, String pkgName)</span> </span>&#123;</span><br><span class="line">    ArrayMap&lt;String, BroadcastStats&gt; uidStats = mBroadcastStats.get(uid);</span><br><span class="line">    <span class="keyword">if</span> (uidStats == <span class="keyword">null</span>) &#123;</span><br><span class="line">        uidStats = <span class="keyword">new</span> ArrayMap&lt;String, BroadcastStats&gt;();</span><br><span class="line">        mBroadcastStats.put(uid, uidStats);</span><br><span class="line">    &#125;</span><br><span class="line">    BroadcastStats bs = uidStats.get(pkgName);</span><br><span class="line">    <span class="keyword">if</span> (bs == <span class="keyword">null</span>) &#123;</span><br><span class="line">        bs = <span class="keyword">new</span> BroadcastStats(uid, pkgName);</span><br><span class="line">        uidStats.put(pkgName, bs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每一个 Alarm 都会有一个 BroadcastStats，用于保存该 Alarm 的分发状态！</p>
<p>同时，AlarmManagerService 也有一个集合：mBroadcastStats，来管理每个 uid 对应的广播分发状态！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> SparseArray&lt;ArrayMap&lt;String, BroadcastStats&gt;&gt; mBroadcastStats</span><br><span class="line">        = <span class="keyword">new</span> SparseArray&lt;ArrayMap&lt;String, BroadcastStats&gt;&gt;();</span><br></pre></td></tr></table></figure>
<p>映射关系：<strong>create uid</strong> -&gt; ArrayMap：<strong>create packageName</strong> -&gt; <strong>BroadcastStats</strong>！</p>
<h1 id="2-分发的流程"><a href="#2-分发的流程" class="headerlink" title="2 分发的流程"></a>2 分发的流程</h1><p>前面我们看到，如果 setAlarm 是通过 PendingIntent 的方式来设置的，系统会通过如下方式分发 Alarm！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alarm.operation.send(getContext(), <span class="number">0</span>,</span><br><span class="line">        mBackgroundIntent.putExtra(</span><br><span class="line">                Intent.EXTRA_ALARM_COUNT, alarm.count),</span><br><span class="line">                mDeliveryTracker, mHandler, <span class="keyword">null</span>,</span><br><span class="line">                allowWhileIdle ? mIdleOptions : <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<p>如果 setAlarm 是通过 AlarmListener 的方式来设置的，系统会通过如下方式分发 Alarm！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 跨进程调用应用进程中的 onAlarmListener 的 doAlarm 方法！</span></span><br><span class="line">alarm.listener.doAlarm(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">// 设置监听超时处理！</span></span><br><span class="line">mHandler.sendMessageDelayed(</span><br><span class="line">        mHandler.obtainMessage(AlarmHandler.LISTENER_TIMEOUT,</span><br><span class="line">                alarm.listener.asBinder()),</span><br><span class="line">        mConstants.LISTENER_TIMEOUT);</span><br></pre></td></tr></table></figure>
<p>下面我们来看看二者的区别！</p>
<h2 id="2-1-Alarm-PendingIntent-send"><a href="#2-1-Alarm-PendingIntent-send" class="headerlink" title="2.1 Alarm.PendingIntent.send"></a>2.1 Alarm.PendingIntent.send</h2><p>我们可以看到，对于 PendingIntent，我们会将 Alarm 的重复分发次数通过 Intent.EXTRA_ALARM_COUNT 发送给处理方！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(Context context, <span class="keyword">int</span> code, @Nullable Intent intent,</span></span></span><br><span class="line"><span class="function"><span class="params">        @Nullable OnFinished onFinished, @Nullable Handler handler,</span></span></span><br><span class="line"><span class="function"><span class="params">        @Nullable String requiredPermission, @Nullable Bundle options)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> CanceledException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String resolvedType = intent != <span class="keyword">null</span> ?</span><br><span class="line">                intent.resolveTypeIfNeeded(context.getContentResolver())</span><br><span class="line">                : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【1】调用 AMS 的 sendIntentSender 方法发送这个 Alarm！！</span></span><br><span class="line">        <span class="keyword">int</span> res = ActivityManagerNative.getDefault().sendIntentSender(</span><br><span class="line">                mTarget, code, intent, resolvedType,</span><br><span class="line">                onFinished != <span class="keyword">null</span></span><br><span class="line">                        ? <span class="keyword">new</span> FinishedDispatcher(<span class="keyword">this</span>, onFinished, handler) <span class="comment">// 创建了 FinishedDispatcher 对象！</span></span><br><span class="line">                        : <span class="keyword">null</span>,</span><br><span class="line">                requiredPermission, options);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> CanceledException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CanceledException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里要注意，我们传入的参数 onFinished 实现对象是 mDeliveryTracker！</p>
<p>这里我们要简单提一下 mTarget，他是 PendingIntent 的内部成员变量，是一个 IIntentSender Binder 对象！我们在调用 PendingIntent.getService 等方法的时候，会有如下的逻辑：</p>
<h3 id="2-1-1-new-FinishedDispatcher"><a href="#2-1-1-new-FinishedDispatcher" class="headerlink" title="2.1.1 new FinishedDispatcher"></a>2.1.1 new FinishedDispatcher</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FinishedDispatcher</span> <span class="keyword">extends</span> <span class="title">IIntentReceiver</span>.<span class="title">Stub</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PendingIntent mPendingIntent;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> OnFinished mWho; <span class="comment">// mDeliveryTracker 对象！</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Handler mHandler;</span><br><span class="line">    <span class="keyword">private</span> Intent mIntent;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mResultCode;</span><br><span class="line">    <span class="keyword">private</span> String mResultData;</span><br><span class="line">    <span class="keyword">private</span> Bundle mResultExtras;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Handler sDefaultSystemHandler;</span><br><span class="line"></span><br><span class="line">    FinishedDispatcher(PendingIntent pi, OnFinished who, Handler handler) &#123;</span><br><span class="line">        mPendingIntent = pi;</span><br><span class="line">        mWho = who;</span><br><span class="line">        <span class="keyword">if</span> (handler == <span class="keyword">null</span> &amp;&amp; ActivityThread.isSystem()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sDefaultSystemHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">                sDefaultSystemHandler = <span class="keyword">new</span> Handler(Looper.getMainLooper());</span><br><span class="line">            &#125;</span><br><span class="line">            mHandler = sDefaultSystemHandler;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mHandler = handler;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果没有传入指定的 Handler，</p>
<h3 id="2-1-2-ActivityMS-sendIntentSender"><a href="#2-1-2-ActivityMS-sendIntentSender" class="headerlink" title="2.1.2 ActivityMS.sendIntentSender"></a>2.1.2 ActivityMS.sendIntentSender</h3><p>PendingIntent.send 方法最终会调用 AMS.sendIntentSender 方法，当然这里涉及到了 PendingIntent 架构和逻辑，这里不做过多的讨论！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sendIntentSender</span><span class="params">(IIntentSender target, <span class="keyword">int</span> code, Intent intent, String resolvedType,</span></span></span><br><span class="line"><span class="function"><span class="params">        IIntentReceiver finishedReceiver, String requiredPermission, Bundle options)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】一般情况，每一个 PendingIntent 都会有一个 PendingIntentRecord 在系统中与之对应！</span></span><br><span class="line">    <span class="comment">// 默认情况下会调用 PendingIntentRecord 的 sendWithResult 方法！</span></span><br><span class="line">    <span class="keyword">if</span> (target <span class="keyword">instanceof</span> PendingIntentRecord) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((PendingIntentRecord)target).sendWithResult(code, intent, resolvedType,</span><br><span class="line">                finishedReceiver, requiredPermission, options);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 下面是特殊情况，我们不关注！</span></span><br><span class="line">        <span class="keyword">if</span> (intent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Slog.wtf(TAG, <span class="string">"Can't use null intent with direct IIntentSender call"</span>);</span><br><span class="line">            intent = <span class="keyword">new</span> Intent(Intent.ACTION_MAIN);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            target.send(code, intent, resolvedType, <span class="keyword">null</span>, requiredPermission, options);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (finishedReceiver != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 处理分发结果！</span></span><br><span class="line">                finishedReceiver.performReceive(intent, <span class="number">0</span>,</span><br><span class="line">                        <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, UserHandle.getCallingUserId());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正常情况下，会调用 PendingIntentRecord.sendWithResult 分发 alarm！</p>
<h3 id="2-1-3-PendingIntentRecord-sendWithResult"><a href="#2-1-3-PendingIntentRecord-sendWithResult" class="headerlink" title="2.1.3 PendingIntentRecord.sendWithResult"></a>2.1.3 PendingIntentRecord.sendWithResult</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sendWithResult</span><span class="params">(<span class="keyword">int</span> code, Intent intent, String resolvedType,</span></span></span><br><span class="line"><span class="function"><span class="params">        IIntentReceiver finishedReceiver, String requiredPermission, Bundle options)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 继续调用 sendInner 方法！</span></span><br><span class="line">    <span class="keyword">return</span> sendInner(code, intent, resolvedType, finishedReceiver,</span><br><span class="line">            requiredPermission, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, options, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-1-4-PendingIntentRecord-sendInner"><a href="#2-1-4-PendingIntentRecord-sendInner" class="headerlink" title="2.1.4 PendingIntentRecord.sendInner"></a>2.1.4 PendingIntentRecord.sendInner</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sendInner</span><span class="params">(<span class="keyword">int</span> code, Intent intent, String resolvedType, IIntentReceiver finishedReceiver,</span></span></span><br><span class="line"><span class="function"><span class="params">        String requiredPermission, IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> flagsMask, <span class="keyword">int</span> flagsValues, Bundle options, IActivityContainer container)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (intent != <span class="keyword">null</span>) intent.setDefusable(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (options != <span class="keyword">null</span>) options.setDefusable(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (whitelistDuration &gt; <span class="number">0</span> &amp;&amp; !canceled) &#123;</span><br><span class="line">        <span class="comment">// Must call before acquiring the lock. It's possible the method return before sending</span></span><br><span class="line">        <span class="comment">// the intent due to some validations inside the lock, in which case the UID shouldn't</span></span><br><span class="line">        <span class="comment">// be whitelisted, but since the whitelist is temporary, that would be ok.</span></span><br><span class="line">        owner.tempWhitelistAppForPowerSave(Binder.getCallingPid(), Binder.getCallingUid(), uid,</span><br><span class="line">                whitelistDuration);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (owner) &#123;</span><br><span class="line">        <span class="keyword">final</span> ActivityContainer activityContainer = (ActivityContainer)container;</span><br><span class="line">        <span class="keyword">if</span> (activityContainer != <span class="keyword">null</span> &amp;&amp; activityContainer.mParentActivity != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                activityContainer.mParentActivity.state</span><br><span class="line">                        != ActivityStack.ActivityState.RESUMED) &#123;</span><br><span class="line">            <span class="comment">// Cannot start a child activity if the parent is not resumed.</span></span><br><span class="line">            <span class="keyword">return</span> ActivityManager.START_CANCELED;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!canceled) &#123;</span><br><span class="line">            sent = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> ((key.flags&amp;PendingIntent.FLAG_ONE_SHOT) != <span class="number">0</span>) &#123;</span><br><span class="line">                owner.cancelIntentSenderLocked(<span class="keyword">this</span>, <span class="keyword">true</span>);</span><br><span class="line">                canceled = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Intent finalIntent = key.requestIntent != <span class="keyword">null</span></span><br><span class="line">                    ? <span class="keyword">new</span> Intent(key.requestIntent) : <span class="keyword">new</span> Intent();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> immutable = (key.flags &amp; PendingIntent.FLAG_IMMUTABLE) != <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (!immutable) &#123;</span><br><span class="line">                <span class="keyword">if</span> (intent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> changes = finalIntent.fillIn(intent, key.flags);</span><br><span class="line">                    <span class="keyword">if</span> ((changes &amp; Intent.FILL_IN_DATA) == <span class="number">0</span>) &#123;</span><br><span class="line">                        resolvedType = key.requestResolvedType;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    resolvedType = key.requestResolvedType;</span><br><span class="line">                &#125;</span><br><span class="line">                flagsMask &amp;= ~Intent.IMMUTABLE_FLAGS;</span><br><span class="line">                flagsValues &amp;= flagsMask;</span><br><span class="line">                finalIntent.setFlags((finalIntent.getFlags() &amp; ~flagsMask) | flagsValues);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resolvedType = key.requestResolvedType;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> sendFinish = finishedReceiver != <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">int</span> userId = key.userId;</span><br><span class="line">            <span class="keyword">if</span> (userId == UserHandle.USER_CURRENT) &#123;</span><br><span class="line">                userId = owner.mUserController.getCurrentOrTargetUserIdLocked();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 根据 alarm 的类型，做不同的处理！</span></span><br><span class="line">            <span class="keyword">switch</span> (key.type) &#123;</span><br><span class="line">                <span class="keyword">case</span> ActivityManager.INTENT_SENDER_ACTIVITY:</span><br><span class="line">                    <span class="keyword">if</span> (options == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        options = key.options;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.options != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        Bundle opts = <span class="keyword">new</span> Bundle(key.options);</span><br><span class="line">                        opts.putAll(options);</span><br><span class="line">                        options = opts;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (key.allIntents != <span class="keyword">null</span> &amp;&amp; key.allIntents.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                            Intent[] allIntents = <span class="keyword">new</span> Intent[key.allIntents.length];</span><br><span class="line">                            String[] allResolvedTypes = <span class="keyword">new</span> String[key.allIntents.length];</span><br><span class="line">                            System.arraycopy(key.allIntents, <span class="number">0</span>, allIntents, <span class="number">0</span>,</span><br><span class="line">                                    key.allIntents.length);</span><br><span class="line">                            <span class="keyword">if</span> (key.allResolvedTypes != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                System.arraycopy(key.allResolvedTypes, <span class="number">0</span>, allResolvedTypes, <span class="number">0</span>,</span><br><span class="line">                                        key.allResolvedTypes.length);</span><br><span class="line">                            &#125;</span><br><span class="line">                            allIntents[allIntents.length-<span class="number">1</span>] = finalIntent;</span><br><span class="line">                            allResolvedTypes[allResolvedTypes.length-<span class="number">1</span>] = resolvedType;</span><br><span class="line">                            owner.startActivitiesInPackage(uid, key.packageName, allIntents,</span><br><span class="line">                                    allResolvedTypes, resultTo, options, userId);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            owner.startActivityInPackage(uid, key.packageName, finalIntent,</span><br><span class="line">                                    resolvedType, resultTo, resultWho, requestCode, <span class="number">0</span>,</span><br><span class="line">                                    options, userId, container, <span class="keyword">null</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">                        Slog.w(TAG, <span class="string">"Unable to send startActivity intent"</span>, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ActivityManager.INTENT_SENDER_ACTIVITY_RESULT:</span><br><span class="line">                    <span class="keyword">if</span> (key.activity.task.stack != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        key.activity.task.stack.sendActivityResultLocked(-<span class="number">1</span>, key.activity,</span><br><span class="line">                                key.who, key.requestCode, code, finalIntent);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ActivityManager.INTENT_SENDER_BROADCAST:</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// If a completion callback has been requested, require</span></span><br><span class="line">                        <span class="comment">// that the broadcast be delivered synchronously</span></span><br><span class="line">                        <span class="keyword">int</span> sent = owner.broadcastIntentInPackage(key.packageName, uid,</span><br><span class="line">                                finalIntent, resolvedType, finishedReceiver, code, <span class="keyword">null</span>, <span class="keyword">null</span>,</span><br><span class="line">                                requiredPermission, options, (finishedReceiver != <span class="keyword">null</span>),</span><br><span class="line">                                <span class="keyword">false</span>, userId);</span><br><span class="line">                        <span class="keyword">if</span> (sent == ActivityManager.BROADCAST_SUCCESS) &#123;</span><br><span class="line">                            sendFinish = <span class="keyword">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">                        Slog.w(TAG, <span class="string">"Unable to send startActivity intent"</span>, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> ActivityManager.INTENT_SENDER_SERVICE:</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        owner.startServiceInPackage(uid, finalIntent,</span><br><span class="line">                                resolvedType, key.packageName, userId);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">                        Slog.w(TAG, <span class="string">"Unable to send startService intent"</span>, e);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (TransactionTooLargeException e) &#123;</span><br><span class="line">                        res = ActivityManager.START_CANCELED;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 处理分发结果！</span></span><br><span class="line">            <span class="keyword">if</span> (sendFinish &amp;&amp; res != ActivityManager.START_CANCELED) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    finishedReceiver.performReceive(<span class="keyword">new</span> Intent(finalIntent), <span class="number">0</span>,</span><br><span class="line">                            <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, key.userId);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Binder.restoreCallingIdentity(origId);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ActivityManager.START_CANCELED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-Alarm-Listener-doAlarm"><a href="#2-2-Alarm-Listener-doAlarm" class="headerlink" title="2.2 Alarm.Listener.doAlarm"></a>2.2 Alarm.Listener.doAlarm</h2><p>Alarm.Listener 是一个 Binder 对象，其服务端是应用进程的 ListenerWrapper 对象，之前我们知道 ListenerWrapper 实现了 IAlarmListener.Stub：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="3-特殊的触发路径"><a href="#3-特殊的触发路径" class="headerlink" title="3 特殊的触发路径"></a>3 特殊的触发路径</h1><p>如果没有 Alarm 驱动，那么我们知道 Alarm 的触发是通过内部的一个 AlarmHandler 实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setLocked</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">long</span> when)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mNativeData != <span class="number">0</span>) &#123;</span><br><span class="line">        ... ... ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Message msg = Message.obtain();</span><br><span class="line">        msg.what = ALARM_EVENT;</span><br><span class="line">        mHandler.removeMessages(ALARM_EVENT);</span><br><span class="line">        mHandler.sendMessageAtTime(msg, when);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，最后发送的是 ALARM_EVENT 给 AlarmHandler：</p>
<h2 id="3-1-AlarmHandler-handleMessage-ALARM-EVENT"><a href="#3-1-AlarmHandler-handleMessage-ALARM-EVENT" class="headerlink" title="3.1 AlarmHandler.handleMessage[ALARM_EVENT]"></a>3.1 AlarmHandler.handleMessage[ALARM_EVENT]</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">        <span class="keyword">case</span> ALARM_EVENT: &#123;</span><br><span class="line">            <span class="comment">// 同样的 triggerList！</span></span><br><span class="line">            ArrayList&lt;Alarm&gt; triggerList = <span class="keyword">new</span> ArrayList&lt;Alarm&gt;();</span><br><span class="line">            <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> nowRTC = System.currentTimeMillis();</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> nowELAPSED = SystemClock.elapsedRealtime();</span><br><span class="line">                <span class="comment">// 调用 triggerAlarmsLocked 收集触发的 alarm！</span></span><br><span class="line">                triggerAlarmsLocked(triggerList, nowELAPSED, nowRTC);</span><br><span class="line">                updateNextAlarmClockLocked(); <span class="comment">// 更新下一个 AlarmClock</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 分发 Alarm！</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;triggerList.size(); i++) &#123;</span><br><span class="line">                Alarm alarm = triggerList.get(i);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    alarm.operation.send(); <span class="comment">// 这里再次调用了 PendingIntent 的 send 方法！</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (PendingIntent.CanceledException e) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (alarm.repeatInterval &gt; <span class="number">0</span>) &#123; <span class="comment">// 发送出问题，如果是重复性 Alarm，那就移除该 Alarm！</span></span><br><span class="line">                        removeImpl(alarm.operation);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法逻辑很简单，不多说了！</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Coolqi.Li</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lishuaiqi.top/2017/08/15/AlarmManager3-triggerAlarm/">https://lishuaiqi.top/2017/08/15/AlarmManager3-triggerAlarm/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lishuaiqi.top">Coolqi`s Blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/AlarmManager闹钟管理/">AlarmManager闹钟管理</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="/img/zfb.jpg"><div class="post-qr-code__desc">支付宝打赏</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="/img/wechat.jpg"><div class="post-qr-code__desc">微信打赏</div></div></div><div class="social-share"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2017/08/25/Permission5-grantPermission/"><i class="fa fa-chevron-left">  </i><span>Permission第 5 篇 - grantPermission 权限授予</span></a></div><div class="next-post pull-right"><a href="/2017/08/13/AppOps2-AppOpsManager/"><span>AppOps 第 2 篇 - AppOpsManager 分析</span><i class="fa fa-chevron-right"></i></a></div></nav><script data-ad-client="ca-pub-6845729157331145" async="" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2015 - 2020 By Coolqi.Li</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://lishuaiqi.top/">blog</a>!</div><div class="busuanzi"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.6"></script><script src="/js/fancybox.js?version=1.5.6"></script><script src="/js/sidebar.js?version=1.5.6"></script><script src="/js/copy.js?version=1.5.6"></script><script src="/js/fireworks.js?version=1.5.6"></script><script src="/js/transition.js?version=1.5.6"></script><script src="/js/scroll.js?version=1.5.6"></script><script src="/js/head.js?version=1.5.6"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="/js/search/local-search.js"></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>