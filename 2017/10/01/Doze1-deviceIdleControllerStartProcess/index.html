<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Doze模式第 1 篇 - DeviceIdleController 的启动"><meta name="keywords" content="Doze假寐模式"><meta name="author" content="Coolqi.Li,undefined"><meta name="copyright" content="Coolqi.Li"><title>Doze模式第 1 篇 - DeviceIdleController 的启动 | Coolqi`s Blog</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.5.6"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css?version=1.5.6"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/gh/upupming/gitalk@36368e5dffd049e956cdbbd751ff96c28d8255cf/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?b7acef5306e54116ad8a99e8b753a92d";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#0-综述"><span class="toc-text">0 综述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-new-DeviceIdleController"><span class="toc-text">1 new DeviceIdleController</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-new-MyHandler"><span class="toc-text">1.1 new MyHandler</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-DeviceIdleController-onStart"><span class="toc-text">2 DeviceIdleController.onStart</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-new-Constants"><span class="toc-text">2.1 new Constants</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-Constants-updateConstants"><span class="toc-text">2.1.1 Constants.updateConstants</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-Constants-常量"><span class="toc-text">2.1.2 Constants 常量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-1-Light-Idle-常量"><span class="toc-text">2.1.2.1 Light Idle 常量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-2-Deep-Idle-常量"><span class="toc-text">2.1.2.2 Deep Idle 常量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-2-3-其他相关变量"><span class="toc-text">2.1.2.3 其他相关变量</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-DeviceIdleController-readConfigFileLocked"><span class="toc-text">2.2 DeviceIdleController.readConfigFileLocked</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-DeviceIdleController-updateWhitelistAppIdsLocked"><span class="toc-text">2.3 DeviceIdleController.updateWhitelistAppIdsLocked</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-DeviceIdleController-buildAppIdArray"><span class="toc-text">2.3.1 DeviceIdleController.buildAppIdArray</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-new-BinderService"><span class="toc-text">2.4 new BinderService</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-new-LocalService"><span class="toc-text">2.5 new LocalService</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-DeviceIdleController-onBootPhase"><span class="toc-text">3 DeviceIdleController.onBootPhase</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-new-BroadcastReceiver"><span class="toc-text">3.1 new BroadcastReceiver</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1-DeviceIdleController-removePowerSaveWhitelistAppInternal"><span class="toc-text">3.1.1 DeviceIdleController.removePowerSaveWhitelistAppInternal</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-register-DisplayListener"><span class="toc-text">3.2 register DisplayListener</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-DeviceIdleController-updateDisplayLocked"><span class="toc-text">3.2.1 DeviceIdleController.updateDisplayLocked</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-DeviceIdleController-updateConnectivityState"><span class="toc-text">3.3 DeviceIdleController.updateConnectivityState</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-启动总结"><span class="toc-text">4 启动总结</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Coolqi.Li</div><div class="author-info__description text-center">“你好，我是李帅奇，Android 系统工程师，MineCraft 忠实玩家，设计和绘画爱好者，缺妹纸晚期患者，熬夜星人。”</div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">66</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">15</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">17</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="https://developer.android.google.cn/">AndroidDeveloper</a><a class="author-info-links__name text-center" href="http://www.android-studio.org/">AndroidStudio</a><a class="author-info-links__name text-center" href="https://www.jianshu.com/u/123a20a96441">简书</a><a class="author-info-links__name text-center" href="https://weibo.com/coolqiLi">微博</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://ws1.sinaimg.cn/large/8700af19ly1fvpabr30o6j22yo1o0q7i.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Coolqi`s Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/about">About</a></span></div><div id="post-info"><div id="post-title">Doze模式第 1 篇 - DeviceIdleController 的启动</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2017-10-01</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/AndroidFramework源码分析/">AndroidFramework源码分析</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/AndroidFramework源码分析/Doze假寐模式/">Doze假寐模式</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">5.9k</span><span class="post-meta__separator">|</span><span>阅读时长: 26 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>[toc]</p>
<p>基于 Android 7.1.1 源码，分析 doze 模式的原理！</p>
<h1 id="0-综述"><a href="#0-综述" class="headerlink" title="0 综述"></a>0 综述</h1><p>下面是 Android devoloper 网站对于 doze 模式的介绍：</p>
<p><img src="http://static.zybuluo.com/Coolqi/pd1xtpoar5dltrz0ze180ark/image.png" alt="image.png-61.3kB"></p>
<p>从 Android 6.0（API 级别 23）开始，Android 引入了两个省电功能，可通过管理应用在设备未连接至电源时的行为方式为用户延长电池寿命。</p>
<ul>
<li><p>低电耗模式（doze）通过在设备长时间处于闲置状态时推迟应用的后台 CPU 和网络操作来减少电池消耗。</p>
</li>
<li><p>应用待机模式可推迟用户近期未与之交互的应用的后台 Activity 的网络操作。</p>
</li>
</ul>
<p>假设一个用户停止充电 (on battery: 利用电池供电)，关闭屏幕 (screen off)。手机处于静止状态 (stationary)。保持以上条件一段时间之后，系统就会进入 Doze 模式。一旦进入 Doze 模式。系统就降低 (延缓) 应用对网络的訪问、以及对 CPU 的占用，来节省电池电量。</p>
<p>这一系列的文章先来分析下低电耗模式!</p>
<p>在低电耗 doze 模式下，应用会受到以下限制：</p>
<ul>
<li>暂停访问 <strong>Network</strong>。</li>
<li>系统将忽略 <strong>Wake Locks</strong>。</li>
<li>标准 <strong>AlarmManager</strong> 闹铃（包括 setExact() 和 setWindow()）推迟到 doze 模式的下一个 maintenance window 时间窗。<ul>
<li>如果您需要设置在低电耗模式下触发的闹铃，请使用 setAndAllowWhileIdle() 或 setExactAndAllowWhileIdle()。</li>
<li>一般情况下，使用 setAlarmClock() 设置的闹铃将继续触发，但系统会在这些闹铃触发之前不久退出低电耗模式。</li>
</ul>
</li>
<li>系统不执行 <strong>WiFi</strong> 扫描。</li>
<li>系统不允许运行 <strong>Sync</strong> 同步适配器。</li>
<li>系统不允许运行 <strong>JobScheduler</strong>。</li>
</ul>
<p>doze 模式的核心实现在 DeviceIdleController 中，下面我们来看看 DeviceIdleController 的启动！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startOtherServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Context context = mSystemContext;</span><br><span class="line">    ... ... ...</span><br><span class="line">    <span class="keyword">if</span> (mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!disableNonCoreServices) &#123;</span><br><span class="line">            traceBeginAndSlog(<span class="string">"StartLockSettingsService"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mSystemServiceManager.startService(LOCK_SETTINGS_SERVICE_CLASS);</span><br><span class="line">                lockSettings = ILockSettings.Stub.asInterface(</span><br><span class="line">                        ServiceManager.getService(<span class="string">"lock_settings"</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                reportWtf(<span class="string">"starting LockSettingsService service"</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!SystemProperties.get(PERSISTENT_DATA_BLOCK_PROP).equals(<span class="string">""</span>)) &#123;</span><br><span class="line">                mSystemServiceManager.startService(PersistentDataBlockService.class);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//【1】启动 DeviceIdleController 服务！</span></span><br><span class="line">            mSystemServiceManager.startService(DeviceIdleController.class);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Always start the Device Policy Manager, so that the API is compatible with</span></span><br><span class="line">            <span class="comment">// API8.</span></span><br><span class="line">            mSystemServiceManager.startService(DevicePolicyManagerService.Lifecycle.class);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ... ... ...</span><br><span class="line">    &#125;</span><br><span class="line">    ... ... ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动 DeviceIdleController 的时机是在 SystemServer.startOtherServices 方法中！</p>
<h1 id="1-new-DeviceIdleController"><a href="#1-new-DeviceIdleController" class="headerlink" title="1 new DeviceIdleController"></a>1 new DeviceIdleController</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DeviceIdleController</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(context);</span><br><span class="line">    mConfigFile = <span class="keyword">new</span> AtomicFile(<span class="keyword">new</span> File(getSystemDir(), <span class="string">"deviceidle.xml"</span>));</span><br><span class="line">    <span class="comment">//【1.1】处理耗时操作！</span></span><br><span class="line">    mHandler = <span class="keyword">new</span> MyHandler(BackgroundThread.getHandler().getLooper());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置文件：</p>
<p>位于 /data/system/deviceidle.xml 中！</p>
<h2 id="1-1-new-MyHandler"><a href="#1-1-new-MyHandler" class="headerlink" title="1.1 new MyHandler"></a>1.1 new MyHandler</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    MyHandler(Looper looper) &#123;</span><br><span class="line">        <span class="keyword">super</span>(looper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">"handleMessage("</span> + msg.what + <span class="string">")"</span>);</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="keyword">case</span> MSG_WRITE_CONFIG: &#123; <span class="comment">//【1】更新持久化文件！</span></span><br><span class="line">                handleWriteConfigFile();</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">case</span> MSG_REPORT_IDLE_ON: <span class="comment">//【2】进入 device idle 状态</span></span><br><span class="line">            <span class="keyword">case</span> MSG_REPORT_IDLE_ON_LIGHT: &#123;</span><br><span class="line">                ... ... ...</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">case</span> MSG_REPORT_IDLE_OFF: &#123; <span class="comment">//【3】进入时间窗 window </span></span><br><span class="line">                ... ... ...</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">case</span> MSG_REPORT_ACTIVE: &#123;<span class="comment">//【4】退出 doze 模式，处于 active 状态</span></span><br><span class="line">                ... ... ...</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">case</span> MSG_TEMP_APP_WHITELIST_TIMEOUT: &#123; <span class="comment">//【5】device idle 临时白名单超时移除操作！</span></span><br><span class="line">                <span class="keyword">int</span> uid = msg.arg1; </span><br><span class="line">                checkTempAppWhitelistTimeout(uid);</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">case</span> MSG_REPORT_MAINTENANCE_ACTIVITY: &#123;</span><br><span class="line">                <span class="keyword">boolean</span> active = (msg.arg1 == <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> size = mMaintenanceActivityListeners.beginBroadcast();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            mMaintenanceActivityListeners.getBroadcastItem(i)</span><br><span class="line">                                    .onMaintenanceActivityChanged(active);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (RemoteException ignored) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    mMaintenanceActivityListeners.finishBroadcast();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">case</span> MSG_FINISH_IDLE_OP: &#123;</span><br><span class="line">                decActiveIdleOps();</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到，MyHandler 绑定到了一个后台线程，他会在后台线程中做一些比较耗时的操作！</p>
<h1 id="2-DeviceIdleController-onStart"><a href="#2-DeviceIdleController-onStart" class="headerlink" title="2 DeviceIdleController.onStart"></a>2 DeviceIdleController.onStart</h1><p>接着是进入 onStart 方法！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> PackageManager pm = getContext().getPackageManager();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">//【1】获得 deep mode 和 light mode 的属性配置！</span></span><br><span class="line">        mLightEnabled = mDeepEnabled = getContext().getResources().getBoolean(</span><br><span class="line">                com.android.internal.R.bool.config_enableAutoPowerModes);</span><br><span class="line">                </span><br><span class="line">        <span class="comment">//【2】从 SystemConfig 中获得解析到了 doze 模式白名单！</span></span><br><span class="line">        <span class="comment">// 获取在 power save 模式下可以运行，但在 device Idle (doze) 模式下不能运行的系统应用名单！</span></span><br><span class="line">        SystemConfig sysConfig = SystemConfig.getInstance();</span><br><span class="line">        ArraySet&lt;String&gt; allowPowerExceptIdle = sysConfig.getAllowInPowerSaveExceptIdle();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;allowPowerExceptIdle.size(); i++) &#123;</span><br><span class="line">            String pkg = allowPowerExceptIdle.valueAt(i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ApplicationInfo ai = pm.getApplicationInfo(pkg,</span><br><span class="line">                        PackageManager.MATCH_SYSTEM_ONLY);</span><br><span class="line">                <span class="keyword">int</span> appid = UserHandle.getAppId(ai.uid);</span><br><span class="line">                mPowerSaveWhitelistAppsExceptIdle.put(ai.packageName, appid);</span><br><span class="line">                mPowerSaveWhitelistSystemAppIdsExceptIdle.put(appid, <span class="keyword">true</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【3】获取在 power save 模式下能够执行的系统应用名单！</span></span><br><span class="line">        ArraySet&lt;String&gt; allowPower = sysConfig.getAllowInPowerSave();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;allowPower.size(); i++) &#123;</span><br><span class="line">            String pkg = allowPower.valueAt(i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ApplicationInfo ai = pm.getApplicationInfo(pkg,</span><br><span class="line">                        PackageManager.MATCH_SYSTEM_ONLY);</span><br><span class="line">                <span class="keyword">int</span> appid = UserHandle.getAppId(ai.uid);</span><br><span class="line">                <span class="comment">//【3.1】在 power save 模式下能够执行的系统应用，也不能在 doze 模式下运行，</span></span><br><span class="line">                <span class="comment">// 所以也加入了上面的集合！</span></span><br><span class="line">                mPowerSaveWhitelistAppsExceptIdle.put(ai.packageName, appid);</span><br><span class="line">                mPowerSaveWhitelistSystemAppIdsExceptIdle.put(appid, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">                mPowerSaveWhitelistApps.put(ai.packageName, appid);</span><br><span class="line">                mPowerSaveWhitelistSystemAppIds.put(appid, <span class="keyword">true</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【*2.1】创建 Constants 实例，继承 ContentObserver，用于监控数据库变化，</span></span><br><span class="line">        <span class="comment">// 同时也定义了 Doze 模式中的一些时间间隔常量！</span></span><br><span class="line">        mConstants = <span class="keyword">new</span> Constants(mHandler, getContext().getContentResolver());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【*2.2】读取持久化的配置 deviceidle.xml，并将当中定义的 package </span></span><br><span class="line">        <span class="comment">// 增加到 mPowerSaveWhitelistUserApps 中！</span></span><br><span class="line">        readConfigFileLocked();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【*2.3】更新名单！</span></span><br><span class="line">        updateWhitelistAppIdsLocked();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【4】初始化状态变量！</span></span><br><span class="line">        mNetworkConnected = <span class="keyword">true</span>;</span><br><span class="line">        mScreenOn = <span class="keyword">true</span>;</span><br><span class="line">        mCharging = <span class="keyword">true</span>;</span><br><span class="line">        mState = STATE_ACTIVE;</span><br><span class="line">        mLightState = LIGHT_STATE_ACTIVE;</span><br><span class="line">        mInactiveTimeout = mConstants.INACTIVE_TIMEOUT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2.4】创建 BinderService 对象，作为 DeviceIdleController 服务桩对象，</span></span><br><span class="line">    <span class="comment">// 并添加到 ServiceManager 中，用于和其他进程通信！</span></span><br><span class="line">    mBinderService = <span class="keyword">new</span> BinderService();</span><br><span class="line">    publishBinderService(Context.DEVICE_IDLE_CONTROLLER, mBinderService);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2.5】创建对应的 LocalService，方便于进程内部通信！</span></span><br><span class="line">    publishLocalService(LocalService.class, <span class="keyword">new</span> LocalService());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>SystemConfig</strong> 我们之前在分析 PMS 的启动的时候有涉及到，SystemConfig 会用来解析系统的配置信息！</p>
<p>这里涉及到了两个内部变量！</p>
<p>DeviceIdleController 提供了 2 中模式： mLightEnabled 和 mDeepEnabled！</p>
<ul>
<li><p><strong>deep idle 模式</strong>：会禁止 NetWork、Wakelock，还会禁止 Alarm。</p>
</li>
<li><p><strong>light idle 模式</strong>：会禁止 NetWork、Wakelock，但是不会禁止 Alarm。</p>
</li>
</ul>
<p>通过 config_enableAutoPowerModes 属性进行初始化，默认是 mLightEnabled = mDeepEnabled = false！</p>
<p>我们再来看下这里涉及到的重要集合：</p>
<ul>
<li><p><strong>mPowerSaveWhitelistAppsExceptIdle</strong>：保存在 power save 模式下可以后台运行，但在 doze 模式下不能后台运行的系统应用名单，packageName 和 appId 的映射！</p>
</li>
<li><p><strong>mPowerSaveWhitelistSystemAppIdsExceptIdle</strong>：保存在 power save 模式下后台运行运行，但在 doze 模式下不能后台运行的系统应用名单，appId 和 true 的映射！</p>
</li>
<li><p><strong>mPowerSaveWhitelistApps</strong>：保存在 power save 模式下可以后台运行的系统应用程序，packageName 和 appId 的映射！</p>
</li>
<li><p><strong>mPowerSaveWhitelistSystemAppIds</strong>：保存在 power save 模式下可以后台运行的系统应用程序，appId 和 true 的映射！</p>
</li>
</ul>
<h2 id="2-1-new-Constants"><a href="#2-1-new-Constants" class="headerlink" title="2.1 new Constants"></a>2.1 new Constants</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Constants</span><span class="params">(Handler handler, ContentResolver resolver)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(handler);</span><br><span class="line">    mResolver = resolver;</span><br><span class="line">    mHasWatch = getContext().getPackageManager().hasSystemFeature(</span><br><span class="line">            PackageManager.FEATURE_WATCH);</span><br><span class="line">    <span class="comment">//【1】监控数据的变化！</span></span><br><span class="line">    mResolver.registerContentObserver(Settings.Global.getUriFor(</span><br><span class="line">            mHasWatch ? Settings.Global.DEVICE_IDLE_CONSTANTS_WATCH</span><br><span class="line">                      : Settings.Global.DEVICE_IDLE_CONSTANTS),</span><br><span class="line">            <span class="keyword">false</span>, <span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//【2.1.1】更新常量值！</span></span><br><span class="line">    updateConstants();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 Constants 会监控数据库的变化，这里先做了一个 feature 的判断：PackageManager.FEATURE_WATCH，判断当前设备是否是可穿戴设备：watch！</p>
<p>因为这里我们关注的是手机设备，所以 Constants 监控的数据库是：Settings.Global.DEVICE_IDLE_CONSTANTS（device_idle_constants）</p>
<h3 id="2-1-1-Constants-updateConstants"><a href="#2-1-1-Constants-updateConstants" class="headerlink" title="2.1.1 Constants.updateConstants"></a>2.1.1 Constants.updateConstants</h3><p>updateConstants 会从 device_idle_constants 数据库中读取属性值，初始化一些关键的常量信息，如果读取不到，会初始化为默认值！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateConstants</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (DeviceIdleController.<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//【1】读取数据库的值！</span></span><br><span class="line">            mParser.setString(Settings.Global.getString(mResolver,</span><br><span class="line">                    mHasWatch ? Settings.Global.DEVICE_IDLE_CONSTANTS_WATCH</span><br><span class="line">                              : Settings.Global.DEVICE_IDLE_CONSTANTS));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">            Slog.e(TAG, <span class="string">"Bad device idle settings"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【2】初始化关键性常量！</span></span><br><span class="line">        LIGHT_IDLE_AFTER_INACTIVE_TIMEOUT = mParser.getLong(</span><br><span class="line">                KEY_LIGHT_IDLE_AFTER_INACTIVE_TIMEOUT,</span><br><span class="line">                !COMPRESS_TIME ? <span class="number">5</span> * <span class="number">60</span> * <span class="number">1000L</span> : <span class="number">15</span> * <span class="number">1000L</span>);</span><br><span class="line">        LIGHT_PRE_IDLE_TIMEOUT = mParser.getLong(KEY_LIGHT_PRE_IDLE_TIMEOUT,</span><br><span class="line">                !COMPRESS_TIME ? <span class="number">10</span> * <span class="number">60</span> * <span class="number">1000L</span> : <span class="number">30</span> * <span class="number">1000L</span>);</span><br><span class="line">        LIGHT_IDLE_TIMEOUT = mParser.getLong(KEY_LIGHT_IDLE_TIMEOUT,</span><br><span class="line">                !COMPRESS_TIME ? <span class="number">5</span> * <span class="number">60</span> * <span class="number">1000L</span> : <span class="number">15</span> * <span class="number">1000L</span>);</span><br><span class="line">        LIGHT_IDLE_FACTOR = mParser.getFloat(KEY_LIGHT_IDLE_FACTOR,</span><br><span class="line">                <span class="number">2f</span>);</span><br><span class="line">        LIGHT_MAX_IDLE_TIMEOUT = mParser.getLong(KEY_LIGHT_MAX_IDLE_TIMEOUT,</span><br><span class="line">                !COMPRESS_TIME ? <span class="number">15</span> * <span class="number">60</span> * <span class="number">1000L</span> : <span class="number">60</span> * <span class="number">1000L</span>);</span><br><span class="line">        LIGHT_IDLE_MAINTENANCE_MIN_BUDGET = mParser.getLong(</span><br><span class="line">                KEY_LIGHT_IDLE_MAINTENANCE_MIN_BUDGET,</span><br><span class="line">                !COMPRESS_TIME ? <span class="number">1</span> * <span class="number">60</span> * <span class="number">1000L</span> : <span class="number">15</span> * <span class="number">1000L</span>);</span><br><span class="line">        LIGHT_IDLE_MAINTENANCE_MAX_BUDGET = mParser.getLong(</span><br><span class="line">                KEY_LIGHT_IDLE_MAINTENANCE_MAX_BUDGET,</span><br><span class="line">                !COMPRESS_TIME ? <span class="number">5</span> * <span class="number">60</span> * <span class="number">1000L</span> : <span class="number">30</span> * <span class="number">1000L</span>);</span><br><span class="line">        MIN_LIGHT_MAINTENANCE_TIME = mParser.getLong(</span><br><span class="line">                KEY_MIN_LIGHT_MAINTENANCE_TIME,</span><br><span class="line">                !COMPRESS_TIME ? <span class="number">5</span> * <span class="number">1000L</span> : <span class="number">1</span> * <span class="number">1000L</span>);</span><br><span class="line">        MIN_DEEP_MAINTENANCE_TIME = mParser.getLong(</span><br><span class="line">                KEY_MIN_DEEP_MAINTENANCE_TIME,</span><br><span class="line">                !COMPRESS_TIME ? <span class="number">30</span> * <span class="number">1000L</span> : <span class="number">5</span> * <span class="number">1000L</span>);</span><br><span class="line">        <span class="keyword">long</span> inactiveTimeoutDefault = (mHasWatch ? <span class="number">15</span> : <span class="number">30</span>) * <span class="number">60</span> * <span class="number">1000L</span>;</span><br><span class="line">        INACTIVE_TIMEOUT = mParser.getLong(KEY_INACTIVE_TIMEOUT,</span><br><span class="line">                !COMPRESS_TIME ? inactiveTimeoutDefault : (inactiveTimeoutDefault / <span class="number">10</span>));</span><br><span class="line">        SENSING_TIMEOUT = mParser.getLong(KEY_SENSING_TIMEOUT,</span><br><span class="line">                !DEBUG ? <span class="number">4</span> * <span class="number">60</span> * <span class="number">1000L</span> : <span class="number">60</span> * <span class="number">1000L</span>);</span><br><span class="line">        LOCATING_TIMEOUT = mParser.getLong(KEY_LOCATING_TIMEOUT,</span><br><span class="line">                !DEBUG ? <span class="number">30</span> * <span class="number">1000L</span> : <span class="number">15</span> * <span class="number">1000L</span>);</span><br><span class="line">        LOCATION_ACCURACY = mParser.getFloat(KEY_LOCATION_ACCURACY, <span class="number">20</span>);</span><br><span class="line">        MOTION_INACTIVE_TIMEOUT = mParser.getLong(KEY_MOTION_INACTIVE_TIMEOUT,</span><br><span class="line">                !COMPRESS_TIME ? <span class="number">10</span> * <span class="number">60</span> * <span class="number">1000L</span> : <span class="number">60</span> * <span class="number">1000L</span>);</span><br><span class="line">        <span class="keyword">long</span> idleAfterInactiveTimeout = (mHasWatch ? <span class="number">15</span> : <span class="number">30</span>) * <span class="number">60</span> * <span class="number">1000L</span>;</span><br><span class="line">        IDLE_AFTER_INACTIVE_TIMEOUT = mParser.getLong(KEY_IDLE_AFTER_INACTIVE_TIMEOUT,</span><br><span class="line">                !COMPRESS_TIME ? idleAfterInactiveTimeout</span><br><span class="line">                               : (idleAfterInactiveTimeout / <span class="number">10</span>));</span><br><span class="line">        IDLE_PENDING_TIMEOUT = mParser.getLong(KEY_IDLE_PENDING_TIMEOUT,</span><br><span class="line">                !COMPRESS_TIME ? <span class="number">5</span> * <span class="number">60</span> * <span class="number">1000L</span> : <span class="number">30</span> * <span class="number">1000L</span>);</span><br><span class="line">        MAX_IDLE_PENDING_TIMEOUT = mParser.getLong(KEY_MAX_IDLE_PENDING_TIMEOUT,</span><br><span class="line">                !COMPRESS_TIME ? <span class="number">10</span> * <span class="number">60</span> * <span class="number">1000L</span> : <span class="number">60</span> * <span class="number">1000L</span>);</span><br><span class="line">        IDLE_PENDING_FACTOR = mParser.getFloat(KEY_IDLE_PENDING_FACTOR,</span><br><span class="line">                <span class="number">2f</span>);</span><br><span class="line">        IDLE_TIMEOUT = mParser.getLong(KEY_IDLE_TIMEOUT,</span><br><span class="line">                !COMPRESS_TIME ? <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000L</span> : <span class="number">6</span> * <span class="number">60</span> * <span class="number">1000L</span>);</span><br><span class="line">        MAX_IDLE_TIMEOUT = mParser.getLong(KEY_MAX_IDLE_TIMEOUT,</span><br><span class="line">                !COMPRESS_TIME ? <span class="number">6</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000L</span> : <span class="number">30</span> * <span class="number">60</span> * <span class="number">1000L</span>);</span><br><span class="line">        IDLE_FACTOR = mParser.getFloat(KEY_IDLE_FACTOR,</span><br><span class="line">                <span class="number">2f</span>);</span><br><span class="line">        MIN_TIME_TO_ALARM = mParser.getLong(KEY_MIN_TIME_TO_ALARM,</span><br><span class="line">                !COMPRESS_TIME ? <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000L</span> : <span class="number">6</span> * <span class="number">60</span> * <span class="number">1000L</span>);</span><br><span class="line">        MAX_TEMP_APP_WHITELIST_DURATION = mParser.getLong(</span><br><span class="line">                KEY_MAX_TEMP_APP_WHITELIST_DURATION, <span class="number">5</span> * <span class="number">60</span> * <span class="number">1000L</span>);</span><br><span class="line">        MMS_TEMP_APP_WHITELIST_DURATION = mParser.getLong(</span><br><span class="line">                KEY_MMS_TEMP_APP_WHITELIST_DURATION, <span class="number">60</span> * <span class="number">1000L</span>);</span><br><span class="line">        SMS_TEMP_APP_WHITELIST_DURATION = mParser.getLong(</span><br><span class="line">                KEY_SMS_TEMP_APP_WHITELIST_DURATION, <span class="number">20</span> * <span class="number">1000L</span>);</span><br><span class="line">        NOTIFICATION_WHITELIST_DURATION = mParser.getLong(</span><br><span class="line">                KEY_NOTIFICATION_WHITELIST_DURATION, <span class="number">30</span> * <span class="number">1000L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 COMPRESS_TIME 为 false！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> COMPRESS_TIME = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure>
<h3 id="2-1-2-Constants-常量"><a href="#2-1-2-Constants-常量" class="headerlink" title="2.1.2 Constants 常量"></a>2.1.2 Constants 常量</h3><p>从上面可以看到，doze 模式下涉及到很多和时间相关的值，这里我们来解释一下：</p>
<h4 id="2-1-2-1-Light-Idle-常量"><a href="#2-1-2-1-Light-Idle-常量" class="headerlink" title="2.1.2.1 Light Idle 常量"></a>2.1.2.1 Light Idle 常量</h4><ul>
<li><strong>LIGHT_IDLE_AFTER_INACTIVE_TIMEOUT</strong><br>light idle 时间属性，取值为 5 mins，当设备进入灭屏不充电的状态时，需要持续的时间!</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LIGHT_IDLE_AFTER_INACTIVE_TIMEOUT = mParser.getLong(</span><br><span class="line">        KEY_LIGHT_IDLE_AFTER_INACTIVE_TIMEOUT,</span><br><span class="line">        !COMPRESS_TIME ? <span class="number">5</span> * <span class="number">60</span> * <span class="number">1000L</span> : <span class="number">15</span> * <span class="number">1000L</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>LIGHT_PRE_IDLE_TIMEOUT</strong><br>light idle 时间属性，取值为 10 mins，在进入 LIGHT_STATE_PRE_IDLE 阶段之前，如果判断设备有活跃操作执行的话，我们会设置一个 10mins 以后的 Alarm，等待这些操作执行完成，再进入 LIGHT_STATE_PRE_IDLE 阶段的处理！ </li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LIGHT_PRE_IDLE_TIMEOUT = mParser.getLong(KEY_LIGHT_PRE_IDLE_TIMEOUT,</span><br><span class="line">        !COMPRESS_TIME ? <span class="number">10</span> * <span class="number">60</span> * <span class="number">1000L</span> : <span class="number">30</span> * <span class="number">1000L</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>LIGHT_IDLE_TIMEOUT</strong><br>light idle 时间属性，取值为 5 mins，表示 light idle 的最小持续时间，也是第一次进入 light idle 的持续时间！</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LIGHT_IDLE_TIMEOUT = mParser.getLong(KEY_LIGHT_IDLE_TIMEOUT,</span><br><span class="line">        !COMPRESS_TIME ? <span class="number">5</span> * <span class="number">60</span> * <span class="number">1000L</span> : <span class="number">15</span> * <span class="number">1000L</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>LIGHT_IDLE_FACTOR</strong><br>light idle 时间属性，取值为 2f, light idle 持续时间因子！</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LIGHT_IDLE_FACTOR = mParser.getFloat(KEY_LIGHT_IDLE_FACTOR, <span class="number">2f</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>LIGHT_MAX_IDLE_TIMEOUT</strong><br>light idle 时间属性，取值为 15 mins，表示 light idle 的最大持续时间！</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LIGHT_MAX_IDLE_TIMEOUT = mParser.getLong(KEY_LIGHT_MAX_IDLE_TIMEOUT,</span><br><span class="line">        !COMPRESS_TIME ? <span class="number">15</span> * <span class="number">60</span> * <span class="number">1000L</span> : <span class="number">60</span> * <span class="number">1000L</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>LIGHT_IDLE_MAINTENANCE_MIN_BUDGET</strong><br>light idle 时间属性，取值为 1mins, light idle 的最小时间窗！</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LIGHT_IDLE_MAINTENANCE_MIN_BUDGET = mParser.getLong(</span><br><span class="line">        KEY_LIGHT_IDLE_MAINTENANCE_MIN_BUDGET,</span><br><span class="line">        !COMPRESS_TIME ? <span class="number">1</span> * <span class="number">60</span> * <span class="number">1000L</span> : <span class="number">15</span> * <span class="number">1000L</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>LIGHT_IDLE_MAINTENANCE_MAX_BUDGET</strong><br>light idle 时间属性，取值为 5mins, light idle 的最大时间窗！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LIGHT_IDLE_MAINTENANCE_MAX_BUDGET = mParser.getLong(</span><br><span class="line">        KEY_LIGHT_IDLE_MAINTENANCE_MAX_BUDGET,</span><br><span class="line">        !COMPRESS_TIME ? <span class="number">5</span> * <span class="number">60</span> * <span class="number">1000L</span> : <span class="number">30</span> * <span class="number">1000L</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>MIN_LIGHT_MAINTENANCE_TIME</strong><br>light idle 时间属性，取值为 5s, 用于判断是否提前退出时间窗！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MIN_LIGHT_MAINTENANCE_TIME = mParser.getLong(</span><br><span class="line">        KEY_MIN_LIGHT_MAINTENANCE_TIME,</span><br><span class="line">        !COMPRESS_TIME ? <span class="number">5</span> * <span class="number">1000L</span> : <span class="number">1</span> * <span class="number">1000L</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2-1-2-2-Deep-Idle-常量"><a href="#2-1-2-2-Deep-Idle-常量" class="headerlink" title="2.1.2.2 Deep Idle 常量"></a>2.1.2.2 Deep Idle 常量</h4><ul>
<li><p><strong>MIN_DEEP_MAINTENANCE_TIME</strong><br>deep idle 时间属性，取值为 30s, 用于判断是否提前退出时间窗！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MIN_DEEP_MAINTENANCE_TIME = mParser.getLong(</span><br><span class="line">        KEY_MIN_DEEP_MAINTENANCE_TIME,</span><br><span class="line">        !COMPRESS_TIME ? <span class="number">30</span> * <span class="number">1000L</span> : <span class="number">5</span> * <span class="number">1000L</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>INACTIVE_TIMEOUT</strong><br>deep idle 时间属性，取值为 30 mins，当设备的角度发生变化后，会回到 STATE_ACTIVE 状态，当下次满足灭屏不充电时，需要持续该时间才能进入 STATE_INACTIVE 状态；第一次进入满足灭屏不充电时，时间值也由 INACTIVE_TIMEOUT 设置  ！！</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> inactiveTimeoutDefault = (mHasWatch ? <span class="number">15</span> : <span class="number">30</span>) * <span class="number">60</span> * <span class="number">1000L</span>;</span><br><span class="line">INACTIVE_TIMEOUT = mParser.getLong(KEY_INACTIVE_TIMEOUT,</span><br><span class="line">        !COMPRESS_TIME ? inactiveTimeoutDefault : (inactiveTimeoutDefault / <span class="number">10</span>));</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>SENSING_TIMEOUT</strong><br>deep idle 时间属性，取值为 4 mins！<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SENSING_TIMEOUT = mParser.getLong(KEY_SENSING_TIMEOUT,</span><br><span class="line">        !DEBUG ? <span class="number">4</span> * <span class="number">60</span> * <span class="number">1000L</span> : <span class="number">60</span> * <span class="number">1000L</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p><strong>LOCATING_TIMEOUT</strong><br>deep idle 时间属性，取值为 30s，当处于定位阶段时，要持续的时间！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LOCATING_TIMEOUT = mParser.getLong(KEY_LOCATING_TIMEOUT,</span><br><span class="line">        !DEBUG ? <span class="number">30</span> * <span class="number">1000L</span> : <span class="number">15</span> * <span class="number">1000L</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>LOCATION_ACCURACY</strong><br>deep idle 定位属性，取值为 20meter，定位精度！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LOCATION_ACCURACY = mParser.getFloat(KEY_LOCATION_ACCURACY, <span class="number">20</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>MOTION_INACTIVE_TIMEOUT</strong><br>deep idle 时间属性，取值为 10mins，当 sensor 被触发后，会回到 STATE_ACTIVE 状态，当下次满足灭屏不充电时，持续的时间就由 30mins 缩短为 10mins！</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOTION_INACTIVE_TIMEOUT = mParser.getLong(KEY_MOTION_INACTIVE_TIMEOUT,</span><br><span class="line">        !COMPRESS_TIME ? <span class="number">10</span> * <span class="number">60</span> * <span class="number">1000L</span> : <span class="number">60</span> * <span class="number">1000L</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>IDLE_AFTER_INACTIVE_TIMEOUT</strong><br>deep idle 时间属性，取值为 30 mins，当设备在 STATE_INACTIVE 阶段是会监听设备运动，需要保持不运动 30mins 才能进入 STATE_IDLE_PENDING 阶段！!</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">long idleAfterInactiveTimeout = (mHasWatch ? 15 : 30) * 60 * 1000L;</span><br><span class="line">IDLE_AFTER_INACTIVE_TIMEOUT = mParser.getLong(KEY_IDLE_AFTER_INACTIVE_TIMEOUT,</span><br><span class="line">        !COMPRESS_TIME ? idleAfterInactiveTimeout</span><br><span class="line">                       : (idleAfterInactiveTimeout / 10));</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>IDLE_PENDING_TIMEOUT</strong><br>deep idle 时间属性，取值为 5 mins，在 deep idle 状态下的初始时间窗！</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IDLE_PENDING_TIMEOUT = mParser.getLong(KEY_IDLE_PENDING_TIMEOUT,</span><br><span class="line">        !COMPRESS_TIME ? <span class="number">5</span> * <span class="number">60</span> * <span class="number">1000L</span> : <span class="number">30</span> * <span class="number">1000L</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>MAX_IDLE_PENDING_TIMEOUT</strong><br>deep idle 时间属性，取值为 10 mins，在 deep idle 状态下的最大时间窗！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MAX_IDLE_PENDING_TIMEOUT = mParser.getLong(KEY_MAX_IDLE_PENDING_TIMEOUT,</span><br><span class="line">        !COMPRESS_TIME ? <span class="number">10</span> * <span class="number">60</span> * <span class="number">1000L</span> : <span class="number">60</span> * <span class="number">1000L</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>IDLE_PENDING_FACTOR</strong><br>deep idle 因子属性，取值为 2f，用于调整 deep idle 的时间窗！</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IDLE_PENDING_FACTOR = mParser.getFloat(KEY_IDLE_PENDING_FACTOR,</span><br><span class="line">        <span class="number">2f</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>IDLE_TIMEOUT</strong><br>deep idle 时间属性，取值为 60 mins，deep idle 状态的初始持续时间！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IDLE_TIMEOUT = mParser.getLong(KEY_IDLE_TIMEOUT,</span><br><span class="line">        !COMPRESS_TIME ? <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000L</span> : <span class="number">6</span> * <span class="number">60</span> * <span class="number">1000L</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>MAX_IDLE_TIMEOUT</strong><br>deep idle 时间属性，取值为 6 hours，deep idle 状态的最大持续时间！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MAX_IDLE_TIMEOUT = mParser.getLong(KEY_MAX_IDLE_TIMEOUT,</span><br><span class="line">        !COMPRESS_TIME ? <span class="number">6</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000L</span> : <span class="number">30</span> * <span class="number">60</span> * <span class="number">1000L</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>IDLE_FACTOR</strong><br>deep idle 因子属性，取值为 2f，用于调整 deep idle 的时间窗！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IDLE_FACTOR = mParser.getFloat(KEY_IDLE_FACTOR, <span class="number">2f</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>MIN_TIME_TO_ALARM</strong><br>deep idle 时间属性，取值为 60mins，在每次改变 deep 状态时，会判断是否有 Alarm 在该时间内触发，如果有，不会进入 deep idle 状态！</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MIN_TIME_TO_ALARM = mParser.getLong(KEY_MIN_TIME_TO_ALARM,</span><br><span class="line">        !COMPRESS_TIME ? <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000L</span> : <span class="number">6</span> * <span class="number">60</span> * <span class="number">1000L</span>);</span><br></pre></td></tr></table></figure>
<h4 id="2-1-2-3-其他相关变量"><a href="#2-1-2-3-其他相关变量" class="headerlink" title="2.1.2.3 其他相关变量"></a>2.1.2.3 其他相关变量</h4><ul>
<li><p><strong>MAX_TEMP_APP_WHITELIST_DURATION</strong><br>doze 模式的临时缓存白名单的最大有效时间，取值为 5mins！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MAX_TEMP_APP_WHITELIST_DURATION = mParser.getLong(</span><br><span class="line">        KEY_MAX_TEMP_APP_WHITELIST_DURATION, <span class="number">5</span> * <span class="number">60</span> * <span class="number">1000L</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>MMS_TEMP_APP_WHITELIST_DURATION</strong><br>MMS 应用的 doze 模式的临时缓存白名单的有效时间，60s</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MMS_TEMP_APP_WHITELIST_DURATION = mParser.getLong(</span><br><span class="line">        KEY_MMS_TEMP_APP_WHITELIST_DURATION, <span class="number">60</span> * <span class="number">1000L</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>SMS_TEMP_APP_WHITELIST_DURATION</strong><br>SMS 应用的 doze 模式的临时缓存白名单的有效时间，20s</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SMS_TEMP_APP_WHITELIST_DURATION = mParser.getLong(</span><br><span class="line">        KEY_SMS_TEMP_APP_WHITELIST_DURATION, <span class="number">20</span> * <span class="number">1000L</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>NOTIFICATION_WHITELIST_DURATION</strong><br>通知的白名单时间间隔，30s</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NOTIFICATION_WHITELIST_DURATION = mParser.getLong(</span><br><span class="line">        KEY_NOTIFICATION_WHITELIST_DURATION, <span class="number">30</span> * <span class="number">1000L</span>);</span><br></pre></td></tr></table></figure>
<p>对于这些变量的使用，我们后续再分析！</p>
<h2 id="2-2-DeviceIdleController-readConfigFileLocked"><a href="#2-2-DeviceIdleController-readConfigFileLocked" class="headerlink" title="2.2 DeviceIdleController.readConfigFileLocked"></a>2.2 DeviceIdleController.readConfigFileLocked</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readConfigFileLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">"Reading config from "</span> + mConfigFile.getBaseFile());</span><br><span class="line">     <span class="comment">//【1】清空 mPowerSaveWhitelistUserApps 集合！</span></span><br><span class="line">     mPowerSaveWhitelistUserApps.clear();</span><br><span class="line">     FileInputStream stream;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         stream = mConfigFile.openRead(); <span class="comment">//【2】创建 /data/system/deviceidle.xml 输入流！</span></span><br><span class="line">     &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         XmlPullParser parser = Xml.newPullParser();</span><br><span class="line">         parser.setInput(stream, StandardCharsets.UTF_8.name());</span><br><span class="line">         <span class="comment">//【2.2.1】读取文件！</span></span><br><span class="line">         readConfigFileLocked(parser);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (XmlPullParserException e) &#123;</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">             stream.close();</span><br><span class="line">         &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>继续调用另一个 readConfigFileLocked 方法！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readConfigFileLocked</span><span class="params">(XmlPullParser parser)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> PackageManager pm = getContext().getPackageManager();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> type;</span><br><span class="line">        <span class="keyword">while</span> ((type = parser.next()) != XmlPullParser.START_TAG</span><br><span class="line">                &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123;</span><br><span class="line">            ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (type != XmlPullParser.START_TAG) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"no start tag found"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> outerDepth = parser.getDepth();</span><br><span class="line">        <span class="keyword">while</span> ((type = parser.next()) != XmlPullParser.END_DOCUMENT</span><br><span class="line">                &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; outerDepth)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            String tagName = parser.getName();</span><br><span class="line">            <span class="keyword">if</span> (tagName.equals(<span class="string">"wl"</span>)) &#123;</span><br><span class="line">                String name = parser.getAttributeValue(<span class="keyword">null</span>, <span class="string">"n"</span>);</span><br><span class="line">                <span class="keyword">if</span> (name != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        ApplicationInfo ai = pm.getApplicationInfo(name,</span><br><span class="line">                                PackageManager.MATCH_UNINSTALLED_PACKAGES);</span><br><span class="line">                        <span class="comment">//【1】将用户应用程序的包名和 appId 加入到 mPowerSaveWhitelistUserApps 中；</span></span><br><span class="line">                        mPowerSaveWhitelistUserApps.put(ai.packageName,</span><br><span class="line">                                UserHandle.getAppId(ai.uid));</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Unknown element under &lt;config&gt;: "</span></span><br><span class="line">                        + parser.getName());</span><br><span class="line">                XmlUtils.skipCurrentTag(parser);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalStateException e) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"Failed parsing config "</span> + e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"Failed parsing config "</span> + e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"Failed parsing config "</span> + e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (XmlPullParserException e) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"Failed parsing config "</span> + e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"Failed parsing config "</span> + e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"Failed parsing config "</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，readConfigFileLocked 方法最终解析 /data/system/deviceidle.xml 文件。</p>
<p>该文件中保存的是在 device mode 模式下，能够后台运行的用户应用白名单！</p>
<p>最终的解析结果，保存到了 <strong>mPowerSaveWhitelistUserApps</strong> 集合中，packageName 和 appId 的映射！</p>
<h2 id="2-3-DeviceIdleController-updateWhitelistAppIdsLocked"><a href="#2-3-DeviceIdleController-updateWhitelistAppIdsLocked" class="headerlink" title="2.3 DeviceIdleController.updateWhitelistAppIdsLocked"></a>2.3 DeviceIdleController.updateWhitelistAppIdsLocked</h2><p>我们先来回顾下前面涉及到的几个集合：</p>
<ul>
<li><p><strong>mPowerSaveWhitelistAppsExceptIdle</strong>：保存在 power save 模式下可以后台运行，但在 doze 模式下不能后台运行的系统应用名单，packageName 和 appId 的映射！</p>
</li>
<li><p><strong>mPowerSaveWhitelistSystemAppIdsExceptIdle</strong>：保存在 power save 模式下可以后台运行，但在 doze 模式下不能后台运行的系统应用名单，appId 和 true 的映射！</p>
</li>
<li><p><strong>mPowerSaveWhitelistApps</strong>：保存在 power save 模式下可以后台运行的系统应用，packageName 和 appId 的映射！</p>
</li>
<li><p><strong>mPowerSaveWhitelistSystemAppIds</strong>：保存在 power save 模式下可以后台运行的系统应用，appId 和 true 的映射！</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updateWhitelistAppIdsLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】合并白名单！</span></span><br><span class="line">    mPowerSaveWhitelistExceptIdleAppIdArray = buildAppIdArray(mPowerSaveWhitelistAppsExceptIdle,</span><br><span class="line">            mPowerSaveWhitelistUserApps, mPowerSaveWhitelistExceptIdleAppIds);</span><br><span class="line"></span><br><span class="line">    mPowerSaveWhitelistAllAppIdArray = buildAppIdArray(mPowerSaveWhitelistApps,</span><br><span class="line">            mPowerSaveWhitelistUserApps, mPowerSaveWhitelistAllAppIds);</span><br><span class="line"></span><br><span class="line">    mPowerSaveWhitelistUserAppIdArray = buildAppIdArray(<span class="keyword">null</span>,</span><br><span class="line">            mPowerSaveWhitelistUserApps, mPowerSaveWhitelistUserAppIds);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【2】将白名单设置到 PowerManager 和 AlarmManager 中！</span></span><br><span class="line">    <span class="keyword">if</span> (mLocalPowerManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">            Slog.d(TAG, <span class="string">"Setting wakelock whitelist to "</span></span><br><span class="line">                    + Arrays.toString(mPowerSaveWhitelistAllAppIdArray));</span><br><span class="line">        &#125;</span><br><span class="line">        mLocalPowerManager.setDeviceIdleWhitelist(mPowerSaveWhitelistAllAppIdArray);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mLocalAlarmManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">            Slog.d(TAG, <span class="string">"Setting alarm whitelist to "</span></span><br><span class="line">                    + Arrays.toString(mPowerSaveWhitelistUserAppIdArray));</span><br><span class="line">        &#125;</span><br><span class="line">        mLocalAlarmManager.setDeviceIdleUserWhitelist(mPowerSaveWhitelistUserAppIdArray);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1、这里又设计到了几个重要集合：</p>
<ul>
<li><strong>mPowerSaveWhitelistExceptIdleAppIds</strong>：</li>
</ul>
<p>保存在 power save 模式下可以后台运行，但在 doze 模式下不能后台运行的系统和用户应用，packageName 和 appId 的映射；</p>
<p>集合来自 mPowerSaveWhitelistAppsExceptIdle 和 mPowerSaveWhitelistUserApps 的合并；</p>
<ul>
<li><strong>mPowerSaveWhitelistExceptIdleAppIdArray</strong>：</li>
</ul>
<p>保存在 power save 模式下可以后台运行，但在 doze 模式下不能后台运行的系统和用户应用 appId；</p>
<p>集合来自 mPowerSaveWhitelistAppsExceptIdle 和 mPowerSaveWhitelistUserApps 的合并；</p>
<ul>
<li><strong>mPowerSaveWhitelistAllAppIds</strong>：</li>
</ul>
<p>保存在 power save 模式下可以后台运行的系统和用户应用 (appId 和 true 的映射)；</p>
<p>集合来自 mPowerSaveWhitelistApps 和 mPowerSaveWhitelistUserApps 的合并；</p>
<ul>
<li><strong>mPowerSaveWhitelistAllAppIdArray</strong>：</li>
</ul>
<p>保存在 power save 模式下可以后台运行的系统和用户应用 appId；</p>
<p>集合来自 mPowerSaveWhitelistApps 和 mPowerSaveWhitelistUserApps 的合并；</p>
<ul>
<li><strong>mPowerSaveWhitelistUserAppIds</strong>：</li>
</ul>
<p>保存在 power save 模式下可以后台运行的用户应用 (appId 和 true 的映射)；</p>
<p>集合来自 mPowerSaveWhitelistUserApps；</p>
<ul>
<li><strong>mPowerSaveWhitelistUserAppIdArray</strong>：</li>
</ul>
<p>保存在 power save 模式下可以后台运行的用户应用 appId；</p>
<p>集合来自 mPowerSaveWhitelistUserApps；</p>
<p><br></p>
<p>2、传递名单</p>
<p>接着，将 mPowerSaveWhitelistAllAppIdArray 传递给了 PowerManagerService；</p>
<p>然后，将 mPowerSaveWhitelistUserAppIdArray 传递给了 AlarmManagerService；</p>
<h3 id="2-3-1-DeviceIdleController-buildAppIdArray"><a href="#2-3-1-DeviceIdleController-buildAppIdArray" class="headerlink" title="2.3.1 DeviceIdleController.buildAppIdArray"></a>2.3.1 DeviceIdleController.buildAppIdArray</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] buildAppIdArray(ArrayMap&lt;String, Integer&gt; systemApps,</span><br><span class="line">        ArrayMap&lt;String, Integer&gt; userApps, SparseBooleanArray outAppIds) &#123;</span><br><span class="line">    outAppIds.clear();</span><br><span class="line">    <span class="comment">//【1】将 systemApps 和 userApps 合并到 outAppIds 中，appId 和 true 值的映射！</span></span><br><span class="line">    <span class="keyword">if</span> (systemApps != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; systemApps.size(); i++) &#123;</span><br><span class="line">            outAppIds.put(systemApps.valueAt(i), <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (userApps != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; userApps.size(); i++) &#123;</span><br><span class="line">            outAppIds.put(userApps.valueAt(i), <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【2】将 outAppIds 中的所有 appId 保存到数组 appids 中，并返回！</span></span><br><span class="line">    <span class="keyword">int</span> size = outAppIds.size();</span><br><span class="line">    <span class="keyword">int</span>[] appids = <span class="keyword">new</span> <span class="keyword">int</span>[size];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        appids[i] = outAppIds.keyAt(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> appids;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-4-new-BinderService"><a href="#2-4-new-BinderService" class="headerlink" title="2.4 new BinderService"></a>2.4 new BinderService</h2><p>创建了一个 BinderService 对象，继承了 IDeviceIdleController.Stub，作为服务端桩对象，用于其它进程访问 DeviceIdleController 内部接口！！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BinderService</span> <span class="keyword">extends</span> <span class="title">IDeviceIdleController</span>.<span class="title">Stub</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】添加应用到 power save 应用白名单中！</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addPowerSaveWhitelistApp</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        getContext().enforceCallingOrSelfPermission(android.Manifest.permission.DEVICE_POWER,</span><br><span class="line">                <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            addPowerSaveWhitelistAppInternal(name);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Binder.restoreCallingIdentity(ident);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【2】移除应用从 power save 应用白名单中！</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removePowerSaveWhitelistApp</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        getContext().enforceCallingOrSelfPermission(android.Manifest.permission.DEVICE_POWER,</span><br><span class="line">                <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            removePowerSaveWhitelistAppInternal(name);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Binder.restoreCallingIdentity(ident);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【3】获取在 power save 模式下可以后台运行但是在 device idle 状态下不能后台运行的白名单！</span></span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> String[] getSystemPowerWhitelistExceptIdle() &#123;</span><br><span class="line">        <span class="keyword">return</span> getSystemPowerWhitelistExceptIdleInternal();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> String[] getSystemPowerWhitelist() &#123;</span><br><span class="line">        <span class="keyword">return</span> getSystemPowerWhitelistInternal();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> String[] getUserPowerWhitelist() &#123;</span><br><span class="line">        <span class="keyword">return</span> getUserPowerWhitelistInternal();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> String[] getFullPowerWhitelistExceptIdle() &#123;</span><br><span class="line">        <span class="keyword">return</span> getFullPowerWhitelistExceptIdleInternal();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> String[] getFullPowerWhitelist() &#123;</span><br><span class="line">        <span class="keyword">return</span> getFullPowerWhitelistInternal();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">int</span>[] getAppIdWhitelistExceptIdle() &#123;</span><br><span class="line">        <span class="keyword">return</span> getAppIdWhitelistExceptIdleInternal();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">int</span>[] getAppIdWhitelist() &#123;</span><br><span class="line">        <span class="keyword">return</span> getAppIdWhitelistInternal();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">int</span>[] getAppIdUserWhitelist() &#123;</span><br><span class="line">        <span class="keyword">return</span> getAppIdUserWhitelistInternal();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">int</span>[] getAppIdTempWhitelist() &#123;</span><br><span class="line">        <span class="keyword">return</span> getAppIdTempWhitelistInternal();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerSaveWhitelistExceptIdleApp</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isPowerSaveWhitelistExceptIdleAppInternal(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPowerSaveWhitelistApp</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isPowerSaveWhitelistAppInternal(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addPowerSaveTempWhitelistApp</span><span class="params">(String packageName, <span class="keyword">long</span> duration,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> userId, String reason)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        addPowerSaveTempWhitelistAppChecked(packageName, duration, userId, reason);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">addPowerSaveTempWhitelistAppForMms</span><span class="params">(String packageName,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> userId, String reason)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> duration = mConstants.MMS_TEMP_APP_WHITELIST_DURATION;</span><br><span class="line">        addPowerSaveTempWhitelistAppChecked(packageName, duration, userId, reason);</span><br><span class="line">        <span class="keyword">return</span> duration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">addPowerSaveTempWhitelistAppForSms</span><span class="params">(String packageName,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> userId, String reason)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> duration = mConstants.SMS_TEMP_APP_WHITELIST_DURATION;</span><br><span class="line">        addPowerSaveTempWhitelistAppChecked(packageName, duration, userId, reason);</span><br><span class="line">        <span class="keyword">return</span> duration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exitIdle</span><span class="params">(String reason)</span> </span>&#123;</span><br><span class="line">        getContext().enforceCallingOrSelfPermission(Manifest.permission.DEVICE_POWER,</span><br><span class="line">                <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            exitIdleInternal(reason);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Binder.restoreCallingIdentity(ident);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">registerMaintenanceActivityListener</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            IMaintenanceActivityListener listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DeviceIdleController.<span class="keyword">this</span>.registerMaintenanceActivityListener(listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unregisterMaintenanceActivityListener</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            IMaintenanceActivityListener listener)</span> </span>&#123;</span><br><span class="line">        DeviceIdleController.<span class="keyword">this</span>.unregisterMaintenanceActivityListener(listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dump</span><span class="params">(FileDescriptor fd, PrintWriter pw, String[] args)</span> </span>&#123;</span><br><span class="line">        DeviceIdleController.<span class="keyword">this</span>.dump(fd, pw, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onShellCommand</span><span class="params">(FileDescriptor in, FileDescriptor out,</span></span></span><br><span class="line"><span class="function"><span class="params">            FileDescriptor err, String[] args, ResultReceiver resultReceiver)</span> </span>&#123;</span><br><span class="line">        (<span class="keyword">new</span> Shell()).exec(<span class="keyword">this</span>, in, out, err, args, resultReceiver);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的接口，我们先不详细看！</p>
<p>最后，将桩对象注册到了 ServiceManager 中！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">publishBinderService(Context.DEVICE_IDLE_CONTROLLER, mBinderService);</span><br></pre></td></tr></table></figure>
<h2 id="2-5-new-LocalService"><a href="#2-5-new-LocalService" class="headerlink" title="2.5 new LocalService"></a>2.5 new LocalService</h2><p>创建了本地服务对象，方便进程内部通信！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addPowerSaveTempWhitelistAppDirect</span><span class="params">(<span class="keyword">int</span> appId, <span class="keyword">long</span> duration, <span class="keyword">boolean</span> sync,</span></span></span><br><span class="line"><span class="function"><span class="params">            String reason)</span> </span>&#123;</span><br><span class="line">        addPowerSaveTempWhitelistAppDirectInternal(<span class="number">0</span>, appId, duration, sync, reason);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getNotificationWhitelistDuration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mConstants.NOTIFICATION_WHITELIST_DURATION;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNetworkPolicyTempWhitelistCallback</span><span class="params">(Runnable callback)</span> </span>&#123;</span><br><span class="line">        setNetworkPolicyTempWhitelistCallbackInternal(callback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setJobsActive</span><span class="params">(<span class="keyword">boolean</span> active)</span> </span>&#123;</span><br><span class="line">        DeviceIdleController.<span class="keyword">this</span>.setJobsActive(active);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Up-call from alarm manager.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAlarmsActive</span><span class="params">(<span class="keyword">boolean</span> active)</span> </span>&#123;</span><br><span class="line">        DeviceIdleController.<span class="keyword">this</span>.setAlarmsActive(active);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] getPowerSaveWhitelistUserAppIds() &#123;</span><br><span class="line">        <span class="keyword">return</span> DeviceIdleController.<span class="keyword">this</span>.getPowerSaveWhitelistUserAppIds();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="3-DeviceIdleController-onBootPhase"><a href="#3-DeviceIdleController-onBootPhase" class="headerlink" title="3 DeviceIdleController.onBootPhase"></a>3 DeviceIdleController.onBootPhase</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBootPhase</span><span class="params">(<span class="keyword">int</span> phase)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (phase == PHASE_SYSTEM_SERVICES_READY) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">//【1】获得了一些重要的系统服务：AlarmManager，BatteryStats，PowerManager，ConnectivityService</span></span><br><span class="line">            <span class="comment">// NetworkPolicyManager，DisplayManager 和 SensorManager；</span></span><br><span class="line">            mAlarmManager = (AlarmManager) getContext().getSystemService(Context.ALARM_SERVICE);</span><br><span class="line">            mBatteryStats = BatteryStatsService.getService();</span><br><span class="line">            mLocalPowerManager = getLocalService(PowerManagerInternal.class);</span><br><span class="line">            mPowerManager = getContext().getSystemService(PowerManager.class);</span><br><span class="line">            mActiveIdleWakeLock = mPowerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,</span><br><span class="line">                    <span class="string">"deviceidle_maint"</span>);</span><br><span class="line">            mActiveIdleWakeLock.setReferenceCounted(<span class="keyword">false</span>);</span><br><span class="line">            mConnectivityService = (ConnectivityService)ServiceManager.getService(</span><br><span class="line">                    Context.CONNECTIVITY_SERVICE);</span><br><span class="line">            mLocalAlarmManager = getLocalService(AlarmManagerService.LocalService.class);</span><br><span class="line">            mNetworkPolicyManager = INetworkPolicyManager.Stub.asInterface(</span><br><span class="line">                    ServiceManager.getService(Context.NETWORK_POLICY_SERVICE));</span><br><span class="line">            mDisplayManager = (DisplayManager) getContext().getSystemService(</span><br><span class="line">                    Context.DISPLAY_SERVICE);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获得 SensorManager，用于获得系统的传感器信息！</span></span><br><span class="line">            mSensorManager = (SensorManager) getContext().getSystemService(Context.SENSOR_SERVICE);</span><br><span class="line">            <span class="keyword">int</span> sigMotionSensorId = getContext().getResources().getInteger(</span><br><span class="line">                    com.android.internal.R.integer.config_autoPowerModeAnyMotionSensor);</span><br><span class="line">            <span class="comment">// 获得运动传感器对象，监听手机位置变化！</span></span><br><span class="line">            <span class="keyword">if</span> (sigMotionSensorId &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                mMotionSensor = mSensorManager.getDefaultSensor(sigMotionSensorId, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mMotionSensor == <span class="keyword">null</span> &amp;&amp; getContext().getResources().getBoolean(</span><br><span class="line">                    com.android.internal.R.bool.config_autoPowerModePreferWristTilt)) &#123;</span><br><span class="line">                mMotionSensor = mSensorManager.getDefaultSensor(</span><br><span class="line">                        Sensor.TYPE_WRIST_TILT_GESTURE, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mMotionSensor == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mMotionSensor = mSensorManager.getDefaultSensor(</span><br><span class="line">                        Sensor.TYPE_SIGNIFICANT_MOTION, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (getContext().getResources().getBoolean(</span><br><span class="line">                    com.android.internal.R.bool.config_autoPowerModePrefetchLocation)) &#123;</span><br><span class="line">                mLocationManager = (LocationManager) getContext().getSystemService(</span><br><span class="line">                        Context.LOCATION_SERVICE);</span><br><span class="line">                mLocationRequest = <span class="keyword">new</span> LocationRequest()</span><br><span class="line">                    .setQuality(LocationRequest.ACCURACY_FINE)</span><br><span class="line">                    .setInterval(<span class="number">0</span>)</span><br><span class="line">                    .setFastestInterval(<span class="number">0</span>)</span><br><span class="line">                    .setNumUpdates(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 通过配置文件。得到角度变化的阈值！</span></span><br><span class="line">            <span class="comment">// 创建一个 AnyMotionDetector，同一时候将 DeviceIdleController 注冊到当中</span></span><br><span class="line">            <span class="comment">// 当 AnyMotionDetector 检測到手机变化角度超过阈值时。就会回调 DeviceIdleController 的接口</span></span><br><span class="line">            <span class="keyword">float</span> angleThreshold = getContext().getResources().getInteger(</span><br><span class="line">                    com.android.internal.R.integer.config_autoPowerModeThresholdAngle) / <span class="number">100f</span>;</span><br><span class="line">            mAnyMotionDetector = <span class="keyword">new</span> AnyMotionDetector(</span><br><span class="line">                    (PowerManager) getContext().getSystemService(Context.POWER_SERVICE),</span><br><span class="line">                    mHandler, mSensorManager, <span class="keyword">this</span>, angleThreshold);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 创建了两个广播对象，一个用于通知 deep doze 模式变化；另一个用于通知 light doze 模式变化！</span></span><br><span class="line">            mIdleIntent = <span class="keyword">new</span> Intent(PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED);</span><br><span class="line">            mIdleIntent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY</span><br><span class="line">                    | Intent.FLAG_RECEIVER_FOREGROUND);</span><br><span class="line">            mLightIdleIntent = <span class="keyword">new</span> Intent(PowerManager.ACTION_LIGHT_DEVICE_IDLE_MODE_CHANGED);</span><br><span class="line">            mLightIdleIntent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY</span><br><span class="line">                    | Intent.FLAG_RECEIVER_FOREGROUND);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【3.1】监听电池变化的广播！</span></span><br><span class="line">            IntentFilter filter = <span class="keyword">new</span> IntentFilter();</span><br><span class="line">            filter.addAction(Intent.ACTION_BATTERY_CHANGED);</span><br><span class="line">            getContext().registerReceiver(mReceiver, filter);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【3】监听 package 变化的广播！</span></span><br><span class="line">            filter = <span class="keyword">new</span> IntentFilter();</span><br><span class="line">            filter.addAction(Intent.ACTION_PACKAGE_REMOVED);</span><br><span class="line">            filter.addDataScheme(<span class="string">"package"</span>);</span><br><span class="line">            getContext().registerReceiver(mReceiver, filter);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【4】监听网络变化的广播！</span></span><br><span class="line">            filter = <span class="keyword">new</span> IntentFilter();</span><br><span class="line">            filter.addAction(ConnectivityManager.CONNECTIVITY_ACTION);</span><br><span class="line">            getContext().registerReceiver(mReceiver, filter);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【5】再次将 mPowerSaveWhitelistAllAppIdArray 传递给了 PowerManagerService；</span></span><br><span class="line">            <span class="comment">// 将 mPowerSaveWhitelistUserAppIdArray 传递给了 AlarmManagerService；</span></span><br><span class="line">            mLocalPowerManager.setDeviceIdleWhitelist(mPowerSaveWhitelistAllAppIdArray);</span><br><span class="line">            mLocalAlarmManager.setDeviceIdleUserWhitelist(mPowerSaveWhitelistUserAppIdArray);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【3.2】注册 DisplayListener 监听熄屏亮屏状态，同时更新屏幕状态！</span></span><br><span class="line">            mDisplayManager.registerDisplayListener(mDisplayListener, <span class="keyword">null</span>);</span><br><span class="line">            updateDisplayLocked();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【3.3】更新网络连接状态！</span></span><br><span class="line">        updateConnectivityState(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们来看看 DisplayListener 对象！</p>
<h2 id="3-1-new-BroadcastReceiver"><a href="#3-1-new-BroadcastReceiver" class="headerlink" title="3.1 new BroadcastReceiver"></a>3.1 new BroadcastReceiver</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BroadcastReceiver mReceiver = <span class="keyword">new</span> BroadcastReceiver() &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (intent.getAction()) &#123;</span><br><span class="line">            <span class="keyword">case</span> ConnectivityManager.CONNECTIVITY_ACTION: &#123;</span><br><span class="line">                updateConnectivityState(intent); <span class="comment">// 网络变化</span></span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> Intent.ACTION_BATTERY_CHANGED: &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (DeviceIdleController.<span class="keyword">this</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> plugged = intent.getIntExtra(<span class="string">"plugged"</span>, <span class="number">0</span>);</span><br><span class="line">                    updateChargingLocked(plugged != <span class="number">0</span>); <span class="comment">// 电量变化</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> Intent.ACTION_PACKAGE_REMOVED: &#123; <span class="comment">// 升级包移除！</span></span><br><span class="line">                <span class="keyword">if</span> (!intent.getBooleanExtra(Intent.EXTRA_REPLACING, <span class="keyword">false</span>)) &#123;</span><br><span class="line">                    Uri data = intent.getData();</span><br><span class="line">                    String ssp;</span><br><span class="line">                    <span class="keyword">if</span> (data != <span class="keyword">null</span> &amp;&amp; (ssp = data.getSchemeSpecificPart()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//【3.1.1】更新用户应用白名单！</span></span><br><span class="line">                        removePowerSaveWhitelistAppInternal(ssp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>创建了一个 BroadcastReceiver 对象，监听 CONNECTIVITY_ACTION，ACTION_BATTERY_CHANGED，ACTION_PACKAGE_REMOVED 广播！</p>
<p>关于监听到变化后的动态处理，这里我们先不分析！</p>
<h3 id="3-1-1-DeviceIdleController-removePowerSaveWhitelistAppInternal"><a href="#3-1-1-DeviceIdleController-removePowerSaveWhitelistAppInternal" class="headerlink" title="3.1.1 DeviceIdleController.removePowerSaveWhitelistAppInternal"></a>3.1.1 DeviceIdleController.removePowerSaveWhitelistAppInternal</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removePowerSaveWhitelistAppInternal</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mPowerSaveWhitelistUserApps.remove(name) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//【1】发送 ACTION_POWER_SAVE_WHITELIST_CHANGED 广播！</span></span><br><span class="line">            reportPowerSaveWhitelistChangedLocked();</span><br><span class="line">            <span class="comment">//【2.3.1】更新名单列表，同时</span></span><br><span class="line">            updateWhitelistAppIdsLocked();</span><br><span class="line">            <span class="comment">//【3】更新本地持久化文件！</span></span><br><span class="line">            writeConfigFileLocked();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>reportPowerSaveWhitelistChangedLocked 方法会发送 PowerManager.ACTION_POWER_SAVE_WHITELIST_CHANGED 广播！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reportPowerSaveWhitelistChangedLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent(PowerManager.ACTION_POWER_SAVE_WHITELIST_CHANGED);</span><br><span class="line">    intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);</span><br><span class="line">    getContext().sendBroadcastAsUser(intent, UserHandle.SYSTEM);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>writeConfigFileLocked 方法会发送 MSG_WRITE_CONFIG 消息给 MyHandler。MyHandler 会处理消息，调用 handleWriteConfigFile -&gt; writeConfigFileLocked(XmlSerializer out) 方法，更新本地名单！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writeConfigFileLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mHandler.removeMessages(MSG_WRITE_CONFIG);</span><br><span class="line">    mHandler.sendEmptyMessageDelayed(MSG_WRITE_CONFIG, <span class="number">5000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>继续看！</p>
<h2 id="3-2-register-DisplayListener"><a href="#3-2-register-DisplayListener" class="headerlink" title="3.2 register DisplayListener"></a>3.2 register DisplayListener</h2><p>mDisplayListener 用于监听屏幕的状态！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> DisplayManager.DisplayListener mDisplayListener</span><br><span class="line">        = <span class="keyword">new</span> DisplayManager.DisplayListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDisplayAdded</span><span class="params">(<span class="keyword">int</span> displayId)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDisplayRemoved</span><span class="params">(<span class="keyword">int</span> displayId)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDisplayChanged</span><span class="params">(<span class="keyword">int</span> displayId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (displayId == Display.DEFAULT_DISPLAY) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (DeviceIdleController.<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="comment">//【3.1.1】当屏幕状态发生变化后，onDisplayChanged 方法被触发！</span></span><br><span class="line">                <span class="comment">// 执行了 DeviceIdleController.updateDisplayLocked 方法！</span></span><br><span class="line">                updateDisplayLocked();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-2-1-DeviceIdleController-updateDisplayLocked"><a href="#3-2-1-DeviceIdleController-updateDisplayLocked" class="headerlink" title="3.2.1 DeviceIdleController.updateDisplayLocked"></a>3.2.1 DeviceIdleController.updateDisplayLocked</h3><p>updateDisplayLocked 用于更新屏幕的状态！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateDisplayLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】获取屏幕当前的状态，并判断是否是亮屏状态！</span></span><br><span class="line">    mCurDisplay = mDisplayManager.getDisplay(Display.DEFAULT_DISPLAY);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> screenOn = mCurDisplay.getState() == Display.STATE_ON;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG) Slog.d(TAG, <span class="string">"updateDisplayLocked: screenOn="</span> + screenOn);</span><br><span class="line">    <span class="keyword">if</span> (!screenOn &amp;&amp; mScreenOn) &#123;</span><br><span class="line">        <span class="comment">//【2.1】如果是从亮屏转为熄屏，设置 mScreenOn 为 false！</span></span><br><span class="line">        mScreenOn = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (!mForceIdle) &#123;</span><br><span class="line">            becomeInactiveIfAppropriateLocked(); <span class="comment">// 进入 Doze 模式；</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (screenOn) &#123;</span><br><span class="line">        <span class="comment">//【2.2】如果是从熄屏转亮屏，设置 mScreenOn 为 true！</span></span><br><span class="line">        mScreenOn = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (!mForceIdle) &#123;</span><br><span class="line">            becomeActiveLocked(<span class="string">"screen"</span>, Process.myUid()); <span class="comment">// 退出 Doze 模式；</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>mForceIdle 表示是否强制进入 idle 状态，默认为 false 的，目前唯一的开启方式是通过 adb shell，执行 dumpsys 命令，触发 force-idle，force-inactive 相关指令，强制进入 idle 状态！！</p>
<p>这里看到，当熄屏后，会调用 becomeInactiveIfAppropriateLocked 方法，进入 doze 模式；当亮屏后，会调用 becomeActiveLocked 方法，退出 doze！</p>
<h2 id="3-3-DeviceIdleController-updateConnectivityState"><a href="#3-3-DeviceIdleController-updateConnectivityState" class="headerlink" title="3.3 DeviceIdleController.updateConnectivityState"></a>3.3 DeviceIdleController.updateConnectivityState</h2><p>更新网络状态！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateConnectivityState</span><span class="params">(Intent connIntent)</span> </span>&#123;</span><br><span class="line">    ConnectivityService cm;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        cm = mConnectivityService;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cm == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    NetworkInfo ni = cm.getActiveNetworkInfo();</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> conn;</span><br><span class="line">        <span class="keyword">if</span> (ni == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//【1】网络断开，conn 为 false；</span></span><br><span class="line">            conn = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//【2】获得网络的连接状态；</span></span><br><span class="line">            <span class="keyword">if</span> (connIntent == <span class="keyword">null</span>) &#123;</span><br><span class="line">                conn = ni.isConnected();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> networkType =</span><br><span class="line">                        connIntent.getIntExtra(ConnectivityManager.EXTRA_NETWORK_TYPE,</span><br><span class="line">                                ConnectivityManager.TYPE_NONE);</span><br><span class="line">                <span class="keyword">if</span> (ni.getType() != networkType) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                conn = !connIntent.getBooleanExtra(ConnectivityManager.EXTRA_NO_CONNECTIVITY,</span><br><span class="line">                        <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【3】处理连接状态，如果当前状态和之前的状态发生了变化，更新 mNetworkConnected 的值</span></span><br><span class="line">        <span class="keyword">if</span> (conn != mNetworkConnected) &#123;</span><br><span class="line">            mNetworkConnected = conn;</span><br><span class="line">            <span class="comment">//【4】如果本次状态是处于连接中，并且 light idle 正在等待网络，那就继续处理状态！！</span></span><br><span class="line">            <span class="keyword">if</span> (conn &amp;&amp; mLightState == LIGHT_STATE_WAITING_FOR_NETWORK) &#123;</span><br><span class="line">                stepLightIdleStateLocked(<span class="string">"network"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到 DeviceIdleController 的启动流程还是很简单的！</p>
<h1 id="4-启动总结"><a href="#4-启动总结" class="headerlink" title="4 启动总结"></a>4 启动总结</h1><p>我们通过一张图来看看 DeviceIdleController 的整个启动过程！</p>
<p><img src="http://static.zybuluo.com/Coolqi/tbg4pb5gnbv170z6lujwzifn/DeviceIdleController%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B.png" alt="DeviceIdleController启动流程.png-75kB"></p>
<p>其他优秀博客！！</p>
<p><a href="https://blog.csdn.net/kc58236582/article/details/54923406" target="_blank" rel="noopener">https://blog.csdn.net/kc58236582/article/details/54923406</a><br><a href="https://www.cnblogs.com/gavanwanggw/p/7327832.html" target="_blank" rel="noopener">https://www.cnblogs.com/gavanwanggw/p/7327832.html</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Coolqi.Li</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://coolqi.top/2017/10/01/Doze1-deviceIdleControllerStartProcess/">https://coolqi.top/2017/10/01/Doze1-deviceIdleControllerStartProcess/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://coolqi.top">Coolqi`s Blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Doze假寐模式/">Doze假寐模式</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="/img/zfb.jpg"><div class="post-qr-code__desc">支付宝打赏</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="/img/wechat.jpg"><div class="post-qr-code__desc">微信打赏</div></div></div><div class="social-share"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2017/11/25/Doze2-deviceIdleControllerDynamic/"><i class="fa fa-chevron-left">  </i><span>Doze模式第 2 篇 - DeviceIdleController 动态机制</span></a></div><div class="next-post pull-right"><a href="/2017/09/27/AlarmManager4-AlarmManagerServiceAttributeSummary/"><span>AlarmManager第 4 篇 - AlarmManagerService属性总结</span><i class="fa fa-chevron-right"></i></a></div></nav><div class="post-adv"><a href="https://www.vultr.com/?ref=7231808"><img src="https://www.vultr.com/media/banner_1.png" width="728" height="90"></a></div><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '0b2bcefa98cd2ef1a87c',
  clientSecret: '8d6fc25cc2643889493c0406c9a7cb0f1663b5c2',
  repo: 'git-single-lee.github.io',
  owner: 'git-single-lee',
  admin: 'git-single-lee',
  id: md5(location.pathname),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2015 - 2019 By Coolqi.Li</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://coolqi.top/">blog</a>!</div><div class="busuanzi"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.6"></script><script src="/js/fancybox.js?version=1.5.6"></script><script src="/js/sidebar.js?version=1.5.6"></script><script src="/js/copy.js?version=1.5.6"></script><script src="/js/fireworks.js?version=1.5.6"></script><script src="/js/transition.js?version=1.5.6"></script><script src="/js/scroll.js?version=1.5.6"></script><script src="/js/head.js?version=1.5.6"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="/js/search/local-search.js"></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"live2d-widget-model-hijiki"},"display":{"position":"right","width":110,"height":220},"mobile":{"show":false},"log":false});</script></body></html>