<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="EventBus 第四篇 - 发送消息"><meta name="keywords" content="EventBus"><meta name="author" content="Coolqi.Li,undefined"><meta name="copyright" content="Coolqi.Li"><title>EventBus 第四篇 - 发送消息 | Coolqi`s Blog</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.5.6"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css?version=1.5.6"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: 'ca-pub-6845729157331145',
  enable_page_level_ads: 'true'
});
</script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?b7acef5306e54116ad8a99e8b753a92d";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-回顾"><span class="toc-text">1 回顾</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-EventBus"><span class="toc-text">2 EventBus</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-post"><span class="toc-text">2.1 post</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-postSingleEvent"><span class="toc-text">2.1.1 postSingleEvent</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-1-lookupAllEventTypes"><span class="toc-text">2.1.1.1  lookupAllEventTypes</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-1-2-addInterfaces"><span class="toc-text">2.1.1.2 addInterfaces</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-postSingleEventForEventType"><span class="toc-text">2.1.2  postSingleEventForEventType</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-postToSubscription-线程模式处理"><span class="toc-text">2.2.1 postToSubscription - 线程模式处理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-invokeSubscriber"><span class="toc-text">2.2.2 invokeSubscriber</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-postSticky"><span class="toc-text">2.2 postSticky</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-PostingThreadState"><span class="toc-text">3 PostingThreadState</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-成员变量"><span class="toc-text">3.1 成员变量</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-Poster"><span class="toc-text">4 Poster</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-HandlerPoster"><span class="toc-text">4.1 HandlerPoster</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-1-成员变量"><span class="toc-text">4.1.1 成员变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-2-enqueue"><span class="toc-text">4.1.2 enqueue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-3-run"><span class="toc-text">4.1.3 run</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-BackgroundPoster"><span class="toc-text">4.2 BackgroundPoster</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-成员变量"><span class="toc-text">4.2.1 成员变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2-enqueue"><span class="toc-text">4.2.2 enqueue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-3-run"><span class="toc-text">4.2.3 run</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-AsyncPoster"><span class="toc-text">4.3 AsyncPoster</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-1-成员变量"><span class="toc-text">4.3.1 成员变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-2-enqueue"><span class="toc-text">4.3.2 enqueue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-3-run"><span class="toc-text">4.3.3 run</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-PendingPost"><span class="toc-text">6 PendingPost</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-成员变量"><span class="toc-text">6.1 成员变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-obtainPendingPost"><span class="toc-text">6.2 obtainPendingPost</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-releasePendingPost"><span class="toc-text">6.3 releasePendingPost</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-PendingPostQueue"><span class="toc-text">7 PendingPostQueue</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-成员变量"><span class="toc-text">7.1 成员变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-enqueue"><span class="toc-text">7.2 enqueue</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-poll"><span class="toc-text">7.3 poll</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-总结"><span class="toc-text">8 总结</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">Coolqi.Li</div><div class="author-info__description text-center">“Hi，我是李帅奇，Android 开发工程师，TeamLeader，熬夜星人，一个努力赚钱，积极向上的好人。”</div><div class="follow-button"><a href="https://github.com/single-li">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">86</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">21</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">26</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="https://developer.android.google.cn/">AndroidDeveloper</a><a class="author-info-links__name text-center" href="http://www.android-studio.org/">AndroidStudio</a><a class="author-info-links__name text-center" href="https://www.jianshu.com/u/123a20a96441">简书</a><a class="author-info-links__name text-center" href="https://weibo.com/coolqiLi">微博</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://ws1.sinaimg.cn/large/8700af19ly1fvpabr30o6j22yo1o0q7i.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Coolqi`s Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a><a class="site-page" href="/">Home</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/about">About</a></span></div><div id="post-info"><div id="post-title">EventBus 第四篇 - 发送消息</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-09-13</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/开源库源码分析/">开源库源码分析</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/开源库源码分析/EventBus/">EventBus</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">3.3k</span><span class="post-meta__separator">|</span><span>阅读时长: 14 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>本系列文章主要分析 EventBus 框架的架构和原理，，基于最新的 <strong>3.1.0</strong> 版本。</p>
<blockquote>
<p>这是 EventBus 开源库的地址，大家可以直接访问<br><a href="https://github.com/greenrobot/EventBus" target="_blank" rel="noopener">https://github.com/greenrobot/EventBus</a></p>
</blockquote>
<p>本篇文章是 EventBus 的第四篇，主要分析发送消息的流程；</p>
<h1 id="1-回顾"><a href="#1-回顾" class="headerlink" title="1 回顾"></a>1 回顾</h1><p>我们回顾下 eventbus 的使用：</p>
<ul>
<li>发送普通的消息</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().post(messageEvent);</span><br></pre></td></tr></table></figure>
<ul>
<li>发送 sticky 消息</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventBus.getDefault().postSticky(messageEvent)</span><br></pre></td></tr></table></figure>
<p>这里我们来分析下 <strong>post</strong> 的流程，也是最后一篇了；</p>
<h1 id="2-EventBus"><a href="#2-EventBus" class="headerlink" title="2 EventBus"></a>2 EventBus</h1><h2 id="2-1-post"><a href="#2-1-post" class="headerlink" title="2.1 post"></a>2.1 post</h2><p>发送普通消息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(Object event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【--&gt;3.1】获取当前线程的 PostingThreadState 实例；</span></span><br><span class="line">    PostingThreadState postingState = currentPostingThreadState.get();</span><br><span class="line">    <span class="comment">//【2】获取每个线程的事件队列 queue；</span></span><br><span class="line">    List&lt;Object&gt; eventQueue = postingState.eventQueue;</span><br><span class="line">    eventQueue.add(event);</span><br><span class="line">    <span class="comment">//【3】如果当前的状态不是正在 posting；</span></span><br><span class="line">    <span class="keyword">if</span> (!postingState.isPosting) &#123;</span><br><span class="line">        <span class="comment">//【4】判断当前是否是主线程；</span></span><br><span class="line">        postingState.isMainThread = isMainThread();</span><br><span class="line">        <span class="comment">//【5】将 posting 状态设置为 true；</span></span><br><span class="line">        postingState.isPosting = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (postingState.canceled) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Internal error. Abort state was not reset"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//【4】事件队列不为 Empty，所以要分发事件；</span></span><br><span class="line">            <span class="keyword">while</span> (!eventQueue.isEmpty()) &#123;</span><br><span class="line">                <span class="comment">//【--&gt;2.1.1】分发单个消息；</span></span><br><span class="line">                postSingleEvent(eventQueue.remove(<span class="number">0</span>), postingState);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            postingState.isPosting = <span class="keyword">false</span>;</span><br><span class="line">            postingState.isMainThread = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段逻辑不是很复杂！！</p>
<p>isMainThread 方法很简单，就不多说了。。。</p>
<h3 id="2-1-1-postSingleEvent"><a href="#2-1-1-postSingleEvent" class="headerlink" title="2.1.1 postSingleEvent"></a>2.1.1 postSingleEvent</h3><p>发送单个事件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postSingleEvent</span><span class="params">(Object event, PostingThreadState postingState)</span> <span class="keyword">throws</span> Error </span>&#123;</span><br><span class="line">    <span class="comment">//【1】获取事件的 class 实例；</span></span><br><span class="line">    Class&lt;?&gt; eventClass = event.getClass();</span><br><span class="line">    <span class="keyword">boolean</span> subscriptionFound = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//【2】如果允许继承的话，那就要针对事件类型做处理，因为可能有继承的关系；</span></span><br><span class="line">    <span class="keyword">if</span> (eventInheritance) &#123;</span><br><span class="line">        <span class="comment">//【--&gt;2.1.1.1】查询所有的事件类型；</span></span><br><span class="line">        List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass);</span><br><span class="line">        <span class="keyword">int</span> countTypes = eventTypes.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; countTypes; h++) &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = eventTypes.get(h);</span><br><span class="line">            <span class="comment">//【--&gt;2.1.2】开始根据每一种事件类型去分发事件（多态）；</span></span><br><span class="line">            subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//【--&gt;2.1.2】开始根据传入的事件类型去分发事件（无需继承）；</span></span><br><span class="line">        subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【3】处理没有订阅者的情况；</span></span><br><span class="line">    <span class="keyword">if</span> (!subscriptionFound) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logNoSubscriberMessages) &#123;</span><br><span class="line">            logger.log(Level.FINE, <span class="string">"No subscribers registered for event "</span> + eventClass);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp;</span><br><span class="line">                eventClass != SubscriberExceptionEvent.class) &#123;</span><br><span class="line">            post(<span class="keyword">new</span> NoSubscriberEvent(<span class="keyword">this</span>, event));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>EventBus  中有一个 eventTypesCache 的 hash：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, List&lt;Class&lt;?&gt;&gt;&gt; eventTypesCache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>key 是事件的 class，而 value 是一个 list，用于保存 class 和其 superClass，以及其他的所有接口；</p>
<p>因为如果允许事件继承的话，那么根据多态的概念，必须要收集所有的父类和接口；</p>
<h4 id="2-1-1-1-lookupAllEventTypes"><a href="#2-1-1-1-lookupAllEventTypes" class="headerlink" title="2.1.1.1  lookupAllEventTypes"></a>2.1.1.1  lookupAllEventTypes</h4><p>查询所有的事件类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;Class&lt;?&gt;&gt; lookupAllEventTypes(Class&lt;?&gt; eventClass) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (eventTypesCache) &#123;</span><br><span class="line">        <span class="comment">//【1】从 eventTypesCache 中获取事件 class 对应的事件类型列表；</span></span><br><span class="line">        List&lt;Class&lt;?&gt;&gt; eventTypes = eventTypesCache.get(eventClass);</span><br><span class="line">        <span class="keyword">if</span> (eventTypes == <span class="keyword">null</span>) &#123;</span><br><span class="line">            eventTypes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            Class&lt;?&gt; clazz = eventClass;</span><br><span class="line">            <span class="keyword">while</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">                eventTypes.add(clazz);</span><br><span class="line">                <span class="comment">//【--&gt;2.1.1.2】添加接口，也就是获取 class 的所有接口；</span></span><br><span class="line">                addInterfaces(eventTypes, clazz.getInterfaces());、</span><br><span class="line">                <span class="comment">//【2】获取其父类，继续遍历；</span></span><br><span class="line">                clazz = clazz.getSuperclass();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//【3】最后放到 cache 目录中；</span></span><br><span class="line">            eventTypesCache.put(eventClass, eventTypes);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> eventTypes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这<strong>部分的代码</strong>，<strong>主要逻辑如下</strong>：</p>
<ul>
<li>将 <strong>eventClass</strong> 加入到 <strong>eventTypesCache</strong> 的 <strong>eventTypes list</strong> 中；</li>
<li><strong>向上遍历</strong>，对于每一个 <strong>super class</strong>，都会将其加入到  <strong>eventTypesCache</strong> 的 <strong>eventTypes list</strong> 中；</li>
<li>对于<strong>每个 class</strong>，将其直接实现和间接实现的所有接口，都添加到 <strong>eventTypesCache</strong> 的 <strong>eventTypes list</strong> 中；</li>
</ul>
<h4 id="2-1-1-2-addInterfaces"><a href="#2-1-1-2-addInterfaces" class="headerlink" title="2.1.1.2 addInterfaces"></a>2.1.1.2 addInterfaces</h4><p>添加接口集合，就是事件类实现的所有接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addInterfaces</span><span class="params">(List&lt;Class&lt;?&gt;&gt; eventTypes, Class&lt;?&gt;[] interfaces)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】遍历所有的接口，将其收集到 eventTypes 中；</span></span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; interfaceClass : interfaces) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!eventTypes.contains(interfaceClass)) &#123;</span><br><span class="line">            eventTypes.add(interfaceClass);</span><br><span class="line">            <span class="comment">//【--&gt;】处理的接口的接口；</span></span><br><span class="line">            addInterfaces(eventTypes, interfaceClass.getInterfaces());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>逻辑很简单！</p>
<h3 id="2-1-2-postSingleEventForEventType"><a href="#2-1-2-postSingleEventForEventType" class="headerlink" title="2.1.2  postSingleEventForEventType"></a>2.1.2  postSingleEventForEventType</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">postSingleEventForEventType</span><span class="params">(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass)</span> </span>&#123;</span><br><span class="line">    CopyOnWriteArrayList&lt;Subscription&gt; subscriptions;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">//【1】首先去查询该事件是否已经有订阅关系了，这个关系在 register 的时候会确定；</span></span><br><span class="line">        subscriptions = subscriptionsByEventType.get(eventClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【2】存在订阅关系的话，那就 post 消息；</span></span><br><span class="line">    <span class="keyword">if</span> (subscriptions != <span class="keyword">null</span> &amp;&amp; !subscriptions.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">//【2.1】处理每一个订阅关系；</span></span><br><span class="line">        <span class="keyword">for</span> (Subscription subscription : subscriptions) &#123;</span><br><span class="line">            postingState.event = event;</span><br><span class="line">            postingState.subscription = subscription;</span><br><span class="line">            <span class="keyword">boolean</span> aborted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//【--&gt;2.2.1】分发事件；</span></span><br><span class="line">                postToSubscription(subscription, event, postingState.isMainThread);</span><br><span class="line">                <span class="comment">//【2.2】判断是否取消事件分发；</span></span><br><span class="line">                aborted = postingState.canceled;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                postingState.event = <span class="keyword">null</span>;</span><br><span class="line">                postingState.subscription = <span class="keyword">null</span>;</span><br><span class="line">                postingState.canceled = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (aborted) &#123; <span class="comment">// 如果要取消分发，那么会跳出循环；</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法很简单；</p>
<h4 id="2-2-1-postToSubscription-线程模式处理"><a href="#2-2-1-postToSubscription-线程模式处理" class="headerlink" title="2.2.1 postToSubscription - 线程模式处理"></a>2.2.1 postToSubscription - 线程模式处理</h4><p>分发事件，根据订阅方法的线程模式启动不同的 poster；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postToSubscription</span><span class="params">(Subscription subscription, Object event, <span class="keyword">boolean</span> isMainThread)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (subscription.subscriberMethod.threadMode) &#123;</span><br><span class="line">        <span class="keyword">case</span> POSTING:</span><br><span class="line">            <span class="comment">//【1】POSTING，就在事件分发的线程分发订阅；</span></span><br><span class="line">            <span class="comment">//【--&gt;2.2.2】分发订阅；</span></span><br><span class="line">            invokeSubscriber(subscription, event);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MAIN:</span><br><span class="line">            <span class="comment">//【2】MAIN，在主线程分发订阅，这里会判断是否已经在 main 线程，</span></span><br><span class="line">            <span class="comment">// 如果是的话，那就直接分发订阅，否则就通过 mainThreadPoster 分发；</span></span><br><span class="line">            <span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">                invokeSubscriber(subscription, event); <span class="comment">//【--&gt;2.2.2】分发订阅；</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mainThreadPoster.enqueue(subscription, event); <span class="comment">//【--&gt;4.1.2】加入队列；</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BACKGROUND:</span><br><span class="line">            <span class="comment">//【3】BACKGROUND，通过子线程分发订阅，如果当前是在 main 线程，</span></span><br><span class="line">            <span class="comment">// 那就通过 backgroundPoster 新起一个线程分发，如果当前是在自线程，那就当前线程分发；</span></span><br><span class="line">            <span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">                backgroundPoster.enqueue(subscription, event); <span class="comment">//【--&gt;4.2.2】加入队列；</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                invokeSubscriber(subscription, event); <span class="comment">//【--&gt;2.2.2】分发订阅；</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ASYNC:</span><br><span class="line">            <span class="comment">//【4】ASYNC，异步分发订阅，通过 asyncPoster 每次都新起一个线程分发；</span></span><br><span class="line">            asyncPoster.enqueue(subscription, event); <span class="comment">//【--&gt;4.3.2】加入队列；</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unknown thread mode: "</span> + subscription.subscriberMethod.threadMode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们看到了四种不同的线程模式，每种模式有着不同的处理！</p>
<p>同时也看到了一个重要的数据结构：Poster</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Poster mainThreadPoster; <span class="comment">// 主线程 poster，指向一个 HandlerPoster 实例；</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BackgroundPoster backgroundPoster; <span class="comment">// 后台线程 poster</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AsyncPoster asyncPoster; <span class="comment">// 异步 poster</span></span><br></pre></td></tr></table></figure>
<p>对于 mainThreadPoster，他是在 AndroidHandlerMainThreadSupport 中创建的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Poster <span class="title">createPoster</span><span class="params">(EventBus eventBus)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HandlerPoster(eventBus, looper, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不多说了！</p>
<h3 id="2-2-2-invokeSubscriber"><a href="#2-2-2-invokeSubscriber" class="headerlink" title="2.2.2 invokeSubscriber"></a>2.2.2 invokeSubscriber</h3><p>分发订阅，也就是调用订阅者的方法处理订阅事件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invokeSubscriber</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//【1】method.invoke 反射调用；</span></span><br><span class="line">        subscription.subscriberMethod.method.invoke(subscription.subscriber, event);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        handleSubscriberException(subscription, event, e.getCause());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unexpected exception"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法很简单，不多说了；</p>
<h2 id="2-2-postSticky"><a href="#2-2-postSticky" class="headerlink" title="2.2 postSticky"></a>2.2 postSticky</h2><p>发送粘性消息，这可以看到，该方法会将 <strong>event</strong> 保存到 <strong>stickyEvents</strong> 表中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postSticky</span><span class="params">(Object event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (stickyEvents) &#123;</span><br><span class="line">        <span class="comment">//【1】保存到 stickyEvents 中；</span></span><br><span class="line">        stickyEvents.put(event.getClass(), event);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【--&gt;2.1】发送该消息；</span></span><br><span class="line">    post(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在前面 <strong>register</strong> 的时候，我们有分析过在 <strong>register</strong> 时会立刻处理 <strong>Sticky</strong> 事件的分发；</p>
<p>这里就不再多说了；</p>
<h1 id="3-PostingThreadState"><a href="#3-PostingThreadState" class="headerlink" title="3 PostingThreadState"></a>3 PostingThreadState</h1><p>这个类用于保存 <strong>thread post</strong> 的状态，在 <strong>EventBus</strong> 中有个 <strong>ThreadLocal</strong> 成员变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;PostingThreadState&gt; currentPostingThreadState = <span class="keyword">new</span> ThreadLocal&lt;PostingThreadState&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> PostingThreadState <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//【--&gt;3.1】创建 PostingThreadState 对象；</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PostingThreadState();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用于保存每一个线程的 <strong>post</strong> 状态！！</p>
<h2 id="3-1-成员变量"><a href="#3-1-成员变量" class="headerlink" title="3.1 成员变量"></a>3.1 成员变量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PostingThreadState</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> List&lt;Object&gt; eventQueue = <span class="keyword">new</span> ArrayList&lt;&gt;(); <span class="comment">// 事件队列；</span></span><br><span class="line">    <span class="keyword">boolean</span> isPosting; <span class="comment">// 线程是否正在 post 消息；</span></span><br><span class="line">    <span class="keyword">boolean</span> isMainThread; <span class="comment">// post 的线程是否是主线程；</span></span><br><span class="line">    Subscription subscription; <span class="comment">// 订阅关系；</span></span><br><span class="line">    Object event; <span class="comment">// 正在 post 的事件，会从 eventQueue 按照顺序来分发；</span></span><br><span class="line">    <span class="keyword">boolean</span> canceled; <span class="comment">// 是否被取消了；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-Poster"><a href="#4-Poster" class="headerlink" title="4 Poster"></a>4 Poster</h1><p>poster 用于订阅事件的最终分发，所有的 Poster 都实现了下面的接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Posts events.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> William Ferguson</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Poster</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Enqueue an event to be posted for a particular subscription.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> subscription Subscription which will receive the event.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> event        Event that will be posted to subscribers.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Subscription subscription, Object event)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们接着分析：</p>
<h2 id="4-1-HandlerPoster"><a href="#4-1-HandlerPoster" class="headerlink" title="4.1 HandlerPoster"></a>4.1 HandlerPoster</h2><p>处理 main thread 的事件分发：</p>
<h3 id="4-1-1-成员变量"><a href="#4-1-1-成员变量" class="headerlink" title="4.1.1 成员变量"></a>4.1.1 成员变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerPoster</span> <span class="keyword">extends</span> <span class="title">Handler</span> <span class="keyword">implements</span> <span class="title">Poster</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PendingPostQueue queue; <span class="comment">// 正在分发的 post 队列；</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> maxMillisInsideHandleMessage;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventBus eventBus;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> handlerActive; <span class="comment">// 是否处于激活状态；</span></span><br></pre></td></tr></table></figure>
<p>参数 maxMillisInsideHandleMessage 表示处理消息的函数的执行事件，单位是毫秒，传入的是 10；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---&gt; [AndroidHandlerMainThreadSupport.java]</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Poster <span class="title">createPoster</span><span class="params">(EventBus eventBus)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HandlerPoster(eventBus, looper, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 AndroidHandlerMainThreadSupport 创建了一个 HandlerPoster，他会作为 EventBus 单例的成员变量；</p>
<h3 id="4-1-2-enqueue"><a href="#4-1-2-enqueue" class="headerlink" title="4.1.2 enqueue"></a>4.1.2 enqueue</h3><p>添加 post 到队列 中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【--&gt;6.2】创建一个 PendingPost；</span></span><br><span class="line">    PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">//【--&gt;7.2】入队列：</span></span><br><span class="line">        queue.enqueue(pendingPost);</span><br><span class="line">        <span class="keyword">if</span> (!handlerActive) &#123;</span><br><span class="line">            handlerActive = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//【3】发送消息；</span></span><br><span class="line">            <span class="keyword">if</span> (!sendMessage(obtainMessage())) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Could not send handler message"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HandlerPoster 本质上是一个 handler！</p>
<h3 id="4-1-3-run"><a href="#4-1-3-run" class="headerlink" title="4.1.3 run"></a>4.1.3 run</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> rescheduled = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">long</span> started = SystemClock.uptimeMillis();</span><br><span class="line">        <span class="comment">//【1】一个 while 循环，处理 PendingPostQueue 中所有的 post 操作；</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//【--&gt;7.3】post 出队列；</span></span><br><span class="line">            PendingPost pendingPost = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (pendingPost == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    <span class="comment">//【--&gt;7.3】第一次为 null，post 出队列；</span></span><br><span class="line">                    pendingPost = queue.poll();</span><br><span class="line">                    <span class="keyword">if</span> (pendingPost == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        handlerActive = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//【--&gt;2.2.2】执行方法；</span></span><br><span class="line">            eventBus.invokeSubscriber(pendingPost);</span><br><span class="line">            <span class="keyword">long</span> timeInMethod = SystemClock.uptimeMillis() - started;</span><br><span class="line">            <span class="comment">//【2】判断了函数的执行时间，如果大于 10 毫秒，那么说明主线程比较卡顿，</span></span><br><span class="line">            <span class="comment">// 这里会再次发送消息，然后立刻退出循环，这是防止 while 循环堵塞主线程；</span></span><br><span class="line">            <span class="keyword">if</span> (timeInMethod &gt;= maxMillisInsideHandleMessage) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!sendMessage(obtainMessage())) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Could not send handler message"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//【3】设置为 true，handlerActive 会被设置为 rescheduled</span></span><br><span class="line">                <span class="comment">// 因为上面已经再次发送了消息。</span></span><br><span class="line">                rescheduled = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        handlerActive = rescheduled;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，主线程的分发策略是：</p>
<ul>
<li>尽可能一次性处理完成 <strong>PendingPostQueue</strong> 中的所有消息；</li>
<li>如果某个消息的处理时间超过 <strong>10</strong> 毫秒，说明主线程很卡，那么就会退出 <strong>while</strong> 循环；</li>
</ul>
<h2 id="4-2-BackgroundPoster"><a href="#4-2-BackgroundPoster" class="headerlink" title="4.2 BackgroundPoster"></a>4.2 BackgroundPoster</h2><p>处理 background thread 的事件分发：</p>
<h3 id="4-2-1-成员变量"><a href="#4-2-1-成员变量" class="headerlink" title="4.2.1 成员变量"></a>4.2.1 成员变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BackgroundPoster</span> <span class="keyword">implements</span> <span class="title">Runnable</span>, <span class="title">Poster</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PendingPostQueue queue; <span class="comment">// 消息队列；</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventBus eventBus;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> executorRunning; <span class="comment">// 线程池是否在运行；</span></span><br></pre></td></tr></table></figure>
<p>可以看到 BackgroundPoster 是一个 Runnable；</p>
<h3 id="4-2-2-enqueue"><a href="#4-2-2-enqueue" class="headerlink" title="4.2.2 enqueue"></a>4.2.2 enqueue</h3><p>添加消息到 poster 中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【--&gt;6.2】创建一个 PendingPost；</span></span><br><span class="line">    PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">//【--&gt;7.2】入队列：</span></span><br><span class="line">        queue.enqueue(pendingPost);</span><br><span class="line">        <span class="keyword">if</span> (!executorRunning) &#123; <span class="comment">// executorRunning 设置为 true；</span></span><br><span class="line">            executorRunning = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//【--&gt;4.2.3】执行 BackgroundPoster;</span></span><br><span class="line">            eventBus.getExecutorService().execute(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个地方加了锁，这是因为 <strong>post</strong> 方法可以在多线程调用；</p>
<h3 id="4-2-3-run"><a href="#4-2-3-run" class="headerlink" title="4.2.3 run"></a>4.2.3 run</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">//【1】post 出队列，这里有个超时处理：</span></span><br><span class="line">                PendingPost pendingPost = queue.poll(<span class="number">1000</span>);</span><br><span class="line">                <span class="keyword">if</span> (pendingPost == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123; <span class="comment">// 这里加锁了；</span></span><br><span class="line">                        <span class="comment">//【2】如果为 null，那就再次检查，如果依然为 null</span></span><br><span class="line">                        <span class="comment">// 那就退出 run 执行，executorRunning 设置为 false；</span></span><br><span class="line">                        pendingPost = queue.poll();</span><br><span class="line">                        <span class="keyword">if</span> (pendingPost == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            executorRunning = <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//【--&gt;2.2.2】执行方法；</span></span><br><span class="line">                eventBus.invokeSubscriber(pendingPost);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            eventBus.getLogger().log(Level.WARNING, Thread.currentThread().getName() + <span class="string">" was interruppted"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        executorRunning = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这个线程因为 while (true) 一直处于 runnable/running 的状态；</p>
<h2 id="4-3-AsyncPoster"><a href="#4-3-AsyncPoster" class="headerlink" title="4.3 AsyncPoster"></a>4.3 AsyncPoster</h2><p>处理 async thread 的事件分发：</p>
<h3 id="4-3-1-成员变量"><a href="#4-3-1-成员变量" class="headerlink" title="4.3.1 成员变量"></a>4.3.1 成员变量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AsyncPoster</span> <span class="keyword">implements</span> <span class="title">Runnable</span>, <span class="title">Poster</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PendingPostQueue queue; <span class="comment">// 队列；</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventBus eventBus;</span><br></pre></td></tr></table></figure>
<h3 id="4-3-2-enqueue"><a href="#4-3-2-enqueue" class="headerlink" title="4.3.2 enqueue"></a>4.3.2 enqueue</h3><p>添加消息到 poster 中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【--&gt;6.2】创建一个 PendingPost；</span></span><br><span class="line">    PendingPost pendingPost = PendingPost.obtainPendingPost(subscription, event);</span><br><span class="line">    <span class="comment">//【--&gt;7.2】入队列：</span></span><br><span class="line">    queue.enqueue(pendingPost);</span><br><span class="line">    eventBus.getExecutorService().execute(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个人地方竟然没有加锁，奇怪啊～</p>
<h3 id="4-3-3-run"><a href="#4-3-3-run" class="headerlink" title="4.3.3 run"></a>4.3.3 run</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【--&gt;7.3】post 出队列；</span></span><br><span class="line">    PendingPost pendingPost = queue.poll();</span><br><span class="line">    <span class="keyword">if</span>(pendingPost == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No pending post available"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【--&gt;2.2.2】执行方法；</span></span><br><span class="line">    eventBus.invokeSubscriber(pendingPost);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="6-PendingPost"><a href="#6-PendingPost" class="headerlink" title="6 PendingPost"></a>6 PendingPost</h1><p>表示一个正在分发的 post。</p>
<h2 id="6-1-成员变量"><a href="#6-1-成员变量" class="headerlink" title="6.1 成员变量"></a>6.1 成员变量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PendingPost</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 缓存 post，用于复用；</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> List&lt;PendingPost&gt; pendingPostPool = <span class="keyword">new</span> ArrayList&lt;PendingPost&gt;(); </span><br><span class="line">    Object event; <span class="comment">// 要分发的事件；</span></span><br><span class="line">    Subscription subscription; <span class="comment">// 订阅关系；</span></span><br><span class="line">    PendingPost next; <span class="comment">// 下一个要分发的 post，用户构成链表结构；！</span></span><br></pre></td></tr></table></figure>
<h2 id="6-2-obtainPendingPost"><a href="#6-2-obtainPendingPost" class="headerlink" title="6.2 obtainPendingPost"></a>6.2 obtainPendingPost</h2><p>获取一个 <strong>PendingPost</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> PendingPost <span class="title">obtainPendingPost</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (pendingPostPool) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = pendingPostPool.size();</span><br><span class="line">        <span class="comment">//【1】优先从 pendingPostPool 中获取；</span></span><br><span class="line">        <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            PendingPost pendingPost = pendingPostPool.remove(size - <span class="number">1</span>);</span><br><span class="line">            pendingPost.event = event;</span><br><span class="line">            pendingPost.subscription = subscription;</span><br><span class="line">            pendingPost.next = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">return</span> pendingPost;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【2】没有的话，再创建新的；</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PendingPost(event, subscription);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有加锁的！</p>
<h2 id="6-3-releasePendingPost"><a href="#6-3-releasePendingPost" class="headerlink" title="6.3 releasePendingPost"></a>6.3 releasePendingPost</h2><p>消息 <strong>post</strong> 完成后，会缓存 <strong>post</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">releasePendingPost</span><span class="params">(PendingPost pendingPost)</span> </span>&#123;</span><br><span class="line">    pendingPost.event = <span class="keyword">null</span>;</span><br><span class="line">    pendingPost.subscription = <span class="keyword">null</span>;</span><br><span class="line">    pendingPost.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">synchronized</span> (pendingPostPool) &#123;</span><br><span class="line">        <span class="comment">//【1】缓存已经 post 的消息的 PendingPost！！！</span></span><br><span class="line">        <span class="keyword">if</span> (pendingPostPool.size() &lt; <span class="number">10000</span>) &#123;</span><br><span class="line">            pendingPostPool.add(pendingPost);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到：pendingPostPool 不会超过 10000 个；</p>
<h1 id="7-PendingPostQueue"><a href="#7-PendingPostQueue" class="headerlink" title="7 PendingPostQueue"></a>7 PendingPostQueue</h1><p>这是一个由链表构成的 正在分发的 post 的队列！</p>
<h2 id="7-1-成员变量"><a href="#7-1-成员变量" class="headerlink" title="7.1 成员变量"></a>7.1 成员变量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PendingPostQueue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> PendingPost head; <span class="comment">// 队列头；</span></span><br><span class="line">    <span class="keyword">private</span> PendingPost tail; <span class="comment">// 队列尾；</span></span><br></pre></td></tr></table></figure>
<p>内部有队列头和队列尾两个属性；</p>
<p>这个方法的 <strong>enqueue</strong> 和 <strong>poll</strong> 是加锁的～</p>
<h2 id="7-2-enqueue"><a href="#7-2-enqueue" class="headerlink" title="7.2 enqueue"></a>7.2 enqueue</h2><p>将 PendingPost 放入到队列中，默认是加入到队尾，该方法是加锁了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(PendingPost pendingPost)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pendingPost == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"null cannot be enqueued"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【1】入队列；</span></span><br><span class="line">    <span class="keyword">if</span> (tail != <span class="keyword">null</span>) &#123;</span><br><span class="line">        tail.next = pendingPost;</span><br><span class="line">        tail = pendingPost;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        head = tail = pendingPost;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Head present, but no tail"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【2】提醒其他阻塞的线程；</span></span><br><span class="line">    notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-3-poll"><a href="#7-3-poll" class="headerlink" title="7.3 poll"></a>7.3 poll</h2><p>PendingPost 出队列：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> PendingPost <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】从 head 出队列，更改指针；</span></span><br><span class="line">    PendingPost pendingPost = head;</span><br><span class="line">    <span class="keyword">if</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        head = head.next;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">            tail = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pendingPost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">synchronized</span> PendingPost <span class="title">poll</span><span class="params">(<span class="keyword">int</span> maxMillisToWait)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//【2】这个方法会在队列为 null 的时候，等待一会儿；</span></span><br><span class="line">        wait(maxMillisToWait);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> poll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="8-总结"><a href="#8-总结" class="headerlink" title="8 总结"></a>8 总结</h1><p>到这里，EventBus 就整完了，驾鹤西去呦～～</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Coolqi.Li</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://coolqi.top/2019/09/13/Eventbus-4-postMessage/">https://coolqi.top/2019/09/13/Eventbus-4-postMessage/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://coolqi.top">Coolqi`s Blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/EventBus/">EventBus</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="/img/zfb.jpg"><div class="post-qr-code__desc">支付宝打赏</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="/img/wechat.jpg"><div class="post-qr-code__desc">微信打赏</div></div></div><div class="social-share"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2020/04/15/ViewDraw-4-measure/"><i class="fa fa-chevron-left">  </i><span>ViewDraw 第四篇 measure 流程分析</span></a></div><div class="next-post pull-right"><a href="/2019/09/10/Eventbus-3-getDefaultAndRegister/"><span>EventBus 第三篇 - 初始化、注册和取消注册</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2015 - 2020 By Coolqi.Li</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://lishuaiqi.top/">blog</a>!</div><div class="busuanzi"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.5.6"></script><script src="/js/fancybox.js?version=1.5.6"></script><script src="/js/sidebar.js?version=1.5.6"></script><script src="/js/copy.js?version=1.5.6"></script><script src="/js/fireworks.js?version=1.5.6"></script><script src="/js/transition.js?version=1.5.6"></script><script src="/js/scroll.js?version=1.5.6"></script><script src="/js/head.js?version=1.5.6"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="/js/search/local-search.js"></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>