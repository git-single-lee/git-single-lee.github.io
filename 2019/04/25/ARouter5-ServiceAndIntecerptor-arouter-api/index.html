<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="ARouter 第五篇 - 服务和拦截器 (arouter-api)"><meta name="keywords" content="ARouter"><meta name="author" content="Coolqi.Li"><meta name="copyright" content="Coolqi.Li"><title>ARouter 第五篇 - 服务和拦截器 (arouter-api) | Coolqi`s Blog</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://unpkg.com"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitment/style/default.min.css"><script src="https://cdn.jsdelivr.net/npm/gitment/dist/gitment.browser.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?b7acef5306e54116ad8a99e8b753a92d";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-开篇"><span class="toc-text">1 开篇</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-实现接口不同"><span class="toc-text">1.1 实现接口不同</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-注解不同"><span class="toc-text">1.2 注解不同</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-逻辑处理不同"><span class="toc-text">1.3 逻辑处理不同</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-服务-Service"><span class="toc-text">1 服务 Service</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-服务统一接口"><span class="toc-text">1.1 服务统一接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-获取服务"><span class="toc-text">1.2 获取服务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-获取流程分析"><span class="toc-text">1.3 获取流程分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-1-navigation-className-class"><span class="toc-text">1.3.1 navigation(className.class)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-1-1-ARouter-navigation"><span class="toc-text">1.3.1.1 _ARouter.navigation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-1-2-LogisticsCenter-buildProvider"><span class="toc-text">1.3.1.2 LogisticsCenter.buildProvider</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-1-3-LogisticsCenter-completion"><span class="toc-text">1.3.1.3 LogisticsCenter.completion</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-2-build-path-navigation"><span class="toc-text">1.3.2 build(path).navigation()</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-2-1-ARouter-navigation"><span class="toc-text">1.3.2.1 _ARouter.navigation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-2-4-ARouter-navigation"><span class="toc-text">1.3.2.4 _ARouter._navigation</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-内置服务"><span class="toc-text">1.4 内置服务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-1-DegradeService"><span class="toc-text">1.4.1 DegradeService</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-2-PathReplaceService"><span class="toc-text">1.4.2 PathReplaceService</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-3-PretreatmentService"><span class="toc-text">1.4.3 PretreatmentService</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-拦截器-Interceptor"><span class="toc-text">2 拦截器 Interceptor</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-InterceptorServiceImpl-统一管理拦截器"><span class="toc-text">2.1 InterceptorServiceImpl - 统一管理拦截器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-初始化-Interceptor"><span class="toc-text">2.2 初始化 Interceptor</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-LogisticsCenter-completion"><span class="toc-text">2.2.1 LogisticsCenter.completion</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-InterceptorServiceImpl-init"><span class="toc-text">2.2.2 InterceptorServiceImpl.init</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-拦截操作"><span class="toc-text">2.3 拦截操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-ARouter-navigation"><span class="toc-text">2.3.1 _ARouter.navigation</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-1-InterceptorCallback"><span class="toc-text">2.3.1.1 InterceptorCallback</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-InterceptorServiceImpl-doInterceptions"><span class="toc-text">2.3.2 InterceptorServiceImpl.doInterceptions</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-1-checkInterceptorsInitStatus"><span class="toc-text">2.3.2.1 checkInterceptorsInitStatus</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-2-excute"><span class="toc-text">2.3.2.2 _excute</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-线程池"><span class="toc-text">3 线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-线程池初始化"><span class="toc-text">3.1 线程池初始化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-DefaultPoolExecutor"><span class="toc-text">3.2 DefaultPoolExecutor</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-getInstance"><span class="toc-text">3.2.1 getInstance</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-new-DefaultPoolExecutor"><span class="toc-text">3.2.2 new DefaultPoolExecutor</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-DefaultThreadFactory"><span class="toc-text">3.3 DefaultThreadFactory</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-总结"><span class="toc-text">4 总结</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.jpg"></div><div class="author-info__name text-center">Coolqi.Li</div><div class="author-info__description text-center">“Hi，我是李帅奇，Android 开发工程师，熬夜星人，一个努力赚钱，积极向上的好人。微信公众号：CoolOriLans (酷奇源语)”</div><div class="follow-button"><a href="https://github.com/single-li">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">90</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">22</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">27</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">coolqi 和他的朋友们</div><a class="author-info-links__name text-center" href="https://developer.android.google.cn/">AndroidDeveloper</a><a class="author-info-links__name text-center" href="http://www.android-studio.org/">AndroidStudio</a><a class="author-info-links__name text-center" href="https://www.jianshu.com/u/123a20a96441">个人简书</a><a class="author-info-links__name text-center" href="https://weibo.com/coolqiLi">个人微博</a><a class="author-info-links__name text-center" href="https://www.jianshu.com/u/fd0b722ce11f">小二哥的 Android 站</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/img/blog-bg.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Coolqi`s Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/about">About</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">ARouter 第五篇 - 服务和拦截器 (arouter-api)</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-04-25</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/开源库源码分析/">开源库源码分析</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/开源库源码分析/ARouter/">ARouter</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">5k</span><span class="post-meta__separator">|</span><span>阅读时长: 22 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>本系列文章主要分析 ARouter 框架的架构和原理。</p>
<blockquote>
<p>这是阿里 ARouter 开源库的地址，大家可以直接访问</p>
<p><a href="https://github.com/alibaba/ARouter" target="_blank" rel="noopener">https://github.com/alibaba/ARouter</a></p>
</blockquote>
<p>本篇博文主要分析 arouter-api 模块，该模块涉及到 ARouter 一些核心逻辑：初始化，跳转，拦截，服务等，下面的几篇文章就要从这几个方向来分析；</p>
<p>在阅读过程中，涉及到方法跳转的时候，注释上有 <code>--&gt;</code>的标志，这样的好处是，以类为单位，一次性分析其所有的方法！</p>
<h1 id="1-开篇"><a href="#1-开篇" class="headerlink" title="1 开篇"></a>1 开篇</h1><p>这篇文章分析下 ARouter 的 Service 和 Interceptor，二者有如下的区别：</p>
<h2 id="1-1-实现接口不同"><a href="#1-1-实现接口不同" class="headerlink" title="1.1 实现接口不同"></a>1.1 实现接口不同</h2><ul>
<li>Service 直接或者间接的实现了 IProvider 接口：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IProvider</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Context context)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Interceptor 直接或者间接的实现了 IInterceptor 接口：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IInterceptor</span> <span class="keyword">extends</span> <span class="title">IProvider</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(Postcard postcard, InterceptorCallback callback)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-2-注解不同"><a href="#1-2-注解不同" class="headerlink" title="1.2 注解不同"></a>1.2 注解不同</h2><ul>
<li>Service 使用 @Route  注解处理：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Route</span>(path = <span class="string">"/yourservicegroupname/single"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleService</span> <span class="keyword">implements</span> <span class="title">IProvider</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Interceptor 使用 @Interceptor  注解处理：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Interceptor</span>(priority = <span class="number">7</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1Interceptor</span> <span class="keyword">implements</span> <span class="title">IInterceptor</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-3-逻辑处理不同"><a href="#1-3-逻辑处理不同" class="headerlink" title="1.3 逻辑处理不同"></a>1.3 逻辑处理不同</h2><ul>
<li>拦截器会在 ARouter 初始化 init 的时候异步初始化，如果第一次路由的时候拦截器还没有初始化结束，路由会等待，直到初始化完成。<pre><code>- 这个下面可以看到，内部有一个同步锁来控制；
</code></pre></li>
<li>服务没有该限制，某一服务可能在 App 整个生命周期中都不会用到，所以服务只有被调用的时候才会触发初始化操作；</li>
</ul>
<h1 id="1-服务-Service"><a href="#1-服务-Service" class="headerlink" title="1 服务 Service"></a>1 服务 Service</h1><h2 id="1-1-服务统一接口"><a href="#1-1-服务统一接口" class="headerlink" title="1.1 服务统一接口"></a>1.1 服务统一接口</h2><p>ARouter 已经帮我们提供了一些 Service 统一接口，对于对内对外提供特定的功能模版：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-rwxr-xr-x  1 lishuaiqi820  235765416  468 May  8 20:46 AutowiredService.java</span><br><span class="line">-rwxr-xr-x  1 lishuaiqi820  235765416  424 May  8 20:46 ClassLoaderService.java</span><br><span class="line">-rwxr-xr-x  1 lishuaiqi820  235765416  590 May  8 20:46 DegradeService.java</span><br><span class="line">-rwxr-xr-x  1 lishuaiqi820  235765416  575 May  8 20:46 InterceptorService.java</span><br><span class="line">-rwxr-xr-x  1 lishuaiqi820  235765416  555 May  8 20:46 PathReplaceService.java</span><br><span class="line">-rwxr-xr-x  1 lishuaiqi820  235765416  656 May  8 20:46 PretreatmentService.java</span><br><span class="line">-rwxr-xr-x  1 lishuaiqi820  235765416  974 May  8 20:46 SerializationService.java</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>AutowiredService</strong>：用于处理 Autowired 注解的变量的 Service，ARouter 内置了一个 AutowiredServiceImpl 实现了 AutowiredService，我们在分析 inject 的时候，再讲；</li>
<li><strong>ClassLoaderService</strong>：针对于 installrun 的 Service；</li>
<li><strong>DegradeService</strong>：用于在跳转不成功的情况下，做降级处理；</li>
<li><strong>InterceptorService</strong>：用于处理 Interceptor 的 Service，ARouter 内置了一个 InterceptorServiceImpl 实现了 InterceptorService，用于初始化所有的  Interceptor 和处理拦截，我们下面分析；</li>
<li><strong>PathReplaceService</strong>：用于对路由的 path 做预处理；</li>
<li><strong>PretreatmentService</strong>；用于在跳转之前做预处理操作；</li>
<li><strong>SerializationService</strong>：用于序列化 Object 对象，和 Autowired 注解配合使用，我们在分析 inject 的时候，再讲；</li>
</ul>
<h2 id="1-2-获取服务"><a href="#1-2-获取服务" class="headerlink" title="1.2 获取服务"></a>1.2 获取服务</h2><p>ARouter 是通过路由跳转的方式获取服务的，我们来回顾 init 的流程：</p>
<ul>
<li>获取拦截器处理服务：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PathReplaceService pService = ARouter.getInstance().navigation(PathReplaceService.class);</span><br></pre></td></tr></table></figure>
<ul>
<li>获取拦截器处理服务：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">interceptorService = (InterceptorService) ARouter.getInstance().build(<span class="string">"/arouter/service/interceptor"</span>).navigation();</span><br></pre></td></tr></table></figure>
<p>之前在分析 init 的过程中，我们又遇到好几个获取 Service 的地方，上面是举了其中几个栗子！</p>
<ul>
<li>获取序列化服务：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serializationService = ARouter.getInstance().navigation(SerializationService.class);</span><br></pre></td></tr></table></figure>
<p>  上面的代码是在处理 @Autowired 注解的时候，也就是 arouter complier 编译的时候处理的，用于传递自定义的对象；</p>
<h2 id="1-3-获取流程分析"><a href="#1-3-获取流程分析" class="headerlink" title="1.3 获取流程分析"></a>1.3 获取流程分析</h2><p>通过上面可以知道，获取一个 Service 的方法有两种：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ARouter.getInstance().navigation(xxxx.class);</span><br><span class="line"></span><br><span class="line">ARouter.getInstance().build(path).navigation();</span><br></pre></td></tr></table></figure>
<p>下面我们会分析下这两种方式的流程！</p>
<p><strong>有些代码在前面的路由处理过程中分析了，这里不会再重复分析。</strong></p>
<h3 id="1-3-1-navigation-className-class"><a href="#1-3-1-navigation-className-class" class="headerlink" title="1.3.1 navigation(className.class)"></a>1.3.1 navigation(className.class)</h3><p>第一种方式是传入 Service 的父类，我们回顾下<strong>调用链</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ARouter.getInstance().navigation(service.class);</span><br><span class="line">		_ARouter.getInstance().navigation(service);</span><br><span class="line">		    Postcard postcard = LogisticsCenter.buildProvider(service.getName());</span><br><span class="line">               Postcard postcard = Warehouse.providersIndex.get(serviceName);</span><br><span class="line">        LogisticsCenter.completion(postcard);</span><br><span class="line">        _ARouter.getInstance()._navigation(...);</span><br></pre></td></tr></table></figure>
<p>上面这部分的调用过程实际上，我们在路由初始化的时候见到过！</p>
<p>这里我们只看核心的逻辑，省略掉一些奇葩的</p>
<h4 id="1-3-1-1-ARouter-navigation"><a href="#1-3-1-1-ARouter-navigation" class="headerlink" title="1.3.1.1 _ARouter.navigation"></a>1.3.1.1 _ARouter.navigation</h4><p>我回顾下 _ARouter.navigation 方法；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">navigation</span><span class="params">(Class&lt;? extends T&gt; service)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//【--&gt;1.3.1.2】通过 serviceName 找到，对应的 Service 的 RouteMeta 实例，然后创建 Postcard 实例</span></span><br><span class="line">        <span class="comment">// service.getName() 返回的是全限定名；</span></span><br><span class="line">        Postcard postcard = LogisticsCenter.buildProvider(service.getName());</span><br><span class="line">  </span><br><span class="line">        <span class="comment">//【1】如果是 null，说明使用的是旧版本的 compiler sdk，早期的 compiler 不使用全限定名区获取服务；</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == postcard) &#123;</span><br><span class="line">            <span class="comment">//【--&gt;1.3.1.2】通过 serviceName 找到，对应的 Service 的 RouteMeta 实例，然后创建 Postcard 实例</span></span><br><span class="line">            postcard = LogisticsCenter.buildProvider(service.getSimpleName());</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == postcard) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【--&gt;1.3.1.3】完成跳转！</span></span><br><span class="line">        LogisticsCenter.completion(postcard);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">//【2】获取 Serivce；</span></span><br><span class="line">        <span class="keyword">return</span> (T) postcard.getProvider();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoRouteFoundException ex) &#123;</span><br><span class="line">        logger.warning(Consts.TAG, ex.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的核心处理：</p>
<ul>
<li>LogisticsCenter.buildProvider</li>
<li>LogisticsCenter.completion</li>
</ul>
<h4 id="1-3-1-2-LogisticsCenter-buildProvider"><a href="#1-3-1-2-LogisticsCenter-buildProvider" class="headerlink" title="1.3.1.2 LogisticsCenter.buildProvider"></a>1.3.1.2 LogisticsCenter.buildProvider</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Postcard <span class="title">buildProvider</span><span class="params">(String serviceName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】我们知道 service 实现了 IProvider 实例，所以保存在了 Warehouse.providersIndex 中！</span></span><br><span class="line">    RouteMeta meta = Warehouse.providersIndex.get(serviceName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == meta) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//【2】创建路由跳转信息；</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Postcard(meta.getPath(), meta.getGroup());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 Warehouse.providersIndex 保存的是如下的数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">providers.put(<span class="string">"com.alibaba.android.arouter.facade.service.SerializationService"</span>, RouteMeta.build(RouteType.PROVIDER, MySerializationService.class, </span><br><span class="line">                            <span class="string">"/coolqiService/MySerializationService"</span>, <span class="string">"coolqiService"</span>, <span class="keyword">null</span>, -<span class="number">1</span>, -<span class="number">2147483648</span>));</span><br></pre></td></tr></table></figure>
<h4 id="1-3-1-3-LogisticsCenter-completion"><a href="#1-3-1-3-LogisticsCenter-completion" class="headerlink" title="1.3.1.3 LogisticsCenter.completion"></a>1.3.1.3 LogisticsCenter.completion</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">completion</span><span class="params">(Postcard postcard)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == postcard) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoRouteFoundException(TAG + <span class="string">"No postcard!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【1】从 Warehouse.routes 中获取 path 对应的 RouteMeta 缓存数据；</span></span><br><span class="line">    RouteMeta routeMeta = Warehouse.routes.get(postcard.getPath());</span><br><span class="line">    <span class="comment">//【2】如果找不到，那么就从 compiler 生成的数据中查找！</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == routeMeta) &#123; </span><br><span class="line">        <span class="comment">//【2.1】从 Warehouse.routes 中获取 group 对应的 group 类文件；</span></span><br><span class="line">        Class&lt;? extends IRouteGroup&gt; groupMeta = Warehouse.groupsIndex.get(postcard.getGroup());</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == groupMeta) &#123; <span class="comment">// 【2.1.1】找不到抛出异常；</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoRouteFoundException(TAG + <span class="string">"There is no route match the path ["</span> + postcard.getPath() + <span class="string">"], in group ["</span> + postcard.getGroup() + <span class="string">"]"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (ARouter.debuggable()) &#123;</span><br><span class="line">                    logger.debug(TAG, String.format(Locale.getDefault(), <span class="string">"The group [%s] starts loading, trigger by [%s]"</span>, postcard.getGroup(), postcard.getPath()));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//【2.1.2】创建 groupMeta 对应的实例；</span></span><br><span class="line">                IRouteGroup iGroupInstance = groupMeta.getConstructor().newInstance();</span><br><span class="line">                <span class="comment">//【2.1.3】调用其 loadInto 将 group 对应的信息加入到缓存 Warehouse.routes 中！</span></span><br><span class="line">                iGroupInstance.loadInto(Warehouse.routes);</span><br><span class="line">                <span class="comment">//【2.1.4】然后从 Warehouse.groupsIndex 删除这个组对应的信息；</span></span><br><span class="line">                Warehouse.groupsIndex.remove(postcard.getGroup());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (ARouter.debuggable()) &#123;</span><br><span class="line">                    logger.debug(TAG, String.format(Locale.getDefault(), <span class="string">"The group [%s] has already been loaded, trigger by [%s]"</span>, postcard.getGroup(), postcard.getPath()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> HandlerException(TAG + <span class="string">"Fatal exception when loading group meta. ["</span> + e.getMessage() + <span class="string">"]"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//【--&gt;1.3.1.3】重新加载；</span></span><br><span class="line">            completion(postcard);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//【3】这里是通过 RouteMeta 来设置 Postcard 对象，我们先不看；</span></span><br><span class="line">        postcard.setDestination(routeMeta.getDestination());</span><br><span class="line">        postcard.setType(routeMeta.getType()); </span><br><span class="line">        postcard.setPriority(routeMeta.getPriority());</span><br><span class="line">        postcard.setExtra(routeMeta.getExtra());</span><br><span class="line">        Uri rawUri = postcard.getUri();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != rawUri) &#123; </span><br><span class="line">            Map&lt;String, String&gt; resultMap = TextUtils.splitQueryParameters(rawUri);</span><br><span class="line">            Map&lt;String, Integer&gt; paramsType = routeMeta.getParamsType(); </span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (MapUtils.isNotEmpty(paramsType)) &#123;</span><br><span class="line">                <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; params : paramsType.entrySet()) &#123;</span><br><span class="line">                    setValue(postcard,</span><br><span class="line">                            params.getValue(),</span><br><span class="line">                            params.getKey(),</span><br><span class="line">                            resultMap.get(params.getKey()));</span><br><span class="line">                &#125;</span><br><span class="line">                postcard.getExtras().putStringArray(ARouter.AUTO_INJECT, paramsType.keySet().toArray(<span class="keyword">new</span> String[]&#123;&#125;));</span><br><span class="line">            &#125;</span><br><span class="line">            postcard.withString(ARouter.RAW_URI, rawUri.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【4】这里是关键点，判断类型，可以看到 activity 这里是不处理的！；</span></span><br><span class="line">        <span class="keyword">switch</span> (routeMeta.getType()) &#123;</span><br><span class="line">            <span class="keyword">case</span> PROVIDER: </span><br><span class="line">                <span class="comment">//【4.1】我们要获取的 Serivce，类型就是 PROVIDER，routeMeta.getDestination 返回的是要访问的目标类：service.class;</span></span><br><span class="line">                Class&lt;? extends IProvider&gt; providerMeta = (Class&lt;? extends IProvider&gt;) routeMeta.getDestination();</span><br><span class="line">                <span class="comment">//【4.2】然后优先从 Warehouse.providers 缓存中获取；</span></span><br><span class="line">                IProvider instance = Warehouse.providers.get(providerMeta);</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123;</span><br><span class="line">                    IProvider provider;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//【4.3】创建 providerMeta 对应的实例，就是 Service 实例；</span></span><br><span class="line">                        provider = providerMeta.getConstructor().newInstance();</span><br><span class="line">                        <span class="comment">//【4.3.1】执行 init 方法；</span></span><br><span class="line">                        provider.init(mContext);</span><br><span class="line">                        <span class="comment">//【4.3.2】然后将加入到 Warehouse.providers 中去；</span></span><br><span class="line">                        Warehouse.providers.put(providerMeta, provider);</span><br><span class="line">                        instance = provider;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> HandlerException(<span class="string">"Init provider failed! "</span> + e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//【5】将 instance 保存到 postcard.provider 中去，因为跳转目标是 IProvider 的子类；</span></span><br><span class="line">                postcard.setProvider(instance);</span><br><span class="line">                postcard.greenChannel();  <span class="comment">//【6】跳过所有的拦截器！</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> FRAGMENT:</span><br><span class="line">                postcard.greenChannel(); <span class="comment">// 跳过所有的拦截器！</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有所谓的 “按组加载”</p>
<p>可以看到，最后获取了 Service，并调用了其 init 方法；</p>
<p>最后将获得的 Service 保存到了 Postcard 中；</p>
<h3 id="1-3-2-build-path-navigation"><a href="#1-3-2-build-path-navigation" class="headerlink" title="1.3.2 build(path).navigation()"></a>1.3.2 build(path).navigation()</h3><p>第二种方式是通过 path 来查找 Service，我们回顾下<strong>调用链</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ARouter.getInstance().build(path).navigation() </span><br><span class="line">      Postcard postcard = _ARouter.getInstance().build(path)</span><br><span class="line">      Object object = Postcard.navigation();</span><br><span class="line">           Object object = ARouter.getInstance().navigation(context, <span class="keyword">this</span>, -<span class="number">1</span>, callback)</span><br><span class="line">           			Object object = _ARouter.getInstance().navigation(mContext, postcard, requestCode, callback)      </span><br><span class="line">										 LogisticsCenter.completion(postcard);       </span><br><span class="line">                     Object object = _ARouter.getInstance()._navigation(...);</span><br></pre></td></tr></table></figure>
<p>上面这部分的调用过程实际上，我们在路由初始化的时候见到过！</p>
<p>这里我们只看核心的逻辑，省略掉一些非核心的代码；</p>
<h4 id="1-3-2-1-ARouter-navigation"><a href="#1-3-2-1-ARouter-navigation" class="headerlink" title="1.3.2.1 _ARouter.navigation"></a>1.3.2.1 _ARouter.navigation</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">navigation</span><span class="params">(<span class="keyword">final</span> Context context, <span class="keyword">final</span> Postcard postcard, <span class="keyword">final</span> <span class="keyword">int</span> requestCode, <span class="keyword">final</span> NavigationCallback callback)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】这里的获取方式是一样的；</span></span><br><span class="line">    PretreatmentService pretreatmentService = ARouter.getInstance().navigation(PretreatmentService.class);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != pretreatmentService &amp;&amp; !pretreatmentService.onPretreatment(context, postcard)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//【--&gt;1.3.1.3】完善跳转信息！</span></span><br><span class="line">        LogisticsCenter.completion(postcard);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoRouteFoundException ex) &#123;</span><br><span class="line">        logger.warning(Consts.TAG, ex.getMessage());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (debuggable()) &#123;</span><br><span class="line">            runInMainThread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    Toast.makeText(mContext, <span class="string">"There's no route matched!\n"</span> +</span><br><span class="line">                            <span class="string">" Path = ["</span> + postcard.getPath() + <span class="string">"]\n"</span> +</span><br><span class="line">                            <span class="string">" Group = ["</span> + postcard.getGroup() + <span class="string">"]"</span>, Toast.LENGTH_LONG).show();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != callback) &#123;</span><br><span class="line">            callback.onLost(postcard);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//【2】这里的获取方式是一样的；</span></span><br><span class="line">            DegradeService degradeService = ARouter.getInstance().navigation(DegradeService.class);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != degradeService) &#123;</span><br><span class="line">                degradeService.onLost(context, postcard);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != callback) &#123;</span><br><span class="line">        callback.onFound(postcard);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【3】对于 Service 是会跳过拦截器的；</span></span><br><span class="line">    <span class="keyword">if</span> (!postcard.isGreenChannel()) &#123;</span><br><span class="line">        interceptorService.doInterceptions(postcard, <span class="keyword">new</span> InterceptorCallback() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onContinue</span><span class="params">(Postcard postcard)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//【--&gt;1.3.2.2】最终的处理；</span></span><br><span class="line">                _navigation(context, postcard, requestCode, callback);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onInterrupt</span><span class="params">(Throwable exception)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != callback) &#123;</span><br><span class="line">                    callback.onInterrupt(postcard);</span><br><span class="line">                &#125;</span><br><span class="line">                logger.info(Consts.TAG, <span class="string">"Navigation failed, termination by interceptor : "</span> + exception.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//【--&gt;1.3.2.2】最终的处理；</span></span><br><span class="line">        <span class="keyword">return</span> _navigation(context, postcard, requestCode, callback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1-3-2-4-ARouter-navigation"><a href="#1-3-2-4-ARouter-navigation" class="headerlink" title="1.3.2.4 _ARouter._navigation"></a>1.3.2.4 _ARouter._navigation</h4><p>最终处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">_navigation</span><span class="params">(<span class="keyword">final</span> Context context, <span class="keyword">final</span> Postcard postcard, <span class="keyword">final</span> <span class="keyword">int</span> requestCode, <span class="keyword">final</span> NavigationCallback callback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Context currentContext = <span class="keyword">null</span> == context ? mContext : context;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (postcard.getType()) &#123;</span><br><span class="line">        <span class="keyword">case</span> ACTIVITY:</span><br><span class="line">            ... ... ...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> PROVIDER:</span><br><span class="line">            <span class="comment">//【1】返回了 iprovider 实例，就是我们的 Service 对象；</span></span><br><span class="line">            <span class="keyword">return</span> postcard.getProvider();</span><br><span class="line">        <span class="keyword">case</span> BOARDCAST:</span><br><span class="line">        <span class="keyword">case</span> CONTENT_PROVIDER:</span><br><span class="line">        <span class="keyword">case</span> FRAGMENT:</span><br><span class="line">            ... ... ...</span><br><span class="line">        <span class="keyword">case</span> METHOD:</span><br><span class="line">        <span class="keyword">case</span> SERVICE:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就这样，我们获得了 Service 对象！</p>
<h2 id="1-4-内置服务"><a href="#1-4-内置服务" class="headerlink" title="1.4 内置服务"></a>1.4 内置服务</h2><p>我们来看看内置服务接口！</p>
<p>对与 AutowiredService，InterceptorService，SerializationService 我们后面会分析，这里就不重点分析了，累！</p>
<h3 id="1-4-1-DegradeService"><a href="#1-4-1-DegradeService" class="headerlink" title="1.4.1 DegradeService"></a>1.4.1 DegradeService</h3><p>降级服务，当跳转失败后，可以在这里做处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DegradeService</span> <span class="keyword">extends</span> <span class="title">IProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onLost</span><span class="params">(Context context, Postcard postcard)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-4-2-PathReplaceService"><a href="#1-4-2-PathReplaceService" class="headerlink" title="1.4.2 PathReplaceService"></a>1.4.2 PathReplaceService</h3><p>路径 path 替换服务，我们可以在启动跳转之前，对 path 进行拦截，替换新的 path： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PathReplaceService</span> <span class="keyword">extends</span> <span class="title">IProvider</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">forString</span><span class="params">(String path)</span></span>;</span><br><span class="line">    <span class="function">Uri <span class="title">forUri</span><span class="params">(Uri uri)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以针对 path 和 uri 两种方式！</p>
<h3 id="1-4-3-PretreatmentService"><a href="#1-4-3-PretreatmentService" class="headerlink" title="1.4.3 PretreatmentService"></a>1.4.3 PretreatmentService</h3><p>跳转预处理服务，我们可以在启动跳转之前，针对跳转路由数据做预处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PathReplaceService</span> <span class="keyword">extends</span> <span class="title">IProvider</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">forString</span><span class="params">(String path)</span></span>;</span><br><span class="line">    <span class="function">Uri <span class="title">forUri</span><span class="params">(Uri uri)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以针对 path 和 uri 两种方式！</p>
<h1 id="2-拦截器-Interceptor"><a href="#2-拦截器-Interceptor" class="headerlink" title="2 拦截器 Interceptor"></a>2 拦截器 Interceptor</h1><h2 id="2-1-InterceptorServiceImpl-统一管理拦截器"><a href="#2-1-InterceptorServiceImpl-统一管理拦截器" class="headerlink" title="2.1 InterceptorServiceImpl - 统一管理拦截器"></a>2.1 InterceptorServiceImpl - 统一管理拦截器</h2><p>在 ARouter 框架里面，有一个 InterceptorServiceImpl 服务，用于统一管理 Interceptor：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">afterInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    interceptorService = (InterceptorService) ARouter.getInstance().build(<span class="string">"/arouter/service/interceptor"</span>).navigation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们就不多说了，这个是获取拦截器管理服务的方式，流程上面分析了；</p>
<h2 id="2-2-初始化-Interceptor"><a href="#2-2-初始化-Interceptor" class="headerlink" title="2.2 初始化 Interceptor"></a>2.2 初始化 Interceptor</h2><p>Interceptor 的初始化由 InterceptorServiceImpl 完成，</p>
<p>核心的逻辑在 <strong>LogisticsCenter.completion</strong> 中！</p>
<h3 id="2-2-1-LogisticsCenter-completion"><a href="#2-2-1-LogisticsCenter-completion" class="headerlink" title="2.2.1 LogisticsCenter.completion"></a>2.2.1 LogisticsCenter.completion</h3><p>这里我们省略掉无关的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">completion</span><span class="params">(Postcard postcard)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == postcard) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoRouteFoundException(TAG + <span class="string">"No postcard!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    RouteMeta routeMeta = Warehouse.routes.get(postcard.getPath());</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == routeMeta) &#123; </span><br><span class="line">    		... ... ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ... ... ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【1】这里是关键点，判断类型，可以看到 activity 这里是不处理的！；</span></span><br><span class="line">        <span class="keyword">switch</span> (routeMeta.getType()) &#123;</span><br><span class="line">            <span class="keyword">case</span> PROVIDER: </span><br><span class="line">                <span class="comment">//【2.1】我们要获取的 InterceptorServiceImpl，类型就是 PROVIDER，routeMeta.getDestination 返回的是要访问的目标类：InterceptorServiceImpl.class;</span></span><br><span class="line">                Class&lt;? extends IProvider&gt; providerMeta = (Class&lt;? extends IProvider&gt;) routeMeta.getDestination();</span><br><span class="line">                <span class="comment">//【1.2】然后优先从 Warehouse.providers 缓存中获取；</span></span><br><span class="line">                IProvider instance = Warehouse.providers.get(providerMeta);</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123;</span><br><span class="line">                    IProvider provider;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//【1.2.1】创建 providerMeta 对应的实例，就是 InterceptorServiceImpl；</span></span><br><span class="line">                        provider = providerMeta.getConstructor().newInstance();</span><br><span class="line">                        <span class="comment">//【---&gt;2.2.2】执行 init 方法；</span></span><br><span class="line">                        provider.init(mContext);</span><br><span class="line">                        <span class="comment">//【1.2.2】然后将加入到 Warehouse.providers 中去；</span></span><br><span class="line">                        Warehouse.providers.put(providerMeta, provider);</span><br><span class="line">                        instance = provider;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> HandlerException(<span class="string">"Init provider failed! "</span> + e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//【1.2.3】将 instance 保存到 postcard.provider 中去，因为跳转目标是 IProvider 的子类；</span></span><br><span class="line">                postcard.setProvider(instance);</span><br><span class="line">                postcard.greenChannel();  <span class="comment">//【1.2.4】跳过所有的拦截器！</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> FRAGMENT:</span><br><span class="line">                postcard.greenChannel(); <span class="comment">// 跳过所有的拦截器！</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>回顾</strong>：</p>
<p>我们知道在路由初始化的过程中，afterInit 会获得 InterceptorServiceImpl 方法并执行其 init 的初始化操作！</p>
<h3 id="2-2-2-InterceptorServiceImpl-init"><a href="#2-2-2-InterceptorServiceImpl-init" class="headerlink" title="2.2.2 InterceptorServiceImpl.init"></a>2.2.2 InterceptorServiceImpl.init</h3><p>在 InterceptorServiceImpl 的 init 方法中，会获取所有的 Interceptor，并对其做初始化操作；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">final</span> Context context)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】这里是在由线程池管理的子线程中执行 init 操作；</span></span><br><span class="line">    LogisticsCenter.executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (MapUtils.isNotEmpty(Warehouse.interceptorsIndex)) &#123;</span><br><span class="line">                <span class="comment">//【1】从 Warehouse.interceptorsIndex 获取所有注解生成的拦截器；</span></span><br><span class="line">                <span class="keyword">for</span> (Map.Entry&lt;Integer, Class&lt;? extends IInterceptor&gt;&gt; entry : Warehouse.interceptorsIndex.entrySet()) &#123;</span><br><span class="line">                    Class&lt;? extends IInterceptor&gt; interceptorClass = entry.getValue();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//【2】创建 interceptors 实例，并执行 init 初始化；</span></span><br><span class="line">                        IInterceptor iInterceptor = interceptorClass.getConstructor().newInstance();</span><br><span class="line">                        iInterceptor.init(context);</span><br><span class="line">                        <span class="comment">//【3】将其加入到缓存 Warehouse.interceptors</span></span><br><span class="line">                        Warehouse.interceptors.add(iInterceptor);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> HandlerException(TAG + <span class="string">"ARouter init interceptor error! name = ["</span> </span><br><span class="line">                                                   + interceptorClass.getName() + <span class="string">"], reason = ["</span> + ex.getMessage() + <span class="string">"]"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                interceptorHasInit = <span class="keyword">true</span>; <span class="comment">//【4】init 状态设置为 true；</span></span><br><span class="line"></span><br><span class="line">                logger.info(TAG, <span class="string">"ARouter interceptors init over."</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span> (interceptorInitLock) &#123; <span class="comment">//【5】当 init 操作完成后 notifyAll 通知等待 init 的线程；</span></span><br><span class="line">                    interceptorInitLock.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里是在由线程池管理的字现场中执行 init 操作！</p>
<p>注意，这里有一个同步锁，如果在路由的时候，发现 interceptorHasInit 为 false，那么会调用 interceptorInitLock.wait 进入阻塞状态，等待初始化完成，被 notifyAll 唤醒！</p>
<h2 id="2-3-拦截操作"><a href="#2-3-拦截操作" class="headerlink" title="2.3 拦截操作"></a>2.3 拦截操作</h2><p>我们来看看拦截操作是如何做的，核心代码在 _ARouter.navigation 中：</p>
<h3 id="2-3-1-ARouter-navigation"><a href="#2-3-1-ARouter-navigation" class="headerlink" title="2.3.1 _ARouter.navigation"></a>2.3.1 _ARouter.navigation</h3><p>我们只关注核心的逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">navigation</span><span class="params">(<span class="keyword">final</span> Context context, <span class="keyword">final</span> Postcard postcard, <span class="keyword">final</span> <span class="keyword">int</span> requestCode, <span class="keyword">final</span> NavigationCallback callback)</span> </span>&#123;</span><br><span class="line">    ... ... ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != callback) &#123;</span><br><span class="line">        callback.onFound(postcard);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【1】如果跳转不能避开所有的拦截器，那么就要在这里处理，我们知道 Fragment 和 IProvider 的子类是会避开拦截器的！</span></span><br><span class="line">    <span class="keyword">if</span> (!postcard.isGreenChannel()) &#123;</span><br><span class="line">        <span class="comment">//【--&gt;2.3.2】这一部分设计拦截器功能，我们在跳转那一篇再分析；</span></span><br><span class="line">        interceptorService.doInterceptions(postcard, <span class="keyword">new</span> InterceptorCallback() &#123;  <span class="comment">//【--&gt;2.3.1.1】处理拦截结果；</span></span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onContinue</span><span class="params">(Postcard postcard)</span> </span>&#123;</span><br><span class="line">                _navigation(context, postcard, requestCode, callback);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onInterrupt</span><span class="params">(Throwable exception)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != callback) &#123;</span><br><span class="line">                    callback.onInterrupt(postcard);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                logger.info(Consts.TAG, <span class="string">"Navigation failed, termination by interceptor : "</span> + exception.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//【--&gt;3.2.7】最终的处理；</span></span><br><span class="line">        <span class="keyword">return</span> _navigation(context, postcard, requestCode, callback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到，这里传入了一个拦截结果回调：</p>
<h4 id="2-3-1-1-InterceptorCallback"><a href="#2-3-1-1-InterceptorCallback" class="headerlink" title="2.3.1.1 InterceptorCallback"></a>2.3.1.1 InterceptorCallback</h4><p>位于 callback 包下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InterceptorCallback</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onContinue</span><span class="params">(Postcard postcard)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onInterrupt</span><span class="params">(Throwable exception)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-2-InterceptorServiceImpl-doInterceptions"><a href="#2-3-2-InterceptorServiceImpl-doInterceptions" class="headerlink" title="2.3.2 InterceptorServiceImpl.doInterceptions"></a>2.3.2 InterceptorServiceImpl.doInterceptions</h3><p>当我们路由跳转时，如果指定了 Interceptor，那么就要执行拦截操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doInterceptions</span><span class="params">(<span class="keyword">final</span> Postcard postcard, <span class="keyword">final</span> InterceptorCallback callback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != Warehouse.interceptors &amp;&amp; Warehouse.interceptors.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//【--&gt;2.3.2.1】判断下 init 操作是否完成；</span></span><br><span class="line">        checkInterceptorsInitStatus();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!interceptorHasInit) &#123;</span><br><span class="line">            callback.onInterrupt(<span class="keyword">new</span> HandlerException(<span class="string">"Interceptors initialization takes too much time."</span>));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【1】这里是在由线程池管理的子线程中执行 init 操作；</span></span><br><span class="line">        LogisticsCenter.executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//【2】创建了一个 CountDownLatch 对象，这个对象以 Warehouse.interceptors 的 size 为计数基准；</span></span><br><span class="line">                <span class="comment">// 没处理一个 inteceptor，计数减一，知道计数为 0，才会释放持有的锁！；</span></span><br><span class="line">                CancelableCountDownLatch interceptorCounter = <span class="keyword">new</span> CancelableCountDownLatch(Warehouse.interceptors.size());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//【--&gt;2.3.2.2】执行拦截操作！</span></span><br><span class="line">                    _excute(<span class="number">0</span>, interceptorCounter, postcard);</span><br><span class="line">                    <span class="comment">//【3】调用 await，子线程进入等待中；</span></span><br><span class="line">                    interceptorCounter.await(postcard.getTimeout(), TimeUnit.SECONDS);</span><br><span class="line">                  </span><br><span class="line">                    <span class="comment">//【4】拦截器处理完成（CountDownLatch 计数归 0），或者 await 超时退出；</span></span><br><span class="line">                    <span class="keyword">if</span> (interceptorCounter.getCount() &gt; <span class="number">0</span>) &#123; <span class="comment">// Cancel the navigation this time, if it hasn't return anythings.</span></span><br><span class="line">                        callback.onInterrupt(<span class="keyword">new</span> HandlerException(<span class="string">"The interceptor processing timed out."</span>));</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">null</span> != postcard.getTag()) &#123; <span class="comment">// Maybe some exception in the tag.</span></span><br><span class="line">                        callback.onInterrupt(<span class="keyword">new</span> HandlerException(postcard.getTag().toString()));</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        callback.onContinue(postcard);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    callback.onInterrupt(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        callback.onContinue(postcard);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里其实可以看出，拦截器使用了责任链模式！</p>
<p>这里有一个新的类型：CancelableCountDownLatch，其实就是一个 CountDownLatch，代码很简单，不多说了！</p>
<h4 id="2-3-2-1-checkInterceptorsInitStatus"><a href="#2-3-2-1-checkInterceptorsInitStatus" class="headerlink" title="2.3.2.1 checkInterceptorsInitStatus"></a>2.3.2.1 checkInterceptorsInitStatus</h4><p>判断是否初始化完成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkInterceptorsInitStatus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (interceptorInitLock) &#123;</span><br><span class="line">        <span class="comment">//【1】主要是判断 interceptorHasInit 是否为 true！</span></span><br><span class="line">        <span class="keyword">while</span> (!interceptorHasInit) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//【1】进入等待状态，超时时间是 10s！</span></span><br><span class="line">                interceptorInitLock.wait(<span class="number">10</span> * <span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> HandlerException(TAG + <span class="string">"Interceptor init cost too much time error! reason = ["</span> + e.getMessage() + <span class="string">"]"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>interceptorInitLock 是 InterceptorServiceImpl 内部的一个锁对象；</p>
<h4 id="2-3-2-2-excute"><a href="#2-3-2-2-excute" class="headerlink" title="2.3.2.2 _excute"></a>2.3.2.2 _excute</h4><p>index 的值为 0，开始执行拦截：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">_excute</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> index, <span class="keyword">final</span> CancelableCountDownLatch counter, <span class="keyword">final</span> Postcard postcard)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; Warehouse.interceptors.size()) &#123;</span><br><span class="line">            <span class="comment">//【1】获得 index 对应的拦截器；</span></span><br><span class="line">            IInterceptor iInterceptor = Warehouse.interceptors.get(index);</span><br><span class="line">            <span class="comment">//【2】执行拦截器的 process 方法，同时传入一个回调：【--&gt;2.3.1.1】InterceptorCallback</span></span><br><span class="line">            iInterceptor.process(postcard, <span class="keyword">new</span> InterceptorCallback() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onContinue</span><span class="params">(Postcard postcard)</span> </span>&#123;</span><br><span class="line">                    <span class="comment">//【2.1】不拦截，CountDownLatch 计数减去 1；</span></span><br><span class="line">                    counter.countDown();</span><br><span class="line">                    <span class="comment">//【--&gt;2.3.2.2】继续调用 _excute 方法，index 加一，下一个拦截器；</span></span><br><span class="line">                    _excute(index + <span class="number">1</span>, counter, postcard);  <span class="comment">// When counter is down, it will be execute continue ,but index bigger than interceptors size, then U know.</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onInterrupt</span><span class="params">(Throwable exception)</span> </span>&#123;</span><br><span class="line">                    <span class="comment">//【2.2】拦截，CountDownLatch 计数归 0；</span></span><br><span class="line">                    postcard.setTag(<span class="keyword">null</span> == exception ? <span class="keyword">new</span> HandlerException(<span class="string">"No message."</span>) : exception.getMessage());    <span class="comment">// save the exception message for backup.</span></span><br><span class="line">                    counter.cancel();</span><br><span class="line">                    <span class="comment">// Be attention, maybe the thread in callback has been changed,</span></span><br><span class="line">                    <span class="comment">// then the catch block(L207) will be invalid.</span></span><br><span class="line">                    <span class="comment">// The worst is the thread changed to main thread, then the app will be crash, if you throw this exception!</span></span><br><span class="line"><span class="comment">//                    if (!Looper.getMainLooper().equals(Looper.myLooper())) &#123;    // You shouldn't throw the exception if the thread is main thread.</span></span><br><span class="line"><span class="comment">//                        throw new HandlerException(exception.getMessage());</span></span><br><span class="line"><span class="comment">//                    &#125;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>整个过程很简单，不多说了。</p>
<h1 id="3-线程池"><a href="#3-线程池" class="headerlink" title="3 线程池"></a>3 线程池</h1><p>刚刚我们有看到，拦截器的初始化和拦截都是在子线程中做的，ARouter 通过内部的一个线程池来管理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DefaultPoolExecutor.java  <span class="comment">// 线程池</span></span><br><span class="line">DefaultThreadFactory.java  <span class="comment">// 线程工厂</span></span><br></pre></td></tr></table></figure>
<h2 id="3-1-线程池初始化"><a href="#3-1-线程池初始化" class="headerlink" title="3.1 线程池初始化"></a>3.1 线程池初始化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">_ARouter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> ILogger logger = <span class="keyword">new</span> DefaultLogger(Consts.TAG);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">boolean</span> monitorMode = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">boolean</span> debuggable = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">boolean</span> autoInject = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> _ARouter instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="keyword">boolean</span> hasInit = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//【1】DefaultPoolExecutor 是 _ARouter 的静态变量；</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> ThreadPoolExecutor executor = DefaultPoolExecutor.getInstance();</span><br></pre></td></tr></table></figure>
<p>然后再初始化 LogisticsCenter 的时候传递给了 LogisticsCenter；</p>
<h2 id="3-2-DefaultPoolExecutor"><a href="#3-2-DefaultPoolExecutor" class="headerlink" title="3.2 DefaultPoolExecutor"></a>3.2 DefaultPoolExecutor</h2><p>我们来看下线程池的构造，这里要重点看看线程池的核心参数：</p>
<h3 id="3-2-1-getInstance"><a href="#3-2-1-getInstance" class="headerlink" title="3.2.1 getInstance"></a>3.2.1 getInstance</h3><p>单例模式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DefaultPoolExecutor <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (DefaultPoolExecutor.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123;</span><br><span class="line">                <span class="comment">//【--&gt;3.2.2】创建线程池；</span></span><br><span class="line">                instance = <span class="keyword">new</span> DefaultPoolExecutor(</span><br><span class="line">                        INIT_THREAD_COUNT,</span><br><span class="line">                        MAX_THREAD_COUNT,</span><br><span class="line">                        SURPLUS_THREAD_LIFE,</span><br><span class="line">                        TimeUnit.SECONDS,</span><br><span class="line">                        <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">64</span>),</span><br><span class="line">                        <span class="keyword">new</span> DefaultThreadFactory());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-2-new-DefaultPoolExecutor"><a href="#3-2-2-new-DefaultPoolExecutor" class="headerlink" title="3.2.2 new DefaultPoolExecutor"></a>3.2.2 new DefaultPoolExecutor</h3><p>我们来研究下 DefaultPoolExecutor 的一些核心参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">DefaultPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, </span></span></span><br><span class="line"><span class="function"><span class="params">                            																																												ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, <span class="keyword">new</span> RejectedExecutionHandler() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> </span>&#123;</span><br><span class="line">             ARouter.logger.error(Consts.TAG, <span class="string">"Task rejected, too many task!"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>这里涉及到了 DefaultPoolExecutor 内部的常量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CPU_COUNT = Runtime.getRuntime().availableProcessors(); <span class="comment">// Java 虚拟机的可用的处理器数量；</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INIT_THREAD_COUNT = CPU_COUNT + <span class="number">1</span>;  <span class="comment">// 核心线程数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_THREAD_COUNT = INIT_THREAD_COUNT;  <span class="comment">// 最大线程数；</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SURPLUS_THREAD_LIFE = <span class="number">30L</span>; <span class="comment">// 空闲线程在</span></span><br></pre></td></tr></table></figure>
<p>可以看到，线程池的参数如下：</p>
<ul>
<li>corePoolSize：核心线程数是可用的处理器数量 + 1；</li>
<li>maximumPoolSize：最大线程数是可用的处理器数量；</li>
<li>keepAliveTime：空闲线程存活时间：30s；</li>
<li>workQueue：阻塞队列是 ArrayBlockingQueue，数组实现的阻塞队列，有界 64；</li>
<li>threadFactory：线程工厂类，自定义的 DefaultThreadFactory 类；</li>
<li>RejectedExecutionHandler：线程池在无法处理添加的 runnnable 时的处理机制，这里是自定义了一个 RejectedExecutionHandler，只是打印了一个 Log；</li>
</ul>
<h2 id="3-3-DefaultThreadFactory"><a href="#3-3-DefaultThreadFactory" class="headerlink" title="3.3 DefaultThreadFactory"></a>3.3 DefaultThreadFactory</h2><p>ARouter 内部自定义的线程工厂类，DefaultThreadFactory 需要实现 ThreadFactory 接口；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultThreadFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】这里通过 SecurityManager 来设置 thread 的 group；</span></span><br><span class="line">    SecurityManager s = System.getSecurityManager();</span><br><span class="line">    group = (s != <span class="keyword">null</span>) ? s.getThreadGroup() :</span><br><span class="line">            Thread.currentThread().getThreadGroup();</span><br><span class="line">    namePrefix = <span class="string">"ARouter task pool No."</span> + poolNumber.getAndIncrement() + <span class="string">", thread No."</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看看 newThread 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(@NonNull Runnable runnable)</span> </span>&#123;</span><br><span class="line">    String threadName = namePrefix + threadNumber.getAndIncrement();</span><br><span class="line">    ARouter.logger.info(Consts.TAG, <span class="string">"Thread production, name is ["</span> + threadName + <span class="string">"]"</span>);</span><br><span class="line">    <span class="comment">//【1】创建线程，一个线程对应一个 runnable；</span></span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(group, runnable, threadName, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (thread.isDaemon()) &#123;   <span class="comment">//【2】设为非后台线程</span></span><br><span class="line">        thread.setDaemon(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (thread.getPriority() != Thread.NORM_PRIORITY) &#123; <span class="comment">// 【2】优先级为 normal</span></span><br><span class="line">        thread.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【3】捕获多线程处理中的异常</span></span><br><span class="line">    thread.setUncaughtExceptionHandler(<span class="keyword">new</span> Thread.UncaughtExceptionHandler() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread thread, Throwable ex)</span> </span>&#123;</span><br><span class="line">            ARouter.logger.info(Consts.TAG, <span class="string">"Running task appeared exception! Thread ["</span> + thread.getName() + <span class="string">"], because ["</span> + ex.getMessage() + <span class="string">"]"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不多说了！</p>
<h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h1><p>本篇文章分析了 ARouter 的服务和拦截器的相关机制</p>
<ul>
<li>拦截器的初始化和拦截操作都是在子线程中处理的，拦截器使用了责任链模式；</li>
<li>子线程通过线程池管理，采用了单例模式；</li>
<li>拦截器是使用了责任链模式，通过它使用 CountDownLatch 来实现了路由等待的操作；</li>
</ul>
<p>但是遗留了几个问题：</p>
<ul>
<li>AutowiredService 和 AutowiredServiceImpl 是如何工作的；</li>
<li>ClassLoaderService 是如何工作的；</li>
</ul>
<p>我们下次再说～～～</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Coolqi.Li</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lishuaiqi.top/2019/04/25/ARouter5-ServiceAndIntecerptor-arouter-api/">https://lishuaiqi.top/2019/04/25/ARouter5-ServiceAndIntecerptor-arouter-api/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lishuaiqi.top">Coolqi`s Blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/ARouter/">ARouter</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="/img/zfb.jpg"><div class="post-qr-code__desc">支付宝打赏</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="/img/wechat.jpg"><div class="post-qr-code__desc">微信打赏</div></div></div><div class="social-share pull-right"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/04/30/ARouter6-autoInjectWithAutoWired-arouter-api/"><i class="fa fa-chevron-left">  </i><span>ARouter 第六篇 - 自动注入 (arouter-api)</span></a></div><div class="next-post pull-right"><a href="/2019/04/23/ARouter4-arouterInitCreate-arouter-api/"><span>ARouter 第四篇 - 路由初始化 (arouter-api)</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitment-container"></div><script>var gitment = new Gitment({
  id: md5(decodeURI(location.pathname)),
  owner: '',
  repo: '',
  oauth: {
    client_id: '7b4efbcd7027d15749d6',
    client_secret: '14b5d7e8580ee29f7aeca733a25c000795967448'
  }
})
gitment.render('gitment-container')</script></div></div><footer class="footer-bg" style="background-image: url(/img/blog-bg.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2015 - 2022 By Coolqi.Li</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://lishuaiqi.top/">blog</a>!</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>