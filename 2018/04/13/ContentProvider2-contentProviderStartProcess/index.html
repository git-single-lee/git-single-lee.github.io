<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="ContentProvider篇  2 - ContentProvider 的启动"><meta name="keywords" content="ContentProvider内容提供者"><meta name="author" content="Coolqi.Li"><meta name="copyright" content="Coolqi.Li"><title>ContentProvider篇  2 - ContentProvider 的启动 | Coolqi`s Blog</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://unpkg.com"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitment/style/default.min.css"><script src="https://cdn.jsdelivr.net/npm/gitment/dist/gitment.browser.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?b7acef5306e54116ad8a99e8b753a92d";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#0-综述"><span class="toc-text">0 综述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#1-ContextImpl"><span class="toc-text">1 ContextImpl</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-getContentResolver"><span class="toc-text">1.1 getContentResolver</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-new-ApplicationContentResolver"><span class="toc-text">1.2 new ApplicationContentResolver</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-ContentResolver"><span class="toc-text">2 ContentResolver</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-query-查询"><span class="toc-text">2.1 query - 查询</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-acquireUnstableProvider-获取-unstable-provider"><span class="toc-text">2.1.1 acquireUnstableProvider - 获取 unstable provider</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-acquireProvider-获取-stable-provider"><span class="toc-text">2.1.2 acquireProvider - 获取 stable provider</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-ApplicationContentResolver"><span class="toc-text">3 ApplicationContentResolver</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-acquireUnstableProvider-获取-unstable-provider"><span class="toc-text">3.1 acquireUnstableProvider  - 获取 unstable provider</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-unstableProviderDied"><span class="toc-text">3.2 unstableProviderDied</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-acquireProvider-获取-stable-provider"><span class="toc-text">3.3 acquireProvider  - 获取 stable provider</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-ActivityThread"><span class="toc-text">4 ActivityThread</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-acquireProvider-获取-provider"><span class="toc-text">4.1 acquireProvider - 获取 provider</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-1-acquireExistingProvider"><span class="toc-text">4.1.1 acquireExistingProvider</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-1-1-handleUnstableProviderDiedLocked"><span class="toc-text">4.1.1.1 handleUnstableProviderDiedLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-1-2-incProviderRefLocked"><span class="toc-text">4.1.1.2 incProviderRefLocked</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-handleUnstableProviderDied"><span class="toc-text">4.2 handleUnstableProviderDied</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-handleUnstableProviderDiedLocked"><span class="toc-text">4.2.1 handleUnstableProviderDiedLocked</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-ActivityManagerService-系统进程1"><span class="toc-text">5 ActivityManagerService  - 系统进程1</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-getContentProvider-Impl"><span class="toc-text">5.1 getContentProvider[Impl]</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-1-Provider-正在运行的情况"><span class="toc-text">5.1.1  Provider 正在运行的情况</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-1-1-isSingleton"><span class="toc-text">5.1.1.1 isSingleton</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-1-2-isValidSingletonCall"><span class="toc-text">5.1.1.2 isValidSingletonCall</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-1-3-checkContentProviderPermissionLocked"><span class="toc-text">5.1.1.3 checkContentProviderPermissionLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-1-4-ContentProviderRecord-canRunHere"><span class="toc-text">5.1.1.4 ContentProviderRecord.canRunHere</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-1-5-ContentProviderRecord-newHolder"><span class="toc-text">5.1.1.5 ContentProviderRecord.newHolder</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-1-6-incProviderCountLocked"><span class="toc-text">5.1.1.6 incProviderCountLocked</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1-1-6-1-new-ContentProviderConnection"><span class="toc-text">5.1.1.6.1 new ContentProviderConnection</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-1-7-decProviderCountLocked"><span class="toc-text">5.1.1.7 decProviderCountLocked</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-2-Provider-没在运行的情况"><span class="toc-text">5.1.2  Provider 没在运行的情况</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-2-1-ProviderMap"><span class="toc-text">5.1.2.1 ProviderMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-2-2-new-ContentProviderRecord"><span class="toc-text">5.1.2.2 new ContentProviderRecord</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-3-ActivityManagerProxy-getContentProvider"><span class="toc-text">5.1.3 ActivityManagerProxy.getContentProvider</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-3-1-ContentProviderHolder-CREATOR-createFromParcel"><span class="toc-text">5.1.3.1 ContentProviderHolder.CREATOR.createFromParcel</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-3-2-new-ContentProviderHolder-Parcel"><span class="toc-text">5.1.3.2 new ContentProviderHolder[Parcel]</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-ActivityThread"><span class="toc-text">6 ActivityThread</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-provider-未启动但是其进程已经启动"><span class="toc-text">6.1 provider 未启动但是其进程已经启动</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-1-scheduleInstallProvider"><span class="toc-text">6.1.1 scheduleInstallProvider</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-2-H-handleMessage-INSTALL-PROVIDER"><span class="toc-text">6.1.2 H.handleMessage[INSTALL_PROVIDER]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-3-handleInstallProvider"><span class="toc-text">6.1.3 handleInstallProvider</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-provider-未启动同时其进程也未启动"><span class="toc-text">6.2 provider 未启动同时其进程也未启动</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-1-AMS-attachApplicationLocked"><span class="toc-text">6.2.1 AMS.attachApplicationLocked</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-1-1-generateApplicationProvidersLocked"><span class="toc-text">6.2.1.1 generateApplicationProvidersLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-1-2-checkAppInLaunchingProvidersLocked"><span class="toc-text">6.2.1.2 checkAppInLaunchingProvidersLocked</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-2-handleBindApplication"><span class="toc-text">6.2.2 handleBindApplication</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-installContentProviders-安装-provider"><span class="toc-text">6.3 installContentProviders - 安装 provider</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-installProvider"><span class="toc-text">6.4 installProvider</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-1-new-ContentProvider"><span class="toc-text">6.4.1 new ContentProvider</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-2-ContentProvider-getIContentProvider"><span class="toc-text">6.4.2 ContentProvider.getIContentProvider</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-2-1-new-Transport"><span class="toc-text">6.4.2.1 new Transport</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-3-ContentProvider-attachInfo-2-gt-3"><span class="toc-text">6.4.3 ContentProvider.attachInfo[2]-&gt;[3]</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-3-1-parse-attribute"><span class="toc-text">6.4.3.1 parse attribute</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-3-2-ContentProvider-onCreate-生命周期方法-onCreate"><span class="toc-text">6.4.3.2 ContentProvider.onCreate - 生命周期方法 onCreate</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-4-new-ContentProviderHolder"><span class="toc-text">6.4.4 new ContentProviderHolder</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-5-installProviderAuthoritiesLocked"><span class="toc-text">6.4.5 installProviderAuthoritiesLocked</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-5-1-new-ProviderClientRecord"><span class="toc-text">6.4.5.1 new ProviderClientRecord</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-5-2-new-ProviderKey"><span class="toc-text">6.4.5.2 new ProviderKey</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-6-incProviderRefLocked"><span class="toc-text">6.4.6 incProviderRefLocked</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-7-new-ProviderRefCount"><span class="toc-text">6.4.7 new ProviderRefCount</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-ActivityManagerService-系统进程2"><span class="toc-text">7 ActivityManagerService - 系统进程2</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-publishContentProviders"><span class="toc-text">7.1 publishContentProviders</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-removeContentProvider"><span class="toc-text">7.2 removeContentProvider</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-refContentProvider"><span class="toc-text">7.3 refContentProvider</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-unstableProviderDied"><span class="toc-text">7.4 unstableProviderDied</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-总结"><span class="toc-text">8 总结</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.jpg"></div><div class="author-info__name text-center">Coolqi.Li</div><div class="author-info__description text-center">“Hi，我是李帅奇，Android 开发工程师，熬夜星人，一个努力赚钱，积极向上的好人。”</div><div class="follow-button"><a href="https://github.com/single-li">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">88</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">21</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">26</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">coolqi 和他的朋友们</div><a class="author-info-links__name text-center" href="https://developer.android.google.cn/">AndroidDeveloper</a><a class="author-info-links__name text-center" href="http://www.android-studio.org/">AndroidStudio</a><a class="author-info-links__name text-center" href="https://www.jianshu.com/u/123a20a96441">个人简书</a><a class="author-info-links__name text-center" href="https://weibo.com/coolqiLi">个人微博</a><a class="author-info-links__name text-center" href="https://www.jianshu.com/u/fd0b722ce11f">小二哥的 Android 站</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/img/blog-bg.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Coolqi`s Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/about">About</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">ContentProvider篇  2 - ContentProvider 的启动</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-04-13</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/AndroidFramework源码分析/">AndroidFramework源码分析</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/AndroidFramework源码分析/ContentProvider内容提供者/">ContentProvider内容提供者</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">12.9k</span><span class="post-meta__separator">|</span><span>阅读时长: 61 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>[toc]</p>
<p>基于 <strong>Android 7.1.1</strong>，分析 ContentProvider 的架构和原理。</p>
<h1 id="0-综述"><a href="#0-综述" class="headerlink" title="0 综述"></a>0 综述</h1><p>ContentProvider 是进程间通信的利器之一，充当数据存储和出具共享的中间者，其和核心是 Binder 和匿名共享内存！</p>
<p>我们在访问一个 ContentProvider 的时候，一般情况下都会先拉起该 ContentProvider 所在的进程，然后对其的增删改查：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ContentResolver cr = getContentResolver();</span><br><span class="line">Cursor cursor = cr.query(uri, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<p>下面我们来分析下，其主要的流程：</p>
<h1 id="1-ContextImpl"><a href="#1-ContextImpl" class="headerlink" title="1 ContextImpl"></a>1 ContextImpl</h1><h2 id="1-1-getContentResolver"><a href="#1-1-getContentResolver" class="headerlink" title="1.1 getContentResolver"></a>1.1 getContentResolver</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ContentResolver <span class="title">getContentResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mContentResolver;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 mContentResolver 是一个 ApplicationContentResolver 的实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ApplicationContentResolver mContentResolver;</span><br></pre></td></tr></table></figure>
<p>其创建是在 ContentImpl 初始化的时候：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ContextImpl</span><span class="params">(@Nullable ContextImpl container, @NonNull ActivityThread mainThread,</span></span></span><br><span class="line"><span class="function"><span class="params">        @NonNull LoadedApk packageInfo, @Nullable String splitName,</span></span></span><br><span class="line"><span class="function"><span class="params">        @Nullable IBinder activityToken, @Nullable UserHandle user, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params">        @Nullable ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ... ... ... ...<span class="comment">// 省略掉和 provider 无关的代码！</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1.2】创建 ApplicationContentResolver 实例！</span></span><br><span class="line">    mContentResolver = <span class="keyword">new</span> ApplicationContentResolver(<span class="keyword">this</span>, mainThread, user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="1-2-new-ApplicationContentResolver"><a href="#1-2-new-ApplicationContentResolver" class="headerlink" title="1.2 new ApplicationContentResolver"></a>1.2 new ApplicationContentResolver</h2><p>可以看到 ApplicationContentResolver 继承了 ContentResolver</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContentResolver</span> <span class="keyword">extends</span> <span class="title">ContentResolver</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ActivityThread mMainThread;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> UserHandle mUser;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ApplicationContentResolver</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            Context context, ActivityThread mainThread, UserHandle user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">        mMainThread = Preconditions.checkNotNull(mainThread);</span><br><span class="line">        mUser = Preconditions.checkNotNull(user);</span><br><span class="line">    &#125;</span><br><span class="line">    ... ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时，ApplicationContentResolver 继承了 ContentResolver 中和增删改查相关的接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="meta">@Nullable</span> <span class="function">Cursor <span class="title">query</span><span class="params">(...)</span> </span>&#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(...)</span> </span>&#123;...&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="meta">@Nullable</span> <span class="function">Uri <span class="title">insert</span><span class="params">(...)</span> </span>&#123;...&#125;</span><br><span class="line">... ... ...</span><br></pre></td></tr></table></figure>
<p>下面，我们通过分析 query 接口，来了解下 ContentProvider 的启动流程！</p>
<h1 id="2-ContentResolver"><a href="#2-ContentResolver" class="headerlink" title="2 ContentResolver"></a>2 ContentResolver</h1><h2 id="2-1-query-查询"><a href="#2-1-query-查询" class="headerlink" title="2.1 query - 查询"></a>2.1 query - 查询</h2><p>下面我们来看下查询的调用！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="meta">@Nullable</span> <span class="function">Cursor <span class="title">query</span><span class="params">(<span class="keyword">final</span> @RequiresPermission.Read @NonNull Uri uri,</span></span></span><br><span class="line"><span class="function"><span class="params">        @Nullable String[] projection, @Nullable String selection,</span></span></span><br><span class="line"><span class="function"><span class="params">        @Nullable String[] selectionArgs, @Nullable String sortOrder,</span></span></span><br><span class="line"><span class="function"><span class="params">        @Nullable CancellationSignal cancellationSignal)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】检查 uri 是否为 null；</span></span><br><span class="line">    Preconditions.checkNotNull(uri, <span class="string">"uri"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【×3.1】获得 unstable Provider 对象！</span></span><br><span class="line">    IContentProvider unstableProvider = acquireUnstableProvider(uri);</span><br><span class="line">    <span class="keyword">if</span> (unstableProvider == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IContentProvider stableProvider = <span class="keyword">null</span>;</span><br><span class="line">    Cursor qCursor = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">long</span> startTime = SystemClock.uptimeMillis();</span><br><span class="line"></span><br><span class="line">        ICancellationSignal remoteCancellationSignal = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (cancellationSignal != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cancellationSignal.throwIfCanceled();</span><br><span class="line">            remoteCancellationSignal = unstableProvider.createCancellationSignal();</span><br><span class="line">            cancellationSignal.setRemote(remoteCancellationSignal);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//【2】通过 unstable Provider 查询，并返回游标 Cursor！</span></span><br><span class="line">            qCursor = unstableProvider.query(mPackageName, uri, projection,</span><br><span class="line">                    selection, selectionArgs, sortOrder, remoteCancellationSignal);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (DeadObjectException e) &#123;</span><br><span class="line">            <span class="comment">//【3】如果 query 时远程进程死亡，我们会尝试恢复，但是恢复时，我们会获取 stable provider！</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//【*3.2】处理 unstable Provider 进程死亡的清理操作！！</span></span><br><span class="line">            unstableProviderDied(unstableProvider);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【×3.3】获得 stable Provider 对象！</span></span><br><span class="line">            stableProvider = acquireProvider(uri);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (stableProvider == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//【4】通过 stable Provider 查询，并返回游标 Cursor！</span></span><br><span class="line">            qCursor = stableProvider.query(mPackageName, uri, projection,</span><br><span class="line">                    selection, selectionArgs, sortOrder, remoteCancellationSignal);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (qCursor == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【5】强制执行 query 的操作，可能会失败抛出运行时异常！！</span></span><br><span class="line">        qCursor.getCount();</span><br><span class="line">        <span class="keyword">long</span> durationMillis = SystemClock.uptimeMillis() - startTime;</span><br><span class="line">        maybeLogQueryToEventLog(durationMillis, uri, projection, selection, sortOrder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【6】将查询结果 Cursor 封装成 CursorWrapperInner，并返回！！</span></span><br><span class="line">        <span class="comment">// 可以看到，我们最后访问的其实是 CursorWrapperInner！！</span></span><br><span class="line">        <span class="keyword">final</span> IContentProvider provider = (stableProvider != <span class="keyword">null</span>) ? stableProvider</span><br><span class="line">                : acquireProvider(uri);</span><br><span class="line">        <span class="keyword">final</span> CursorWrapperInner wrapper = <span class="keyword">new</span> CursorWrapperInner(qCursor, provider);</span><br><span class="line">        stableProvider = <span class="keyword">null</span>;</span><br><span class="line">        qCursor = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> wrapper;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="comment">//【7】如果抛出运行时异常，ams 会杀掉该进程！</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (qCursor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            qCursor.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cancellationSignal != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cancellationSignal.setRemote(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (unstableProvider != <span class="keyword">null</span>) &#123;</span><br><span class="line">            releaseUnstableProvider(unstableProvider);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stableProvider != <span class="keyword">null</span>) &#123;</span><br><span class="line">            releaseProvider(stableProvider);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里简单的说下，stable provider 和 unstable provider 的区别：</p>
<ul>
<li>获取 stable provider 的进程会因为 provider 所在进程死亡而被杀死；而获取 unstable provider 的进程则不会出现这种情况；</li>
</ul>
<p>具体的原因我们后面再分析！</p>
<p>这个流程很简单，不多说了！！</p>
<h3 id="2-1-1-acquireUnstableProvider-获取-unstable-provider"><a href="#2-1-1-acquireUnstableProvider-获取-unstable-provider" class="headerlink" title="2.1.1 acquireUnstableProvider - 获取 unstable provider"></a>2.1.1 acquireUnstableProvider - 获取 unstable provider</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> IContentProvider <span class="title">acquireUnstableProvider</span><span class="params">(Uri uri)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】如果 uri 的 scheme 不是 "content"，那就返回 null！</span></span><br><span class="line">    <span class="keyword">if</span> (!SCHEME_CONTENT.equals(uri.getScheme())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【2】如果 uri 没有指定 authority，也返回 null；</span></span><br><span class="line">    String auth = uri.getAuthority();</span><br><span class="line">    <span class="keyword">if</span> (auth != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//【×3.1】继续调用！</span></span><br><span class="line">        <span class="keyword">return</span> acquireUnstableProvider(mContext, uri.getAuthority());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-1-2-acquireProvider-获取-stable-provider"><a href="#2-1-2-acquireProvider-获取-stable-provider" class="headerlink" title="2.1.2 acquireProvider - 获取 stable provider"></a>2.1.2 acquireProvider - 获取 stable provider</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> IContentProvider <span class="title">acquireProvider</span><span class="params">(Uri uri)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】如果 uri 的 scheme 不是 "content"，那就返回 null！</span></span><br><span class="line">    <span class="keyword">if</span> (!SCHEME_CONTENT.equals(uri.getScheme())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【2】如果 uri 没有指定 authority，也返回 null；</span></span><br><span class="line">    <span class="keyword">final</span> String auth = uri.getAuthority();</span><br><span class="line">    <span class="keyword">if</span> (auth != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//【×3.3】继续调用！</span></span><br><span class="line">        <span class="keyword">return</span> acquireProvider(mContext, auth);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-ApplicationContentResolver"><a href="#3-ApplicationContentResolver" class="headerlink" title="3 ApplicationContentResolver"></a>3 ApplicationContentResolver</h1><h2 id="3-1-acquireUnstableProvider-获取-unstable-provider"><a href="#3-1-acquireUnstableProvider-获取-unstable-provider" class="headerlink" title="3.1 acquireUnstableProvider  - 获取 unstable provider"></a>3.1 acquireUnstableProvider  - 获取 unstable provider</h2><p>获取 unstable provider</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> IContentProvider <span class="title">acquireUnstableProvider</span><span class="params">(Context c, String auth)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【×4.1】进入 ActivityThread</span></span><br><span class="line">    <span class="keyword">return</span> mMainThread.acquireProvider(c,</span><br><span class="line">            ContentProvider.getAuthorityWithoutUserId(auth),</span><br><span class="line">            resolveUserIdFromAuthority(auth), <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-2-unstableProviderDied"><a href="#3-2-unstableProviderDied" class="headerlink" title="3.2 unstableProviderDied"></a>3.2 unstableProviderDied</h2><p>处理 unstable provider 所在进程死亡后的工作！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unstableProviderDied</span><span class="params">(IContentProvider icp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【×4.2】进入 ActivityThread</span></span><br><span class="line">    mMainThread.handleUnstableProviderDied(icp.asBinder(), <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-3-acquireProvider-获取-stable-provider"><a href="#3-3-acquireProvider-获取-stable-provider" class="headerlink" title="3.3 acquireProvider  - 获取 stable provider"></a>3.3 acquireProvider  - 获取 stable provider</h2><p>获取 stable provider</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> IContentProvider <span class="title">acquireProvider</span><span class="params">(Context context, String auth)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【×4.1】进入 ActivityThread</span></span><br><span class="line">    <span class="keyword">return</span> mMainThread.acquireProvider(context,</span><br><span class="line">            ContentProvider.getAuthorityWithoutUserId(auth),</span><br><span class="line">            resolveUserIdFromAuthority(auth), <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 ApplicationContentResolver 最终都访问了 ActivityThread 中的逻辑！</p>
<h1 id="4-ActivityThread"><a href="#4-ActivityThread" class="headerlink" title="4 ActivityThread"></a>4 ActivityThread</h1><h2 id="4-1-acquireProvider-获取-provider"><a href="#4-1-acquireProvider-获取-provider" class="headerlink" title="4.1 acquireProvider - 获取 provider"></a>4.1 acquireProvider - 获取 provider</h2><p>无论是 unstable provider 还是 stable provider，最终都会调用 ActivityThread 的 acquireProvider 方法，参数传递：</p>
<ul>
<li><strong>String auth</strong>：authority 属性；</li>
<li><strong>int userId</strong>：设备用户 id；</li>
<li><strong>boolean stable</strong>：provider 的类型；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> IContentProvider <span class="title">acquireProvider</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Context c, String auth, <span class="keyword">int</span> userId, <span class="keyword">boolean</span> stable)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【×4.1.1】尝试查询一个已经存在的 provider，如果有，那就返回这个 provider！</span></span><br><span class="line">    <span class="keyword">final</span> IContentProvider provider = acquireExistingProvider(c, auth, userId, stable);</span><br><span class="line">    <span class="keyword">if</span> (provider != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> provider;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IActivityManager.ContentProviderHolder holder = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//【×5.1】如果没有已经存在的，那就需要通过 ams 来获取！</span></span><br><span class="line">        holder = ActivityManagerNative.getDefault().getContentProvider(</span><br><span class="line">                getApplicationThread(), auth, userId, stable);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Slog.e(TAG, <span class="string">"Failed to find provider info for "</span> + auth);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【×6.4】增加引用计数，将 provider 封装为 ContentProviderHolder 然后返回！</span></span><br><span class="line">    holder = installProvider(c, holder, holder.info,</span><br><span class="line">            <span class="keyword">true</span> <span class="comment">/*noisy*/</span>, holder.noReleaseNeeded, stable);</span><br><span class="line">    <span class="comment">//【1】最后返回 holder.provider！</span></span><br><span class="line">    <span class="keyword">return</span> holder.provider;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于 holder 和 holder.provider 我们后面再分析！</p>
<p>继续来看：</p>
<h3 id="4-1-1-acquireExistingProvider"><a href="#4-1-1-acquireExistingProvider" class="headerlink" title="4.1.1 acquireExistingProvider"></a>4.1.1 acquireExistingProvider</h3><p>尝试获得已经存在的一个 provider：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> IContentProvider <span class="title">acquireExistingProvider</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Context c, String auth, <span class="keyword">int</span> userId, <span class="keyword">boolean</span> stable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mProviderMap) &#123;</span><br><span class="line">        <span class="comment">//【1】根据 authority 属性创建 ProviderKey 对象！</span></span><br><span class="line">        <span class="keyword">final</span> ProviderKey key = <span class="keyword">new</span> ProviderKey(auth, userId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【2】尝试获得已经存在的 ProviderClientRecord 客户端对象！</span></span><br><span class="line">        <span class="keyword">final</span> ProviderClientRecord pr = mProviderMap.get(key);</span><br><span class="line">        <span class="keyword">if</span> (pr == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【3】判断 provdier 所在的进程是否死亡，这里的 provider 其实是一个 Transport 对象，</span></span><br><span class="line">        <span class="comment">// 目标进程的 provider 被拉起是会创建！</span></span><br><span class="line">        IContentProvider provider = pr.mProvider;</span><br><span class="line">        IBinder jBinder = provider.asBinder();</span><br><span class="line">        <span class="keyword">if</span> (!jBinder.isBinderAlive()) &#123;</span><br><span class="line">            <span class="comment">//【3.1】如果 provider 所在进程死亡了，那么就返回 null！</span></span><br><span class="line">            Log.i(TAG, <span class="string">"Acquiring provider "</span> + auth + <span class="string">" for user "</span> + userId</span><br><span class="line">                    + <span class="string">": existing object's process dead"</span>);</span><br><span class="line">            <span class="comment">//【×4.1.1.1】处理进程死亡后，unstable providre 的引用计数！</span></span><br><span class="line">            handleUnstableProviderDiedLocked(jBinder, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【4】如果可以找到已经存在的合适的 provider，那么就增加客户端的引用计数！</span></span><br><span class="line">        ProviderRefCount prc = mProviderRefCountMap.get(jBinder);</span><br><span class="line">        <span class="keyword">if</span> (prc != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//【×4.1.1.2】增加客户端的引用计数！</span></span><br><span class="line">            incProviderRefLocked(prc, stable);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> provider;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要逻辑如下：</p>
<ul>
<li>尝试从 ActivityThread 的 mProviderMap 查询已存在相对应的 provider，若不存在，则返回 null；</li>
<li>如果 ActivityThread 存在该 provider ，但其所在的进程已经死亡，则调用 handleUnstableProviderDiedLocked 清理 provider 信息，并返回 null；</li>
<li>当 provider 记录存在，并且其进程仍然存活，则在 provider 引用计数不为空时继续增加引用计数。然后返回当前进程已经存在的 provider。</li>
</ul>
<h4 id="4-1-1-1-handleUnstableProviderDiedLocked"><a href="#4-1-1-1-handleUnstableProviderDiedLocked" class="headerlink" title="4.1.1.1 handleUnstableProviderDiedLocked"></a>4.1.1.1 handleUnstableProviderDiedLocked</h4><p>如果 provdier 所在的进程已经死亡，那么我们会将该 provider 从引用它的进程中的相关结构体中移除！</p>
<p>boolean fromClient 是否是客户端移除的！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">handleUnstableProviderDiedLocked</span><span class="params">(IBinder provider, <span class="keyword">boolean</span> fromClient)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】获得该进程对该 provider 的引用对象！</span></span><br><span class="line">    ProviderRefCount prc = mProviderRefCountMap.get(provider);</span><br><span class="line">    <span class="keyword">if</span> (prc != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_PROVIDER) Slog.v(TAG, <span class="string">"Cleaning up dead provider "</span></span><br><span class="line">                + provider + <span class="string">" "</span> + prc.holder.info.name);</span><br><span class="line">        <span class="comment">//【1.1】从引用计数 mProviderRefCountMap 中移除该 provider 的信息！</span></span><br><span class="line">        mProviderRefCountMap.remove(provider);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = mProviderMap.size() - <span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            ProviderClientRecord pr = mProviderMap.valueAt(i);</span><br><span class="line">            <span class="keyword">if</span> (pr != <span class="keyword">null</span> &amp;&amp; pr.mProvider.asBinder() == provider) &#123;</span><br><span class="line">                Slog.i(TAG, <span class="string">"Removing dead content provider:"</span> + pr.mProvider.toString());</span><br><span class="line">                <span class="comment">//【1.2】从 mProviderMap 中移除该 provider 的信息！</span></span><br><span class="line">                mProviderMap.removeAt(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fromClient) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//【5】通知 ams 该 provider 已经死亡！</span></span><br><span class="line">                ActivityManagerNative.getDefault().unstableProviderDied(</span><br><span class="line">                        prc.holder.connection);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                <span class="comment">//do nothing content provider object is dead any way</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的逻辑就不多说了！</p>
<h4 id="4-1-1-2-incProviderRefLocked"><a href="#4-1-1-2-incProviderRefLocked" class="headerlink" title="4.1.1.2 incProviderRefLocked"></a>4.1.1.2 incProviderRefLocked</h4><p>增加 provider 的引用计数， 参数 boolean stable 表示的是稳定引用，还是非稳定引用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">incProviderRefLocked</span><span class="params">(ProviderRefCount prc, <span class="keyword">boolean</span> stable)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】stable 引用进入这里！</span></span><br><span class="line">    <span class="keyword">if</span> (stable) &#123;</span><br><span class="line">        prc.stableCount += <span class="number">1</span>; <span class="comment">// 增加引用计数</span></span><br><span class="line">        <span class="keyword">if</span> (prc.stableCount == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> unstableDelta;</span><br><span class="line">            <span class="keyword">if</span> (prc.removePending) &#123; <span class="comment">// 如果此时我们正在移除 provider，那就取消移除！</span></span><br><span class="line">                unstableDelta = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_PROVIDER) &#123;</span><br><span class="line">                    Slog.v(TAG, <span class="string">"incProviderRef: stable "</span></span><br><span class="line">                            + <span class="string">"snatched provider from the jaws of death"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                prc.removePending = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">//【1.1】移除 REMOVE_PROVIDER 消息！</span></span><br><span class="line">                mH.removeMessages(H.REMOVE_PROVIDER, prc);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                unstableDelta = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_PROVIDER) &#123;</span><br><span class="line">                    Slog.v(TAG, <span class="string">"incProviderRef Now stable - "</span></span><br><span class="line">                            + prc.holder.info.name + <span class="string">": unstableDelta="</span></span><br><span class="line">                            + unstableDelta);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//【×7.2】通知 ams，增加框架层的引用信息！</span></span><br><span class="line">                ActivityManagerNative.getDefault().refContentProvider(</span><br><span class="line">                        prc.holder.connection, <span class="number">1</span>, unstableDelta);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//【2】no stable 引用进入这里；</span></span><br><span class="line">        prc.unstableCount += <span class="number">1</span>; <span class="comment">// 增加引用计数</span></span><br><span class="line">        <span class="keyword">if</span> (prc.unstableCount == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prc.removePending) &#123; <span class="comment">// 如果此时我们正在移除 provider，那就取消移除！</span></span><br><span class="line">                <span class="keyword">if</span> (DEBUG_PROVIDER) &#123;</span><br><span class="line">                    Slog.v(TAG, <span class="string">"incProviderRef: unstable "</span></span><br><span class="line">                            + <span class="string">"snatched provider from the jaws of death"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//【2.1】移除 REMOVE_PROVIDER 消息！</span></span><br><span class="line">                prc.removePending = <span class="keyword">false</span>;</span><br><span class="line">                mH.removeMessages(H.REMOVE_PROVIDER, prc);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG_PROVIDER) &#123;</span><br><span class="line">                        Slog.v(TAG, <span class="string">"incProviderRef: Now unstable - "</span></span><br><span class="line">                                + prc.holder.info.name);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//【×7.2】通知 ams，增加框架层的引用信息！</span></span><br><span class="line">                    ActivityManagerNative.getDefault().refContentProvider(</span><br><span class="line">                            prc.holder.connection, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，如果是第一次引用，那么会做一些额外的处理！</p>
<h2 id="4-2-handleUnstableProviderDied"><a href="#4-2-handleUnstableProviderDied" class="headerlink" title="4.2 handleUnstableProviderDied"></a>4.2 handleUnstableProviderDied</h2><p>处理 unstable provider 死亡的清理操作，boolean fromClient 表示本次操作是否来自客户端进程，通过前面的参数传递                   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">handleUnstableProviderDied</span><span class="params">(IBinder provider, <span class="keyword">boolean</span> fromClient)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mProviderMap) &#123;</span><br><span class="line">        <span class="comment">//【×4.2.1】继续分析：</span></span><br><span class="line">        handleUnstableProviderDiedLocked(provider, fromClient);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就不多说了，继续看！</p>
<h3 id="4-2-1-handleUnstableProviderDiedLocked"><a href="#4-2-1-handleUnstableProviderDiedLocked" class="headerlink" title="4.2.1 handleUnstableProviderDiedLocked"></a>4.2.1 handleUnstableProviderDiedLocked</h3><p>根据参数，这里的 boolean fromClient 为 true，当该进程持有的 unstable provider 所在进程死亡后，<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">handleUnstableProviderDiedLocked</span><span class="params">(IBinder provider, <span class="keyword">boolean</span> fromClient)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】尝试从当前进程的引用集合中获得该 provider 的引用计数对象，并移除！</span></span><br><span class="line">    ProviderRefCount prc = mProviderRefCountMap.get(provider);</span><br><span class="line">    <span class="keyword">if</span> (prc != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_PROVIDER) Slog.v(TAG, <span class="string">"Cleaning up dead provider "</span></span><br><span class="line">                + provider + <span class="string">" "</span> + prc.holder.info.name);</span><br><span class="line">        mProviderRefCountMap.remove(provider);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=mProviderMap.size()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">//【1.2】移除该进程持有的 provider 的 ProviderClientRecord 客户端对象！</span></span><br><span class="line">            ProviderClientRecord pr = mProviderMap.valueAt(i);</span><br><span class="line">            <span class="keyword">if</span> (pr != <span class="keyword">null</span> &amp;&amp; pr.mProvider.asBinder() == provider) &#123;</span><br><span class="line">                Slog.i(TAG, <span class="string">"Removing dead content provider:"</span> + pr.mProvider.toString());</span><br><span class="line">                mProviderMap.removeAt(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fromClient) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//【×7.4】通知 ams，客户端进程移除了该 provider 相关的引用计数和客户端实例！</span></span><br><span class="line">                ActivityManagerNative.getDefault().unstableProviderDied(</span><br><span class="line">                        prc.holder.connection);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                <span class="comment">//do nothing content provider object is dead any way</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里就不多说了！</p>
<h1 id="5-ActivityManagerService-系统进程1"><a href="#5-ActivityManagerService-系统进程1" class="headerlink" title="5 ActivityManagerService  - 系统进程1"></a>5 ActivityManagerService  - 系统进程1</h1><p>当我们拉起了 Content provider 所在的进程，并且执行了一些初始化的操作后，就需要将创建的 provider 注册到系统进程中进行管理！</p>
<h2 id="5-1-getContentProvider-Impl"><a href="#5-1-getContentProvider-Impl" class="headerlink" title="5.1 getContentProvider[Impl]"></a>5.1 getContentProvider[Impl]</h2><p>下面我们来看 ActivityManagerService 中的 getContentProvider 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ContentProviderHolder <span class="title">getContentProvider</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        IApplicationThread caller, String name, <span class="keyword">int</span> userId, <span class="keyword">boolean</span> stable)</span> </span>&#123;</span><br><span class="line">    enforceNotIsolatedCaller(<span class="string">"getContentProvider"</span>);</span><br><span class="line">    <span class="keyword">if</span> (caller == <span class="keyword">null</span>) &#123;</span><br><span class="line">        String msg = <span class="string">"null IApplicationThread when getting content provider "</span></span><br><span class="line">                + name;</span><br><span class="line">        Slog.w(TAG, msg);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【1】调用了另外一个 getContentProviderImpl 方法！</span></span><br><span class="line">    <span class="keyword">return</span> getContentProviderImpl(caller, name, <span class="keyword">null</span>, stable, userId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续来看，getContentProviderImpl 方法的逻辑很长，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ContentProviderHolder <span class="title">getContentProviderImpl</span><span class="params">(IApplicationThread caller,</span></span></span><br><span class="line"><span class="function"><span class="params">        String name, IBinder token, <span class="keyword">boolean</span> stable, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】在 ams 中每一个的 provider 都是以 ContentProviderRecord 的形式保存的!</span></span><br><span class="line">    ContentProviderRecord cpr;</span><br><span class="line">    <span class="comment">//【2】用于保存和 provider 的连接关系！</span></span><br><span class="line">    ContentProviderConnection conn = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//【3】provider 的信息对象，在应用程序安装的时候会解析保存！</span></span><br><span class="line">    ProviderInfo cpi = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">long</span> startTime = SystemClock.uptimeMillis();</span><br><span class="line">        <span class="comment">//【4】判断访问者进程 r 是否存在，如果不存在，那就抛出异常，并返回！</span></span><br><span class="line">        ProcessRecord r = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (caller != <span class="keyword">null</span>) &#123;</span><br><span class="line">            r = getRecordForAppLocked(caller);</span><br><span class="line">            <span class="keyword">if</span> (r == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(</span><br><span class="line">                        <span class="string">"Unable to find app for caller "</span> + caller</span><br><span class="line">                      + <span class="string">" (pid="</span> + Binder.getCallingPid()</span><br><span class="line">                      + <span class="string">") when getting content provider "</span> + name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> checkCrossUser = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        checkTime(startTime, <span class="string">"getContentProviderImpl: getProviderByName"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【5】判断该 provider 是否已经 publish 到该 userId 中了！</span></span><br><span class="line">        cpr = mProviderMap.getProviderByName(name, userId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果在 userId 下并没有 publish，那么就判断下，该 provider 是否只是给 USER_SYSTEM 使用的</span></span><br><span class="line">        <span class="comment">// 如果是，那么就要校验下是否是单例模式！</span></span><br><span class="line">        <span class="keyword">if</span> (cpr == <span class="keyword">null</span> &amp;&amp; userId != UserHandle.USER_SYSTEM) &#123;</span><br><span class="line">            cpr = mProviderMap.getProviderByName(name, UserHandle.USER_SYSTEM);</span><br><span class="line">            <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                cpi = cpr.info;</span><br><span class="line">                <span class="comment">//【5.1】如果该 provider 是给 USER_SYSTEM 使用的，那么只有该 provider 是单例模式，并且</span></span><br><span class="line">                <span class="comment">// 本地调用对于单例是有效的，那么才可以使用该 provider！</span></span><br><span class="line">                <span class="comment">//【×5.1.1.1】通过 isSingleton 判断是否是单例模式！</span></span><br><span class="line">                <span class="comment">//【×5.1.1.2】通过 isValidSingletonCall 方法判断方法访问单例 pvodier </span></span><br><span class="line">                <span class="keyword">if</span> (isSingleton(cpi.processName, cpi.applicationInfo,</span><br><span class="line">                        cpi.name, cpi.flags)</span><br><span class="line">                        &amp;&amp; isValidSingletonCall(r.uid, cpi.applicationInfo.uid)) &#123;</span><br><span class="line">                    <span class="comment">//【5.2】单例模式的 provider 运行在默认用户，所以 userId 被设置为了 USER_SYSTEM！</span></span><br><span class="line">                    <span class="comment">// 同时其他的用户可以访问！</span></span><br><span class="line">                    userId = UserHandle.USER_SYSTEM;</span><br><span class="line">                    checkCrossUser = <span class="keyword">false</span>; <span class="comment">// 不用校验 user 了！</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    cpr = <span class="keyword">null</span>; <span class="comment">// 不是单例模式，进入这里！</span></span><br><span class="line">                    cpi = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【6】判断 provider 是否正在运行！</span></span><br><span class="line">        <span class="keyword">boolean</span> providerRunning = cpr != <span class="keyword">null</span> &amp;&amp; cpr.proc != <span class="keyword">null</span> &amp;&amp; !cpr.proc.killed;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【7】如果 provider 正在运行，即： cpr 不为 null，同时其进程存在，那么就直接返回该 provider！</span></span><br><span class="line">        <span class="keyword">if</span> (providerRunning) &#123;</span><br><span class="line">            cpi = cpr.info;</span><br><span class="line">            String msg;</span><br><span class="line">            checkTime(startTime, <span class="string">"getContentProviderImpl: before checkContentProviderPermission"</span>);</span><br><span class="line">            <span class="comment">//【×5.1.1.3】校验 provider 权限！</span></span><br><span class="line">            <span class="keyword">if</span> ((msg = checkContentProviderPermissionLocked(cpi, r, userId, checkCrossUser))</span><br><span class="line">                    != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(msg);</span><br><span class="line">            &#125;</span><br><span class="line">            checkTime(startTime, <span class="string">"getContentProviderImpl: after checkContentProviderPermission"</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//【×5.1.1.4】如果访问者进程存在，并且 provider 能够在访问者的进程中运行的话，进入这里！</span></span><br><span class="line">            <span class="comment">// 该 provider 支持 multi process，或者 provider 和访问者属于同一进程，并且所属 userId 相同！</span></span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span> &amp;&amp; cpr.canRunHere(r)) &#123;</span><br><span class="line">                <span class="comment">//【×5.1.1.5】那么这里会通过 provider 在 ams 中的 ContentProviderRecord 实例，创建一个</span></span><br><span class="line">                <span class="comment">// ContentProviderHolder 实例，同时设置 holder.connection 和 holder.provider 为 null；</span></span><br><span class="line">                <span class="comment">// 因为访问者会建立自己的本地 provider！</span></span><br><span class="line">                ContentProviderHolder holder = cpr.newHolder(<span class="keyword">null</span>);</span><br><span class="line">                holder.provider = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">return</span> holder;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">            checkTime(startTime, <span class="string">"getContentProviderImpl: incProviderCountLocked"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【×5.1.1.6】增加 provider 引用计数，并返回连接对象 ContentProviderConnection！</span></span><br><span class="line">            conn = incProviderCountLocked(r, cpr, token, stable);</span><br><span class="line">            <span class="keyword">if</span> (conn != <span class="keyword">null</span> &amp;&amp; (conn.stableCount+conn.unstableCount) == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//【8】如果是第一次连接，那么会判断下访问者进程的 adj，如果优先级是可感知进程，或者比可感知进程高</span></span><br><span class="line">                <span class="comment">// 那么会调整 provider 所在进程在 lruProcess 中的位置！</span></span><br><span class="line">                <span class="keyword">if</span> (cpr.proc != <span class="keyword">null</span> &amp;&amp; r.setAdj &lt;= ProcessList.PERCEPTIBLE_APP_ADJ) &#123;</span><br><span class="line">                    checkTime(startTime, <span class="string">"getContentProviderImpl: before updateLruProcess"</span>);</span><br><span class="line">                    updateLruProcessLocked(cpr.proc, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">                    checkTime(startTime, <span class="string">"getContentProviderImpl: after updateLruProcess"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            checkTime(startTime, <span class="string">"getContentProviderImpl: before updateOomAdj"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【9】调整 provider 所在进程的优先级！</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> verifiedAdj = cpr.proc.verifiedAdj;</span><br><span class="line">            <span class="keyword">boolean</span> success = updateOomAdjLocked(cpr.proc);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//【10】异常校验，如果优先级调整结果是成功的，但是 provider 的进程 adj 校验不过，并且 provider </span></span><br><span class="line">            <span class="comment">// 的进程不处于 alive 状态，那么这属于异常情况！</span></span><br><span class="line">            <span class="keyword">if</span> (success &amp;&amp; verifiedAdj != cpr.proc.setAdj &amp;&amp; !isProcessAliveLocked(cpr.proc)) &#123;</span><br><span class="line">                success = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【11】更新使用情况！</span></span><br><span class="line">            maybeUpdateProviderUsageStatsLocked(r, cpr.info.packageName, name);</span><br><span class="line"></span><br><span class="line">            checkTime(startTime, <span class="string">"getContentProviderImpl: after updateOomAdj"</span>);</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_PROVIDER) Slog.i(TAG_PROVIDER, <span class="string">"Adjust success: "</span> + success);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【12】如果 success 为 false，说明出现了异常，比如 provider 的进程被杀死了。</span></span><br><span class="line">            <span class="comment">// 那么我们需要启动一个新的进程，并且确认 provider 进程的死亡不会杀掉我们的进程！</span></span><br><span class="line">            <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">                Slog.i(TAG, <span class="string">"Existing provider "</span> + cpr.name.flattenToShortString()</span><br><span class="line">                        + <span class="string">" is crashing; detaching "</span> + r);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//【×5.1.1.7】减少 provider 引用计数，因为前面尝试增加了！</span></span><br><span class="line">                <span class="comment">// 并判断取消的引用是否是该进程对 provider 的最后引用！</span></span><br><span class="line">                <span class="keyword">boolean</span> lastRef = decProviderCountLocked(conn, cpr, token, stable);</span><br><span class="line">                checkTime(startTime, <span class="string">"getContentProviderImpl: before appDied"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//【12.1】这个是处理 provider 进程死亡后的相关工作，这里不关注！</span></span><br><span class="line">                appDiedLocked(cpr.proc);</span><br><span class="line"></span><br><span class="line">                checkTime(startTime, <span class="string">"getContentProviderImpl: after appDied"</span>);</span><br><span class="line">                <span class="keyword">if</span> (!lastRef) &#123;</span><br><span class="line">                    <span class="comment">//【12.2】如果取消的引用不是该进程对 provider 的最后引用，返回一个 null！</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//【12.3】设置 providerRunning 为 false，conn 为 null，下面我们会继续处理！</span></span><br><span class="line">                providerRunning = <span class="keyword">false</span>;</span><br><span class="line">                conn = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cpr.proc.verifiedAdj = cpr.proc.setAdj;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Binder.restoreCallingIdentity(origId);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【8】如果 provider 没有在运行，进入这里！！</span></span><br><span class="line">        <span class="keyword">if</span> (!providerRunning) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                checkTime(startTime, <span class="string">"getContentProviderImpl: before resolveContentProvider"</span>);</span><br><span class="line">                <span class="comment">//【8.1】查询 provider 的信息；</span></span><br><span class="line">                cpi = AppGlobals.getPackageManager().</span><br><span class="line">                    resolveContentProvider(name,</span><br><span class="line">                        STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS, userId);</span><br><span class="line">                checkTime(startTime, <span class="string">"getContentProviderImpl: after resolveContentProvider"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cpi == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【8.2】如果 provider 是单例模式，同时且满足访问单例的条件，那么我们才允许访问 provider！</span></span><br><span class="line">            <span class="comment">//【×5.1.1.1】通过 isSingleton 判断是否是单例模式！</span></span><br><span class="line">            <span class="comment">//【×5.1.1.2】通过 isValidSingletonCall 方法判断是否可以访问单例 provider！</span></span><br><span class="line">            <span class="keyword">boolean</span> singleton = isSingleton(cpi.processName, cpi.applicationInfo,</span><br><span class="line">                    cpi.name, cpi.flags)</span><br><span class="line">                    &amp;&amp; isValidSingletonCall(r.uid, cpi.applicationInfo.uid);</span><br><span class="line">            <span class="keyword">if</span> (singleton) &#123; <span class="comment">// 如果是单例访问，那么 userId 为 USER_SYSTEM！</span></span><br><span class="line">                userId = UserHandle.USER_SYSTEM;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【8.2】获得 provider 在该 userId 下的 ApplicationInfo</span></span><br><span class="line">            cpi.applicationInfo = getAppInfoForUser(cpi.applicationInfo, userId);</span><br><span class="line">            checkTime(startTime, <span class="string">"getContentProviderImpl: got app info for user"</span>);</span><br><span class="line"></span><br><span class="line">            String msg;</span><br><span class="line">            checkTime(startTime, <span class="string">"getContentProviderImpl: before checkContentProviderPermission"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【×5.1.1.3】检验访问者是否有权限访问 provider！</span></span><br><span class="line">            <span class="keyword">if</span> ((msg = checkContentProviderPermissionLocked(cpi, r, userId, !singleton))</span><br><span class="line">                    != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(msg);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            checkTime(startTime, <span class="string">"getContentProviderImpl: after checkContentProviderPermission"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【8.3】如果该 provider 是运行在其他进程中的，但是系统进程没有启动完成，</span></span><br><span class="line">            <span class="comment">// 那么也无法启动 provider 所在进程，抛出异常！！</span></span><br><span class="line">            <span class="keyword">if</span> (!mProcessesReady</span><br><span class="line">                    &amp;&amp; !cpi.processName.equals(<span class="string">"system"</span>)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                        <span class="string">"Attempt to launch content provider before system ready"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【8.4】确保 provider 所在的设备用户处于运行状态！</span></span><br><span class="line">            <span class="keyword">if</span> (!mUserController.isUserRunningLocked(userId, <span class="number">0</span>)) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Unable to launch app "</span></span><br><span class="line">                        + cpi.applicationInfo.packageName + <span class="string">"/"</span></span><br><span class="line">                        + cpi.applicationInfo.uid + <span class="string">" for provider "</span></span><br><span class="line">                        + name + <span class="string">": user "</span> + userId + <span class="string">" is stopped"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//【8.5】封装 provider 的组件信息！</span></span><br><span class="line">            ComponentName comp = <span class="keyword">new</span> ComponentName(cpi.packageName, cpi.name);</span><br><span class="line">            checkTime(startTime, <span class="string">"getContentProviderImpl: before getProviderByClass"</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//【×5.1.2.1】尝试通过组件名获得 provider 实例！</span></span><br><span class="line">            cpr = mProviderMap.getProviderByClass(comp, userId);</span><br><span class="line">            checkTime(startTime, <span class="string">"getContentProviderImpl: after getProviderByClass"</span>);</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> firstClass = cpr == <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【8.6】如果该 provider 并没有 publish 到系统中，说明这是第一次！</span></span><br><span class="line">            <span class="comment">// 那么我们会创建一个 ContentProviderRecord 实例！</span></span><br><span class="line">            <span class="keyword">if</span> (firstClass) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//【8.6.1】如果运行任何组件前要重新确认权限，那么这里会拉起权限确认！</span></span><br><span class="line">                <span class="keyword">if</span> (Build.PERMISSIONS_REVIEW_REQUIRED) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!requestTargetProviderPermissionsReviewIfNeededLocked(cpi, r, userId)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    checkTime(startTime, <span class="string">"getContentProviderImpl: before getApplicationInfo"</span>);</span><br><span class="line">                    <span class="comment">//【8.6.2】获得应用程序的 ApplicationInfo 实例！！</span></span><br><span class="line">                    ApplicationInfo ai =</span><br><span class="line">                        AppGlobals.getPackageManager().</span><br><span class="line">                            getApplicationInfo(</span><br><span class="line">                                    cpi.applicationInfo.packageName,</span><br><span class="line">                                    STOCK_PM_FLAGS, userId);</span><br><span class="line">                    checkTime(startTime, <span class="string">"getContentProviderImpl: after getApplicationInfo"</span>);</span><br><span class="line">                    <span class="keyword">if</span> (ai == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        Slog.w(TAG, <span class="string">"No package info for content provider "</span></span><br><span class="line">                                + cpi.name);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//【8.6.3】根据本次访问的 userId，动态调整 ApplicationInfo 的信息！</span></span><br><span class="line">                    ai = getAppInfoForUser(ai, userId);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//【×5.1.2.2】创建 provider 的 ContentProviderRecord 实例！！</span></span><br><span class="line">                    cpr = <span class="keyword">new</span> ContentProviderRecord(<span class="keyword">this</span>, cpi, ai, comp, singleton);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    Binder.restoreCallingIdentity(ident);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            checkTime(startTime, <span class="string">"getContentProviderImpl: now have ContentProviderRecord"</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//【×5.1.1.4】如果访问者进程存在，并且 provider 能够在访问者的进程中运行的话，进入这里！</span></span><br><span class="line">            <span class="comment">// 该 provider 支持 multi process，或者 provider 和访问者属于同一进程，并且所属 userId 相同！</span></span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span> &amp;&amp; cpr.canRunHere(r)) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//【×5.1.1.5】那么这里会通过 provider 在 ams 中的 ContentProviderRecord 实例，创建一个</span></span><br><span class="line">                <span class="comment">// ContentProviderHolder 实例，同时设置 holder.connection 和 holder.provider 为 null；</span></span><br><span class="line">                <span class="comment">//（holder.provider 在前面 new ContentProviderRecord 时就是 null 的）</span></span><br><span class="line">                <span class="comment">// 因为访问者会建立自己的本地 provider！！</span></span><br><span class="line">                <span class="keyword">return</span> cpr.newHolder(<span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (DEBUG_PROVIDER) Slog.w(TAG_PROVIDER, <span class="string">"LAUNCHING REMOTE PROVIDER (myuid "</span></span><br><span class="line">                        + (r != <span class="keyword">null</span> ? r.uid : <span class="keyword">null</span>) + <span class="string">" pruid "</span> + cpr.appInfo.uid + <span class="string">"): "</span></span><br><span class="line">                        + cpr.info.name + <span class="string">" callers="</span> + Debug.getCallers(<span class="number">6</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【8.7】判断 provider 是否正在启动中，每一个正在启动的 provider 都会被加入到 </span></span><br><span class="line">            <span class="comment">// mLaunchingProviders 列表中！！！</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> N = mLaunchingProviders.size();</span><br><span class="line">            <span class="keyword">int</span> i;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">                <span class="comment">//【8.7.1】如果该 provider 正在启动，那么 i 不会超过 N！</span></span><br><span class="line">                <span class="keyword">if</span> (mLaunchingProviders.get(i) == cpr) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【8.8】如果 provider 还没有启动，那么我们会先启动 orovider！</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= N) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        checkTime(startTime, <span class="string">"getContentProviderImpl: before set stopped state"</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//【8.8.1】provider 所属的 package 不能处于 stop 状态！</span></span><br><span class="line">                        AppGlobals.getPackageManager().setPackageStoppedState(</span><br><span class="line">                                cpr.appInfo.packageName, <span class="keyword">false</span>, userId);</span><br><span class="line"></span><br><span class="line">                        checkTime(startTime, <span class="string">"getContentProviderImpl: after set stopped state"</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">                        Slog.w(TAG, <span class="string">"Failed trying to unstop package "</span></span><br><span class="line">                                + cpr.appInfo.packageName + <span class="string">": "</span> + e);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    checkTime(startTime, <span class="string">"getContentProviderImpl: looking for process record"</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//【8.8.2】获得 provider 所属的进程！</span></span><br><span class="line">                    ProcessRecord proc = getProcessRecordLocked(</span><br><span class="line">                            cpi.processName, cpr.appInfo.uid, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//【8.8.3】如果 provider 所属进程已经启动了，那我们就拉起该 provider！！</span></span><br><span class="line">                    <span class="keyword">if</span> (proc != <span class="keyword">null</span> &amp;&amp; proc.thread != <span class="keyword">null</span> &amp;&amp; !proc.killed) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (DEBUG_PROVIDER) Slog.d(TAG_PROVIDER,</span><br><span class="line">                                <span class="string">"Installing in existing process "</span> + proc);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (!proc.pubProviders.containsKey(cpi.name)) &#123;</span><br><span class="line">                            checkTime(startTime, <span class="string">"getContentProviderImpl: scheduling install"</span>);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">//【8.8.3.1】如果该 provider 不在该进程的 pubProviders，将其添加其中！</span></span><br><span class="line">                            proc.pubProviders.put(cpi.name, cpr);</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                <span class="comment">//【×6.1】进入 provider 所在进程，拉起 provider！</span></span><br><span class="line">                                proc.thread.scheduleInstallProvider(cpi);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        checkTime(startTime, <span class="string">"getContentProviderImpl: before start process"</span>);</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">//【8.8.4】如果该 provider 所在进程未启动，那么就启动所在进程！</span></span><br><span class="line">                        proc = startProcessLocked(cpi.processName,</span><br><span class="line">                                cpr.appInfo, <span class="keyword">false</span>, <span class="number">0</span>, <span class="string">"content provider"</span>,</span><br><span class="line">                                <span class="keyword">new</span> ComponentName(cpi.applicationInfo.packageName,</span><br><span class="line">                                        cpi.name), <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">                        checkTime(startTime, <span class="string">"getContentProviderImpl: after start process"</span>);</span><br><span class="line">                        <span class="keyword">if</span> (proc == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            Slog.w(TAG, <span class="string">"Unable to launch app "</span></span><br><span class="line">                                    + cpi.applicationInfo.packageName + <span class="string">"/"</span></span><br><span class="line">                                    + cpi.applicationInfo.uid + <span class="string">" for provider "</span></span><br><span class="line">                                    + name + <span class="string">": process is bad"</span>);</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//【8.8.4.1】设置 cpr.launchingApp 为 proc，表示正在等待该进程启动！</span></span><br><span class="line">                    cpr.launchingApp = proc;</span><br><span class="line">                    <span class="comment">//【8.8.4.2】将该 provider 加入到 mLaunchingProviders 中，表示其正在启动！</span></span><br><span class="line">                    mLaunchingProviders.add(cpr);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    Binder.restoreCallingIdentity(origId);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            checkTime(startTime, <span class="string">"getContentProviderImpl: updating data structures"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【9】将 provider 加入的 mProviderMap 中！</span></span><br><span class="line">            <span class="keyword">if</span> (firstClass) &#123;</span><br><span class="line">                mProviderMap.putProviderByClass(comp, cpr);</span><br><span class="line">            &#125;</span><br><span class="line">            mProviderMap.putProviderByName(name, cpr);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//【×5.1.1.6】增加 provider 引用计数，并返回连接对象 ContentProviderConnection！！</span></span><br><span class="line">            conn = incProviderCountLocked(r, cpr, token, stable);</span><br><span class="line">            <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                conn.waiting = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        checkTime(startTime, <span class="string">"getContentProviderImpl: done!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【9】等待 provider publish 完成！</span></span><br><span class="line">    <span class="keyword">synchronized</span> (cpr) &#123;</span><br><span class="line">        <span class="comment">//【9.1】当 cpr.provider 为 null 的时候，说明 provider 还没有 publish 完成，所以这里会持续等待！！</span></span><br><span class="line">        <span class="keyword">while</span> (cpr.provider == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cpr.launchingApp == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//【9.3】 cpr.launchingApp 表示其正在等待启动的进程，如果为 null，说明无法启动 provider 所在</span></span><br><span class="line">                <span class="comment">// 的进程，那么就返回 null！</span></span><br><span class="line">                Slog.w(TAG, <span class="string">"Unable to launch app "</span></span><br><span class="line">                        + cpi.applicationInfo.packageName + <span class="string">"/"</span></span><br><span class="line">                        + cpi.applicationInfo.uid + <span class="string">" for provider "</span></span><br><span class="line">                        + name + <span class="string">": launching app became null"</span>);</span><br><span class="line">                EventLog.writeEvent(EventLogTags.AM_PROVIDER_LOST_PROCESS,</span><br><span class="line">                        UserHandle.getUserId(cpi.applicationInfo.uid),</span><br><span class="line">                        cpi.applicationInfo.packageName,</span><br><span class="line">                        cpi.applicationInfo.uid, name);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_MU) Slog.v(TAG_MU,</span><br><span class="line">                        <span class="string">"Waiting to start provider "</span> + cpr</span><br><span class="line">                        + <span class="string">" launchingApp="</span> + cpr.launchingApp);</span><br><span class="line">                <span class="comment">//【9.4】如果此时创建了连接对象，那么设置 conn.waiting 为 true，表示等待 provider 的 publish！！ </span></span><br><span class="line">                <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    conn.waiting = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cpr.wait(); <span class="comment">// Binder 线程加入了该对象的等待队列中等待条件满足！</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    conn.waiting = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【10】provider 启动完成了，返回一个 Holder 对象，此时我们已经创建了连接对象 conn！</span></span><br><span class="line">    <span class="comment">// 同时 cpr.provider 也不为 null；</span></span><br><span class="line">    <span class="keyword">return</span> cpr != <span class="keyword">null</span> ? cpr.newHolder(conn) : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 ams 中有如下的集合：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//【1】用于保存正在启动的 provider！</span></span><br><span class="line"><span class="keyword">final</span> ArrayList&lt;ContentProviderRecord&gt; mLaunchingProviders</span><br><span class="line">        = <span class="keyword">new</span> ArrayList&lt;ContentProviderRecord&gt;();</span><br></pre></td></tr></table></figure>
<h3 id="5-1-1-Provider-正在运行的情况"><a href="#5-1-1-Provider-正在运行的情况" class="headerlink" title="5.1.1  Provider 正在运行的情况"></a>5.1.1  Provider 正在运行的情况</h3><h4 id="5-1-1-1-isSingleton"><a href="#5-1-1-1-isSingleton" class="headerlink" title="5.1.1.1 isSingleton"></a>5.1.1.1 isSingleton</h4><p>判断该 provider 时候是否是单例模式！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">(String componentProcessName, ApplicationInfo aInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">        String className, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (UserHandle.getAppId(aInfo.uid) &gt;= Process.FIRST_APPLICATION_UID) &#123;</span><br><span class="line">        <span class="comment">//【1】如果 provider 所属应用的 uid 大于等于 FIRST_APPLICATION_UID，那么其必须要设置 FLAG_SINGLE_USER</span></span><br><span class="line">        <span class="comment">// 标志位，同时也要被授予 INTERACT_ACROSS_USERS 权限才行！</span></span><br><span class="line">        <span class="keyword">if</span> ((flags &amp; ServiceInfo.FLAG_SINGLE_USER) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ActivityManager.checkUidPermission(</span><br><span class="line">                    INTERACT_ACROSS_USERS,</span><br><span class="line">                    aInfo.uid) != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">                ComponentName comp = <span class="keyword">new</span> ComponentName(aInfo.packageName, className);</span><br><span class="line">                String msg = <span class="string">"Permission Denial: Component "</span> + comp.flattenToShortString()</span><br><span class="line">                        + <span class="string">" requests FLAG_SINGLE_USER, but app does not hold "</span></span><br><span class="line">                        + INTERACT_ACROSS_USERS;</span><br><span class="line">                Slog.w(TAG, msg);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(msg);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"system"</span>.equals(componentProcessName)) &#123;</span><br><span class="line">        <span class="comment">//【2】如果 1 满足，那么 provider 所在进程必须是 system 进程！</span></span><br><span class="line">        result = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((flags &amp; ServiceInfo.FLAG_SINGLE_USER) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//【3】如果 1 和 2 都不满足，那么必须是 Phone app 或者 persistent apps，才能提供单例 provider！</span></span><br><span class="line">        result = UserHandle.isSameApp(aInfo.uid, Process.PHONE_UID)</span><br><span class="line">                || (aInfo.flags &amp; ApplicationInfo.FLAG_PERSISTENT) != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_MU) Slog.v(TAG_MU,</span><br><span class="line">            <span class="string">"isSingleton("</span> + componentProcessName + <span class="string">", "</span> + aInfo + <span class="string">", "</span> + className + <span class="string">", 0x"</span></span><br><span class="line">            + Integer.toHexString(flags) + <span class="string">") = "</span> + result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>属性：</strong></p>
<p>android:singleUser，取值为 true 或者 false，如果为 true，那么该 privider 将会是一个单例组件，系统中将有且只会存在一个单例组件运行在所有的设备用户下！</p>
<p>判断一个 provider 是否是单例模式，要满足一下条件之一：</p>
<ul>
<li>如果 provider 所属 appId 大于等于 FIRST_APPLICATION_UID，并且其 flags 设置了 FLAG_SINGLE_USER 位，同时其被授予了 INTERACT_ACROSS_USERS 权限；</li>
</ul>
<p><br></p>
<ul>
<li>如果条件 1 不满足，那么如果 provider 所属进程是 system 进程，那么其就是单例的！</li>
</ul>
<p><br></p>
<ul>
<li>条件 1，2 都不满足，如果 provider 所属进程不是系统进程，同时其设置了 FLAG_SINGLE_USER 位，那么其所属应必须用是 phone app 或者是 persistent app，那么才是单例的！ </li>
</ul>
<p>逻辑很简单，不多说了！</p>
<h4 id="5-1-1-2-isValidSingletonCall"><a href="#5-1-1-2-isValidSingletonCall" class="headerlink" title="5.1.1.2 isValidSingletonCall"></a>5.1.1.2 isValidSingletonCall</h4><p>用于判断调用单例 provider 的操作是否有效：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isValidSingletonCall</span><span class="params">(<span class="keyword">int</span> callingUid, <span class="keyword">int</span> componentUid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> componentAppId = UserHandle.getAppId(componentUid);</span><br><span class="line">    <span class="comment">//【1】对于单例模式，调用者和 provider 必须属于同一个应用，或者 provider 组件属于 system/phone</span></span><br><span class="line">    <span class="comment">// 或者 provider 组件有垮用户的权限！</span></span><br><span class="line">    <span class="keyword">return</span> UserHandle.isSameApp(callingUid, componentUid)</span><br><span class="line">            || componentAppId == Process.SYSTEM_UID</span><br><span class="line">            || componentAppId == Process.PHONE_UID</span><br><span class="line">            || ActivityManager.checkUidPermission(INTERACT_ACROSS_USERS_FULL, componentUid)</span><br><span class="line">                    == PackageManager.PERMISSION_GRANTED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断是否可以访问单例 provider，至少要满足以下的条件之一：</p>
<ul>
<li>单例的 provider 组件和调用者是同一个 app；</li>
<li>单例的 provider 是 system uid 或者 phone uid；</li>
<li>单例的 provider 所属应用有 INTERACT_ACROSS_USERS_FULL 的权限！</li>
</ul>
<p>不多说了！</p>
<h4 id="5-1-1-3-checkContentProviderPermissionLocked"><a href="#5-1-1-3-checkContentProviderPermissionLocked" class="headerlink" title="5.1.1.3 checkContentProviderPermissionLocked"></a>5.1.1.3 checkContentProviderPermissionLocked</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> String <span class="title">checkContentProviderPermissionLocked</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ProviderInfo cpi, ProcessRecord r, <span class="keyword">int</span> userId, <span class="keyword">boolean</span> checkUser)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> callingPid = (r != <span class="keyword">null</span>) ? r.pid : Binder.getCallingPid();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> callingUid = (r != <span class="keyword">null</span>) ? r.uid : Binder.getCallingUid();</span><br><span class="line">    <span class="keyword">boolean</span> checkedGrants = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (checkUser) &#123;</span><br><span class="line">        <span class="comment">// Looking for cross-user grants before enforcing the typical cross-users permissions</span></span><br><span class="line">        <span class="keyword">int</span> tmpTargetUserId = mUserController.unsafeConvertIncomingUserLocked(userId);</span><br><span class="line">        <span class="keyword">if</span> (tmpTargetUserId != UserHandle.getUserId(callingUid)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (checkAuthorityGrants(callingUid, cpi, tmpTargetUserId, checkUser)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            checkedGrants = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        userId = mUserController.handleIncomingUser(callingPid, callingUid, userId, <span class="keyword">false</span>,</span><br><span class="line">                ALLOW_NON_FULL, <span class="string">"checkContentProviderPermissionLocked "</span> + cpi.authority, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (userId != tmpTargetUserId) &#123;</span><br><span class="line">            <span class="comment">// When we actually went to determine the final targer user ID, this ended</span></span><br><span class="line">            <span class="comment">// up different than our initial check for the authority.  This is because</span></span><br><span class="line">            <span class="comment">// they had asked for USER_CURRENT_OR_SELF and we ended up switching to</span></span><br><span class="line">            <span class="comment">// SELF.  So we need to re-check the grants again.</span></span><br><span class="line">            checkedGrants = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (checkComponentPermission(cpi.readPermission, callingPid, callingUid,</span><br><span class="line">            cpi.applicationInfo.uid, cpi.exported)</span><br><span class="line">            == PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (checkComponentPermission(cpi.writePermission, callingPid, callingUid,</span><br><span class="line">            cpi.applicationInfo.uid, cpi.exported)</span><br><span class="line">            == PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PathPermission[] pps = cpi.pathPermissions;</span><br><span class="line">    <span class="keyword">if</span> (pps != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = pps.length;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            i--;</span><br><span class="line">            PathPermission pp = pps[i];</span><br><span class="line">            String pprperm = pp.getReadPermission();</span><br><span class="line">            <span class="keyword">if</span> (pprperm != <span class="keyword">null</span> &amp;&amp; checkComponentPermission(pprperm, callingPid, callingUid,</span><br><span class="line">                    cpi.applicationInfo.uid, cpi.exported)</span><br><span class="line">                    == PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            String ppwperm = pp.getWritePermission();</span><br><span class="line">            <span class="keyword">if</span> (ppwperm != <span class="keyword">null</span> &amp;&amp; checkComponentPermission(ppwperm, callingPid, callingUid,</span><br><span class="line">                    cpi.applicationInfo.uid, cpi.exported)</span><br><span class="line">                    == PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!checkedGrants &amp;&amp; checkAuthorityGrants(callingUid, cpi, userId, checkUser)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String msg;</span><br><span class="line">    <span class="keyword">if</span> (!cpi.exported) &#123;</span><br><span class="line">        msg = <span class="string">"Permission Denial: opening provider "</span> + cpi.name</span><br><span class="line">                + <span class="string">" from "</span> + (r != <span class="keyword">null</span> ? r : <span class="string">"(null)"</span>) + <span class="string">" (pid="</span> + callingPid</span><br><span class="line">                + <span class="string">", uid="</span> + callingUid + <span class="string">") that is not exported from uid "</span></span><br><span class="line">                + cpi.applicationInfo.uid;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        msg = <span class="string">"Permission Denial: opening provider "</span> + cpi.name</span><br><span class="line">                + <span class="string">" from "</span> + (r != <span class="keyword">null</span> ? r : <span class="string">"(null)"</span>) + <span class="string">" (pid="</span> + callingPid</span><br><span class="line">                + <span class="string">", uid="</span> + callingUid + <span class="string">") requires "</span></span><br><span class="line">                + cpi.readPermission + <span class="string">" or "</span> + cpi.writePermission;</span><br><span class="line">    &#125;</span><br><span class="line">    Slog.w(TAG, msg);</span><br><span class="line">    <span class="keyword">return</span> msg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-1-1-4-ContentProviderRecord-canRunHere"><a href="#5-1-1-4-ContentProviderRecord-canRunHere" class="headerlink" title="5.1.1.4 ContentProviderRecord.canRunHere"></a>5.1.1.4 ContentProviderRecord.canRunHere</h4><p>判断该 provider 是否可以在指定的进程中运行：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canRunHere</span><span class="params">(ProcessRecord app)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】provider 设置了 multiprocess 属性，或者 provider 的进程是该进程</span></span><br><span class="line">    <span class="comment">// 并且该 provider 所属 userId 和该进程所属应用程序的 userId 一样（相同用户下）！</span></span><br><span class="line">    <span class="keyword">return</span> (info.multiprocess || info.processName.equals(app.processName))</span><br><span class="line">            &amp;&amp; uid == app.info.uid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不多说了！</p>
<h4 id="5-1-1-5-ContentProviderRecord-newHolder"><a href="#5-1-1-5-ContentProviderRecord-newHolder" class="headerlink" title="5.1.1.5 ContentProviderRecord.newHolder"></a>5.1.1.5 ContentProviderRecord.newHolder</h4><p>根据系统中已经 publish 的 provider，创建一个 ContentProviderHolder 对象！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ContentProviderHolder <span class="title">newHolder</span><span class="params">(ContentProviderConnection conn)</span> </span>&#123;</span><br><span class="line">    ContentProviderHolder holder = <span class="keyword">new</span> ContentProviderHolder(info);</span><br><span class="line">    holder.provider = provider;</span><br><span class="line">    holder.noReleaseNeeded = noReleaseNeeded;</span><br><span class="line">    holder.connection = conn;</span><br><span class="line">    <span class="keyword">return</span> holder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于 ContentProviderHolder，我们后面会分析！</p>
<h4 id="5-1-1-6-incProviderCountLocked"><a href="#5-1-1-6-incProviderCountLocked" class="headerlink" title="5.1.1.6 incProviderCountLocked"></a>5.1.1.6 incProviderCountLocked</h4><p>增加 provider 的引用计数，参数 r 是访问 provider 的进程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ContentProviderConnection <span class="title">incProviderCountLocked</span><span class="params">(ProcessRecord r,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> ContentProviderRecord cpr, IBinder externalProcessToken, <span class="keyword">boolean</span> stable)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】判断下访问者进程是否存在！</span></span><br><span class="line">    <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r.conProviders.size(); i++) &#123;</span><br><span class="line">            <span class="comment">//【1.1】如果进程存在（当然是存在的），那就依次遍历其持有的 provider connection 对象！</span></span><br><span class="line">            <span class="comment">// 找到该进程持有的对该 provider 的连接对象！</span></span><br><span class="line">            ContentProviderConnection conn = r.conProviders.get(i);</span><br><span class="line">            <span class="keyword">if</span> (conn.provider == cpr) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_PROVIDER) Slog.v(TAG_PROVIDER,</span><br><span class="line">                        <span class="string">"Adding provider requested by "</span></span><br><span class="line">                        + r.processName + <span class="string">" from process "</span></span><br><span class="line">                        + cpr.info.processName + <span class="string">": "</span> + cpr.name.flattenToShortString()</span><br><span class="line">                        + <span class="string">" scnt="</span> + conn.stableCount + <span class="string">" uscnt="</span> + conn.unstableCount);</span><br><span class="line">                <span class="comment">//【1.2】如果是访问的是 stable provider，增加 stable count！</span></span><br><span class="line">                <span class="keyword">if</span> (stable) &#123;</span><br><span class="line">                    conn.stableCount++;</span><br><span class="line">                    conn.numStableIncs++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//【1.3】如果是访问的是 unstable provider，增加 unstable count！</span></span><br><span class="line">                    conn.unstableCount++;</span><br><span class="line">                    conn.numUnstableIncs++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//【1.4】返回该 connection 对象！</span></span><br><span class="line">                <span class="keyword">return</span> conn;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【*5.1.1.6.1】如果找不到，说明是第一次访问该 provider，那就先创建</span></span><br><span class="line">        <span class="comment">// 一个 ContentProviderConnection 对象！！</span></span><br><span class="line">        ContentProviderConnection conn = <span class="keyword">new</span> ContentProviderConnection(cpr, r);</span><br><span class="line">        <span class="comment">//【1.5】增加引用计数！</span></span><br><span class="line">        <span class="keyword">if</span> (stable) &#123;</span><br><span class="line">            conn.stableCount = <span class="number">1</span>;</span><br><span class="line">            conn.numStableIncs = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            conn.unstableCount = <span class="number">1</span>;</span><br><span class="line">            conn.numUnstableIncs = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【1.6】将其添加到 ContentProviderRecord.connections 集合中；</span></span><br><span class="line">        cpr.connections.add(conn);</span><br><span class="line">        <span class="comment">//【1.7】将其添加到 ProcessRecord.conProviders 集合中；</span></span><br><span class="line">        r.conProviders.add(conn);</span><br><span class="line">        startAssociationLocked(r.uid, r.processName, r.curProcState,</span><br><span class="line">                cpr.uid, cpr.name, cpr.info.processName); <span class="comment">// 用于记录进程间的关联性的，这里先不关注！</span></span><br><span class="line">        <span class="comment">//【1.8】返回该新建的连接对象！</span></span><br><span class="line">        <span class="keyword">return</span> conn;</span><br><span class="line">    &#125;</span><br><span class="line">    cpr.addExternalProcessHandleLocked(externalProcessToken);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不多说了！</p>
<h5 id="5-1-1-6-1-new-ContentProviderConnection"><a href="#5-1-1-6-1-new-ContentProviderConnection" class="headerlink" title="5.1.1.6.1 new ContentProviderConnection"></a>5.1.1.6.1 new ContentProviderConnection</h5><p>创建连接对象，本质上是一个 Binder 对象：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ContentProviderConnection</span> <span class="keyword">extends</span> <span class="title">Binder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> ContentProviderRecord provider; <span class="comment">// provider 对象；</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> ProcessRecord client; <span class="comment">// 连接到该 provider 的进程；</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> createTime;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> stableCount; <span class="comment">// stable provider 的引用计数；</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> unstableCount; <span class="comment">// unstable provider 的引用计数；</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> waiting; <span class="comment">// 是否正在等待 provider publish，被锁保护！</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> dead; <span class="comment">// provider 是否死亡！</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> numStableIncs; <span class="comment">// 用于调试！</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> numUnstableIncs;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ContentProviderConnection</span><span class="params">(ContentProviderRecord _provider, ProcessRecord _client)</span> </span>&#123;</span><br><span class="line">        provider = _provider;</span><br><span class="line">        client = _client;</span><br><span class="line">        createTime = SystemClock.elapsedRealtime();</span><br><span class="line">    &#125;</span><br><span class="line">    ... ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>数据结构都很简答，不多说了！！</p>
<h4 id="5-1-1-7-decProviderCountLocked"><a href="#5-1-1-7-decProviderCountLocked" class="headerlink" title="5.1.1.7 decProviderCountLocked"></a>5.1.1.7 decProviderCountLocked</h4><p>减少 provider 的引用计数，参数 conn 是该 provider 的连接对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">decProviderCountLocked</span><span class="params">(ContentProviderConnection conn,</span></span></span><br><span class="line"><span class="function"><span class="params">        ContentProviderRecord cpr, IBinder externalProcessToken, <span class="keyword">boolean</span> stable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//【1】获得该连接对象链接的 provider 对爱 ContentProviderRecord！</span></span><br><span class="line">        cpr = conn.provider;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_PROVIDER) Slog.v(TAG_PROVIDER,</span><br><span class="line">                <span class="string">"Removing provider requested by "</span></span><br><span class="line">                + conn.client.processName + <span class="string">" from process "</span></span><br><span class="line">                + cpr.info.processName + <span class="string">": "</span> + cpr.name.flattenToShortString()</span><br><span class="line">                + <span class="string">" scnt="</span> + conn.stableCount + <span class="string">" uscnt="</span> + conn.unstableCount);</span><br><span class="line">        <span class="comment">//【2】减少该连接对象的相应引用计数！</span></span><br><span class="line">        <span class="keyword">if</span> (stable) &#123;</span><br><span class="line">            conn.stableCount--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            conn.unstableCount--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【3】判断是否是该 provider 的最后一个引用，即本次减少引用后，该连接对象的 stable count </span></span><br><span class="line">        <span class="comment">// 和 unstable count 都是 0。</span></span><br><span class="line">        <span class="keyword">if</span> (conn.stableCount == <span class="number">0</span> &amp;&amp; conn.unstableCount == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//【3.1】ContentProviderRecord.connections 移除该连接对象；</span></span><br><span class="line">            cpr.connections.remove(conn);</span><br><span class="line">            <span class="comment">//【3.2】从该连接对象的所属进程中移除自身！</span></span><br><span class="line">            conn.client.conProviders.remove(conn);</span><br><span class="line">            <span class="keyword">if</span> (conn.client.setProcState &lt; ActivityManager.PROCESS_STATE_LAST_ACTIVITY) &#123;</span><br><span class="line">                <span class="comment">// The client is more important than last activity -- note the time this</span></span><br><span class="line">                <span class="comment">// is happening, so we keep the old provider process around a bit as last</span></span><br><span class="line">                <span class="comment">// activity to avoid thrashing it.</span></span><br><span class="line">                <span class="keyword">if</span> (cpr.proc != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    cpr.proc.lastProviderTime = SystemClock.uptimeMillis();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            stopAssociationLocked(conn.client.uid, conn.client.processName, cpr.uid, cpr.name);</span><br><span class="line">            <span class="comment">//【3.3】返回 true，说明取消的是最后一个引用！</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cpr.removeExternalProcessHandleLocked(externalProcessToken);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不多说了！</p>
<h3 id="5-1-2-Provider-没在运行的情况"><a href="#5-1-2-Provider-没在运行的情况" class="headerlink" title="5.1.2  Provider 没在运行的情况"></a>5.1.2  Provider 没在运行的情况</h3><h4 id="5-1-2-1-ProviderMap"><a href="#5-1-2-1-ProviderMap" class="headerlink" title="5.1.2.1 ProviderMap"></a>5.1.2.1 ProviderMap</h4><p>在 ams 有一个这样的数据结构：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ProviderMap mProviderMap = <span class="keyword">new</span> ProviderMap(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>
<p>用来记录系统中所有 publish 的 provider：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"ProviderMap"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DBG = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ActivityManagerService mAm;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】单例 provdier 集合，key 为 authority，value 为 ContentProviderRecord 实例！</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;String, ContentProviderRecord&gt; mSingletonByName</span><br><span class="line">            = <span class="keyword">new</span> HashMap&lt;String, ContentProviderRecord&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;ComponentName, ContentProviderRecord&gt; mSingletonByClass</span><br><span class="line">            = <span class="keyword">new</span> HashMap&lt;ComponentName, ContentProviderRecord&gt;();</span><br><span class="line">    <span class="comment">//【2】非单例 provdier 集合，key 为 userId，value 是 authority 和 ContentProviderRecord 的映射！</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SparseArray&lt;HashMap&lt;String, ContentProviderRecord&gt;&gt; mProvidersByNamePerUser</span><br><span class="line">            = <span class="keyword">new</span> SparseArray&lt;HashMap&lt;String, ContentProviderRecord&gt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SparseArray&lt;HashMap&lt;ComponentName, ContentProviderRecord&gt;&gt; mProvidersByClassPerUser</span><br><span class="line">            = <span class="keyword">new</span> SparseArray&lt;HashMap&lt;ComponentName, ContentProviderRecord&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    ProviderMap(ActivityManagerService am) &#123;</span><br><span class="line">        mAm = am;</span><br><span class="line">    &#125;</span><br><span class="line">    ... ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就不多说了！</p>
<p>同时也提供了如下的 get set 接口：</p>
<p> 5.1.2.2.1 ProviderMap.get</p>
<h4 id="5-1-2-2-new-ContentProviderRecord"><a href="#5-1-2-2-new-ContentProviderRecord" class="headerlink" title="5.1.2.2 new ContentProviderRecord"></a>5.1.2.2 new ContentProviderRecord</h4><p>创建一个 ContentProviderRecord 实例，用于在系统进程中描述一个 provider！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ContentProviderRecord</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ActivityManagerService service; <span class="comment">// ams 实力</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> ProviderInfo info; <span class="comment">// provider 的信息对象；</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> uid; <span class="comment">// 所属应用的 uid；</span></span><br><span class="line">    <span class="keyword">final</span> ApplicationInfo appInfo; <span class="comment">// 所属应用程序的信息；</span></span><br><span class="line">    <span class="keyword">final</span> ComponentName name; <span class="comment">// provider 对应的组件名实例；</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> singleton; <span class="comment">// 是否是单例模式；</span></span><br><span class="line">    <span class="keyword">public</span> IContentProvider provider;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> noReleaseNeeded;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】所有连接到该 provider 的进程的连接对象！</span></span><br><span class="line">    <span class="keyword">final</span> ArrayList&lt;ContentProviderConnection&gt; connections</span><br><span class="line">            = <span class="keyword">new</span> ArrayList&lt;ContentProviderConnection&gt;();</span><br><span class="line">            </span><br><span class="line">    <span class="comment">//final HashSet&lt;ProcessRecord&gt; clients = new HashSet&lt;ProcessRecord&gt;();</span></span><br><span class="line">    <span class="comment">// Handles for non-framework processes supported by this provider</span></span><br><span class="line">    HashMap&lt;IBinder, ExternalProcessHandle&gt; externalProcessTokenToHandle;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Count for external process for which we have no handles.</span></span><br><span class="line">    <span class="keyword">int</span> externalProcessNoHandleCount;</span><br><span class="line">    ProcessRecord proc; <span class="comment">//【2】所在进程</span></span><br><span class="line">    ProcessRecord launchingApp; <span class="comment">//【3】等待启动的进程！</span></span><br><span class="line">    String stringName;</span><br><span class="line">    String shortStringName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ContentProviderRecord</span><span class="params">(ActivityManagerService _service, ProviderInfo _info,</span></span></span><br><span class="line"><span class="function"><span class="params">            ApplicationInfo ai, ComponentName _name, <span class="keyword">boolean</span> _singleton)</span> </span>&#123;</span><br><span class="line">        service = _service;</span><br><span class="line">        info = _info;</span><br><span class="line">        uid = ai.uid;</span><br><span class="line">        appInfo = ai;</span><br><span class="line">        name = _name;</span><br><span class="line">        singleton = _singleton;</span><br><span class="line">        noReleaseNeeded = uid == <span class="number">0</span> || uid == Process.SYSTEM_UID;</span><br><span class="line">    &#125;</span><br><span class="line">    ... ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续分析！</p>
<h3 id="5-1-3-ActivityManagerProxy-getContentProvider"><a href="#5-1-3-ActivityManagerProxy-getContentProvider" class="headerlink" title="5.1.3 ActivityManagerProxy.getContentProvider"></a>5.1.3 ActivityManagerProxy.getContentProvider</h3><p>对于 getContentProvider，我们再去看下 ActivityManagerProxy 中是如何调用的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ContentProviderHolder <span class="title">getContentProvider</span><span class="params">(IApplicationThread caller,</span></span></span><br><span class="line"><span class="function"><span class="params">        String name, <span class="keyword">int</span> userId, <span class="keyword">boolean</span> stable)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    Parcel data = Parcel.obtain();</span><br><span class="line">    Parcel reply = Parcel.obtain();</span><br><span class="line">    data.writeInterfaceToken(IActivityManager.descriptor);</span><br><span class="line">    data.writeStrongBinder(caller != <span class="keyword">null</span> ? caller.asBinder() : <span class="keyword">null</span>);</span><br><span class="line">    data.writeString(name);</span><br><span class="line">    data.writeInt(userId);</span><br><span class="line">    data.writeInt(stable ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    mRemote.transact(GET_CONTENT_PROVIDER_TRANSACTION, data, reply, <span class="number">0</span>);</span><br><span class="line">    reply.readException();</span><br><span class="line">    <span class="keyword">int</span> res = reply.readInt();</span><br><span class="line">    ContentProviderHolder cph = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (res != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//【*5.1.3.1】调用了 ContentProviderHolder.CREATOR 的 createFromParcel 方法！</span></span><br><span class="line">        cph = ContentProviderHolder.CREATOR.createFromParcel(reply);</span><br><span class="line">    &#125;</span><br><span class="line">    data.recycle();</span><br><span class="line">    reply.recycle();</span><br><span class="line">    <span class="keyword">return</span> cph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getContentProvider 会返回一个 ContentProviderHolder 实例，ContentProviderHolder 看源码，实现了 Parcelable 接口，可以序列化!</p>
<h4 id="5-1-3-1-ContentProviderHolder-CREATOR-createFromParcel"><a href="#5-1-3-1-ContentProviderHolder-CREATOR-createFromParcel" class="headerlink" title="5.1.3.1 ContentProviderHolder.CREATOR.createFromParcel"></a>5.1.3.1 ContentProviderHolder.CREATOR.createFromParcel</h4><p>我们来看下 ContentProviderHolder.CREATOR 的 createFromParcel 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Parcelable.Creator&lt;ContentProviderHolder&gt; CREATOR</span><br><span class="line">        = <span class="keyword">new</span> Parcelable.Creator&lt;ContentProviderHolder&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ContentProviderHolder <span class="title">createFromParcel</span><span class="params">(Parcel source)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//【*5.1.3.2】这里是通过服务端进程返回的 Parcel，再创建了一个 ContentProviderHolder！</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ContentProviderHolder(source);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> ContentProviderHolder[] newArray(<span class="keyword">int</span> size) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ContentProviderHolder[size];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="5-1-3-2-new-ContentProviderHolder-Parcel"><a href="#5-1-3-2-new-ContentProviderHolder-Parcel" class="headerlink" title="5.1.3.2 new ContentProviderHolder[Parcel]"></a>5.1.3.2 new ContentProviderHolder[Parcel]</h4><p>这里通过 ContentProviderHolder 另外一个构造器创建了访问者进程中的 ContentProviderHolder 实例！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ContentProviderHolder</span><span class="params">(Parcel source)</span> </span>&#123;</span><br><span class="line">    info = ProviderInfo.CREATOR.createFromParcel(source);</span><br><span class="line">    <span class="comment">//【1】初始化 provider 实例！</span></span><br><span class="line">    provider = ContentProviderNative.asInterface(</span><br><span class="line">            source.readStrongBinder());</span><br><span class="line">    connection = source.readStrongBinder();</span><br><span class="line">    noReleaseNeeded = source.readInt() != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们知道在 provider 的宿主进程里，这里的 provider 是 Transport 实例！！</p>
<p>但是在访问者进程中，这里的 provider 是一个 ContentProviderProxy 实例，也就是 Transport 的客户端代理对象！</p>
<p>这样访问者进程就可以通过 ContentProviderProxy -&gt; Transport 来跨进程通信啦！！</p>
<h1 id="6-ActivityThread"><a href="#6-ActivityThread" class="headerlink" title="6 ActivityThread"></a>6 ActivityThread</h1><h2 id="6-1-provider-未启动但是其进程已经启动"><a href="#6-1-provider-未启动但是其进程已经启动" class="headerlink" title="6.1 provider 未启动但是其进程已经启动"></a>6.1 provider 未启动但是其进程已经启动</h2><h3 id="6-1-1-scheduleInstallProvider"><a href="#6-1-1-scheduleInstallProvider" class="headerlink" title="6.1.1 scheduleInstallProvider"></a>6.1.1 scheduleInstallProvider</h3><p>发送了 INSTALL_PROVIDER 消息：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleInstallProvider</span><span class="params">(ProviderInfo provider)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】发送了 INSTALL_PROVIDER 消息！</span></span><br><span class="line">    sendMessage(H.INSTALL_PROVIDER, provider);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="6-1-2-H-handleMessage-INSTALL-PROVIDER"><a href="#6-1-2-H-handleMessage-INSTALL-PROVIDER" class="headerlink" title="6.1.2 H.handleMessage[INSTALL_PROVIDER]"></a>6.1.2 H.handleMessage[INSTALL_PROVIDER]</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> INSTALL_PROVIDER:</span><br><span class="line">    <span class="comment">//【6.1.3】安装 provider！</span></span><br><span class="line">    handleInstallProvider((ProviderInfo) msg.obj);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<h3 id="6-1-3-handleInstallProvider"><a href="#6-1-3-handleInstallProvider" class="headerlink" title="6.1.3 handleInstallProvider"></a>6.1.3 handleInstallProvider</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleInstallProvider</span><span class="params">(ProviderInfo info)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskWrites();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//【×6.3】安装 content provider！</span></span><br><span class="line">        installContentProviders(mInitialApplication, Lists.newArrayList(info));</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        StrictMode.setThreadPolicy(oldPolicy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里就不多说了！！</p>
<h2 id="6-2-provider-未启动同时其进程也未启动"><a href="#6-2-provider-未启动同时其进程也未启动" class="headerlink" title="6.2 provider 未启动同时其进程也未启动"></a>6.2 provider 未启动同时其进程也未启动</h2><h3 id="6-2-1-AMS-attachApplicationLocked"><a href="#6-2-1-AMS-attachApplicationLocked" class="headerlink" title="6.2.1 AMS.attachApplicationLocked"></a>6.2.1 AMS.attachApplicationLocked</h3><p>startProcessLocked 方法，先会调用 attachApplicationLocked 方法，这里省略掉了和 ContentProvider 无关的逻辑和代码：</p>
<p>attachApplicationLocked 我们在进程的启动中有分析过！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">attachApplicationLocked</span><span class="params">(IApplicationThread thread,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> pid)</span> </span>&#123;</span><br><span class="line">    ... ... ... ...</span><br><span class="line">    <span class="comment">//【×6.2.1.1】获得进程中需要 install 和 publish 的 provider！</span></span><br><span class="line">    <span class="keyword">boolean</span> normalMode = mProcessesReady || isAllowedWhileBooting(app.info);</span><br><span class="line">    List&lt;ProviderInfo&gt; providers = normalMode ? generateApplicationProvidersLocked(app) : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【×6.2.1.2】如果有 provider 正在等待该进程启动，那么就设置超时消息！</span></span><br><span class="line">    <span class="keyword">if</span> (providers != <span class="keyword">null</span> &amp;&amp; checkAppInLaunchingProvidersLocked(app)) &#123;</span><br><span class="line">        Message msg = mHandler.obtainMessage(CONTENT_PROVIDER_PUBLISH_TIMEOUT_MSG);</span><br><span class="line">        msg.obj = app;</span><br><span class="line">        mHandler.sendMessageDelayed(msg, CONTENT_PROVIDER_PUBLISH_TIMEOUT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ... ... ... ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ... ... ... ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【×6.2.2】bind 应用程序进程，这个地方，我们将 providers 作为参数传递到了 bindApplication</span></span><br><span class="line">        <span class="comment">// 方法里！</span></span><br><span class="line">        thread.bindApplication(processName, appInfo, providers, app.instrumentationClass,</span><br><span class="line">                profilerInfo, app.instrumentationArguments, app.instrumentationWatcher,</span><br><span class="line">                app.instrumentationUiAutomationConnection, testMode,</span><br><span class="line">                mBinderTransactionTrackingEnabled, enableTrackAllocation,</span><br><span class="line">                isRestrictedBackupMode || !normalMode, app.persistent,</span><br><span class="line">                <span class="keyword">new</span> Configuration(mConfiguration), app.compat,</span><br><span class="line">                getCommonServicesLocked(app.isolated),</span><br><span class="line">                mCoreSettingsObserver.getCoreSettingsLocked());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【1】更新 lru 进程列表！</span></span><br><span class="line">        updateLruProcessLocked(app, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        app.lastRequestedGc = app.lastLowMemory = SystemClock.uptimeMillis();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        Slog.wtf(TAG, <span class="string">"Exception thrown during bind of "</span> + app, e);</span><br><span class="line">        app.resetPackageList(mProcessStats);</span><br><span class="line">        app.unlinkDeathRecipient();</span><br><span class="line">        startProcessLocked(app, <span class="string">"bind fail"</span>, processName);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ... ... ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-2-1-1-generateApplicationProvidersLocked"><a href="#6-2-1-1-generateApplicationProvidersLocked" class="headerlink" title="6.2.1.1 generateApplicationProvidersLocked"></a>6.2.1.1 generateApplicationProvidersLocked</h4><p>收集该进程中需要启动的 provider！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;ProviderInfo&gt; <span class="title">generateApplicationProvidersLocked</span><span class="params">(ProcessRecord app)</span> </span>&#123;</span><br><span class="line">    List&lt;ProviderInfo&gt; providers = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//【1】获得该进程中所有 provider！</span></span><br><span class="line">        providers = AppGlobals.getPackageManager()</span><br><span class="line">                .queryContentProviders(app.processName, app.uid,</span><br><span class="line">                        STOCK_PM_FLAGS | PackageManager.GET_URI_PERMISSION_PATTERNS</span><br><span class="line">                                | MATCH_DEBUG_TRIAGED_MISSING)</span><br><span class="line">                .getList();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG_MU) Slog.v(TAG_MU,</span><br><span class="line">            <span class="string">"generateApplicationProvidersLocked, app.info.uid = "</span> + app.uid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> userId = app.userId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】遍历获得的所有的 provider！</span></span><br><span class="line">    <span class="keyword">if</span> (providers != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> N = providers.size();</span><br><span class="line">        app.pubProviders.ensureCapacity(N + app.pubProviders.size());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">            ProviderInfo cpi =</span><br><span class="line">                (ProviderInfo)providers.get(i);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//【×5.1.1.1】判断 provider 是否是单例模式的！</span></span><br><span class="line">            <span class="keyword">boolean</span> singleton = isSingleton(cpi.processName, cpi.applicationInfo,</span><br><span class="line">                    cpi.name, cpi.flags);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【2.1】如果 provider 是单例模式，那么他们只能在默认用户下的进程中运行，如果</span></span><br><span class="line">            <span class="comment">// 进程的所属用户不是默认用户，那就不能运行！</span></span><br><span class="line">            <span class="keyword">if</span> (singleton &amp;&amp; UserHandle.getUserId(app.uid) != UserHandle.USER_SYSTEM) &#123;</span><br><span class="line">                <span class="comment">//【2.1.1】将该 provider 从集合中移除！</span></span><br><span class="line">                providers.remove(i);</span><br><span class="line">                N--;</span><br><span class="line">                i--;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//【2.3】创建 provider 对应的组件对象，并创建 provider 对应的 ContentProviderRecord 实例</span></span><br><span class="line">            <span class="comment">// 将其添加到 mProviderMap 和 mProviderMap 中！</span></span><br><span class="line">            ComponentName comp = <span class="keyword">new</span> ComponentName(cpi.packageName, cpi.name);</span><br><span class="line">            ContentProviderRecord cpr = mProviderMap.getProviderByClass(comp, userId);</span><br><span class="line">            <span class="keyword">if</span> (cpr == <span class="keyword">null</span>) &#123;</span><br><span class="line">                cpr = <span class="keyword">new</span> ContentProviderRecord(<span class="keyword">this</span>, cpi, app.info, comp, singleton);</span><br><span class="line">                mProviderMap.putProviderByClass(comp, cpr);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_MU) Slog.v(TAG_MU,</span><br><span class="line">                    <span class="string">"generateApplicationProvidersLocked, cpi.uid = "</span> + cpr.uid);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//【2.4】将该 provdier 添加到所属进程的 app.pubProviders 集合中！</span></span><br><span class="line">            app.pubProviders.put(cpi.name, cpr);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【2.5】如果 provider 不是 multiprocess；</span></span><br><span class="line">            <span class="comment">// 或者 provider 是 multiprocess 同时其宿主进程名不是 android，我们会将其所属包名加入到该进程中！</span></span><br><span class="line">            <span class="keyword">if</span> (!cpi.multiprocess || !<span class="string">"android"</span>.equals(cpi.packageName)) &#123;</span><br><span class="line">                <span class="comment">// 如果是平台组件的话，那么是不会加入的，因为其属于框架层！</span></span><br><span class="line">                app.addPackage(cpi.applicationInfo.packageName, cpi.applicationInfo.versionCode,</span><br><span class="line">                        mProcessStats);</span><br><span class="line">            &#125;</span><br><span class="line">            notifyPackageUse(cpi.applicationInfo.packageName,</span><br><span class="line">                             PackageManager.NOTIFY_PACKAGE_USE_CONTENT_PROVIDER);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【2】返回要启动的 provider！</span></span><br><span class="line">    <span class="keyword">return</span> providers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里就不多说了！！</p>
<h4 id="6-2-1-2-checkAppInLaunchingProvidersLocked"><a href="#6-2-1-2-checkAppInLaunchingProvidersLocked" class="headerlink" title="6.2.1.2 checkAppInLaunchingProvidersLocked"></a>6.2.1.2 checkAppInLaunchingProvidersLocked</h4><p>判断是否有 content provider 等待该进程的启动！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">checkAppInLaunchingProvidersLocked</span><span class="params">(ProcessRecord app)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】遍历 mLaunchingProviders 集合，如果有 provider 所属进程属于该 process，返回 true！</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = mLaunchingProviders.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        ContentProviderRecord cpr = mLaunchingProviders.get(i);</span><br><span class="line">        <span class="keyword">if</span> (cpr.launchingApp == app) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-2-2-handleBindApplication"><a href="#6-2-2-handleBindApplication" class="headerlink" title="6.2.2 handleBindApplication"></a>6.2.2 handleBindApplication</h3><p>startProcessLocked 方法，最后会调用 handleBindApplication 方法，这里省略掉了和 ContentProvider 无关的逻辑和代码：</p>
<p>handleBindApplication 我们在进程的启动中有分析过！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleBindApplication</span><span class="params">(AppBindData data)</span> </span>&#123;</span><br><span class="line">    ... ... ... ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> StrictMode.ThreadPolicy savedPolicy = StrictMode.allowThreadDiskWrites();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Application app = data.info.makeApplication(data.restrictedBackupMode, <span class="keyword">null</span>);</span><br><span class="line">        mInitialApplication = app;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!data.restrictedBackupMode) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!ArrayUtils.isEmpty(data.providers)) &#123;</span><br><span class="line">                <span class="comment">//【×6.3】安装 content provider！！</span></span><br><span class="line">                installContentProviders(app, data.providers);</span><br><span class="line">                mH.sendEmptyMessageDelayed(H.ENABLE_JIT, <span class="number">10</span>*<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mInstrumentation.onCreate(data.instrumentationArgs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Exception thrown in onCreate() of "</span></span><br><span class="line">                + data.instrumentationName + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mInstrumentation.callApplicationOnCreate(app);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mInstrumentation.onException(app, e)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="string">"Unable to create application "</span> + app.getClass().getName()</span><br><span class="line">                    + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        StrictMode.setThreadPolicy(savedPolicy);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-3-installContentProviders-安装-provider"><a href="#6-3-installContentProviders-安装-provider" class="headerlink" title="6.3 installContentProviders - 安装 provider"></a>6.3 installContentProviders - 安装 provider</h2><p>安装 contentprovider：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">installContentProviders</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Context context, List&lt;ProviderInfo&gt; providers)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】该进程中的所有 provider！</span></span><br><span class="line">    <span class="keyword">final</span> ArrayList&lt;IActivityManager.ContentProviderHolder&gt; results =</span><br><span class="line">        <span class="keyword">new</span> ArrayList&lt;IActivityManager.ContentProviderHolder&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ProviderInfo cpi : providers) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_PROVIDER) &#123;</span><br><span class="line">            StringBuilder buf = <span class="keyword">new</span> StringBuilder(<span class="number">128</span>);</span><br><span class="line">            buf.append(<span class="string">"Pub "</span>);</span><br><span class="line">            buf.append(cpi.authority);</span><br><span class="line">            buf.append(<span class="string">": "</span>);</span><br><span class="line">            buf.append(cpi.name);</span><br><span class="line">            Log.i(TAG, buf.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【×6.4】封装 provider！</span></span><br><span class="line">        IActivityManager.ContentProviderHolder cph = installProvider(context, <span class="keyword">null</span>, cpi,</span><br><span class="line">                <span class="keyword">false</span> <span class="comment">/*noisy*/</span>, <span class="keyword">true</span> <span class="comment">/*noReleaseNeeded*/</span>, <span class="keyword">true</span> <span class="comment">/*stable*/</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【2】设置 ContentProviderHolder 的 noReleaseNeeded 属性</span></span><br><span class="line">        <span class="comment">// 同时将其添加到 results 集合中！</span></span><br><span class="line">        <span class="keyword">if</span> (cph != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cph.noReleaseNeeded = <span class="keyword">true</span>;</span><br><span class="line">            results.add(cph);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//【×7.1】将 provider 注册到 ams 中！</span></span><br><span class="line">        ActivityManagerNative.getDefault().publishContentProviders(</span><br><span class="line">            getApplicationThread(), results);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里我们要注意下参数：</p>
<ul>
<li><strong>Context context</strong>：进程的上下文环境！</li>
<li><strong>IActivityManager.ContentProviderHolder holder</strong>：null</li>
<li><strong>ProviderInfo info</strong>：provider 的信息对象；</li>
<li><strong>boolean noisy</strong>：false</li>
<li><strong>boolean noReleaseNeeded</strong>：true</li>
<li><strong>boolean stable</strong>：true</li>
</ul>
<h2 id="6-4-installProvider"><a href="#6-4-installProvider" class="headerlink" title="6.4 installProvider"></a>6.4 installProvider</h2><p>封装 provider，返回对应的 ContentProviderHolder 实例，注意，这里由于 provider 的进程刚启动，所以 installProvider 的 </p>
<p>IActivityManager.ContentProviderHolder holder 参数为 null！<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> IActivityManager.<span class="function">ContentProviderHolder <span class="title">installProvider</span><span class="params">(Context context,</span></span></span><br><span class="line"><span class="function"><span class="params">        IActivityManager.ContentProviderHolder holder, ProviderInfo info,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> noisy, <span class="keyword">boolean</span> noReleaseNeeded, <span class="keyword">boolean</span> stable)</span> </span>&#123;</span><br><span class="line">    ContentProvider localProvider = <span class="keyword">null</span>;</span><br><span class="line">    IContentProvider provider;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【1】如果 if 条件满足，说明进程要创建自己的本地 provider 实例！！</span></span><br><span class="line">    <span class="keyword">if</span> (holder == <span class="keyword">null</span> || holder.provider == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_PROVIDER || noisy) &#123;</span><br><span class="line">            Slog.d(TAG, <span class="string">"Loading provider "</span> + info.authority + <span class="string">": "</span></span><br><span class="line">                    + info.name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【1.1】获取 Context 上下文环境！</span></span><br><span class="line">        Context c = <span class="keyword">null</span>;</span><br><span class="line">        ApplicationInfo ai = info.applicationInfo;</span><br><span class="line">        <span class="keyword">if</span> (context.getPackageName().equals(ai.packageName)) &#123;</span><br><span class="line">            c = context;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mInitialApplication != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                mInitialApplication.getPackageName().equals(ai.packageName)) &#123;</span><br><span class="line">            c = mInitialApplication;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                c = context.createPackageContext(ai.packageName,</span><br><span class="line">                        Context.CONTEXT_INCLUDE_CODE);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Unable to get context for package "</span> +</span><br><span class="line">                  ai.packageName +</span><br><span class="line">                  <span class="string">" while loading content provider "</span> +</span><br><span class="line">                  info.name);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> java.lang.ClassLoader cl = c.getClassLoader();</span><br><span class="line">            <span class="comment">//【×6.4.1】第一次创建时，会通过反射，创建 ContentProvider 对象！</span></span><br><span class="line">            localProvider = (ContentProvider)cl.</span><br><span class="line">                loadClass(info.name).newInstance();</span><br><span class="line">                </span><br><span class="line">            <span class="comment">//【×6.4.2】获得内部的 IContentProvider 对象，用于 Binder 通信；</span></span><br><span class="line">            <span class="comment">// 返回的是其内部的一个 Transport 实例！</span></span><br><span class="line">            provider = localProvider.getIContentProvider();</span><br><span class="line">            <span class="keyword">if</span> (provider == <span class="keyword">null</span>) &#123;</span><br><span class="line">                Slog.e(TAG, <span class="string">"Failed to instantiate class "</span> +</span><br><span class="line">                      info.name + <span class="string">" from sourceDir "</span> +</span><br><span class="line">                      info.applicationInfo.sourceDir);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_PROVIDER) Slog.v(</span><br><span class="line">                TAG, <span class="string">"Instantiating local provider "</span> + info.name);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【*6.4.3】设置 Context，解析保存 providerInfo 中的信息！</span></span><br><span class="line">            localProvider.attachInfo(c, info);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (java.lang.Exception e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mInstrumentation.onException(<span class="keyword">null</span>, e)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                        <span class="string">"Unable to get provider "</span> + info.name</span><br><span class="line">                        + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//【1.2】如果 if 条件不满足，说明进程不需要创建本地 provider 而是需要获得远程的 provider 连接对象！</span></span><br><span class="line">        <span class="comment">// holder.provider 就是 6.4.2.1 的 Transport 实例，后面我们再看！！</span></span><br><span class="line">        provider = holder.provider;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_PROVIDER) Slog.v(TAG, <span class="string">"Installing external provider "</span> + info.authority + <span class="string">": "</span></span><br><span class="line">                + info.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    IActivityManager.ContentProviderHolder retHolder;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mProviderMap) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_PROVIDER) Slog.v(TAG, <span class="string">"Checking to add "</span> + provider</span><br><span class="line">                + <span class="string">" / "</span> + info.name);</span><br><span class="line">        <span class="comment">//【2】获得 provider 的 Transport 对象！</span></span><br><span class="line">        IBinder jBinder = provider.asBinder();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【3】如果进程需要创建自己的 local provider（比如 multi process 情况下），</span></span><br><span class="line">        <span class="comment">// 那么此时 localProvider 不为 null！</span></span><br><span class="line">        <span class="keyword">if</span> (localProvider != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//【3.1】创建对应的 ComponentName！</span></span><br><span class="line">            ComponentName cname = <span class="keyword">new</span> ComponentName(info.packageName, info.name);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【3.2】判断当前进程中是否已经有该 provider 对应的 ProviderClientRecord，当然，</span></span><br><span class="line">            <span class="comment">// 如果是第一次创建，是不会有的；</span></span><br><span class="line">            ProviderClientRecord pr = mLocalProvidersByName.get(cname);</span><br><span class="line">            <span class="keyword">if</span> (pr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_PROVIDER) &#123;</span><br><span class="line">                    Slog.v(TAG, <span class="string">"installProvider: lost the race, "</span></span><br><span class="line">                            + <span class="string">"using existing local provider"</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//【3.2.1】获得其 Transport 实例</span></span><br><span class="line">                provider = pr.mProvider;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//【*6.4.4】如果本地还未创建，那就创建 ContentProviderHolder 对象！</span></span><br><span class="line">                <span class="comment">// 并设置 holder.provider！！</span></span><br><span class="line">                holder = <span class="keyword">new</span> IActivityManager.ContentProviderHolder(info);</span><br><span class="line">                holder.provider = provider;</span><br><span class="line">                holder.noReleaseNeeded = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//【*6.4.5】处理 authority 返回一个 ProviderClientRecord 对象！</span></span><br><span class="line">                pr = installProviderAuthoritiesLocked(provider, localProvider, holder);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//【3.3】将应用关系保存到进程内部的指定集合中！</span></span><br><span class="line">                mLocalProviders.put(jBinder, pr);</span><br><span class="line">                mLocalProvidersByName.put(cname, pr);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【2.4】将创建的 Holder 保存到 retHolder 中；</span></span><br><span class="line">            retHolder = pr.mHolder;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//【4】如果进程不需要创建自己的 local provider，而是需要访问远程的 provider，</span></span><br><span class="line">            <span class="comment">// 那么我们需要和远程的 provider，建立引用关系！</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//【4.1】尝试根据 provider 的 Transport 对象，获得其对应的引用计数对象！</span></span><br><span class="line">            ProviderRefCount prc = mProviderRefCountMap.get(jBinder);</span><br><span class="line">            <span class="keyword">if</span> (prc != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//【2.5.1】如果引用计数对象存在，那就增加引用计数！</span></span><br><span class="line">                <span class="keyword">if</span> (DEBUG_PROVIDER) &#123;</span><br><span class="line">                    Slog.v(TAG, <span class="string">"installProvider: lost the race, updating ref count"</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!noReleaseNeeded) &#123; <span class="comment">// 如果需要 release 的话，我们会增加引用，同时释放掉旧的引用；</span></span><br><span class="line">                    <span class="comment">//【1.3.6】增加引用计数！</span></span><br><span class="line">                    incProviderRefLocked(prc, stable);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//【×2.2】释放旧的引用！</span></span><br><span class="line">                        ActivityManagerNative.getDefault().removeContentProvider(</span><br><span class="line">                                holder.connection, stable);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//【2.5.2】如果引用计数对象为 null，那就会创建引用计数对象，这里会分为稳定引用和不稳定引用！</span></span><br><span class="line">                ProviderClientRecord client = installProviderAuthoritiesLocked(</span><br><span class="line">                        provider, localProvider, holder);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//【2.3.7】创建引用计数对象！</span></span><br><span class="line">                <span class="keyword">if</span> (noReleaseNeeded) &#123; <span class="comment">// 如果这个引用无需释放，那么会设置为 1000！</span></span><br><span class="line">                    prc = <span class="keyword">new</span> ProviderRefCount(holder, client, <span class="number">1000</span>, <span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    prc = stable</span><br><span class="line">                            ? <span class="keyword">new</span> ProviderRefCount(holder, client, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">                            : <span class="keyword">new</span> ProviderRefCount(holder, client, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将 Transport 和引用计数对象的映射关系保存到 mProviderRefCountMap 中！</span></span><br><span class="line">                mProviderRefCountMap.put(jBinder, prc);</span><br><span class="line">            &#125;</span><br><span class="line">            retHolder = prc.holder;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【3】返回创建的 Holder！</span></span><br><span class="line">    <span class="keyword">return</span> retHolder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在 ActivityThread 中有如下和 provider 相关的集合：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//【1】用于保存 Transport 和对其他进程中的 provider 的引用计数 ProviderRefCount 的映射关系！</span></span><br><span class="line"><span class="keyword">final</span> ArrayMap&lt;IBinder, ProviderRefCount&gt; mProviderRefCountMap</span><br><span class="line">                                            = <span class="keyword">new</span> ArrayMap&lt;IBinder, ProviderRefCount&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//【2】用于保存 Transport 和 ProviderClientRecord 的映射关系！</span></span><br><span class="line"><span class="keyword">final</span> ArrayMap&lt;IBinder, ProviderClientRecord&gt; mLocalProviders</span><br><span class="line">                                            = <span class="keyword">new</span> ArrayMap&lt;IBinder, ProviderClientRecord&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//【3】用于保存 provide ComponentName 和 ProviderClientRecord 的映射关系！</span></span><br><span class="line"><span class="keyword">final</span> ArrayMap&lt;ComponentName, ProviderClientRecord&gt; mLocalProvidersByName </span><br><span class="line">                                            = <span class="keyword">new</span> ArrayMap&lt;ComponentName, ProviderClientRecord&gt;();</span><br></pre></td></tr></table></figure>
<h3 id="6-4-1-new-ContentProvider"><a href="#6-4-1-new-ContentProvider" class="headerlink" title="6.4.1 new ContentProvider"></a>6.4.1 new ContentProvider</h3><p>创建 ContentProvider 实例，表示该进程中的 provider！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ContentProvider</span> <span class="keyword">implements</span> <span class="title">ComponentCallbacks2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"ContentProvider"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Context mContext = <span class="keyword">null</span>; <span class="comment">// provider 所在进程的上下文环境；</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mMyUid; <span class="comment">// 所在进程 uid</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String mAuthority;</span><br><span class="line">    <span class="keyword">private</span> String[] mAuthorities;</span><br><span class="line">    <span class="keyword">private</span> String mReadPermission; <span class="comment">// 读权限</span></span><br><span class="line">    <span class="keyword">private</span> String mWritePermission; <span class="comment">// 写权限</span></span><br><span class="line">    <span class="keyword">private</span> PathPermission[] mPathPermissions; <span class="comment">// path 权限</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mExported; <span class="comment">// 是否 export 属性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mNoPerms;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mSingleUser; <span class="comment">// 是否是 single user</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; mCallingPackage = <span class="keyword">new</span> ThreadLocal&lt;String&gt;(); <span class="comment">// 访问该 provider 的应用包名</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Transport mTransport = <span class="keyword">new</span> Transport(); <span class="comment">// 这个很重要，下面会分析！</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ContentProvider</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    ... ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里不多说！</p>
<h3 id="6-4-2-ContentProvider-getIContentProvider"><a href="#6-4-2-ContentProvider-getIContentProvider" class="headerlink" title="6.4.2 ContentProvider.getIContentProvider"></a>6.4.2 ContentProvider.getIContentProvider</h3><p>返回内部的一个 Transport 实例，该实例实现了 IContentProvider 接口！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IContentProvider <span class="title">getIContentProvider</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【*6.4.2.1】返回内部的 Transport 实例！</span></span><br><span class="line">    <span class="keyword">return</span> mTransport;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-4-2-1-new-Transport"><a href="#6-4-2-1-new-Transport" class="headerlink" title="6.4.2.1 new Transport"></a>6.4.2.1 new Transport</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Transport</span> <span class="keyword">extends</span> <span class="title">ContentProviderNative</span> </span>&#123;</span><br><span class="line">    AppOpsManager mAppOpsManager = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> mReadOp = AppOpsManager.OP_NONE;</span><br><span class="line">    <span class="keyword">int</span> mWriteOp = AppOpsManager.OP_NONE;</span><br><span class="line">    ... ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Transport 继承了 ContentProviderNative，其本质上是一个 Binder 对象，用于跨进程通信，作为 Binder 通信的服务端：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContentProviderNative</span> <span class="keyword">extends</span> <span class="title">Binder</span> <span class="keyword">implements</span> <span class="title">IContentProvider</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ContentProviderNative</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        attachInterface(<span class="keyword">this</span>, descriptor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">public</span> IContentProvider <span class="title">asInterface</span><span class="params">(IBinder obj)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        IContentProvider in =</span><br><span class="line">            (IContentProvider)obj.queryLocalInterface(descriptor);</span><br><span class="line">        <span class="keyword">if</span> (in != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> in;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ContentProviderProxy(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getProviderName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">        ... ... ... <span class="comment">// 省略这部分逻辑，后面再分析！</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">asBinder</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>; <span class="comment">// 返回的是自身！</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续来看！！</p>
<h3 id="6-4-3-ContentProvider-attachInfo-2-gt-3"><a href="#6-4-3-ContentProvider-attachInfo-2-gt-3" class="headerlink" title="6.4.3 ContentProvider.attachInfo[2]-&gt;[3]"></a>6.4.3 ContentProvider.attachInfo[2]-&gt;[3]</h3><p>attachInfo 方法的作用是，解析 provider 的属性！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attachInfo</span><span class="params">(Context context, ProviderInfo info)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】调用三参数方法！</span></span><br><span class="line">    attachInfo(context, info, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续分析：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">attachInfo</span><span class="params">(Context context, ProviderInfo info, <span class="keyword">boolean</span> testing)</span> </span>&#123;</span><br><span class="line">    mNoPerms = testing;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mContext == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//【1】将当前进程的 Context 保存到 mContext 中！</span></span><br><span class="line">        mContext = context;</span><br><span class="line">        <span class="keyword">if</span> (context != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//【2】初始化内部 Transport 的 appOps 属性！</span></span><br><span class="line">            mTransport.mAppOpsManager = (AppOpsManager) context.getSystemService(</span><br><span class="line">                    Context.APP_OPS_SERVICE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【3】初始化 uid</span></span><br><span class="line">        mMyUid = Process.myUid();</span><br><span class="line">        <span class="keyword">if</span> (info != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//【*6.4.3.1】解析 provider 的属性！</span></span><br><span class="line">            setReadPermission(info.readPermission);</span><br><span class="line">            setWritePermission(info.writePermission);</span><br><span class="line">            setPathPermissions(info.pathPermissions);</span><br><span class="line">            mExported = info.exported;</span><br><span class="line">            mSingleUser = (info.flags &amp; ProviderInfo.FLAG_SINGLE_USER) != <span class="number">0</span>;</span><br><span class="line">            setAuthorities(info.authority);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【*6.4.3.2】拉起 provider 的 onCreate 方法！</span></span><br><span class="line">        ContentProvider.<span class="keyword">this</span>.onCreate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="6-4-3-1-parse-attribute"><a href="#6-4-3-1-parse-attribute" class="headerlink" title="6.4.3.1 parse attribute"></a>6.4.3.1 parse attribute</h4><ul>
<li><strong>读/写权限</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setReadPermission</span><span class="params">(@Nullable String permission)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】读权限；</span></span><br><span class="line">    mReadPermission = permission;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setWritePermission</span><span class="params">(@Nullable String permission)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】写权限；</span></span><br><span class="line">    mWritePermission = permission;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>Path 权限</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setPathPermissions</span><span class="params">(@Nullable PathPermission[] permissions)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】path  权限；</span></span><br><span class="line">    mPathPermissions = permissions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>authority 权限</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setAuthorities</span><span class="params">(String authorities)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (authorities != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (authorities.indexOf(<span class="string">';'</span>) == -<span class="number">1</span>) &#123;</span><br><span class="line">            mAuthority = authorities;</span><br><span class="line">            mAuthorities = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mAuthority = <span class="keyword">null</span>;</span><br><span class="line">            mAuthorities = authorities.split(<span class="string">";"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>不多说了！</p>
<h4 id="6-4-3-2-ContentProvider-onCreate-生命周期方法-onCreate"><a href="#6-4-3-2-ContentProvider-onCreate-生命周期方法-onCreate" class="headerlink" title="6.4.3.2 ContentProvider.onCreate - 生命周期方法 onCreate"></a>6.4.3.2 ContentProvider.onCreate - 生命周期方法 onCreate</h4><p>拉起 provider 的 onCreate 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">onCreate</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>当然，这个方法是抽象方法，因为我们 ContentProvider 这个类本身就是抽喜类，我们要实现自己的 provider 实例！！</p>
<h3 id="6-4-4-new-ContentProviderHolder"><a href="#6-4-4-new-ContentProviderHolder" class="headerlink" title="6.4.4 new ContentProviderHolder"></a>6.4.4 new ContentProviderHolder</h3><p>创建 ContentProviderHolder 对象！！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ContentProviderHolder</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> ProviderInfo info; <span class="comment">// provider 数据对象！</span></span><br><span class="line">    <span class="keyword">public</span> IContentProvider provider; <span class="comment">// 就是 Transport 对象！</span></span><br><span class="line">    <span class="keyword">public</span> IBinder connection; <span class="comment">// provider 连接对象！</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> noReleaseNeeded;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ContentProviderHolder</span><span class="params">(ProviderInfo _info)</span> </span>&#123;</span><br><span class="line">        info = _info;</span><br><span class="line">    &#125;</span><br><span class="line">    ... ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到了 ContentProviderHolder 是实现了 Parcelable 接口，可以跨进程传输！！</p>
<p>不多说，继续看：</p>
<h3 id="6-4-5-installProviderAuthoritiesLocked"><a href="#6-4-5-installProviderAuthoritiesLocked" class="headerlink" title="6.4.5 installProviderAuthoritiesLocked"></a>6.4.5 installProviderAuthoritiesLocked</h3><p>处理 provider 的 authority 属性，同时创建 ProviderClientRecord 对象并返回：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ProviderClientRecord <span class="title">installProviderAuthoritiesLocked</span><span class="params">(IContentProvider provider,</span></span></span><br><span class="line"><span class="function"><span class="params">        ContentProvider localProvider, IActivityManager.ContentProviderHolder holder)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】获得 provider 的 authority 属性！</span></span><br><span class="line">    <span class="keyword">final</span> String auths[] = holder.info.authority.split(<span class="string">";"</span>);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> userId = UserHandle.getUserId(holder.info.applicationInfo.uid); <span class="comment">// 应用程序的目标 userId</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【*6.4.5.1】创建了 provider 对应的 ProviderClientRecord 对象！</span></span><br><span class="line">    <span class="keyword">final</span> ProviderClientRecord pcr = <span class="keyword">new</span> ProviderClientRecord(</span><br><span class="line">            auths, provider, localProvider, holder);</span><br><span class="line">            </span><br><span class="line">    <span class="comment">//【2】将该 provider 的 authority 和其 ProviderClientRecord 的映射关系，保存到</span></span><br><span class="line">    <span class="comment">// mProviderMap 中！</span></span><br><span class="line">    <span class="keyword">for</span> (String auth : auths) &#123;</span><br><span class="line">        <span class="comment">//【*6.4.5.2】创建 ProviderKey 对象！</span></span><br><span class="line">        <span class="keyword">final</span> ProviderKey key = <span class="keyword">new</span> ProviderKey(auth, userId);</span><br><span class="line">        <span class="keyword">final</span> ProviderClientRecord existing = mProviderMap.get(key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (existing != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//【2.1】已存在，就不会添加！</span></span><br><span class="line">            Slog.w(TAG, <span class="string">"Content provider "</span> + pcr.mHolder.info.name</span><br><span class="line">                    + <span class="string">" already published as "</span> + auth);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mProviderMap.put(key, pcr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【3】返回 ProviderClientRecord 实例！</span></span><br><span class="line">    <span class="keyword">return</span> pcr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 ActivityThread 中有一个 mProviderMap 哈希表：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//【1】保存该 authority 属性和其所属 provider 的 ProviderClientRecord 映射关系！</span></span><br><span class="line"><span class="keyword">final</span> ArrayMap&lt;ProviderKey, ProviderClientRecord&gt; mProviderMap</span><br><span class="line">    = <span class="keyword">new</span> ArrayMap&lt;ProviderKey, ProviderClientRecord&gt;();</span><br></pre></td></tr></table></figure></p>
<p>继续看！</p>
<h4 id="6-4-5-1-new-ProviderClientRecord"><a href="#6-4-5-1-new-ProviderClientRecord" class="headerlink" title="6.4.5.1 new ProviderClientRecord"></a>6.4.5.1 new ProviderClientRecord</h4><p>创建 ProviderClientRecord 实例！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderClientRecord</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String[] mNames; <span class="comment">// authority 属性！</span></span><br><span class="line">    <span class="keyword">final</span> IContentProvider mProvider; <span class="comment">// Transport 对象；</span></span><br><span class="line">    <span class="keyword">final</span> ContentProvider mLocalProvider; <span class="comment">// ContentProvider 实例；</span></span><br><span class="line">    <span class="keyword">final</span> IActivityManager.ContentProviderHolder mHolder; <span class="comment">// Holder 对象；</span></span><br><span class="line"></span><br><span class="line">    ProviderClientRecord(String[] names, IContentProvider provider,</span><br><span class="line">            ContentProvider localProvider,</span><br><span class="line">            IActivityManager.ContentProviderHolder holder) &#123;</span><br><span class="line">        mNames = names;</span><br><span class="line">        mProvider = provider;</span><br><span class="line">        mLocalProvider = localProvider;</span><br><span class="line">        mHolder = holder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不多说！！</p>
<h4 id="6-4-5-2-new-ProviderKey"><a href="#6-4-5-2-new-ProviderKey" class="headerlink" title="6.4.5.2 new ProviderKey"></a>6.4.5.2 new ProviderKey</h4><p>创建 authority 属性对应的 ProviderKey 实例！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderKey</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String authority; <span class="comment">// authority 属性</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> userId;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProviderKey</span><span class="params">(String authority, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.authority = authority;</span><br><span class="line">        <span class="keyword">this</span>.userId = userId;</span><br><span class="line">    &#125;</span><br><span class="line">    ... ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不多说！</p>
<h3 id="6-4-6-incProviderRefLocked"><a href="#6-4-6-incProviderRefLocked" class="headerlink" title="6.4.6 incProviderRefLocked"></a>6.4.6 incProviderRefLocked</h3><p>增加 provider 的引用计数， 参数 boolean stable 表示的是稳定引用，还是非稳定引用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">incProviderRefLocked</span><span class="params">(ProviderRefCount prc, <span class="keyword">boolean</span> stable)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】stable 引用进入这里！</span></span><br><span class="line">    <span class="keyword">if</span> (stable) &#123;</span><br><span class="line">        prc.stableCount += <span class="number">1</span>; <span class="comment">// 增加客户端引用计数</span></span><br><span class="line">        <span class="keyword">if</span> (prc.stableCount == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> unstableDelta;</span><br><span class="line">            <span class="keyword">if</span> (prc.removePending) &#123; <span class="comment">// 如果此时我们正在移除 provider，那就取消移除！</span></span><br><span class="line">                unstableDelta = -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_PROVIDER) &#123;</span><br><span class="line">                    Slog.v(TAG, <span class="string">"incProviderRef: stable "</span></span><br><span class="line">                            + <span class="string">"snatched provider from the jaws of death"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                prc.removePending = <span class="keyword">false</span>;</span><br><span class="line">                mH.removeMessages(H.REMOVE_PROVIDER, prc);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                unstableDelta = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_PROVIDER) &#123;</span><br><span class="line">                    Slog.v(TAG, <span class="string">"incProviderRef Now stable - "</span></span><br><span class="line">                            + prc.holder.info.name + <span class="string">": unstableDelta="</span></span><br><span class="line">                            + unstableDelta);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//【*7.3】增加系统进程中 provider 的引用计数！</span></span><br><span class="line">                ActivityManagerNative.getDefault().refContentProvider(</span><br><span class="line">                        prc.holder.connection, <span class="number">1</span>, unstableDelta);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//【2】no stable 引用进入这里；</span></span><br><span class="line">        prc.unstableCount += <span class="number">1</span>; <span class="comment">// 增加客户端引用计数</span></span><br><span class="line">        <span class="keyword">if</span> (prc.unstableCount == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prc.removePending) &#123; <span class="comment">// 如果此时我们正在移除 provider，那就取消移除！</span></span><br><span class="line">                <span class="keyword">if</span> (DEBUG_PROVIDER) &#123;</span><br><span class="line">                    Slog.v(TAG, <span class="string">"incProviderRef: unstable "</span></span><br><span class="line">                            + <span class="string">"snatched provider from the jaws of death"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                prc.removePending = <span class="keyword">false</span>;</span><br><span class="line">                mH.removeMessages(H.REMOVE_PROVIDER, prc);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG_PROVIDER) &#123;</span><br><span class="line">                        Slog.v(TAG, <span class="string">"incProviderRef: Now unstable - "</span></span><br><span class="line">                                + prc.holder.info.name);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//【*7.3】增加系统进程中 provider 的引用计数！</span></span><br><span class="line">                    ActivityManagerNative.getDefault().refContentProvider(</span><br><span class="line">                            prc.holder.connection, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，如果是第一次引用，那么会做一些额外的处理！</p>
<h3 id="6-4-7-new-ProviderRefCount"><a href="#6-4-7-new-ProviderRefCount" class="headerlink" title="6.4.7 new ProviderRefCount"></a>6.4.7 new ProviderRefCount</h3><p>创建一个 provider 的引用计数对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderRefCount</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> IActivityManager.ContentProviderHolder holder;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> ProviderClientRecord client;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> stableCount;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> unstableCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果为 true，那么 stable 和 unstable 的引用计数都为 0，同时 ams 准备移除引用计数</span></span><br><span class="line">    <span class="comment">// 但是在 ams 中依然持有一个 unstable 的引用！</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> removePending;</span><br><span class="line"></span><br><span class="line">    ProviderRefCount(IActivityManager.ContentProviderHolder inHolder,</span><br><span class="line">            ProviderClientRecord inClient, <span class="keyword">int</span> sCount, <span class="keyword">int</span> uCount) &#123;</span><br><span class="line">        holder = inHolder;</span><br><span class="line">        client = inClient;</span><br><span class="line">        stableCount = sCount;</span><br><span class="line">        unstableCount = uCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先看到这里！</p>
<h1 id="7-ActivityManagerService-系统进程2"><a href="#7-ActivityManagerService-系统进程2" class="headerlink" title="7 ActivityManagerService - 系统进程2"></a>7 ActivityManagerService - 系统进程2</h1><p>这里我们又从 provider 进程进入了系统进程！</p>
<h2 id="7-1-publishContentProviders"><a href="#7-1-publishContentProviders" class="headerlink" title="7.1 publishContentProviders"></a>7.1 publishContentProviders</h2><p>publishContentProviders 用于将 provider publish 到系统中！</p>
<p>首先来看下 ActivityManagerNative 中的代码，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> PUBLISH_CONTENT_PROVIDERS_TRANSACTION: &#123;</span><br><span class="line">    data.enforceInterface(IActivityManager.descriptor);</span><br><span class="line">    IBinder b = data.readStrongBinder();</span><br><span class="line">    <span class="comment">//【1】获得 provider 所在的进程的 ApplicationThreadProxy</span></span><br><span class="line">    IApplicationThread app = ApplicationThreadNative.asInterface(b);</span><br><span class="line">    <span class="comment">//【2】这里是从 provider 的 Holder 对象！</span></span><br><span class="line">    ArrayList&lt;ContentProviderHolder&gt; providers =</span><br><span class="line">        data.createTypedArrayList(ContentProviderHolder.CREATOR);</span><br><span class="line">    <span class="comment">//【3】调用 ams 的 publishContentProviders 方法！</span></span><br><span class="line">    publishContentProviders(app, providers);</span><br><span class="line">    reply.writeNoException();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着，进入了 ActivityManagerService 中：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">publishContentProviders</span><span class="params">(IApplicationThread caller,</span></span></span><br><span class="line"><span class="function"><span class="params">        List&lt;ContentProviderHolder&gt; providers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (providers == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    enforceNotIsolatedCaller(<span class="string">"publishContentProviders"</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">//【1】获得 provider 所在的进程 ProcessRecord！</span></span><br><span class="line">        <span class="keyword">final</span> ProcessRecord r = getRecordForAppLocked(caller);</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_MU) Slog.v(TAG_MU, <span class="string">"ProcessRecord uid = "</span> + r.uid);</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(</span><br><span class="line">                    <span class="string">"Unable to find app for caller "</span> + caller</span><br><span class="line">                  + <span class="string">" (pid="</span> + Binder.getCallingPid()</span><br><span class="line">                  + <span class="string">") when publishing content providers"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> N = providers.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            ContentProviderHolder src = providers.get(i);</span><br><span class="line">            <span class="keyword">if</span> (src == <span class="keyword">null</span> || src.info == <span class="keyword">null</span> || src.provider == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//【2】我们知道 provider 对应的 ContentProviderRecord 在前面就已经添加到 r.pubProviders 中了！</span></span><br><span class="line">            ContentProviderRecord dst = r.pubProviders.get(src.info.name);</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_MU) Slog.v(TAG_MU, <span class="string">"ContentProviderRecord uid = "</span> + dst.uid);</span><br><span class="line">            <span class="keyword">if</span> (dst != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//【2.1】将 ContentProviderRecord 实例添加到 ProviderMap 中！</span></span><br><span class="line">                ComponentName comp = <span class="keyword">new</span> ComponentName(dst.info.packageName, dst.info.name);</span><br><span class="line">                mProviderMap.putProviderByClass(comp, dst);</span><br><span class="line">                String names[] = dst.info.authority.split(<span class="string">";"</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; names.length; j++) &#123;</span><br><span class="line">                    mProviderMap.putProviderByName(names[j], dst);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> launchingCount = mLaunchingProviders.size();</span><br><span class="line">                <span class="keyword">int</span> j;</span><br><span class="line">                <span class="comment">//【2.2】判断其是否在 mLaunchingProviders 中，如果有，那就从中移除！</span></span><br><span class="line">                <span class="keyword">boolean</span> wasInLaunchingProviders = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; launchingCount; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mLaunchingProviders.get(j) == dst) &#123;</span><br><span class="line">                        mLaunchingProviders.remove(j);</span><br><span class="line">                        wasInLaunchingProviders = <span class="keyword">true</span>;</span><br><span class="line">                        j--;</span><br><span class="line">                        launchingCount--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//【2.3】移除 provider publish 超时消息！</span></span><br><span class="line">                <span class="keyword">if</span> (wasInLaunchingProviders) &#123;</span><br><span class="line">                    mHandler.removeMessages(CONTENT_PROVIDER_PUBLISH_TIMEOUT_MSG, r);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (dst) &#123;</span><br><span class="line">                    <span class="comment">//【2.4】更新 ContentProviderRecord 中的属性，包括 dst.provider 等等！</span></span><br><span class="line">                    dst.provider = src.provider;</span><br><span class="line">                    dst.proc = r;</span><br><span class="line">                    <span class="comment">//【important】这里调用了 Object.notifyAll 方法，唤醒在等待队列中等待的 Binder 线程</span></span><br><span class="line">                    <span class="comment">// 这里就回到了 5.1 getContentProvider[Impl] 方法中了！</span></span><br><span class="line">                    dst.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 更新进程的优先级！</span></span><br><span class="line">                updateOomAdjLocked(r);</span><br><span class="line">                <span class="comment">// 更新进程的使用情况！</span></span><br><span class="line">                maybeUpdateProviderUsageStatsLocked(r, src.info.packageName,</span><br><span class="line">                        src.info.authority);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不多说了！</p>
<h2 id="7-2-removeContentProvider"><a href="#7-2-removeContentProvider" class="headerlink" title="7.2 removeContentProvider"></a>7.2 removeContentProvider</h2><p>减少系统进程中的 provider 的引用计数！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> REMOVE_CONTENT_PROVIDER_TRANSACTION: &#123;</span><br><span class="line">    data.enforceInterface(IActivityManager.descriptor);</span><br><span class="line">    IBinder b = data.readStrongBinder();</span><br><span class="line">    <span class="keyword">boolean</span> stable = data.readInt() != <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//【1】调用了 removeContentProvider 方法！</span></span><br><span class="line">    removeContentProvider(b, stable);</span><br><span class="line">    reply.writeNoException();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续来看：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeContentProvider</span><span class="params">(IBinder connection, <span class="keyword">boolean</span> stable)</span> </span>&#123;</span><br><span class="line">    enforceNotIsolatedCaller(<span class="string">"removeContentProvider"</span>);</span><br><span class="line">    <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            ContentProviderConnection conn;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//【1】获得 ContentProviderConnection 连接对象！</span></span><br><span class="line">                conn = (ContentProviderConnection)connection;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassCastException e) &#123;</span><br><span class="line">                String msg =<span class="string">"removeContentProvider: "</span> + connection</span><br><span class="line">                        + <span class="string">" not a ContentProviderConnection"</span>;</span><br><span class="line">                Slog.w(TAG, msg);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(msg);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (conn == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"connection is null"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//【×5.1.1.7】减少对 provider 的引用计数！</span></span><br><span class="line">            <span class="keyword">if</span> (decProviderCountLocked(conn, <span class="keyword">null</span>, <span class="keyword">null</span>, stable)) &#123;</span><br><span class="line">                updateOomAdjLocked(); <span class="comment">// 调整进程优先级！</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Binder.restoreCallingIdentity(ident);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里就不多说了！</p>
<h2 id="7-3-refContentProvider"><a href="#7-3-refContentProvider" class="headerlink" title="7.3 refContentProvider"></a>7.3 refContentProvider</h2><p>增加系统进程中的 provider 的引用计数！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">refContentProvider</span><span class="params">(IBinder connection, <span class="keyword">int</span> stable, <span class="keyword">int</span> unstable)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    Parcel data = Parcel.obtain();</span><br><span class="line">    Parcel reply = Parcel.obtain();</span><br><span class="line">    data.writeInterfaceToken(IActivityManager.descriptor);</span><br><span class="line">    data.writeStrongBinder(connection);</span><br><span class="line">    data.writeInt(stable);</span><br><span class="line">    data.writeInt(unstable);</span><br><span class="line">    mRemote.transact(REF_CONTENT_PROVIDER_TRANSACTION, data, reply, <span class="number">0</span>);</span><br><span class="line">    reply.readException();</span><br><span class="line">    <span class="keyword">boolean</span> res = reply.readInt() != <span class="number">0</span>;</span><br><span class="line">    data.recycle();</span><br><span class="line">    reply.recycle();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续来看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">refContentProvider</span><span class="params">(IBinder connection, <span class="keyword">int</span> stable, <span class="keyword">int</span> unstable)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】获得 ContentProviderConnection 连接对象！</span></span><br><span class="line">    ContentProviderConnection conn;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        conn = (ContentProviderConnection)connection;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassCastException e) &#123;</span><br><span class="line">        String msg =<span class="string">"refContentProvider: "</span> + connection</span><br><span class="line">                + <span class="string">" not a ContentProviderConnection"</span>;</span><br><span class="line">        Slog.w(TAG, msg);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (conn == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"connection is null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (stable &gt; <span class="number">0</span>) &#123; <span class="comment">// 统计总的引用数，debug 用不关注！</span></span><br><span class="line">            conn.numStableIncs += stable;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【2】调整 stable connect 计数！</span></span><br><span class="line">        stable = conn.stableCount + stable;</span><br><span class="line">        <span class="keyword">if</span> (stable &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"stableCount &lt; 0: "</span> + stable);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (unstable &gt; <span class="number">0</span>) &#123; <span class="comment">// 统计总的引用数，debug 用不关注！</span></span><br><span class="line">            conn.numUnstableIncs += unstable;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【3】调整 unstable connect 计数！</span></span><br><span class="line">        unstable = conn.unstableCount + unstable;</span><br><span class="line">        <span class="keyword">if</span> (unstable &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"unstableCount &lt; 0: "</span> + unstable);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((stable+unstable) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"ref counts can't go to zero here: stable="</span></span><br><span class="line">                    + stable + <span class="string">" unstable="</span> + unstable);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【4】更新 ContentProviderConnection 中的引用计数！</span></span><br><span class="line">        conn.stableCount = stable;</span><br><span class="line">        conn.unstableCount = unstable;</span><br><span class="line">        <span class="keyword">return</span> !conn.dead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不多说了！</p>
<h2 id="7-4-unstableProviderDied"><a href="#7-4-unstableProviderDied" class="headerlink" title="7.4 unstableProviderDied"></a>7.4 unstableProviderDied</h2><p>处理 unstable provider 进程的死亡后事：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unstableProviderDied</span><span class="params">(IBinder connection)</span> </span>&#123;</span><br><span class="line">    ContentProviderConnection conn;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//【1】获得引用的连接对象！</span></span><br><span class="line">        conn = (ContentProviderConnection)connection;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassCastException e) &#123;</span><br><span class="line">        String msg =<span class="string">"refContentProvider: "</span> + connection</span><br><span class="line">                + <span class="string">" not a ContentProviderConnection"</span>;</span><br><span class="line">        Slog.w(TAG, msg);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (conn == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"connection is null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】获得该 conn 对象绑定着的 provider，这里是返回 provider 内部的 Transport 实例！</span></span><br><span class="line">    IContentProvider provider;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        provider = conn.provider.provider;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (provider == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【3】判读客户端的连接是否仍然存在，如果是，那就直接返回！</span></span><br><span class="line">    <span class="keyword">if</span> (provider.asBinder().pingBinder()) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"unstableProviderDied: caller "</span> + Binder.getCallingUid()</span><br><span class="line">                    + <span class="string">" says "</span> + conn + <span class="string">" died, but we don't agree"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【4】从处理进程死亡的后事！</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">//【4.1】发生了神奇的变化，返回！</span></span><br><span class="line">        <span class="keyword">if</span> (conn.provider.provider != provider) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【4.2】如果进程已经被清理了，那就返回！</span></span><br><span class="line">        ProcessRecord proc = conn.provider.proc;</span><br><span class="line">        <span class="keyword">if</span> (proc == <span class="keyword">null</span> || proc.thread == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Slog.i(TAG, <span class="string">"Process "</span> + proc.processName + <span class="string">" (pid "</span> + proc.pid</span><br><span class="line">                + <span class="string">") early provider death"</span>);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//【4.3】处理进程的死亡后事！</span></span><br><span class="line">            appDiedLocked(proc);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Binder.restoreCallingIdentity(ident);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不多说了！</p>
<h1 id="8-总结"><a href="#8-总结" class="headerlink" title="8 总结"></a>8 总结</h1><p>我们来看下 provider 相关的类图：</p>
<p><img src="http://static.zybuluo.com/Coolqi/bbpfu2ji0g1badsutpkh0m1m/ContentProvider-N.png" alt="ContentProvider-N.png-486.9kB"></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Coolqi.Li</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lishuaiqi.top/2018/04/13/ContentProvider2-contentProviderStartProcess/">https://lishuaiqi.top/2018/04/13/ContentProvider2-contentProviderStartProcess/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lishuaiqi.top">Coolqi`s Blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/ContentProvider内容提供者/">ContentProvider内容提供者</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="/img/zfb.jpg"><div class="post-qr-code__desc">支付宝打赏</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="/img/wechat.jpg"><div class="post-qr-code__desc">微信打赏</div></div></div><div class="social-share pull-right"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2018/04/13/Javabase-1-SPI/"><i class="fa fa-chevron-left">  </i><span>Java 基础 - SPI 机制原理分析</span></a></div><div class="next-post pull-right"><a href="/2018/03/03/PMS5-PMS_SCAN_END/"><span>PMS 第 5 篇 - PMS_SCAN_END 阶段</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitment-container"></div><script>var gitment = new Gitment({
  id: md5(decodeURI(location.pathname)),
  owner: '',
  repo: '',
  oauth: {
    client_id: '7b4efbcd7027d15749d6',
    client_secret: '14b5d7e8580ee29f7aeca733a25c000795967448'
  }
})
gitment.render('gitment-container')</script></div></div><footer class="footer-bg" style="background-image: url(/img/blog-bg.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2015 - 2020 By Coolqi.Li</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://lishuaiqi.top/">blog</a>!</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>