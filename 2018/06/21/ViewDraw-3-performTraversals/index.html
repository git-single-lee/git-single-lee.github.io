<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="ViewDraw 第三篇 performTraversals 流程分析"><meta name="keywords" content="ViewDraw"><meta name="author" content="Coolqi.Li"><meta name="copyright" content="Coolqi.Li"><title>ViewDraw 第三篇 performTraversals 流程分析 | Coolqi`s Blog</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://unpkg.com"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitment/style/default.min.css"><script src="https://cdn.jsdelivr.net/npm/gitment/dist/gitment.browser.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?b7acef5306e54116ad8a99e8b753a92d";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-回顾"><span class="toc-text">1 回顾</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-TraversalRunnable-run"><span class="toc-text">1.1 TraversalRunnable.run</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-doTraversal"><span class="toc-text">1.2 doTraversal</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-ViewRootImpl"><span class="toc-text">2 ViewRootImpl</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-performTraversals-核心"><span class="toc-text">2.1 performTraversals - 核心</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-getHostVisibility"><span class="toc-text">2.1.1 getHostVisibility</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-shouldUseDisplaySize"><span class="toc-text">2.1.2 shouldUseDisplaySize</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-3-dispatchApplyInsets"><span class="toc-text">2.1.3 dispatchApplyInsets</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-4-ensureTouchModeLocally"><span class="toc-text">2.1.4 ensureTouchModeLocally</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-5-maybeHandleWindowMove"><span class="toc-text">2.1.5 maybeHandleWindowMove</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-measureHierarchy-预测量"><span class="toc-text">2.2 measureHierarchy - 预测量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-getRootMeasureSpec"><span class="toc-text">2.2.1 getRootMeasureSpec</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-relayoutWindow-通过-wms-计算窗口大小"><span class="toc-text">2.3 relayoutWindow - 通过 wms 计算窗口大小</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-performMeasure-测量"><span class="toc-text">2.4 performMeasure - 测量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-performLayout-布局"><span class="toc-text">2.5 performLayout - 布局</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-1-getValidLayoutRequesters"><span class="toc-text">2.5.1 getValidLayoutRequesters</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-performDraw-绘制"><span class="toc-text">2.6 performDraw - 绘制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-1-draw"><span class="toc-text">2.6.1 draw</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-2-drawSoftware-软件绘制"><span class="toc-text">2.6.2 drawSoftware - 软件绘制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-mid-DecorView"><span class="toc-text">2-mid DecorView</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-mid-onAttachedToWindow"><span class="toc-text">2.1-mid onAttachedToWindow</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-ViewGroup"><span class="toc-text">3 ViewGroup</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-dispatchAttachedToWindow-核心（设置-attrachInfo）"><span class="toc-text">3.1 dispatchAttachedToWindow - 核心（设置 attrachInfo）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-dispatchWindowVisibilityChanged"><span class="toc-text">3.2 dispatchWindowVisibilityChanged</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-dispatchVisibilityAggregated"><span class="toc-text">3.3 dispatchVisibilityAggregated</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-View"><span class="toc-text">4 View</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-dispatchAttachedToWindow-核心（设置-attrachInfo）"><span class="toc-text">4.1 dispatchAttachedToWindow - 核心（设置 attrachInfo）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-1-registerPendingFrameMetricsObservers"><span class="toc-text">4.1.1 registerPendingFrameMetricsObservers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-2-performCollectViewAttributes"><span class="toc-text">4.1.2 performCollectViewAttributes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-3-onAttachedToWindow"><span class="toc-text">4.1.3 onAttachedToWindow</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-4-onWindowVisibilityChanged"><span class="toc-text">4.1.4 onWindowVisibilityChanged</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-5-isShown"><span class="toc-text">4.1.5 isShown</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-5-onVisibilityAggregated"><span class="toc-text">4.1.5 onVisibilityAggregated</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-dispatchWindowVisibilityChanged"><span class="toc-text">4.2 dispatchWindowVisibilityChanged</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-dispatchVisibilityAggregated"><span class="toc-text">4.3 dispatchVisibilityAggregated</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-MeasureSpec-测量规格"><span class="toc-text">4.4 MeasureSpec - 测量规格</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-1-测量模式"><span class="toc-text">4.4.1 测量模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-2-makeMeasureSpec"><span class="toc-text">4.4.2 makeMeasureSpec</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-ViewTreeObserver-视图树的观察者"><span class="toc-text">5 ViewTreeObserver - 视图树的观察者</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-merge"><span class="toc-text">5.1 merge</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-dispatchOnWindowAttachedChange"><span class="toc-text">5.2 dispatchOnWindowAttachedChange</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-dispatchOnTouchModeChanged"><span class="toc-text">5.3 dispatchOnTouchModeChanged</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-dispatchOnGlobalLayout"><span class="toc-text">5.4 dispatchOnGlobalLayout</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-dispatchOnComputeInternalInsets"><span class="toc-text">5.5 dispatchOnComputeInternalInsets</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-6-dispatchOnPreDraw"><span class="toc-text">5.6 dispatchOnPreDraw</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-Surface-相关"><span class="toc-text">6 Surface 相关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-Surface"><span class="toc-text">6.1 Surface</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-1-new-Surface"><span class="toc-text">6.1.1 new Surface</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-2-getGenerationId"><span class="toc-text">6.1.2 getGenerationId</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-3-readFromParcel"><span class="toc-text">6.1.3 readFromParcel</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-总结"><span class="toc-text">7 总结</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#遗留汇总"><span class="toc-text">遗留汇总</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#View-相关"><span class="toc-text">View 相关</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Window-相关"><span class="toc-text">Window 相关</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Surface-相关"><span class="toc-text">Surface 相关</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.jpg"></div><div class="author-info__name text-center">Coolqi.Li</div><div class="author-info__description text-center">“Hi，我是李帅奇，Android 开发工程师，熬夜星人，一个努力赚钱，积极向上的好人。微信公众号：CoolOriLans (酷奇源语)”</div><div class="follow-button"><a href="https://github.com/single-li">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">90</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">23</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">29</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">coolqi 和他的朋友们</div><a class="author-info-links__name text-center" href="https://developer.android.google.cn/">AndroidDeveloper</a><a class="author-info-links__name text-center" href="http://www.android-studio.org/">AndroidStudio</a><a class="author-info-links__name text-center" href="https://www.jianshu.com/u/123a20a96441">个人简书</a><a class="author-info-links__name text-center" href="https://weibo.com/coolqiLi">个人微博</a><a class="author-info-links__name text-center" href="https://www.jianshu.com/u/fd0b722ce11f">小二哥的 Android 站</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/img/blog-bg.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Coolqi`s Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/about">About</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">ViewDraw 第三篇 performTraversals 流程分析</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-06-21</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/View-视图/">View 视图</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/View-视图/View-的加载和绘制/">View 的加载和绘制</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">14.5k</span><span class="post-meta__separator">|</span><span>阅读时长: 65 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>篇文章基于 Android N - 7.1.1 主要分析下 performTraversals 方法的执行流程；</p>
<h1 id="1-回顾"><a href="#1-回顾" class="headerlink" title="1 回顾"></a>1 回顾</h1><p>我们来回顾下，当请求到 Vsync 信号后就会触发 callback：</p>
<h2 id="1-1-TraversalRunnable-run"><a href="#1-1-TraversalRunnable-run" class="headerlink" title="1.1 TraversalRunnable.run"></a>1.1 TraversalRunnable.run</h2><p>TraversalRunnable 只是一个 runnable，其内部会调用另外一个方法：<strong>doTraversal()</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TraversalRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//【--&gt;1.2】开始遍历；</span></span><br><span class="line">        doTraversal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> TraversalRunnable mTraversalRunnable = <span class="keyword">new</span> TraversalRunnable();</span><br></pre></td></tr></table></figure>
<h2 id="1-2-doTraversal"><a href="#1-2-doTraversal" class="headerlink" title="1.2 doTraversal"></a>1.2 doTraversal</h2><p>开始遍历了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doTraversal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mTraversalScheduled) &#123;</span><br><span class="line">        <span class="comment">//【1】要设置为 false，否则下一次重绘制没法触发；</span></span><br><span class="line">        mTraversalScheduled = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//【2】移出障栅；</span></span><br><span class="line">        mHandler.getLooper().getQueue().removeSyncBarrier(mTraversalBarrier);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mProfile) &#123;</span><br><span class="line">            Debug.startMethodTracing(<span class="string">"ViewAncestor"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【--&gt;2.1】执行视图遍历；</span></span><br><span class="line">        performTraversals();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mProfile) &#123;</span><br><span class="line">            Debug.stopMethodTracing();</span><br><span class="line">            mProfile = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到，最后调用了 performTraversals 方法！！</p>
<h1 id="2-ViewRootImpl"><a href="#2-ViewRootImpl" class="headerlink" title="2 ViewRootImpl"></a>2 ViewRootImpl</h1><h2 id="2-1-performTraversals-核心"><a href="#2-1-performTraversals-核心" class="headerlink" title="2.1 performTraversals - 核心"></a>2.1 performTraversals - 核心</h2><p>执行视图遍历，这个方法很长很长：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】讲 DecorView 保存到 host 中；</span></span><br><span class="line">    <span class="keyword">final</span> View host = mView;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DBG) &#123;</span><br><span class="line">        System.out.println(<span class="string">"======================================"</span>);</span><br><span class="line">        System.out.println(<span class="string">"performTraversals"</span>);</span><br><span class="line">        host.debug();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (host == <span class="keyword">null</span> || !mAdded)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//【2】均设置为 true，正在遍历/即将绘制；</span></span><br><span class="line">    mIsInTraversal = <span class="keyword">true</span>;</span><br><span class="line">    mWillDrawSoon = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">boolean</span> windowSizeMayChange = <span class="keyword">false</span>; <span class="comment">// 视图的大小可能改变</span></span><br><span class="line">    <span class="keyword">boolean</span> newSurface = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> surfaceChanged = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【3】获得布局参数；</span></span><br><span class="line">    WindowManager.LayoutParams lp = mWindowAttributes;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【4】DecorView 所需要的宽度和高度；</span></span><br><span class="line">    <span class="keyword">int</span> desiredWindowWidth;</span><br><span class="line">    <span class="keyword">int</span> desiredWindowHeight;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【--&gt;2.1.1】获取 Decorview 的可见性，默认为 true；</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> viewVisibility = getHostVisibility();</span><br><span class="line">    <span class="comment">//【5】判断 Decorview 可见性是否变化：不是第一次加载 &amp;&amp; （可见性和之前不一样 || 需要新的 surface）</span></span><br><span class="line">    <span class="comment">// 当然第一次加载 mFirst 为 true，所以为 false；</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> viewVisibilityChanged = !mFirst</span><br><span class="line">        &amp;&amp; (mViewVisibility != viewVisibility || mNewSurfaceNeeded);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【6】判断 Decorview 用户可感知的可见性是否变化：这是的用户可见性指的是能感知到的变化</span></span><br><span class="line">    <span class="comment">// 上面的变化还包括 Surface 的变化，整个用户不一定能感知的到；</span></span><br><span class="line">    <span class="comment">// 当然第一次加载 mFirst 为 true；所以为 false</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> viewUserVisibilityChanged = !mFirst &amp;&amp;</span><br><span class="line">        ((mViewVisibility == View.VISIBLE) != (viewVisibility == View.VISIBLE));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【7】对布局参数再做一次调整；</span></span><br><span class="line">    WindowManager.LayoutParams params = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (mWindowAttributesChanged) &#123;</span><br><span class="line">        mWindowAttributesChanged = <span class="keyword">false</span>;</span><br><span class="line">        surfaceChanged = <span class="keyword">true</span>;</span><br><span class="line">        params = lp;</span><br><span class="line">    &#125;</span><br><span class="line">    CompatibilityInfo compatibilityInfo =</span><br><span class="line">        mDisplay.getDisplayAdjustments().getCompatibilityInfo();</span><br><span class="line">    <span class="keyword">if</span> (compatibilityInfo.supportsScreen() == mLastInCompatMode) &#123;</span><br><span class="line">        params = lp;</span><br><span class="line">        mFullRedrawNeeded = <span class="keyword">true</span>;</span><br><span class="line">        mLayoutRequested = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (mLastInCompatMode) &#123;</span><br><span class="line">            params.privateFlags &amp;= ~WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;</span><br><span class="line">            mLastInCompatMode = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            params.privateFlags |= WindowManager.LayoutParams.PRIVATE_FLAG_COMPATIBLE_WINDOW;</span><br><span class="line">            mLastInCompatMode = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mWindowAttributesChangesFlag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【8】用来保存窗口宽度和高度，这个 mWinFrame 保存了窗口最新尺寸；</span></span><br><span class="line">    <span class="comment">// 是由 wms 返回的，是一个 Rect 实例；此时他的意义是上一次请求的大小；</span></span><br><span class="line">    <span class="comment">// 这里的 desiredWindowWidth 和 desiredWindowHeight 表示的是期望的宽高，但不一定是实际的；</span></span><br><span class="line">    Rect frame = mWinFrame;</span><br><span class="line">    <span class="comment">//【9】这里 mFirst 表示是否是第一次显示，在 new ViewRootImpl 的时候是设置为 true！</span></span><br><span class="line">    <span class="keyword">if</span> (mFirst) &#123;</span><br><span class="line">        <span class="comment">// 是否需要全部重绘/是否要求重新 Layout 界面</span></span><br><span class="line">        mFullRedrawNeeded = <span class="keyword">true</span>;</span><br><span class="line">        mLayoutRequested = <span class="keyword">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【--&gt;2.1.2】这里针对了一个特殊的 type 做了判断，他们使用除去 action bar 后屏幕的宽高</span></span><br><span class="line">        <span class="keyword">if</span> (shouldUseDisplaySize(lp)) &#123;</span><br><span class="line">            <span class="comment">// 这里会设置成除去 action bar 后屏幕的宽高；</span></span><br><span class="line">            Point size = <span class="keyword">new</span> Point();</span><br><span class="line">            mDisplay.getRealSize(size);</span><br><span class="line">            desiredWindowWidth = size.x;</span><br><span class="line">            desiredWindowHeight = size.y;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则所需要窗口的宽度和高度就是整个屏幕的宽高；</span></span><br><span class="line">            Configuration config = mContext.getResources().getConfiguration();</span><br><span class="line">            desiredWindowWidth = dipToPx(config.screenWidthDp);</span><br><span class="line">            desiredWindowHeight = dipToPx(config.screenHeightDp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【*10】设置下 mAttachInfo 中的一些参数：</span></span><br><span class="line">        <span class="comment">// 使用 32 为绘制缓存 true</span></span><br><span class="line">        <span class="comment">// 窗口持有焦点 false</span></span><br><span class="line">        <span class="comment">// 窗口可见性：viewVisibility 一般是 true；</span></span><br><span class="line">        <span class="comment">// 重新计算全局的布局属性：false；</span></span><br><span class="line">        <span class="comment">// 我们以前使用以下条件来选择32位图形缓存： PixelFormat.hasAlpha（lp.format）</span></span><br><span class="line">        <span class="comment">// || lp.format == PixelFormat.RGBX_8888，但是，现在默认情况下，窗口始终为 32位，</span></span><br><span class="line">        <span class="comment">// 因此请选择 32 位；</span></span><br><span class="line">        mAttachInfo.mUse32BitDrawingCache = <span class="keyword">true</span>;</span><br><span class="line">        mAttachInfo.mHasWindowFocus = <span class="keyword">false</span>;</span><br><span class="line">        mAttachInfo.mWindowVisibility = viewVisibility;</span><br><span class="line">        mAttachInfo.mRecomputeGlobalAttributes = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//【11】设置上一次的配置和上一的可见性，也就是本次的设置；</span></span><br><span class="line">        mLastConfiguration.setTo(host.getResources().getConfiguration());</span><br><span class="line">        mLastSystemUiVisibility = mAttachInfo.mSystemUiVisibility;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【12】设置布局方向，如果还没有设置，默认是 inherit</span></span><br><span class="line">        <span class="keyword">if</span> (mViewLayoutDirectionInitial == View.LAYOUT_DIRECTION_INHERIT) &#123;</span><br><span class="line">            host.setLayoutDirection(mLastConfiguration.getLayoutDirection());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【--&gt;3.1】讲 mAttachInfo 设置到 DecorView 中，host 是 DecorView！</span></span><br><span class="line">        host.dispatchAttachedToWindow(mAttachInfo, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【--&gt;5.2】通过 ViewTreeObserver 发出通知：已经 attach 到了 window 上；</span></span><br><span class="line">        mAttachInfo.mTreeObserver.dispatchOnWindowAttachedChange(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 使用 windowInserts；</span></span><br><span class="line">        dispatchApplyInsets(host);</span><br><span class="line">        <span class="comment">// Log.i(mTag, "Screen on initialized: " + attachInfo.mKeepScreenOn);</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 对于不是第一次显示的情况，这里就不会有 attach 的过程；</span></span><br><span class="line">        <span class="comment">// 也就是上一次储存的宽高值；</span></span><br><span class="line">        desiredWindowWidth = frame.width();</span><br><span class="line">        desiredWindowHeight = frame.height();</span><br><span class="line">        <span class="keyword">if</span> (desiredWindowWidth != mWidth || desiredWindowHeight != mHeight) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_ORIENTATION) Log.v(mTag, <span class="string">"View "</span> + host + <span class="string">" resized to: "</span> + frame);</span><br><span class="line">            mFullRedrawNeeded = <span class="keyword">true</span>;</span><br><span class="line">            mLayoutRequested = <span class="keyword">true</span>;</span><br><span class="line">            windowSizeMayChange = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【13】如果 DecorView 的可见性发生变化，第一次进入为 false；</span></span><br><span class="line">    <span class="keyword">if</span> (viewVisibilityChanged) &#123;</span><br><span class="line">        <span class="comment">//【*13.1】更新  mAttachInfo.mWindowVisibility（窗口可见性）为 viewVisibility；</span></span><br><span class="line">        mAttachInfo.mWindowVisibility = viewVisibility;</span><br><span class="line">        <span class="comment">//【--&gt;4.2】通知所有的 child；</span></span><br><span class="line">        host.dispatchWindowVisibilityChanged(viewVisibility);</span><br><span class="line">        <span class="comment">//【13.2】如果 DecorView 的用户可见性发生变化；</span></span><br><span class="line">        <span class="keyword">if</span> (viewUserVisibilityChanged) &#123;</span><br><span class="line">            <span class="comment">//【--&gt;4.3】通知所有的 child；</span></span><br><span class="line">            host.dispatchVisibilityAggregated(viewVisibility == View.VISIBLE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (viewVisibility != View.VISIBLE || mNewSurfaceNeeded) &#123;</span><br><span class="line">            endDragResizing();</span><br><span class="line">            destroyHardwareResources();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (viewVisibility == View.GONE) &#123;</span><br><span class="line">            <span class="comment">//【13.3】如果 DecorView 的变为不可见，那么 mHasHadWindowFocus 为 false，表示不持有 window 焦点；</span></span><br><span class="line">            mHasHadWindowFocus = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【14】上面有更新过 mWindowVisibility，如果 window 不可见，那么其不能持有辅助服务的焦点；</span></span><br><span class="line">    <span class="keyword">if</span> (mAttachInfo.mWindowVisibility != View.VISIBLE) &#123;</span><br><span class="line">        host.clearAccessibilityFocus(); <span class="comment">// 这个方法就先不看了；</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【15】在主线程上执行内部任务队列的 runnable 任务，这里的任务是用于触发布局的，</span></span><br><span class="line">    <span class="comment">// 如果我们在布局的过程中触发 requestLayout 的话，那么在布局完成后会再次针对请求进行布局；</span></span><br><span class="line">    <span class="comment">// 如果第二次布局完成后，还有 requestLayout，那么会被加入到 RunQueue 中，在下一帧，也就是这里，进行布局；</span></span><br><span class="line">    getRunQueue().executeActions(mAttachInfo.mHandler);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> insetsChanged = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【16】判断是否请求布局，mLayoutRequested 在 requestLayout() 设置为了 true；</span></span><br><span class="line">    <span class="keyword">boolean</span> layoutRequested = mLayoutRequested &amp;&amp; (!mStopped || mReportNextDraw);</span><br><span class="line">    <span class="keyword">if</span> (layoutRequested) &#123;</span><br><span class="line">        <span class="keyword">final</span> Resources res = mView.getContext().getResources();</span><br><span class="line">        <span class="comment">//【16.1】对于第一次显示 view，显然 mFirst 为 true，那么会进入这里；</span></span><br><span class="line">        <span class="keyword">if</span> (mFirst) &#123;</span><br><span class="line">            <span class="comment">// 处理和 touch mode 相关逻辑；</span></span><br><span class="line">            mAttachInfo.mInTouchMode = !mAddedTouchMode;</span><br><span class="line">            ensureTouchModeLocally(mAddedTouchMode);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//【16.2】对于不是第一次加载，那么会进入这里；处理 Overscan 区域的处理，这个我们先不关注；</span></span><br><span class="line">            <span class="comment">// 先判断一下几个 insects 的值和上一次相比有没有什么变化，不想等的话就将 insetsChanged 标志位变为 ture;</span></span><br><span class="line">            <span class="keyword">if</span> (!mPendingOverscanInsets.equals(mAttachInfo.mOverscanInsets)) &#123;</span><br><span class="line">                insetsChanged = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!mPendingContentInsets.equals(mAttachInfo.mContentInsets)) &#123;</span><br><span class="line">                insetsChanged = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!mPendingStableInsets.equals(mAttachInfo.mStableInsets)) &#123;</span><br><span class="line">                insetsChanged = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!mPendingVisibleInsets.equals(mAttachInfo.mVisibleInsets)) &#123;</span><br><span class="line">                mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_LAYOUT) Log.v(mTag, <span class="string">"Visible insets changing to: "</span></span><br><span class="line">                                        + mAttachInfo.mVisibleInsets);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!mPendingOutsets.equals(mAttachInfo.mOutsets)) &#123;</span><br><span class="line">                insetsChanged = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mPendingAlwaysConsumeNavBar != mAttachInfo.mAlwaysConsumeNavBar) &#123;</span><br><span class="line">                insetsChanged = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//【16.3】这里判断了如果布局参数 lp 指定的宽/高为 WRAP_CONTENT，也就是适应内部布局，那么窗口大小可能会改变</span></span><br><span class="line">            <span class="comment">// 所以设置 windowSizeMayChange 为 true；</span></span><br><span class="line">            <span class="keyword">if</span> (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT</span><br><span class="line">                || lp.height == ViewGroup.LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">                windowSizeMayChange = <span class="keyword">true</span>;</span><br><span class="line">           		<span class="comment">// 这里和上面的逻辑一样，设置 window 的显示大小；</span></span><br><span class="line">                <span class="keyword">if</span> (shouldUseDisplaySize(lp)) &#123;</span><br><span class="line">                    Point size = <span class="keyword">new</span> Point();</span><br><span class="line">                    mDisplay.getRealSize(size);</span><br><span class="line">                    desiredWindowWidth = size.x;</span><br><span class="line">                    desiredWindowHeight = size.y;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    Configuration config = res.getConfiguration();</span><br><span class="line">                    desiredWindowWidth = dipToPx(config.screenWidthDp);</span><br><span class="line">                    desiredWindowHeight = dipToPx(config.screenHeightDp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【--&gt;2.2】为了确定 Window 的大小而执行预测量，预判下 window 的大小会不会变化；</span></span><br><span class="line">        windowSizeMayChange |= measureHierarchy(host, lp, res,</span><br><span class="line">                                                desiredWindowWidth, desiredWindowHeight);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【17】这里之前是有分析过，更新了 mAttachInfo 的一些属性，不多看；</span></span><br><span class="line">    <span class="comment">// 然后把 pl 保存到 params 中；</span></span><br><span class="line">    <span class="keyword">if</span> (collectViewAttributes()) &#123;</span><br><span class="line">        params = lp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mAttachInfo.mForceReportNewAttributes) &#123;</span><br><span class="line">        mAttachInfo.mForceReportNewAttributes = <span class="keyword">false</span>;</span><br><span class="line">        params = lp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【18】如果是第一次，或者说 DecorView 可见性变化了，那么就会进入这里，调整 resize mode；</span></span><br><span class="line">    <span class="keyword">if</span> (mFirst || mAttachInfo.mViewVisibilityChanged) &#123;</span><br><span class="line">        mAttachInfo.mViewVisibilityChanged = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> resizeMode = mSoftInputMode &amp;</span><br><span class="line">            WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST;</span><br><span class="line">        <span class="keyword">if</span> (resizeMode == WindowManager.LayoutParams.SOFT_INPUT_ADJUST_UNSPECIFIED) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> N = mAttachInfo.mScrollContainers.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mAttachInfo.mScrollContainers.get(i).isShown()) &#123;</span><br><span class="line">                    resizeMode = WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resizeMode == <span class="number">0</span>) &#123;</span><br><span class="line">                resizeMode = WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((lp.softInputMode &amp;</span><br><span class="line">                 WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) != resizeMode) &#123;</span><br><span class="line">                lp.softInputMode = (lp.softInputMode &amp;</span><br><span class="line">                                    ~WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST) |</span><br><span class="line">                    resizeMode;</span><br><span class="line">                params = lp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【19】对参数进行新一步的调整；</span></span><br><span class="line">    <span class="keyword">if</span> (params != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//【19.1】如果 DecorView 设置成了透明背景，那么这里会设置下 format 为 PixelFormat.TRANSLUCENT；</span></span><br><span class="line">        <span class="keyword">if</span> ((host.mPrivateFlags &amp; View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!PixelFormat.formatHasAlpha(params.format)) &#123;</span><br><span class="line">                params.format = PixelFormat.TRANSLUCENT;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【19.2】如果有窗口标记 FLAG_LAYOUT_IN_OVERSCAN，则允许窗口内容扩展到屏幕的 OverScan 区域</span></span><br><span class="line">        <span class="comment">// 这样的话，会导致部分 content 进入  OverScan 区域显示不全，这里可以使用 View.setFitsSystemWindows(boolean)</span></span><br><span class="line">        <span class="comment">// 进行调整；</span></span><br><span class="line">        mAttachInfo.mOverscanRequested = (params.flags</span><br><span class="line">                                          &amp; WindowManager.LayoutParams.FLAG_LAYOUT_IN_OVERSCAN) != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【20】通过 requestFitSystemWindows() 方法设置其为 true，然后会重新执行 scheduleTraversals() 方法；</span></span><br><span class="line">    <span class="keyword">if</span> (mApplyInsetsRequested) &#123;</span><br><span class="line">        mApplyInsetsRequested = <span class="keyword">false</span>;</span><br><span class="line">        mLastOverscanRequested = mAttachInfo.mOverscanRequested;</span><br><span class="line">        <span class="comment">// 使用 windowInserts；</span></span><br><span class="line">        dispatchApplyInsets(host);</span><br><span class="line">        <span class="keyword">if</span> (mLayoutRequested) &#123;</span><br><span class="line">            <span class="comment">//【--&gt;2.2】 这里又进行了一次预测量；</span></span><br><span class="line">            windowSizeMayChange |= measureHierarchy(host, lp,</span><br><span class="line">                                                    mView.getContext().getResources(),</span><br><span class="line">                                                    desiredWindowWidth, desiredWindowHeight);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (layoutRequested) &#123;</span><br><span class="line">        <span class="comment">//【20.1】这里会清除 layout requested 标记，这样下面的代码如果要再请求布局的话，我们会重新开始执行布局流程；</span></span><br><span class="line">        mLayoutRequested = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【21】判断窗口是否需要重新调整大小；</span></span><br><span class="line">    <span class="comment">// 1、layoutRequested 为 true，说明程序已经发起了一次测量，布局，绘制流程。</span></span><br><span class="line">    <span class="comment">// 2、windowSizeMayChange 为 true, 说明前面预测量已经检测到了 Activity 窗口的变化，或者 h/w 为 wrap_content</span></span><br><span class="line">    <span class="comment">// 3、当测量出来的大小和当前大小不一致；</span></span><br><span class="line">    <span class="keyword">boolean</span> windowShouldResize = layoutRequested &amp;&amp; windowSizeMayChange</span><br><span class="line">        &amp;&amp; ((mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight())</span><br><span class="line">            || (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT &amp;&amp;</span><br><span class="line">                frame.width() &lt; desiredWindowWidth &amp;&amp; frame.width() != mWidth)</span><br><span class="line">            || (lp.height == ViewGroup.LayoutParams.WRAP_CONTENT &amp;&amp;</span><br><span class="line">                frame.height() &lt; desiredWindowHeight &amp;&amp; frame.height() != mHeight));</span><br><span class="line">    </span><br><span class="line">    windowShouldResize |= mDragResizing &amp;&amp; mResizeMode == RESIZE_MODE_FREEFORM;</span><br><span class="line">    <span class="comment">//【22】如果活动刚刚重新启动，则它可能已经冻结了任务边界（重新启动时），因此我们需要强制通过 wms 获取最新的边界。</span></span><br><span class="line">    windowShouldResize |= mActivityRelaunched;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【23】检查 Activity 窗口是否需要指定有额外的内容边衬区域和可见边衬区域。</span></span><br><span class="line">    <span class="comment">// Activity 窗口指定额外的内容边衬区域和可见边衬区域是为了放置一些额外的东西。</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> computesInternalInsets =</span><br><span class="line">        mAttachInfo.mTreeObserver.hasComputeInternalInsetsListeners()</span><br><span class="line">        || mAttachInfo.mHasNonEmptyGivenInternalInsets;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> insetsPending = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> relayoutResult = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> updatedConfiguration = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【--&gt;6.1.1】mSurface 是 ViewRootImpl 内部成员，是一个 Surface 实例内部，持有一个 Canvas;</span></span><br><span class="line">    <span class="comment">// 我们的绘制实际上就是发生其上的；</span></span><br><span class="line">    <span class="comment">//【--&gt;6.1.2】这里是获取其 id 标示；</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> surfaceGenerationId = mSurface.getGenerationId();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> isViewVisible = viewVisibility == View.VISIBLE; <span class="comment">// 这里又判断了下 DecorView 可见性；</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【24】如果是第一次加载，或者 window 需要重新调整大小，或者 insets 发生了改变，或者 view 可见性变化了；</span></span><br><span class="line">    <span class="comment">// 或者布局参数不为 null，或者强制视图重新布局，都会进入这里；</span></span><br><span class="line">    <span class="keyword">if</span> (mFirst || windowShouldResize || insetsChanged ||</span><br><span class="line">        viewVisibilityChanged || params != <span class="keyword">null</span> || mForceNextWindowRelayout) &#123;</span><br><span class="line">        mForceNextWindowRelayout = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isViewVisible) &#123;</span><br><span class="line">            <span class="comment">//【24.1】检查接下来请求 WMS 服务计算大小时，是否要告诉 WMS 服务它指定了额外的内容区域边衬和可见区域边衬，</span></span><br><span class="line">            <span class="comment">// 但是这些额外的内容区域边衬和可见区域边衬又还没确定，</span></span><br><span class="line">            <span class="comment">// 这种情况发生在 Activity 窗口第一次执行测量、布局和绘制操作或者由不可见变化可见时；</span></span><br><span class="line">            insetsPending = computesInternalInsets &amp;&amp; (mFirst || viewVisibilityChanged);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【24.3】我们知道默认的情况下 mSurfaceHolder 是 null 的，这里不进入；</span></span><br><span class="line">        <span class="keyword">if</span> (mSurfaceHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mSurfaceHolder.mSurfaceLock.lock();</span><br><span class="line">            mDrawingAllowed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> hwInitialized = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span> contentInsetsChanged = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//【24.4】判断 surface 是否有效，目前是无效的；</span></span><br><span class="line">        <span class="keyword">boolean</span> hadSurface = mSurface.isValid();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_LAYOUT) &#123;</span><br><span class="line">                Log.i(mTag, <span class="string">"host=w:"</span> + host.getMeasuredWidth() + <span class="string">", h:"</span> +</span><br><span class="line">                      host.getMeasuredHeight() + <span class="string">", params="</span> + params);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//【25】如果开启了硬件加速，那么这里会对 suface 进行锁定，防止 relayoutWindow 时；</span></span><br><span class="line">            <span class="comment">// wms 对 surface 进行销毁；</span></span><br><span class="line">            <span class="keyword">if</span> (mAttachInfo.mHardwareRenderer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mAttachInfo.mHardwareRenderer.pauseSurface(mSurface)) &#123;</span><br><span class="line">                    <span class="comment">// Animations were running so we need to push a frame</span></span><br><span class="line">                    <span class="comment">// to resume them</span></span><br><span class="line">                    mDirty.set(<span class="number">0</span>, <span class="number">0</span>, mWidth, mHeight);</span><br><span class="line">                &#125;</span><br><span class="line">                mChoreographer.mFrameInfo.addFlags(FrameInfo.FLAG_WINDOW_LAYOUT_CHANGED);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//【--&gt;2.3】请求 WMS 计算Activity窗口的大小以及过扫描区域边衬大小和可见区域边衬大小</span></span><br><span class="line">            <span class="comment">// 同时，Surface 只有通过 request 后才是有效的；</span></span><br><span class="line">            <span class="comment">// 该流程会进入 wms，最终就通过 Binder 调用，该方法会返回，请求的大小，然后设置到 mWinFrame 中；</span></span><br><span class="line">            relayoutResult = relayoutWindow(params, viewVisibility, insetsPending);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (DEBUG_LAYOUT) Log.v(mTag, <span class="string">"relayout: frame="</span> + frame.toShortString()</span><br><span class="line">                                    + <span class="string">" overscan="</span> + mPendingOverscanInsets.toShortString()</span><br><span class="line">                                    + <span class="string">" content="</span> + mPendingContentInsets.toShortString()</span><br><span class="line">                                    + <span class="string">" visible="</span> + mPendingVisibleInsets.toShortString()</span><br><span class="line">                                    + <span class="string">" visible="</span> + mPendingStableInsets.toShortString()</span><br><span class="line">                                    + <span class="string">" outsets="</span> + mPendingOutsets.toShortString()</span><br><span class="line">                                    + <span class="string">" surface="</span> + mSurface);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mPendingConfiguration.seq != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_CONFIGURATION) Log.v(mTag, <span class="string">"Visible with new config: "</span></span><br><span class="line">                                               + mPendingConfiguration);</span><br><span class="line">                updateConfiguration(<span class="keyword">new</span> Configuration(mPendingConfiguration), !mFirst);</span><br><span class="line">                mPendingConfiguration.seq = <span class="number">0</span>;</span><br><span class="line">                updatedConfiguration = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【26】判断边衬是否发生了变化；</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> overscanInsetsChanged = !mPendingOverscanInsets.equals(</span><br><span class="line">                mAttachInfo.mOverscanInsets);</span><br><span class="line">            contentInsetsChanged = !mPendingContentInsets.equals(</span><br><span class="line">                mAttachInfo.mContentInsets);</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> visibleInsetsChanged = !mPendingVisibleInsets.equals(</span><br><span class="line">                mAttachInfo.mVisibleInsets);</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> stableInsetsChanged = !mPendingStableInsets.equals(</span><br><span class="line">                mAttachInfo.mStableInsets);</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> outsetsChanged = !mPendingOutsets.equals(mAttachInfo.mOutsets);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//【27】判断 surface 大小是否发生变化；</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> surfaceSizeChanged = (relayoutResult</span><br><span class="line">                                                &amp; WindowManagerGlobal.RELAYOUT_RES_SURFACE_RESIZED) != <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> alwaysConsumeNavBarChanged =</span><br><span class="line">                mPendingAlwaysConsumeNavBar != mAttachInfo.mAlwaysConsumeNavBar;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//【28】更新新的边衬数据；</span></span><br><span class="line">            <span class="keyword">if</span> (contentInsetsChanged) &#123;</span><br><span class="line">                mAttachInfo.mContentInsets.set(mPendingContentInsets);</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_LAYOUT) Log.v(mTag, <span class="string">"Content insets changing to: "</span></span><br><span class="line">                                        + mAttachInfo.mContentInsets);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (overscanInsetsChanged) &#123;</span><br><span class="line">                mAttachInfo.mOverscanInsets.set(mPendingOverscanInsets);</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_LAYOUT) Log.v(mTag, <span class="string">"Overscan insets changing to: "</span></span><br><span class="line">                                        + mAttachInfo.mOverscanInsets);</span><br><span class="line">                <span class="comment">// Need to relayout with content insets.</span></span><br><span class="line">                contentInsetsChanged = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (stableInsetsChanged) &#123;</span><br><span class="line">                mAttachInfo.mStableInsets.set(mPendingStableInsets);</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_LAYOUT) Log.v(mTag, <span class="string">"Decor insets changing to: "</span></span><br><span class="line">                                        + mAttachInfo.mStableInsets);</span><br><span class="line">                <span class="comment">// Need to relayout with content insets.</span></span><br><span class="line">                contentInsetsChanged = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (alwaysConsumeNavBarChanged) &#123;</span><br><span class="line">                mAttachInfo.mAlwaysConsumeNavBar = mPendingAlwaysConsumeNavBar;</span><br><span class="line">                contentInsetsChanged = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (contentInsetsChanged || mLastSystemUiVisibility !=</span><br><span class="line">                mAttachInfo.mSystemUiVisibility || mApplyInsetsRequested</span><br><span class="line">                || mLastOverscanRequested != mAttachInfo.mOverscanRequested</span><br><span class="line">                || outsetsChanged) &#123;</span><br><span class="line">                mLastSystemUiVisibility = mAttachInfo.mSystemUiVisibility;</span><br><span class="line">                mLastOverscanRequested = mAttachInfo.mOverscanRequested;</span><br><span class="line">                mAttachInfo.mOutsets.set(mPendingOutsets);</span><br><span class="line">                mApplyInsetsRequested = <span class="keyword">false</span>;</span><br><span class="line">                dispatchApplyInsets(host);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (visibleInsetsChanged) &#123;</span><br><span class="line">                mAttachInfo.mVisibleInsets.set(mPendingVisibleInsets);</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_LAYOUT) Log.v(mTag, <span class="string">"Visible insets changing to: "</span></span><br><span class="line">                                        + mAttachInfo.mVisibleInsets);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【29】处理 surface；</span></span><br><span class="line">            <span class="keyword">if</span> (!hadSurface) &#123;</span><br><span class="line">                <span class="comment">//【29.1】如果之前还没持有 surface，显然会进入这里，而此时 requestWindow 返回后；</span></span><br><span class="line">                <span class="comment">// Surface 就有效了，isValid 返回了 true；</span></span><br><span class="line">                <span class="keyword">if</span> (mSurface.isValid()) &#123;</span><br><span class="line">                    <span class="comment">// 如果要创建一个新 surface，则需要完全重绘它。同样，当我们到达绘制点时，我们将推迟并安排新的遍历。</span></span><br><span class="line">                    <span class="comment">// 这样一来，我们可以在实际绘制窗口之前告诉窗口管理器所有正在显示的窗口，以便随后显示。</span></span><br><span class="line">                    newSurface = <span class="keyword">true</span>;</span><br><span class="line">                    mFullRedrawNeeded = <span class="keyword">true</span>; <span class="comment">// 重绘；</span></span><br><span class="line">                    mPreviousTransparentRegion.setEmpty();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 仅在不要求透明区域的情况下才预先初始化，否则请推迟查看整个窗口。</span></span><br><span class="line">                    <span class="keyword">if</span> (mAttachInfo.mHardwareRenderer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            hwInitialized = mAttachInfo.mHardwareRenderer.initialize(</span><br><span class="line">                                mSurface);</span><br><span class="line">                            <span class="keyword">if</span> (hwInitialized &amp;&amp; (host.mPrivateFlags</span><br><span class="line">                                                  &amp; View.PFLAG_REQUEST_TRANSPARENT_REGIONS) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="comment">// 如果要求透明区域，则不要预先分配，因为可能不需要透明区域；</span></span><br><span class="line">                                mSurface.allocateBuffers();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (OutOfResourcesException e) &#123;</span><br><span class="line">                            handleOutOfResourcesException(e);</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!mSurface.isValid()) &#123;</span><br><span class="line">                <span class="comment">//【29.2】如果已经持有 surface，但是已经失效了，那就进入这里；</span></span><br><span class="line">                <span class="comment">// 这里会重置滚动位置；</span></span><br><span class="line">                <span class="keyword">if</span> (mLastScrolledFocus != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mLastScrolledFocus.clear();</span><br><span class="line">                &#125;</span><br><span class="line">                mScrollY = mCurScrollY = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (mView <span class="keyword">instanceof</span> RootViewSurfaceTaker) &#123;</span><br><span class="line">                    ((RootViewSurfaceTaker) mView).onRootViewScrollYChanged(mCurScrollY);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (mScroller != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mScroller.abortAnimation();</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> (mAttachInfo.mHardwareRenderer != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                    mAttachInfo.mHardwareRenderer.isEnabled()) &#123;</span><br><span class="line">                    mAttachInfo.mHardwareRenderer.destroy();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((surfaceGenerationId != mSurface.getGenerationId()</span><br><span class="line">                        || surfaceSizeChanged)</span><br><span class="line">                       &amp;&amp; mSurfaceHolder == <span class="keyword">null</span></span><br><span class="line">                       &amp;&amp; mAttachInfo.mHardwareRenderer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//【29.3】如果已经持有 surface，但是并且是有效的，如果 Surface 发生了更改（ID 变化了）</span></span><br><span class="line">                <span class="comment">// 或 WindowManager 更改了 Surface 大小，那么就会进入这里；</span></span><br><span class="line">                mFullRedrawNeeded = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 需要执行 updateSurface（这会导致 CanvasContext::setSurface 并重新创建 EGLSurface）</span></span><br><span class="line">                    <span class="comment">// 后者是因为在某些芯片上，除非我们创建新的 EGLSurface，否则更改用户端 BufferQueue 的大小可能不会立即生效。</span></span><br><span class="line">                    <span class="comment">// 请注意，框架尺寸的改变并不总是意味着表面尺寸的改变（例如，拖动调整大小使用全屏表面），</span></span><br><span class="line">                    <span class="comment">// 需要从 WindowManager 中检查 surfaceSizeChanged 标志。</span></span><br><span class="line">                    mAttachInfo.mHardwareRenderer.updateSurface(mSurface);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (OutOfResourcesException e) &#123;</span><br><span class="line">                    handleOutOfResourcesException(e);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">			</span><br><span class="line">            <span class="comment">//【30】下面事处理 resize 的情况；</span></span><br><span class="line">            <span class="comment">// 判断是否是因为 freeform 导致窗口大小变化，通过拖动窗口角之一来调整窗口的大小；</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> freeformResizing = (relayoutResult</span><br><span class="line">                                              &amp; WindowManagerGlobal.RELAYOUT_RES_DRAG_RESIZING_FREEFORM) != <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 判断是否是因为 Dock 模式导致窗口大小变化，也就是通过拖动停靠的分隔线来调整窗口大小；</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> dockedResizing = (relayoutResult</span><br><span class="line">                                            &amp; WindowManagerGlobal.RELAYOUT_RES_DRAG_RESIZING_DOCKED) != <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 判断是否是因为拖动导致大小变化；</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> dragResizing = freeformResizing || dockedResizing;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果是大小变化和大小不变的状态之间发生了切换，进入这里；</span></span><br><span class="line">            <span class="keyword">if</span> (mDragResizing != dragResizing) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dragResizing) &#123; </span><br><span class="line">                    <span class="comment">// 如果这一次是发生变化了，那么会计算计算下 resize mode；</span></span><br><span class="line">                    mResizeMode = freeformResizing</span><br><span class="line">                        ? RESIZE_MODE_FREEFORM</span><br><span class="line">                        : RESIZE_MODE_DOCKED_DIVIDER;</span><br><span class="line">                    <span class="comment">// 回调通知；</span></span><br><span class="line">                    startDragResizing(mPendingBackDropFrame,</span><br><span class="line">                                      mWinFrame.equals(mPendingBackDropFrame), mPendingVisibleInsets,</span><br><span class="line">                                      mPendingStableInsets, mResizeMode);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 停止大小变化，回调通知；</span></span><br><span class="line">                    endDragResizing();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 该常量用于设置是否使用多线程渲染器，默认是 true 也就是使用，如果为 false 的话；</span></span><br><span class="line">            <span class="comment">// WindowCallbacks 将不会触发;</span></span><br><span class="line">            <span class="keyword">if</span> (!USE_MT_RENDERER) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dragResizing) &#123;</span><br><span class="line">                    mCanvasOffsetX = mWinFrame.left;</span><br><span class="line">                    mCanvasOffsetY = mWinFrame.top;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mCanvasOffsetX = mCanvasOffsetY = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DEBUG_ORIENTATION) Log.v(</span><br><span class="line">            TAG, <span class="string">"Relayout returned: frame="</span> + frame + <span class="string">", surface="</span> + mSurface);</span><br><span class="line">        <span class="comment">//【31】获得 wms 计算的窗口的最新的 top 和 left 距离，这个我就不说了；</span></span><br><span class="line">        mAttachInfo.mWindowLeft = frame.left;</span><br><span class="line">        mAttachInfo.mWindowTop = frame.top;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// !!FIXME!! This next section handles the case where we did not get the</span></span><br><span class="line">        <span class="comment">// window size we asked for. We should avoid this by getting a maximum size from</span></span><br><span class="line">        <span class="comment">// the window session beforehand.</span></span><br><span class="line">        <span class="comment">//【32】这里是用 frame 更新下 mWidth/mHeight 的值；</span></span><br><span class="line">        <span class="keyword">if</span> (mWidth != frame.width() || mHeight != frame.height()) &#123;</span><br><span class="line">            mWidth = frame.width();</span><br><span class="line">            mHeight = frame.height();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【33】mSurfaceHolder 不为 null 说明应用创建了一个 holder，其可以对 Surface</span></span><br><span class="line">        <span class="comment">// 进行直接操作，这里是针对应用持有 SurfaceHolder 的情况；</span></span><br><span class="line">        <span class="keyword">if</span> (mSurfaceHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//【33.1】surface 保存到 SurfaceHolder 内部；</span></span><br><span class="line">            <span class="keyword">if</span> (mSurface.isValid()) &#123;</span><br><span class="line">                <span class="comment">// XXX .copyFrom() doesn't work!</span></span><br><span class="line">                <span class="comment">//mSurfaceHolder.mSurface.copyFrom(mSurface);</span></span><br><span class="line">                mSurfaceHolder.mSurface = mSurface;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//【33.2】设置 surface 的大小；</span></span><br><span class="line">            mSurfaceHolder.setSurfaceFrameSize(mWidth, mHeight);</span><br><span class="line">            mSurfaceHolder.mSurfaceLock.unlock();</span><br><span class="line">            <span class="keyword">if</span> (mSurface.isValid()) &#123;</span><br><span class="line">                <span class="comment">// 说明 surface 是有效的，如果 hadSurface 为 false，</span></span><br><span class="line">                <span class="comment">// 这里会回调 SurfaceHolder.Callback 的 surfaceCreated 方法，通知 surface 被创建；</span></span><br><span class="line">                <span class="keyword">if</span> (!hadSurface) &#123;</span><br><span class="line">                    mSurfaceHolder.ungetCallbacks();</span><br><span class="line"></span><br><span class="line">                    mIsCreating = <span class="keyword">true</span>;</span><br><span class="line">                    mSurfaceHolderCallback.surfaceCreated(mSurfaceHolder);</span><br><span class="line">                    SurfaceHolder.Callback callbacks[] = mSurfaceHolder.getCallbacks();</span><br><span class="line">                    <span class="keyword">if</span> (callbacks != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (SurfaceHolder.Callback c : callbacks) &#123;</span><br><span class="line">                            c.surfaceCreated(mSurfaceHolder);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    surfaceChanged = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 这里会回调 SurfaceHolder.Callback 的 surfaceChanged 方法，通知 surface 发生了变化；</span></span><br><span class="line">                <span class="keyword">if</span> (surfaceChanged || surfaceGenerationId != mSurface.getGenerationId()) &#123;</span><br><span class="line">                    mSurfaceHolderCallback.surfaceChanged(mSurfaceHolder,</span><br><span class="line">                                                          lp.format, mWidth, mHeight);</span><br><span class="line">                    SurfaceHolder.Callback callbacks[] = mSurfaceHolder.getCallbacks();</span><br><span class="line">                    <span class="keyword">if</span> (callbacks != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (SurfaceHolder.Callback c : callbacks) &#123;</span><br><span class="line">                            c.surfaceChanged(mSurfaceHolder, lp.format,</span><br><span class="line">                                             mWidth, mHeight);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                mIsCreating = <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hadSurface) &#123;</span><br><span class="line">                <span class="comment">// 说明 surface 无效的，但是此时已经创建了 surface；</span></span><br><span class="line">                <span class="comment">// 这里会回调 SurfaceHolder.Callback 的 surfaceDestroyed 方法，通知 surface 被销毁；</span></span><br><span class="line">                <span class="comment">// 然后重新 new Surface；</span></span><br><span class="line">                mSurfaceHolder.ungetCallbacks();</span><br><span class="line">                SurfaceHolder.Callback callbacks[] = mSurfaceHolder.getCallbacks();</span><br><span class="line">                mSurfaceHolderCallback.surfaceDestroyed(mSurfaceHolder);</span><br><span class="line">                <span class="keyword">if</span> (callbacks != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (SurfaceHolder.Callback c : callbacks) &#123;</span><br><span class="line">                        c.surfaceDestroyed(mSurfaceHolder);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                mSurfaceHolder.mSurfaceLock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    mSurfaceHolder.mSurface = <span class="keyword">new</span> Surface();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    mSurfaceHolder.mSurfaceLock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【34】判断是否开启了硬件加速，如果开启了，同时窗口的宽高和硬件加速的宽/高；</span></span><br><span class="line">        <span class="comment">// 这里要讲新的 width/height 设置到硬件加速环境中；</span></span><br><span class="line">        <span class="keyword">final</span> ThreadedRenderer hardwareRenderer = mAttachInfo.mHardwareRenderer;</span><br><span class="line">        <span class="keyword">if</span> (hardwareRenderer != <span class="keyword">null</span> &amp;&amp; hardwareRenderer.isEnabled()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hwInitialized</span><br><span class="line">                || mWidth != hardwareRenderer.getWidth()</span><br><span class="line">                || mHeight != hardwareRenderer.getHeight()</span><br><span class="line">                || mNeedsHwRendererSetup) &#123;</span><br><span class="line">                hardwareRenderer.setup(mWidth, mHeight, mAttachInfo,</span><br><span class="line">                                       mWindowAttributes.surfaceInsets);</span><br><span class="line">                mNeedsHwRendererSetup = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">        <span class="comment">//【35】如果此窗口的所有者处于停止状态，则设置 mStopped 为 true，此时该窗口不处于活动状态。</span></span><br><span class="line">        <span class="keyword">if</span> (!mStopped || mReportNextDraw) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> focusChangedDueToTouchMode = ensureTouchModeLocally(</span><br><span class="line">                (relayoutResult&amp;WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE) != <span class="number">0</span>);</span><br><span class="line">            <span class="comment">//【35.1】如果要进入 touch mode，或者之前预测量的宽高和请求的宽高不一样；</span></span><br><span class="line">            <span class="comment">// 或者边衬的距离变化了，或者配置更新了，这都会开始测量；</span></span><br><span class="line">            <span class="keyword">if</span> (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth()</span><br><span class="line">                || mHeight != host.getMeasuredHeight() || contentInsetsChanged ||</span><br><span class="line">                updatedConfiguration) &#123;</span><br><span class="line">                <span class="comment">//【--&gt;2.2.1】计算出 root view 的测量规格 Measure Spec，此时 mWidth 和 mHeight 是 wms 返回的大小；</span></span><br><span class="line">                <span class="comment">// 他们是具体的数值；</span></span><br><span class="line">                <span class="keyword">int</span> childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);</span><br><span class="line">                <span class="keyword">int</span> childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (DEBUG_LAYOUT) Log.v(mTag, <span class="string">"Ooops, something changed!  mWidth="</span></span><br><span class="line">                                        + mWidth + <span class="string">" measuredWidth="</span> + host.getMeasuredWidth()</span><br><span class="line">                                        + <span class="string">" mHeight="</span> + mHeight</span><br><span class="line">                                        + <span class="string">" measuredHeight="</span> + host.getMeasuredHeight()</span><br><span class="line">                                        + <span class="string">" coveredInsetsChanged="</span> + contentInsetsChanged);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//【--&gt;2.4】开始测量；</span></span><br><span class="line">                performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//【35.1.1】getMeasuredWidth() 所获得 View 的宽高绝大部分情况下等于 View 最终的宽高；</span></span><br><span class="line">                <span class="keyword">int</span> width = host.getMeasuredWidth();</span><br><span class="line">                <span class="keyword">int</span> height = host.getMeasuredHeight();</span><br><span class="line">                <span class="keyword">boolean</span> measureAgain = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//【35.1.2】处理设置了权重的情况，如果有权重的话，那么会分配剩余的空间；</span></span><br><span class="line">                <span class="comment">// 这里的权重是浮点数，也就是百分比；</span></span><br><span class="line">                <span class="keyword">if</span> (lp.horizontalWeight &gt; <span class="number">0.0f</span>) &#123;</span><br><span class="line">                    width += (<span class="keyword">int</span>) ((mWidth - width) * lp.horizontalWeight);</span><br><span class="line">                    childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(width,</span><br><span class="line">                                                                        MeasureSpec.EXACTLY);</span><br><span class="line">                    measureAgain = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (lp.verticalWeight &gt; <span class="number">0.0f</span>) &#123;</span><br><span class="line">                    height += (<span class="keyword">int</span>) ((mHeight - height) * lp.verticalWeight);</span><br><span class="line">                    childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(height,</span><br><span class="line">                                                                         MeasureSpec.EXACTLY);</span><br><span class="line">                    measureAgain = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (measureAgain) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG_LAYOUT) Log.v(mTag,</span><br><span class="line">                                            <span class="string">"And hey let's measure once more: width="</span> + width</span><br><span class="line">                                            + <span class="string">" height="</span> + height);</span><br><span class="line">                    <span class="comment">//【--&gt;2.4】再次测量；</span></span><br><span class="line">                    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                layoutRequested = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//【--&gt;2.1.5】如果不是第一次加载，并且窗口/边衬/可见性没有变化，但是窗口可能已经移动了，</span></span><br><span class="line">        <span class="comment">// 这里会检查一下是否要更新 attachInfo 中的 left/top 的值。</span></span><br><span class="line">        maybeHandleWindowMove(frame);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否需要布局，显然是需要的；</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> didLayout = layoutRequested &amp;&amp; (!mStopped || mReportNextDraw);</span><br><span class="line">    <span class="comment">//【36】是否触发全局布局的回调；</span></span><br><span class="line">    <span class="keyword">boolean</span> triggerGlobalLayoutListener = didLayout</span><br><span class="line">        || mAttachInfo.mRecomputeGlobalAttributes;</span><br><span class="line">    <span class="keyword">if</span> (didLayout) &#123;</span><br><span class="line">        <span class="comment">//【--&gt;2.4】开始布局；</span></span><br><span class="line">        performLayout(lp, mWidth, mHeight);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 至此，所有视图的大小和位置都已确定，我们可以计算出透明区域；</span></span><br><span class="line">        <span class="keyword">if</span> ((host.mPrivateFlags &amp; View.PFLAG_REQUEST_TRANSPARENT_REGIONS) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 设置透明区域；</span></span><br><span class="line">            host.getLocationInWindow(mTmpLocation);</span><br><span class="line">            mTransparentRegion.set(mTmpLocation[<span class="number">0</span>], mTmpLocation[<span class="number">1</span>],</span><br><span class="line">                                   mTmpLocation[<span class="number">0</span>] + host.mRight - host.mLeft,</span><br><span class="line">                                   mTmpLocation[<span class="number">1</span>] + host.mBottom - host.mTop);</span><br><span class="line"></span><br><span class="line">            host.gatherTransparentRegion(mTransparentRegion);</span><br><span class="line">            <span class="keyword">if</span> (mTranslator != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mTranslator.translateRegionInWindowToScreen(mTransparentRegion);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!mTransparentRegion.equals(mPreviousTransparentRegion)) &#123;</span><br><span class="line">                mPreviousTransparentRegion.set(mTransparentRegion);</span><br><span class="line">                mFullRedrawNeeded = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">// 将透明区域传递给 wms，进一步设置；</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    mWindowSession.setTransparentRegion(mWindow, mTransparentRegion);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DBG) &#123;</span><br><span class="line">            System.out.println(<span class="string">"======================================"</span>);</span><br><span class="line">            System.out.println(<span class="string">"performTraversals -- after setFrame"</span>);</span><br><span class="line">            host.debug();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【37】第一次加载的情况，肯定是为 true；</span></span><br><span class="line">    <span class="keyword">if</span> (triggerGlobalLayoutListener) &#123;</span><br><span class="line">        mAttachInfo.mRecomputeGlobalAttributes = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//【--&gt;5.4】全局布局回调；</span></span><br><span class="line">        mAttachInfo.mTreeObserver.dispatchOnGlobalLayout();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【38】设置边衬距离，并通知给 wms；</span></span><br><span class="line">    <span class="keyword">if</span> (computesInternalInsets) &#123;</span><br><span class="line">        <span class="comment">//【38.1】清空旧的边衬信息；</span></span><br><span class="line">        <span class="keyword">final</span> ViewTreeObserver.InternalInsetsInfo insets = mAttachInfo.mGivenInternalInsets;</span><br><span class="line">        insets.reset();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【--&gt;5.5】回调相关接口计算当前插入边衬。</span></span><br><span class="line">        mAttachInfo.mTreeObserver.dispatchOnComputeInternalInsets(insets);</span><br><span class="line">        mAttachInfo.mHasNonEmptyGivenInternalInsets = !insets.isEmpty();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (insetsPending || !mLastGivenInsets.equals(insets)) &#123;</span><br><span class="line">            mLastGivenInsets.set(insets);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Translate insets to screen coordinates if needed.</span></span><br><span class="line">            <span class="keyword">final</span> Rect contentInsets;</span><br><span class="line">            <span class="keyword">final</span> Rect visibleInsets;</span><br><span class="line">            <span class="keyword">final</span> Region touchableRegion;</span><br><span class="line">            <span class="keyword">if</span> (mTranslator != <span class="keyword">null</span>) &#123;</span><br><span class="line">                contentInsets = mTranslator.getTranslatedContentInsets(insets.contentInsets);</span><br><span class="line">                visibleInsets = mTranslator.getTranslatedVisibleInsets(insets.visibleInsets);</span><br><span class="line">                touchableRegion = mTranslator.getTranslatedTouchableArea(insets.touchableRegion);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                contentInsets = insets.contentInsets;</span><br><span class="line">                visibleInsets = insets.visibleInsets;</span><br><span class="line">                touchableRegion = insets.touchableRegion;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//【38.2】通知给 wms；</span></span><br><span class="line">                mWindowSession.setInsets(mWindow, insets.mTouchableInsets,</span><br><span class="line">                                         contentInsets, visibleInsets, touchableRegion);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【39】如果是第一次加载，这里会请求交点操作！</span></span><br><span class="line">    <span class="keyword">if</span> (mFirst) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_INPUT_RESIZE) Log.v(mTag, <span class="string">"First: mView.hasFocus()="</span></span><br><span class="line">                                      + mView.hasFocus());</span><br><span class="line">        <span class="keyword">if</span> (mView != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mView.hasFocus()) &#123;</span><br><span class="line">                <span class="comment">//【*39.1】请求焦点，这里先不分析。</span></span><br><span class="line">                mView.requestFocus(View.FOCUS_FORWARD);</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_INPUT_RESIZE) Log.v(mTag, <span class="string">"First: requested focused view="</span></span><br><span class="line">                                              + mView.findFocus());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_INPUT_RESIZE) Log.v(mTag, <span class="string">"First: existing focused view="</span></span><br><span class="line">                                              + mView.findFocus());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> changedVisibility = (viewVisibilityChanged || mFirst) &amp;&amp; isViewVisible;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> hasWindowFocus = mAttachInfo.mHasWindowFocus &amp;&amp; isViewVisible;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> regainedFocus = hasWindowFocus &amp;&amp; mLostWindowFocus;</span><br><span class="line">    <span class="keyword">if</span> (regainedFocus) &#123;</span><br><span class="line">        mLostWindowFocus = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasWindowFocus &amp;&amp; mHadWindowFocus) &#123;</span><br><span class="line">        mLostWindowFocus = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (changedVisibility || regainedFocus) &#123;</span><br><span class="line">        <span class="comment">// Toast 以通知的形式显示，而不是 window；</span></span><br><span class="line">        <span class="keyword">boolean</span> isToast = (mWindowAttributes == <span class="keyword">null</span>) ? <span class="keyword">false</span></span><br><span class="line">            : (mWindowAttributes.type == WindowManager.LayoutParams.TYPE_TOAST);</span><br><span class="line">        <span class="keyword">if</span> (!isToast) &#123;</span><br><span class="line">            host.sendAccessibilityEvent(AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mFirst = <span class="keyword">false</span>;</span><br><span class="line">    mWillDrawSoon = <span class="keyword">false</span>;</span><br><span class="line">    mNewSurfaceNeeded = <span class="keyword">false</span>;</span><br><span class="line">    mActivityRelaunched = <span class="keyword">false</span>;</span><br><span class="line">    mViewVisibility = viewVisibility;</span><br><span class="line">    mHadWindowFocus = hasWindowFocus;</span><br><span class="line">    <span class="comment">//【40】针对于输入法的处理；</span></span><br><span class="line">    <span class="keyword">if</span> (hasWindowFocus &amp;&amp; !isInLocalFocusMode()) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> imTarget = WindowManager.LayoutParams</span><br><span class="line">            .mayUseInputMethod(mWindowAttributes.flags);</span><br><span class="line">        <span class="keyword">if</span> (imTarget != mLastWasImTarget) &#123;</span><br><span class="line">            mLastWasImTarget = imTarget;</span><br><span class="line">            InputMethodManager imm = InputMethodManager.peekInstance();</span><br><span class="line">            <span class="keyword">if</span> (imm != <span class="keyword">null</span> &amp;&amp; imTarget) &#123;</span><br><span class="line">                imm.onPreWindowFocus(mView, hasWindowFocus);</span><br><span class="line">                imm.onPostWindowFocus(mView, mView.findFocus(),</span><br><span class="line">                                      mWindowAttributes.softInputMode,</span><br><span class="line">                                      !mHasHadWindowFocus, mWindowAttributes.flags);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果请求结果设置了 RELAYOUT_RES_FIRST_TIME，表示：</span></span><br><span class="line">    <span class="comment">// 这是第一次被绘制的窗口，所以做的时候，客户端必须调用 drawingFinshed（）</span></span><br><span class="line">    <span class="keyword">if</span> ((relayoutResult &amp; WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != <span class="number">0</span>) &#123;</span><br><span class="line">        mReportNextDraw = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【--&gt;5.6】判断是否取消 draw；</span></span><br><span class="line">    <span class="keyword">boolean</span> cancelDraw = mAttachInfo.mTreeObserver.dispatchOnPreDraw() || !isViewVisible;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cancelDraw &amp;&amp; !newSurface) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mPendingTransitions != <span class="keyword">null</span> &amp;&amp; mPendingTransitions.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mPendingTransitions.size(); ++i) &#123;</span><br><span class="line">                mPendingTransitions.get(i).startChangingAnimations();</span><br><span class="line">            &#125;</span><br><span class="line">            mPendingTransitions.clear();</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//【--&gt;2.5】开始绘制；</span></span><br><span class="line">        performDraw();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isViewVisible) &#123;</span><br><span class="line">            <span class="comment">// Try again</span></span><br><span class="line">            scheduleTraversals();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mPendingTransitions != <span class="keyword">null</span> &amp;&amp; mPendingTransitions.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mPendingTransitions.size(); ++i) &#123;</span><br><span class="line">                mPendingTransitions.get(i).endChangingAnimations();</span><br><span class="line">            &#125;</span><br><span class="line">            mPendingTransitions.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mIsInTraversal = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-1-1-getHostVisibility"><a href="#2-1-1-getHostVisibility" class="headerlink" title="2.1.1 getHostVisibility"></a>2.1.1 getHostVisibility</h3><p>获取显示配置，看 DecorView（根 view group）是否显示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getHostVisibility</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】如果应用是可见的，或者强制 DecorView 可见，那么取值为 mView.getVisibility()</span></span><br><span class="line">    <span class="keyword">return</span> (mAppVisible || mForceDecorViewVisibility) ? mView.getVisibility() : View.GONE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，对于 DecorView，默认是可见的，所以这个方法返回的是 true；</p>
<h3 id="2-1-2-shouldUseDisplaySize"><a href="#2-1-2-shouldUseDisplaySize" class="headerlink" title="2.1.2 shouldUseDisplaySize"></a>2.1.2 shouldUseDisplaySize</h3><p>是否要设置成屏幕的大小；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldUseDisplaySize</span><span class="params">(<span class="keyword">final</span> WindowManager.LayoutParams lp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lp.type == TYPE_STATUS_BAR_PANEL</span><br><span class="line">            || lp.type == TYPE_INPUT_METHOD</span><br><span class="line">            || lp.type == TYPE_VOLUME_OVERLAY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里会根据 window 的类型，判断是否设置成屏幕的大小；</p>
<h3 id="2-1-3-dispatchApplyInsets"><a href="#2-1-3-dispatchApplyInsets" class="headerlink" title="2.1.3 dispatchApplyInsets"></a>2.1.3 dispatchApplyInsets</h3><p>使用 windowInserts</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchApplyInsets</span><span class="params">(View host)</span> </span>&#123;</span><br><span class="line">    host.dispatchApplyWindowInsets(getWindowInsets(<span class="keyword">true</span> <span class="comment">/* forceConstruct */</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-1-4-ensureTouchModeLocally"><a href="#2-1-4-ensureTouchModeLocally" class="headerlink" title="2.1.4 ensureTouchModeLocally"></a>2.1.4 ensureTouchModeLocally</h3><p>确保已设置此窗口的触摸模式：</p>
<ul>
<li>参数 boolean inTouchMode：取值为 relayoutResult &amp; WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE) != 0，是否要进入 touch 模式；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">ensureTouchModeLocally</span><span class="params">(<span class="keyword">boolean</span> inTouchMode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DBG) Log.d(<span class="string">"touchmode"</span>, <span class="string">"ensureTouchModeLocally("</span> + inTouchMode + <span class="string">"), current "</span></span><br><span class="line">            + <span class="string">"touch mode is "</span> + mAttachInfo.mInTouchMode);</span><br><span class="line">    <span class="comment">//【1】判断 touch mode 状态是否变化，如果没有，就退出；</span></span><br><span class="line">    <span class="keyword">if</span> (mAttachInfo.mInTouchMode == inTouchMode) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//【2】跟新 touch mode 状态；</span></span><br><span class="line">    mAttachInfo.mInTouchMode = inTouchMode;</span><br><span class="line">    <span class="comment">//【--&gt;5.3】通知 TreeObserver；</span></span><br><span class="line">    mAttachInfo.mTreeObserver.dispatchOnTouchModeChanged(inTouchMode);</span><br><span class="line">    <span class="comment">//【4】如果要退出或者进入 touch mode，那么会调用响应的方法打开/关闭；</span></span><br><span class="line">    <span class="keyword">return</span> (inTouchMode) ? enterTouchMode() : leaveTouchMode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-1-5-maybeHandleWindowMove"><a href="#2-1-5-maybeHandleWindowMove" class="headerlink" title="2.1.5 maybeHandleWindowMove"></a>2.1.5 maybeHandleWindowMove</h3><p>这里会处理下 window 移动的情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">maybeHandleWindowMove</span><span class="params">(Rect frame)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】这里判断了下 window 是否发生了移动，也就是 left/top 的值不一样；</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> windowMoved = mAttachInfo.mWindowLeft != frame.left</span><br><span class="line">            || mAttachInfo.mWindowTop != frame.top;</span><br><span class="line">    <span class="comment">//【2】如果窗口移动了，那就更新 attachInfo 中的 Left/top</span></span><br><span class="line">    <span class="keyword">if</span> (windowMoved) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mTranslator != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mTranslator.translateRectInScreenToAppWinFrame(frame);</span><br><span class="line">        &#125;</span><br><span class="line">        mAttachInfo.mWindowLeft = frame.left;</span><br><span class="line">        mAttachInfo.mWindowTop = frame.top;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (windowMoved || mAttachInfo.mNeedsUpdateLightCenter) &#123;</span><br><span class="line">        <span class="comment">// 更新光源位置以获得新的偏移量(na ni?)</span></span><br><span class="line">        <span class="keyword">if</span> (mAttachInfo.mHardwareRenderer != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mAttachInfo.mHardwareRenderer.setLightCenter(mAttachInfo);</span><br><span class="line">        &#125;</span><br><span class="line">        mAttachInfo.mNeedsUpdateLightCenter = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-measureHierarchy-预测量"><a href="#2-2-measureHierarchy-预测量" class="headerlink" title="2.2 measureHierarchy - 预测量"></a>2.2 measureHierarchy - 预测量</h2><p>这里是在正式测量绘制前，做一次预测量，测量结果会保存在 mMeasuredWidth 和 mMeasuredHeight 中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">measureHierarchy</span><span class="params">(<span class="keyword">final</span> View host, <span class="keyword">final</span> WindowManager.LayoutParams lp,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> Resources res, <span class="keyword">final</span> <span class="keyword">int</span> desiredWindowWidth, <span class="keyword">final</span> <span class="keyword">int</span> desiredWindowHeight)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> childWidthMeasureSpec;</span><br><span class="line">    <span class="keyword">int</span> childHeightMeasureSpec;</span><br><span class="line">    <span class="keyword">boolean</span> windowSizeMayChange = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG_ORIENTATION || DEBUG_LAYOUT) Log.v(mTag,</span><br><span class="line">            <span class="string">"Measuring "</span> + host + <span class="string">" in display "</span> + desiredWindowWidth</span><br><span class="line">            + <span class="string">"x"</span> + desiredWindowHeight + <span class="string">"..."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> goodMeasure = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//【1】这里针对于布局参数为 WRAP_CONTENT 的情况出了特殊处理，也就是 Dialog 的情况；</span></span><br><span class="line">    <span class="keyword">if</span> (lp.width == ViewGroup.LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">        <span class="comment">//【1.1】在大屏幕上，我们不希望对话框仅拉伸以填充屏幕的整个宽度以显示一行文本。</span></span><br><span class="line">        <span class="comment">// 首先尝试以较小的尺寸进行布局，以查看是否适合。</span></span><br><span class="line">        <span class="keyword">final</span> DisplayMetrics packageMetrics = res.getDisplayMetrics();</span><br><span class="line">        res.getValue(com.android.internal.R.dimen.config_prefDialogWidth, mTmpValue, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">int</span> baseSize = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//【1.2】这里是获取系统内置的 TYPE_DIMENSION，保存到 baseSize；</span></span><br><span class="line">        <span class="keyword">if</span> (mTmpValue.type == TypedValue.TYPE_DIMENSION) &#123;</span><br><span class="line">            baseSize = (<span class="keyword">int</span>)mTmpValue.getDimension(packageMetrics);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_DIALOG) Log.v(mTag, <span class="string">"Window "</span> + mView + <span class="string">": baseSize="</span> + baseSize</span><br><span class="line">                + <span class="string">", desiredWindowWidth="</span> + desiredWindowWidth);</span><br><span class="line">        <span class="comment">//【1.3】如果 desiredWindowWidth 大于 baseSize，那么我们以 baseSize 为宽度基准；</span></span><br><span class="line">        <span class="keyword">if</span> (baseSize != <span class="number">0</span> &amp;&amp; desiredWindowWidth &gt; baseSize) &#123;</span><br><span class="line">            <span class="comment">//【--&gt;2.2.1】根据 view 的布局参数计算出其布局度量规范 measure spec;</span></span><br><span class="line">            childWidthMeasureSpec = getRootMeasureSpec(baseSize, lp.width);</span><br><span class="line">            childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//【--&gt;2.4】执行测量；</span></span><br><span class="line">            performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_DIALOG) Log.v(mTag, <span class="string">"Window "</span> + mView + <span class="string">": measured ("</span></span><br><span class="line">                    + host.getMeasuredWidth() + <span class="string">","</span> + host.getMeasuredHeight()</span><br><span class="line">                    + <span class="string">") from width spec: "</span> + MeasureSpec.toString(childWidthMeasureSpec)</span><br><span class="line">                    + <span class="string">" and height spec: "</span> + MeasureSpec.toString(childHeightMeasureSpec));</span><br><span class="line">  </span><br><span class="line">            <span class="comment">//【1.3】这里判断了下测量结果是不是太小了，如果合适，goodMeasure 为 true；</span></span><br><span class="line">            <span class="keyword">if</span> ((host.getMeasuredWidthAndState()&amp;View.MEASURED_STATE_TOO_SMALL) == <span class="number">0</span>) &#123;</span><br><span class="line">                goodMeasure = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//【1.4】这里在前面的基础上再增加一些，重新测量；</span></span><br><span class="line">                baseSize = (baseSize+desiredWindowWidth)/<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_DIALOG) Log.v(mTag, <span class="string">"Window "</span> + mView + <span class="string">": next baseSize="</span></span><br><span class="line">                        + baseSize);</span><br><span class="line">                <span class="comment">//【--&gt;2.2.1】再次根据 view 的布局参数计算出其布局度量规范 measure spec;</span></span><br><span class="line">                childWidthMeasureSpec = getRootMeasureSpec(baseSize, lp.width);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//【--&gt;2.4】开始测量：</span></span><br><span class="line">                performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (DEBUG_DIALOG) Log.v(mTag, <span class="string">"Window "</span> + mView + <span class="string">": measured ("</span></span><br><span class="line">                        + host.getMeasuredWidth() + <span class="string">","</span> + host.getMeasuredHeight() + <span class="string">")"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//【1.5】如果测量结果合适，goodMeasure 为 true；</span></span><br><span class="line">                <span class="keyword">if</span> ((host.getMeasuredWidthAndState()&amp;View.MEASURED_STATE_TOO_SMALL) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG_DIALOG) Log.v(mTag, <span class="string">"Good!"</span>);</span><br><span class="line">                    goodMeasure = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】如果上面的测量不合适，那么下面会用 desiredWindowWidth 来进行测量</span></span><br><span class="line">    <span class="keyword">if</span> (!goodMeasure) &#123;</span><br><span class="line">        <span class="comment">//【--&gt;2.2.1】最后再根据 view 的布局参数计算出其布局度量规范 measure spec;</span></span><br><span class="line">        childWidthMeasureSpec = getRootMeasureSpec(desiredWindowWidth, lp.width);</span><br><span class="line">        childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//【--&gt;2.4】开始测量：</span></span><br><span class="line">        performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">        <span class="comment">//【2.1】这里会判断下测量的结果</span></span><br><span class="line">        <span class="keyword">if</span> (mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight()) &#123;</span><br><span class="line">            windowSizeMayChange = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DBG) &#123;</span><br><span class="line">        System.out.println(<span class="string">"======================================"</span>);</span><br><span class="line">        System.out.println(<span class="string">"performTraversals -- after measure"</span>);</span><br><span class="line">        host.debug();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> windowSizeMayChange;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里是提前做一次预测量。</p>
<h3 id="2-2-1-getRootMeasureSpec"><a href="#2-2-1-getRootMeasureSpec" class="headerlink" title="2.2.1 getRootMeasureSpec"></a>2.2.1 getRootMeasureSpec</h3><p>根据 view 的布局参数计算出其布局度量规范 measure spec：</p>
<ul>
<li><strong>int windowSize</strong>：窗口的可用宽度或高度（mHeight/ mWidth）</li>
<li><strong>int rootDimension</strong>：布局参数参数指定的宽度或高度（match_parent/ wrap_content/ lp.height(width)）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getRootMeasureSpec</span><span class="params">(<span class="keyword">int</span> windowSize, <span class="keyword">int</span> rootDimension)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> measureSpec;</span><br><span class="line">    <span class="keyword">switch</span> (rootDimension) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> ViewGroup.LayoutParams.MATCH_PARENT:</span><br><span class="line">        <span class="comment">//【--&gt;4.4.2】计算度量规范，此时父布局 decorview 的布局参数是 MATCH_PARENT，那么，</span></span><br><span class="line">        <span class="comment">// 窗口无法调整大小，这里就会强制以父布局的大小来设置度量规范，同时由于确定了大小，所以 mode 为 MeasureSpec.EXACTLY</span></span><br><span class="line">        measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ViewGroup.LayoutParams.WRAP_CONTENT:</span><br><span class="line">        <span class="comment">//【--&gt;4.4.2】计算度量规范，此时父布局 decorview 的布局参数是 MATCH_PARENT，那么，</span></span><br><span class="line">        <span class="comment">// 意味着窗口可以调整大小，这里就会强制以父布局的大小来设置度量规范，由于其可以调整大小，</span></span><br><span class="line">        <span class="comment">// 但是不能超过 windowSize，所以 mode 为 WRAP_CONTENT.</span></span><br><span class="line">        measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">//【--&gt;4.4.2】计算度量规范，这种情况 rootDimension 为具体的参数；</span></span><br><span class="line">        <span class="comment">// 意味着窗口明确的指定了 windowSize，显然此时以 rootDimension 为准了。</span></span><br><span class="line">        measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> measureSpec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 DecorView 来说，显然是第一个分支：</p>
<ul>
<li>measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);</li>
</ul>
<h2 id="2-3-relayoutWindow-通过-wms-计算窗口大小"><a href="#2-3-relayoutWindow-通过-wms-计算窗口大小" class="headerlink" title="2.3 relayoutWindow - 通过 wms 计算窗口大小"></a>2.3 relayoutWindow - 通过 wms 计算窗口大小</h2><p>请求 Wms 计算 Activity 窗口的大小以及过扫描区域边衬大小和可见区域边衬大小，同时返回可用的 Surface：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">relayoutWindow</span><span class="params">(WindowManager.LayoutParams params, <span class="keyword">int</span> viewVisibility,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> insetsPending)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> appScale = mAttachInfo.mApplicationScale;</span><br><span class="line">    <span class="keyword">boolean</span> restore = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (params != <span class="keyword">null</span> &amp;&amp; mTranslator != <span class="keyword">null</span>) &#123;</span><br><span class="line">        restore = <span class="keyword">true</span>;</span><br><span class="line">        params.backup();</span><br><span class="line">        mTranslator.translateWindowLayout(params);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (params != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DBG) Log.d(mTag, <span class="string">"WindowLayout in layoutWindow:"</span> + params);</span><br><span class="line">    &#125;</span><br><span class="line">    mPendingConfiguration.seq = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//Log.d(mTag, "&gt;&gt;&gt;&gt;&gt;&gt; CALLING relayout");</span></span><br><span class="line">    <span class="keyword">if</span> (params != <span class="keyword">null</span> &amp;&amp; mOrigWindowType != params.type) &#123;</span><br><span class="line">        <span class="comment">// For compatibility with old apps, don't crash here.</span></span><br><span class="line">        <span class="keyword">if</span> (mTargetSdkVersion &lt; Build.VERSION_CODES.ICE_CREAM_SANDWICH) &#123;</span><br><span class="line">            Slog.w(mTag, <span class="string">"Window type can not be changed after "</span></span><br><span class="line">                    + <span class="string">"the window is added; ignoring change of "</span> + mView);</span><br><span class="line">            params.type = mOrigWindowType;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【*1】通过 WindowSession 来请求 relayout；</span></span><br><span class="line">    <span class="comment">// 我们会传入 W 实例，布局参数 params，以及 view 的测量宽高，以及可见性，边衬边框，以及 Surface 对象；</span></span><br><span class="line">    <span class="comment">// 通过 request 后，surface 才是有效的；</span></span><br><span class="line">    <span class="keyword">int</span> relayoutResult = mWindowSession.relayout(</span><br><span class="line">            mWindow, mSeq, params,</span><br><span class="line">            (<span class="keyword">int</span>) (mView.getMeasuredWidth() * appScale + <span class="number">0.5f</span>),</span><br><span class="line">            (<span class="keyword">int</span>) (mView.getMeasuredHeight() * appScale + <span class="number">0.5f</span>),</span><br><span class="line">            viewVisibility, insetsPending ? WindowManagerGlobal.RELAYOUT_INSETS_PENDING : <span class="number">0</span>,</span><br><span class="line">            mWinFrame, mPendingOverscanInsets, mPendingContentInsets, mPendingVisibleInsets,</span><br><span class="line">            mPendingStableInsets, mPendingOutsets, mPendingBackDropFrame, mPendingConfiguration,</span><br><span class="line">            mSurface);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//【2】在多窗口中，我们强制显示导航栏。</span></span><br><span class="line">    mPendingAlwaysConsumeNavBar =</span><br><span class="line">            (relayoutResult &amp; WindowManagerGlobal.RELAYOUT_RES_CONSUME_ALWAYS_NAV_BAR) != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Log.d(mTag, "&lt;&lt;&lt;&lt;&lt;&lt; BACK FROM relayout");</span></span><br><span class="line">    <span class="keyword">if</span> (restore) &#123;</span><br><span class="line">        params.restore();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mTranslator != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mTranslator.translateRectInScreenToAppWinFrame(mWinFrame);</span><br><span class="line">        mTranslator.translateRectInScreenToAppWindow(mPendingOverscanInsets);</span><br><span class="line">        mTranslator.translateRectInScreenToAppWindow(mPendingContentInsets);</span><br><span class="line">        mTranslator.translateRectInScreenToAppWindow(mPendingVisibleInsets);</span><br><span class="line">        mTranslator.translateRectInScreenToAppWindow(mPendingStableInsets);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> relayoutResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这里的核心逻辑就是：</p>
<ul>
<li>通过 WindowSession 来请求 wms 计算 view 的宽高；</li>
<li>同时会初始化 mWinFrame, mPendingOverscanInsets,  mPendingContentInsets,  mPendingVisibleInsets,  mPendingStableInsets, mPendingOutsets,  mPendingBackDropFrame,  mPendingConfiguration,  mSurface，对于 Surface，触发其 readFromParcel 方法；</li>
</ul>
<p>我们去看看 IWindowSession.aidl 文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">relayout</span><span class="params">(IWindow window, <span class="keyword">int</span> seq, in WindowManager.LayoutParams attrs,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> requestedWidth, <span class="keyword">int</span> requestedHeight, <span class="keyword">int</span> viewVisibility,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> flags, out Rect outFrame, out Rect outOverscanInsets,</span></span></span><br><span class="line"><span class="function"><span class="params">        out Rect outContentInsets, out Rect outVisibleInsets, out Rect outStableInsets,</span></span></span><br><span class="line"><span class="function"><span class="params">        out Rect outOutsets, out Rect outBackdropFrame, out Configuration outConfig,</span></span></span><br><span class="line"><span class="function"><span class="params">        out Surface outSurface)</span></span>;</span><br></pre></td></tr></table></figure>
<p>可以看到，我们初始化的那几个成员变量都是用 out 修饰的，这里我们简单回顾下 in 和 out 的区别：</p>
<ul>
<li>in 修饰的参数传递到服务方，服务方对实参的任何改变，不会反应给调用方。</li>
<li>out 修饰的参数，不会真正传到服务方，只是传一个实参的初始值过去，但服务方对实参的任何改变，在调用结束后会反应给调用方。<ul>
<li>这里实参只是作为返回值来使用的，这样除了 return 那里的返回值，还可以返回另外的东西；</li>
</ul>
</li>
<li>inout 参数则是上面二者的结合，实参会顺利传到服务方，且服务方对实参的任何改变，在调用结束后会反应回调用方。</li>
</ul>
<h2 id="2-4-performMeasure-测量"><a href="#2-4-performMeasure-测量" class="headerlink" title="2.4 performMeasure - 测量"></a>2.4 performMeasure - 测量</h2><p>这里的参数：childWidthMeasureSpec 和 childHeightMeasureSpec 是 root view，也就是 DecorView 的测量标准！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performMeasure</span><span class="params">(<span class="keyword">int</span> childWidthMeasureSpec, <span class="keyword">int</span> childHeightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">"measure"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//【1】最终调用了 DecorView（ViewGroup）的 measure 方法，并讲自身的测量规范传递下去；</span></span><br><span class="line">        mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 mView.measure 我们在下一篇文章中分析：</p>
<h2 id="2-5-performLayout-布局"><a href="#2-5-performLayout-布局" class="headerlink" title="2.5 performLayout - 布局"></a>2.5 performLayout - 布局</h2><p>开始布局：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performLayout</span><span class="params">(WindowManager.LayoutParams lp, <span class="keyword">int</span> desiredWindowWidth,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> desiredWindowHeight)</span> </span>&#123;</span><br><span class="line">    mLayoutRequested = <span class="keyword">false</span>;</span><br><span class="line">    mScrollMayChange = <span class="keyword">true</span>;</span><br><span class="line">    mInLayout = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> View host = mView;</span><br><span class="line">    <span class="keyword">if</span> (host == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_ORIENTATION || DEBUG_LAYOUT) &#123;</span><br><span class="line">        Log.v(mTag, <span class="string">"Laying out "</span> + host + <span class="string">" to ("</span> +</span><br><span class="line">                host.getMeasuredWidth() + <span class="string">", "</span> + host.getMeasuredHeight() + <span class="string">")"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">"layout"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//【1-core】调用 DecorView（GroupView）的 layout；</span></span><br><span class="line">        host.layout(<span class="number">0</span>, <span class="number">0</span>, host.getMeasuredWidth(), host.getMeasuredHeight());</span><br><span class="line"></span><br><span class="line">        mInLayout = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> numViewsRequestingLayout = mLayoutRequesters.size();</span><br><span class="line">        <span class="comment">//【2】如果 mLayoutRequesters 大小不为 0 ；说明我们在布局的过程中调用了 requestLayout 方法；</span></span><br><span class="line">        <span class="keyword">if</span> (numViewsRequestingLayout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 在布局期间调用了 requestLayout()。</span></span><br><span class="line">            <span class="comment">// 如果在请求的视图上未设置布局请求标志，则没有问题。</span></span><br><span class="line">            <span class="comment">// 如果某些请求仍在等待处理中，那么我们需要清除这些标志并进行完整的请求/度量/布局传递以处理这种情况。</span></span><br><span class="line">            <span class="comment">//【--&gt;2.5.1】获取有效的布局请求；</span></span><br><span class="line">            ArrayList&lt;View&gt; validLayoutRequesters = getValidLayoutRequesters(mLayoutRequesters,</span><br><span class="line">                    <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (validLayoutRequesters != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//【3】设置此标志，表示即将进入第二次布局中，这样的话，如果再发起 requestlayout 的话；</span></span><br><span class="line">                <span class="comment">// 这些请求会延迟到下一帧</span></span><br><span class="line">                mHandlingLayoutInLayoutRequest = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//【4】处理有效的布局请求；</span></span><br><span class="line">                <span class="keyword">int</span> numValidRequests = validLayoutRequesters.size();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numValidRequests; ++i) &#123;</span><br><span class="line">                    <span class="keyword">final</span> View view = validLayoutRequesters.get(i);</span><br><span class="line">                    Log.w(<span class="string">"View"</span>, <span class="string">"requestLayout() improperly called by "</span> + view +</span><br><span class="line">                            <span class="string">" during layout: running second layout pass"</span>);</span><br><span class="line">                    <span class="comment">//【4.1-core】调用每一个 View 的 layout 方法；</span></span><br><span class="line">                    view.requestLayout();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//【--&gt;2.2】再次预测量；</span></span><br><span class="line">                measureHierarchy(host, lp, mView.getContext().getResources(),</span><br><span class="line">                        desiredWindowWidth, desiredWindowHeight);</span><br><span class="line">                mInLayout = <span class="keyword">true</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//【5-core】调用 DecorView（GroupView）的 layout，再次布局；</span></span><br><span class="line">                host.layout(<span class="number">0</span>, <span class="number">0</span>, host.getMeasuredWidth(), host.getMeasuredHeight());</span><br><span class="line"></span><br><span class="line">                mHandlingLayoutInLayoutRequest = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//【--&gt;2.5.1】再次获取有效的布局请求，注意这里第二个参数传入的是 true</span></span><br><span class="line">                <span class="comment">// 这次不会清除布局标志，因为在第二次布局中的请求会延迟到下一帧;</span></span><br><span class="line">                validLayoutRequesters = getValidLayoutRequesters(mLayoutRequesters, <span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">if</span> (validLayoutRequesters != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">final</span> ArrayList&lt;View&gt; finalRequesters = validLayoutRequesters;</span><br><span class="line">                    <span class="comment">//【6】将第二次的请求发布到下一帧，这个 runnable 会在 performTraversals 中执行；</span></span><br><span class="line">                    getRunQueue().post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">int</span> numValidRequests = finalRequesters.size();</span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numValidRequests; ++i) &#123;</span><br><span class="line">                                <span class="keyword">final</span> View view = finalRequesters.get(i);</span><br><span class="line">                                Log.w(<span class="string">"View"</span>, <span class="string">"requestLayout() improperly called by "</span> + view +</span><br><span class="line">                                        <span class="string">" during second layout pass: posting in next frame"</span>);</span><br><span class="line">                                <span class="comment">//【6.1】触发 requestLayout 方法！</span></span><br><span class="line">                                view.requestLayout();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">    &#125;</span><br><span class="line">    mInLayout = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心就是 ViewGroup 的 layout！！</p>
<p>我们这里会再看到有一个 list 列表：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;View&gt; mLayoutRequesters = <span class="keyword">new</span> ArrayList&lt;View&gt;();</span><br></pre></td></tr></table></figure>
<p>当一个 View.requestLayout() 方法被调用的时候，如果此时处于布局中，那么该 view 会被添加到 mLayoutRequesters 中：</p>
<ul>
<li><strong>requestLayoutDuringLayout</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">requestLayoutDuringLayout</span><span class="params">(<span class="keyword">final</span> View view)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (view.mParent == <span class="keyword">null</span> || view.mAttachInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//【1】没有 parent 或者 mAttachInfo 为 null，那么其绑定异常，返回 true，对于这种情况，则不会触发布局；</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【2】将其加入到 mLayoutRequesters 列表中；</span></span><br><span class="line">    <span class="keyword">if</span> (!mLayoutRequesters.contains(view)) &#123;</span><br><span class="line">        mLayoutRequesters.add(view);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class="line">        <span class="comment">//【3】表示是在第一次布局过程收到的请求，返回 true，下面会强制二次布局；</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//【4】表示是在第二次强制布局过程收到的请求，返回 false，推迟到下一帧；</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（下面来自方法的翻译，感觉已经很清晰了）</p>
<p>一般不应该在布局过程中调用 requestLayout 方法，也就是说：正常情况下，应该是对该容器层次结构中的所有子级进行统一的一次性测量并在布局结束后进行统一布局。</p>
<p>如果仍然调用 requestLayout()，我们将通过在帧进行过程中将这些请求缓存下来，在布局结束后，我们会检查下，看是否还有待处理的布局请求，表示它们未被其容器层次结构正确处理。</p>
<p>如果真是这样，我们将清除树中的所有此类标志，并在该帧中强制第二次请求/度量/布局传递。<br>如果在第二次布局传递过程中收到了更多的 requestLayout 调用，我们会将这些请求发布到下一帧，以避免可能的无限循环。</p>
<p>此方法的返回值指示请求是否应该继续二次布局（如果是在第一次布局过程中收到的请求）<br>还是应该跳过并发布到下一个帧（如果是在第二个过程中收到的请求）</p>
<h3 id="2-5-1-getValidLayoutRequesters"><a href="#2-5-1-getValidLayoutRequesters" class="headerlink" title="2.5.1 getValidLayoutRequesters"></a>2.5.1 getValidLayoutRequesters</h3><p>获取有效的布局请求！</p>
<p>如果在布局期间调用了 requestLayout 方法，则在布局期间会出发此方法。</p>
<p>它遍历了请求布局的视图列表，以根据层次结构中的可见性以及是否已经处理了它们来确定仍需要布局的视图（通常是 ListView 子级的情况）。</p>
<ul>
<li>参数 layoutRequesters 保存的是 requestLayoutDuringLayout 的 View；</li>
<li>参数 secondLayoutRequests 表示的是是否是第二次布局，第一次布局时传入的 false；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ArrayList&lt;View&gt; <span class="title">getValidLayoutRequesters</span><span class="params">(ArrayList&lt;View&gt; layoutRequesters,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> secondLayoutRequests)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numViewsRequestingLayout = layoutRequesters.size();</span><br><span class="line">    ArrayList&lt;View&gt; validLayoutRequesters = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//【1】遍历 layoutRequesters 中的 view；</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numViewsRequestingLayout; ++i) &#123;</span><br><span class="line">        View view = layoutRequesters.get(i);</span><br><span class="line">        <span class="comment">//【2】如果 view 已经绑定完成，并且 本次是第二次布局或者 view 仅设置了 PFLAG_FORCE_LAYOUT 标识位；</span></span><br><span class="line">        <span class="keyword">if</span> (view != <span class="keyword">null</span> &amp;&amp; view.mAttachInfo != <span class="keyword">null</span> &amp;&amp; view.mParent != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                (secondLayoutRequests || (view.mPrivateFlags &amp; View.PFLAG_FORCE_LAYOUT) ==</span><br><span class="line">                        View.PFLAG_FORCE_LAYOUT)) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> gone = <span class="keyword">false</span>;</span><br><span class="line">            View parent = view;</span><br><span class="line">            <span class="comment">//【3】这里看到，只会对非 gone 层次结构的视图重新触发布局；no gone 的 view 会被加入到 </span></span><br><span class="line">            <span class="comment">// validLayoutRequesters 中；</span></span><br><span class="line">            <span class="keyword">while</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((parent.mViewFlags &amp; View.VISIBILITY_MASK) == View.GONE) &#123;</span><br><span class="line">                    gone = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 这里是判断 view 以及其 parent 是否有 gone，只要有就算 gone！</span></span><br><span class="line">                <span class="keyword">if</span> (parent.mParent <span class="keyword">instanceof</span> View) &#123;</span><br><span class="line">                    parent = (View) parent.mParent;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    parent = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!gone) &#123;</span><br><span class="line">                <span class="keyword">if</span> (validLayoutRequesters == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    validLayoutRequesters = <span class="keyword">new</span> ArrayList&lt;View&gt;();</span><br><span class="line">                &#125;</span><br><span class="line">                validLayoutRequesters.add(view);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【4】对于第一次布局，这里会清空掉 view 的 PFLAG_FORCE_LAYOUT 标志位；</span></span><br><span class="line">    <span class="comment">// 对于 view 以及其 parent 都要清掉；</span></span><br><span class="line">    <span class="keyword">if</span> (!secondLayoutRequests) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numViewsRequestingLayout; ++i) &#123;</span><br><span class="line">            View view = layoutRequesters.get(i);</span><br><span class="line">            <span class="keyword">while</span> (view != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                    (view.mPrivateFlags &amp; View.PFLAG_FORCE_LAYOUT) != <span class="number">0</span>) &#123;</span><br><span class="line">                view.mPrivateFlags &amp;= ~View.PFLAG_FORCE_LAYOUT;</span><br><span class="line">                <span class="keyword">if</span> (view.mParent <span class="keyword">instanceof</span> View) &#123;</span><br><span class="line">                    view = (View) view.mParent;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    view = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【5】清空 mLayoutRequesters，然后返回 validLayoutRequesters；</span></span><br><span class="line">    layoutRequesters.clear();</span><br><span class="line">    <span class="keyword">return</span> validLayoutRequesters;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不多说了！</p>
<h2 id="2-6-performDraw-绘制"><a href="#2-6-performDraw-绘制" class="headerlink" title="2.6 performDraw - 绘制"></a>2.6 performDraw - 绘制</h2><p>开始绘制：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performDraw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】如果屏幕状态是灭屏，或者不需要 next draw，那就不绘制；</span></span><br><span class="line">    <span class="keyword">if</span> (mAttachInfo.mDisplayState == Display.STATE_OFF &amp;&amp; !mReportNextDraw) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> fullRedrawNeeded = mFullRedrawNeeded; <span class="comment">// 判断是否全量绘制；</span></span><br><span class="line">    mFullRedrawNeeded = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    mIsDrawing = <span class="keyword">true</span>;</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">"draw"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//【--&gt;2.6.1】执行绘制；</span></span><br><span class="line">        draw(fullRedrawNeeded);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mIsDrawing = <span class="keyword">false</span>;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// For whatever reason we didn't create a HardwareRenderer, end any</span></span><br><span class="line">    <span class="comment">// hardware animations that are now dangling</span></span><br><span class="line">    <span class="keyword">if</span> (mAttachInfo.mPendingAnimatingRenderNodes != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> count = mAttachInfo.mPendingAnimatingRenderNodes.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            mAttachInfo.mPendingAnimatingRenderNodes.get(i).endAllAnimators();</span><br><span class="line">        &#125;</span><br><span class="line">        mAttachInfo.mPendingAnimatingRenderNodes.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mReportNextDraw) &#123;</span><br><span class="line">        mReportNextDraw = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if we're using multi-thread renderer, wait for the window frame draws</span></span><br><span class="line">        <span class="keyword">if</span> (mWindowDrawCountDown != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mWindowDrawCountDown.await();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                Log.e(mTag, <span class="string">"Window redraw count down interruped!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            mWindowDrawCountDown = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mAttachInfo.mHardwareRenderer != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mAttachInfo.mHardwareRenderer.fence();</span><br><span class="line">            mAttachInfo.mHardwareRenderer.setStopped(mStopped);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (LOCAL_LOGV) &#123;</span><br><span class="line">            Log.v(mTag, <span class="string">"FINISHED DRAWING: "</span> + mWindowAttributes.getTitle());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 window 创建了 mSurfaceHolder，并且 surface 是有效的，那就要触发回调；</span></span><br><span class="line">        <span class="comment">// 这里的 mSurfaceHolder 一般是 null；</span></span><br><span class="line">        <span class="keyword">if</span> (mSurfaceHolder != <span class="keyword">null</span> &amp;&amp; mSurface.isValid()) &#123;</span><br><span class="line">            mSurfaceHolderCallback.surfaceRedrawNeeded(mSurfaceHolder);</span><br><span class="line">            SurfaceHolder.Callback callbacks[] = mSurfaceHolder.getCallbacks();</span><br><span class="line">            <span class="keyword">if</span> (callbacks != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (SurfaceHolder.Callback c : callbacks) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (c <span class="keyword">instanceof</span> SurfaceHolder.Callback2) &#123;</span><br><span class="line">                        ((SurfaceHolder.Callback2)c).surfaceRedrawNeeded(mSurfaceHolder);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//【2】通过 Window Session </span></span><br><span class="line">            mWindowSession.finishDrawing(mWindow);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-6-1-draw"><a href="#2-6-1-draw" class="headerlink" title="2.6.1 draw"></a>2.6.1 draw</h3><p>执行绘制：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">boolean</span> fullRedrawNeeded)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】这个是否的 Surface 已经是有效的了；</span></span><br><span class="line">    Surface surface = mSurface;</span><br><span class="line">    <span class="keyword">if</span> (!surface.isValid()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG_FPS) &#123;</span><br><span class="line">        trackFPS(); <span class="comment">// debug 相关；</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!sFirstDrawComplete) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (sFirstDrawHandlers) &#123;</span><br><span class="line">            sFirstDrawComplete = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> count = sFirstDrawHandlers.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; count; i++) &#123;</span><br><span class="line">                mHandler.post(sFirstDrawHandlers.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    scrollToRectOrFocus(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】如果 view 的 scroll 变化了，触发 TreeObserver.dispatchOnScrollChanged 方法；</span></span><br><span class="line">    <span class="keyword">if</span> (mAttachInfo.mViewScrollChanged) &#123;</span><br><span class="line">        mAttachInfo.mViewScrollChanged = <span class="keyword">false</span>;</span><br><span class="line">        mAttachInfo.mTreeObserver.dispatchOnScrollChanged();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> animating = mScroller != <span class="keyword">null</span> &amp;&amp; mScroller.computeScrollOffset();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> curScrollY;</span><br><span class="line">    <span class="keyword">if</span> (animating) &#123;</span><br><span class="line">        curScrollY = mScroller.getCurrY();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        curScrollY = mScrollY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mCurScrollY != curScrollY) &#123;</span><br><span class="line">        mCurScrollY = curScrollY;</span><br><span class="line">        fullRedrawNeeded = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (mView <span class="keyword">instanceof</span> RootViewSurfaceTaker) &#123;</span><br><span class="line">            ((RootViewSurfaceTaker) mView).onRootViewScrollYChanged(mCurScrollY);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> appScale = mAttachInfo.mApplicationScale;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> scalingRequired = mAttachInfo.mScalingRequired;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> resizeAlpha = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//【3】处理要绘制的区域 mDirty，首先是先获取了 mDirty 值，该值保存了需要重绘的区域的信息；</span></span><br><span class="line">    <span class="keyword">final</span> Rect dirty = mDirty;</span><br><span class="line">    <span class="keyword">if</span> (mSurfaceHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 不绘制 app 自己持有的 surface；</span></span><br><span class="line">        dirty.setEmpty();</span><br><span class="line">        <span class="keyword">if</span> (animating &amp;&amp; mScroller != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mScroller.abortAnimation();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【4】判断下是否是全量绘制，如果是的话，那么 dirty 就是整个 window 的范围了，表示整个视图都需要绘制</span></span><br><span class="line">    <span class="comment">// 第一次绘制流程，需要绘制所有视图；</span></span><br><span class="line">    <span class="keyword">if</span> (fullRedrawNeeded) &#123;</span><br><span class="line">        mAttachInfo.mIgnoreDirtyState = <span class="keyword">true</span>;</span><br><span class="line">        dirty.set(<span class="number">0</span>, <span class="number">0</span>, (<span class="keyword">int</span>) (mWidth * appScale + <span class="number">0.5f</span>), (<span class="keyword">int</span>) (mHeight * appScale + <span class="number">0.5f</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG_ORIENTATION || DEBUG_DRAW) &#123;</span><br><span class="line">        Log.v(mTag, <span class="string">"Draw "</span> + mView + <span class="string">"/"</span></span><br><span class="line">                + mWindowAttributes.getTitle()</span><br><span class="line">                + <span class="string">": dirty=&#123;"</span> + dirty.left + <span class="string">","</span> + dirty.top</span><br><span class="line">                + <span class="string">","</span> + dirty.right + <span class="string">","</span> + dirty.bottom + <span class="string">"&#125; surface="</span></span><br><span class="line">                + surface + <span class="string">" surface.isValid()="</span> + surface.isValid() + <span class="string">", appScale:"</span> +</span><br><span class="line">                appScale + <span class="string">", width="</span> + mWidth + <span class="string">", height="</span> + mHeight);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【5】触发 TreeObserver.dispatchOnDraw 方法；</span></span><br><span class="line">    mAttachInfo.mTreeObserver.dispatchOnDraw();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> xOffset = -mCanvasOffsetX;</span><br><span class="line">    <span class="keyword">int</span> yOffset = -mCanvasOffsetY + curScrollY;</span><br><span class="line">    <span class="keyword">final</span> WindowManager.LayoutParams params = mWindowAttributes;</span><br><span class="line">    <span class="keyword">final</span> Rect surfaceInsets = params != <span class="keyword">null</span> ? params.surfaceInsets : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (surfaceInsets != <span class="keyword">null</span>) &#123;</span><br><span class="line">        xOffset -= surfaceInsets.left;</span><br><span class="line">        yOffset -= surfaceInsets.top;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Offset dirty rect for surface insets.</span></span><br><span class="line">        dirty.offset(surfaceInsets.left, surfaceInsets.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> accessibilityFocusDirty = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">final</span> Drawable drawable = mAttachInfo.mAccessibilityFocusDrawable;</span><br><span class="line">    <span class="keyword">if</span> (drawable != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> Rect bounds = mAttachInfo.mTmpInvalRect;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> hasFocus = getAccessibilityFocusedRect(bounds);</span><br><span class="line">        <span class="keyword">if</span> (!hasFocus) &#123;</span><br><span class="line">            bounds.setEmpty();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!bounds.equals(drawable.getBounds())) &#123;</span><br><span class="line">            accessibilityFocusDirty = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mAttachInfo.mDrawingTime =</span><br><span class="line">            mChoreographer.getFrameTimeNanos() / TimeUtils.NANOS_PER_MS;</span><br><span class="line">    <span class="comment">//【6】下面就要进入绘制了；</span></span><br><span class="line">    <span class="keyword">if</span> (!dirty.isEmpty() || mIsAnimating || accessibilityFocusDirty) &#123;</span><br><span class="line">        <span class="comment">//【6.1】硬件绘制，当然前提是开启了硬件加速；</span></span><br><span class="line">        <span class="keyword">if</span> (mAttachInfo.mHardwareRenderer != <span class="keyword">null</span> &amp;&amp; mAttachInfo.mHardwareRenderer.isEnabled()) &#123;</span><br><span class="line">            <span class="comment">// If accessibility focus moved, always invalidate the root.</span></span><br><span class="line">            <span class="keyword">boolean</span> invalidateRoot = accessibilityFocusDirty || mInvalidateRootRequested;</span><br><span class="line">            mInvalidateRootRequested = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            mIsAnimating = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mHardwareYOffset != yOffset || mHardwareXOffset != xOffset) &#123;</span><br><span class="line">                mHardwareYOffset = yOffset;</span><br><span class="line">                mHardwareXOffset = xOffset;</span><br><span class="line">                invalidateRoot = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (invalidateRoot) &#123;</span><br><span class="line">                mAttachInfo.mHardwareRenderer.invalidateRoot();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dirty.setEmpty();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新绘制的内容大小。它将在 draw 命令发送到渲染器之前不久将其传输到渲染器。</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> updated = updateContentDrawBounds();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mReportNextDraw) &#123;</span><br><span class="line">                <span class="comment">// mReportNextDraw 会覆盖 setStop 方法，在处理完 reportNextDraw 的绘制后</span></span><br><span class="line">                <span class="comment">// 值；会恢复；</span></span><br><span class="line">                mAttachInfo.mHardwareRenderer.setStopped(<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (updated) &#123;</span><br><span class="line">                requestDrawWindow();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//【6.2】使用 render thread 进行绘制，这个是在另外一个线程中；</span></span><br><span class="line">            mAttachInfo.mHardwareRenderer.draw(mView, mAttachInfo, <span class="keyword">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//【6.3】软件绘制；</span></span><br><span class="line"><span class="comment">// 如果硬件渲染被禁，但是本次绘制缺请求了硬件渲染，那么这里会执行初始化硬件渲染；</span></span><br><span class="line">            <span class="keyword">if</span> (mAttachInfo.mHardwareRenderer != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                    !mAttachInfo.mHardwareRenderer.isEnabled() &amp;&amp;</span><br><span class="line">                    mAttachInfo.mHardwareRenderer.isRequested()) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//【6.4】初始化硬件渲染；</span></span><br><span class="line">                    mAttachInfo.mHardwareRenderer.initializeIfNeeded(</span><br><span class="line">                            mWidth, mHeight, mAttachInfo, mSurface, surfaceInsets);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (OutOfResourcesException e) &#123;</span><br><span class="line">                    handleOutOfResourcesException(e);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                mFullRedrawNeeded = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">//【6.5-core】请求下一帧；</span></span><br><span class="line">                scheduleTraversals();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//【--&gt;2.6.2】执行软件绘制，返回值表示绘制是否成功；</span></span><br><span class="line">            <span class="keyword">if</span> (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (animating) &#123;</span><br><span class="line">        mFullRedrawNeeded = <span class="keyword">true</span>;</span><br><span class="line">        scheduleTraversals();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心逻辑是：</p>
<ul>
<li>如果是硬件绘制，那就通过 mHardwareRenderer draw，这个是在 render 线程；</li>
<li>如果是软件绘制，那就通过 drawSoftware 触发 view draw，这个是在主线程；</li>
</ul>
<h3 id="2-6-2-drawSoftware-软件绘制"><a href="#2-6-2-drawSoftware-软件绘制" class="headerlink" title="2.6.2 drawSoftware - 软件绘制"></a>2.6.2 drawSoftware - 软件绘制</h3><p>软件绘制开始：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">drawSoftware</span><span class="params">(Surface surface, AttachInfo attachInfo, <span class="keyword">int</span> xoff, <span class="keyword">int</span> yoff,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> scalingRequired, Rect dirty)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Canvas canvas;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> left = dirty.left;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> top = dirty.top;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> right = dirty.right;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> bottom = dirty.bottom;</span><br><span class="line">        <span class="comment">//【1】锁定 canvas，canvas 的大小由 dirty 区域决定；</span></span><br><span class="line">        canvas = mSurface.lockCanvas(dirty);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The dirty rectangle can be modified by Surface.lockCanvas()</span></span><br><span class="line">        <span class="comment">// noinspection ConstantConditions</span></span><br><span class="line">        <span class="keyword">if</span> (left != dirty.left || top != dirty.top || right != dirty.right</span><br><span class="line">                || bottom != dirty.bottom) &#123;</span><br><span class="line">            attachInfo.mIgnoreDirtyState = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//【2】设置像素信息；</span></span><br><span class="line">        canvas.setDensity(mDensity);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Surface.OutOfResourcesException e) &#123;</span><br><span class="line">        handleOutOfResourcesException(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">        Log.e(mTag, <span class="string">"Could not lock surface"</span>, e);</span><br><span class="line">        <span class="comment">// Don't assume this is due to out of memory, it could be</span></span><br><span class="line">        <span class="comment">// something else, and if it is something else then we could</span></span><br><span class="line">        <span class="comment">// kill stuff (or ourself) for no reason.</span></span><br><span class="line">        mLayoutRequested = <span class="keyword">true</span>;    <span class="comment">// ask wm for a new surface next time.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_ORIENTATION || DEBUG_DRAW) &#123;</span><br><span class="line">            Log.v(mTag, <span class="string">"Surface "</span> + surface + <span class="string">" drawing to bitmap w="</span></span><br><span class="line">                    + canvas.getWidth() + <span class="string">", h="</span> + canvas.getHeight());</span><br><span class="line">            <span class="comment">//canvas.drawARGB(255, 255, 0, 0);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果该位图的格式包含 Alpha 通道，则我们需要在绘制之前清除它，以便 child 可以在透明背景上正确地重新组合其图形。</span></span><br><span class="line">        <span class="comment">// 这将自动考虑裁剪区域或者脏区，或者如果我们要应用偏移，则需要清除没有出现偏移的区域，以避免在空白区域中留下垃圾。</span></span><br><span class="line">        <span class="keyword">if</span> (!canvas.isOpaque() || yoff != <span class="number">0</span> || xoff != <span class="number">0</span>) &#123;</span><br><span class="line">            canvas.drawColor(<span class="number">0</span>, PorterDuff.Mode.CLEAR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dirty.setEmpty(); <span class="comment">// 将 dirty 区域置空；</span></span><br><span class="line">        mIsAnimating = <span class="keyword">false</span>;</span><br><span class="line">        mView.mPrivateFlags |= View.PFLAG_DRAWN;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DEBUG_DRAW) &#123;</span><br><span class="line">            Context cxt = mView.getContext();</span><br><span class="line">            Log.i(mTag, <span class="string">"Drawing: package:"</span> + cxt.getPackageName() +</span><br><span class="line">                    <span class="string">", metrics="</span> + cxt.getResources().getDisplayMetrics() +</span><br><span class="line">                    <span class="string">", compatibilityInfo="</span> + cxt.getResources().getCompatibilityInfo());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            canvas.translate(-xoff, -yoff);</span><br><span class="line">            <span class="keyword">if</span> (mTranslator != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mTranslator.translateCanvas(canvas);</span><br><span class="line">            &#125;</span><br><span class="line">            canvas.setScreenDensity(scalingRequired ? mNoncompatDensity : <span class="number">0</span>);</span><br><span class="line">            attachInfo.mSetIgnoreDirtyState = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//【2-core】调用 DecorView（GroupView）的 draw 方法；</span></span><br><span class="line">            mView.draw(canvas);</span><br><span class="line"></span><br><span class="line">            drawAccessibilityFocusedDrawableIfNeeded(canvas);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!attachInfo.mSetIgnoreDirtyState) &#123;</span><br><span class="line">                <span class="comment">// Only clear the flag if it was not set during the mView.draw() call</span></span><br><span class="line">                attachInfo.mIgnoreDirtyState = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//【3】解锁 canvas</span></span><br><span class="line">            surface.unlockCanvasAndPost(canvas);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">            Log.e(mTag, <span class="string">"Could not unlock surface"</span>, e);</span><br><span class="line">            mLayoutRequested = <span class="keyword">true</span>;    <span class="comment">// ask wm for a new surface next time.</span></span><br><span class="line">            <span class="comment">//noinspection ReturnInsideFinallyBlock</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (LOCAL_LOGV) &#123;</span><br><span class="line">            Log.v(mTag, <span class="string">"Surface "</span> + surface + <span class="string">" unlockCanvasAndPost"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心逻辑：</p>
<ul>
<li>锁定 canvas，并返回一个 Canvas，大小和 dirty 一样；</li>
<li>调用 DecorView 的 draw 方法开始绘制；</li>
</ul>
<h1 id="2-mid-DecorView"><a href="#2-mid-DecorView" class="headerlink" title="2-mid DecorView"></a>2-mid DecorView</h1><h2 id="2-1-mid-onAttachedToWindow"><a href="#2-1-mid-onAttachedToWindow" class="headerlink" title="2.1-mid onAttachedToWindow"></a>2.1-mid onAttachedToWindow</h2><p>DecorView 复写了这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onAttachedToWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">//【--&gt;4.1.3】这里是先调用了父类 View 的方法；</span></span><br><span class="line">     <span class="keyword">super</span>.onAttachedToWindow();</span><br><span class="line">     <span class="comment">//【1】通过 PhoneWindow 获取回调 callback，实际上是 Activity，这里其实是触发</span></span><br><span class="line">     <span class="comment">// Activity.onAttachedToWindow；</span></span><br><span class="line">     <span class="keyword">final</span> Window.Callback cb = mWindow.getCallback();</span><br><span class="line">     <span class="keyword">if</span> (cb != <span class="keyword">null</span> &amp;&amp; !mWindow.isDestroyed() &amp;&amp; mFeatureId &lt; <span class="number">0</span>) &#123;</span><br><span class="line">         cb.onAttachedToWindow();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (mFeatureId == -<span class="number">1</span>)  <span class="comment">// 针对于 activity 的情况；</span></span><br><span class="line"><span class="comment">// 窗口已经被绑定，这里会尝试恢复以前可能已打开的所有 panels。</span></span><br><span class="line">         <span class="comment">// 在活动因配置更改而被杀死并且菜单已打开的情况下，将调用此方法。</span></span><br><span class="line">         <span class="comment">// 重新创建活动后，应再次显示菜单（没看懂）。</span></span><br><span class="line">         mWindow.openPanelsAfterRestore();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (!mWindowResizeCallbacksAdded) &#123;</span><br><span class="line">         <span class="comment">//【2】这里会设置 window call back，就是 DecorView 到 ViewRootImpl 中；</span></span><br><span class="line">         getViewRootImpl().addWindowCallbacks(<span class="keyword">this</span>);</span><br><span class="line">         mWindowResizeCallbacksAdded = <span class="keyword">true</span>;</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mBackdropFrameRenderer != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">// 由于配置更改，大小调整，这里是通知到渲染器；</span></span><br><span class="line">         mBackdropFrameRenderer.onConfigurationChange();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>这里的核心逻辑是：</p>
<ul>
<li>调用了 Activity.onAttachedToWindow 方法；</li>
<li>将 DecorView 作为 callback 注册到 ViewRootImpl 中；</li>
</ul>
<h1 id="3-ViewGroup"><a href="#3-ViewGroup" class="headerlink" title="3 ViewGroup"></a>3 ViewGroup</h1><p>由于 DecorView 是一个 FlameLayout，所以其本质是一个 ViewGroup，对于 DecorView，其 parent 是 ViewRootImpl，他需要 attach 到 ViewRootImpl 上才行：</p>
<h2 id="3-1-dispatchAttachedToWindow-核心（设置-attrachInfo）"><a href="#3-1-dispatchAttachedToWindow-核心（设置-attrachInfo）" class="headerlink" title="3.1 dispatchAttachedToWindow - 核心（设置 attrachInfo）"></a>3.1 dispatchAttachedToWindow - 核心（设置 attrachInfo）</h2><p>将 AttachInfo 设置到 ViewGroup 中，这个方法是从 DecorView 开始出发的！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchAttachedToWindow</span><span class="params">(AttachInfo info, <span class="keyword">int</span> visibility)</span> </span>&#123;</span><br><span class="line">    mGroupFlags |= FLAG_PREVENT_DISPATCH_ATTACHED_TO_WINDOW;</span><br><span class="line">    <span class="comment">//【--&gt;4.1】调用父类 View 的 dispatchAttachedToWindow；</span></span><br><span class="line">    <span class="keyword">super</span>.dispatchAttachedToWindow(info, visibility);</span><br><span class="line">    mGroupFlags &amp;= ~FLAG_PREVENT_DISPATCH_ATTACHED_TO_WINDOW;</span><br><span class="line">    <span class="comment">//【2】紧接着，处理 childs，可能是 View，也可能是 ViewGroup；</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> count = mChildrenCount;</span><br><span class="line">    <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> View child = children[i];</span><br><span class="line">        <span class="comment">//【--&gt;3.1/--&gt;4.1】调用 childs(ViewGroup/View)的 dispatchAttachedToWindow</span></span><br><span class="line">        <span class="comment">// 第二个参数：可见性，这里会在父亲可见性和 child 可见性中求最大值； </span></span><br><span class="line">        child.dispatchAttachedToWindow(info,</span><br><span class="line">                combineVisibility(visibility, child.getVisibility()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【3】对 TransientView 也会这样处理；</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> transientCount = mTransientIndices == <span class="keyword">null</span> ? <span class="number">0</span> : mTransientIndices.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; transientCount; ++i) &#123;</span><br><span class="line">        View view = mTransientViews.get(i);</span><br><span class="line">        <span class="comment">//【--&gt;3.1/--&gt;4.1】调用 childs(ViewGroup/View)的 dispatchAttachedToWindow</span></span><br><span class="line">        <span class="comment">// 第二个参数：可见性，这里会在父亲可见性和 child 可见性中求最大值；</span></span><br><span class="line">        view.dispatchAttachedToWindow(info,</span><br><span class="line">                combineVisibility(visibility, view.getVisibility()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，从 DecorView 开始对每一个 Child 都会 dispatchAttachedToWindow，将 mAttachInfo 设置进去；</p>
<h2 id="3-2-dispatchWindowVisibilityChanged"><a href="#3-2-dispatchWindowVisibilityChanged" class="headerlink" title="3.2 dispatchWindowVisibilityChanged"></a>3.2 dispatchWindowVisibilityChanged</h2><p>分发窗口改变给所有的 child：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchWindowVisibilityChanged</span><span class="params">(<span class="keyword">int</span> visibility)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【--&gt;4.2】自身父类的方法；</span></span><br><span class="line">    <span class="keyword">super</span>.dispatchWindowVisibilityChanged(visibility);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> count = mChildrenCount;</span><br><span class="line">    <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="comment">//【--&gt;3.2/--&gt;4.2】遍历每个孩子；</span></span><br><span class="line">        children[i].dispatchWindowVisibilityChanged(visibility);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-3-dispatchVisibilityAggregated"><a href="#3-3-dispatchVisibilityAggregated" class="headerlink" title="3.3 dispatchVisibilityAggregated"></a>3.3 dispatchVisibilityAggregated</h2><p>执行可见性合并给所有的 child：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">dispatchVisibilityAggregated</span><span class="params">(<span class="keyword">boolean</span> isVisible)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【--&gt;4.3】自身父类的方法；</span></span><br><span class="line">    isVisible = <span class="keyword">super</span>.dispatchVisibilityAggregated(isVisible);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> count = mChildrenCount;</span><br><span class="line">    <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="comment">//【--&gt;3.2/--&gt;4.2】遍历每个孩子；这里只会遍历看些用户可见的 view，因为不可见的 view 和他们 child tree</span></span><br><span class="line">        <span class="comment">// 清楚自身是不可见的，那么他们的不可见的状态不会变化；</span></span><br><span class="line">        <span class="keyword">if</span> (children[i].getVisibility() == VISIBLE) &#123;</span><br><span class="line">            children[i].dispatchVisibilityAggregated(isVisible);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isVisible;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-View"><a href="#4-View" class="headerlink" title="4 View"></a>4 View</h1><p>ViewGroup 的父类就是 View：</p>
<h2 id="4-1-dispatchAttachedToWindow-核心（设置-attrachInfo）"><a href="#4-1-dispatchAttachedToWindow-核心（设置-attrachInfo）" class="headerlink" title="4.1 dispatchAttachedToWindow - 核心（设置 attrachInfo）"></a>4.1 dispatchAttachedToWindow - 核心（设置 attrachInfo）</h2><p>这里来看看 View 中的操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchAttachedToWindow</span><span class="params">(AttachInfo info, <span class="keyword">int</span> visibility)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1-core】将 info 保存到 View 内部的 mAttachInfo 中；</span></span><br><span class="line">    mAttachInfo = info;</span><br><span class="line">    <span class="keyword">if</span> (mOverlay != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mOverlay.getOverlayView().dispatchAttachedToWindow(info, visibility);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【2】计数 +1；</span></span><br><span class="line">    mWindowAttachCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面可能会修改 drawable state 所以这里好设置标记，下面会更新；</span></span><br><span class="line">    mPrivateFlags |= PFLAG_DRAWABLE_STATE_DIRTY;</span><br><span class="line">    <span class="comment">//【3】如果 view 指定了单独的 TreeObserver，那么这里会进行一次合并；</span></span><br><span class="line">    <span class="keyword">if</span> (mFloatingTreeObserver != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//【--&gt;5.1】合并 mFloatingTreeObserver 到 info.mTreeObserver 中；</span></span><br><span class="line">        info.mTreeObserver.merge(mFloatingTreeObserver);</span><br><span class="line">        mFloatingTreeObserver = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//【--&gt;4.1.1】注册 Frame 监听器；</span></span><br><span class="line">    registerPendingFrameMetricsObservers();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((mPrivateFlags&amp;PFLAG_SCROLL_CONTAINER) != <span class="number">0</span>) &#123;</span><br><span class="line">        mAttachInfo.mScrollContainers.add(<span class="keyword">this</span>);</span><br><span class="line">        mPrivateFlags |= PFLAG_SCROLL_CONTAINER_ADDED;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//【4】执行所有 View.post 添加的 Runnable 任务！</span></span><br><span class="line">    <span class="keyword">if</span> (mRunQueue != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mRunQueue.executeActions(info.mHandler);</span><br><span class="line">        mRunQueue = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【--&gt;4.1.2】收集当前 view 的属性到 mAttachInfo 中，因为子 view 可能设置的属性和</span></span><br><span class="line">    <span class="comment">// DecorView 是不一样的；</span></span><br><span class="line">    performCollectViewAttributes(mAttachInfo, visibility);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//【--&gt;4.1.3】触发生命周期函数 onAttachedToWindow，这里要重点说下，DecorView 覆盖了这个方法</span></span><br><span class="line">    onAttachedToWindow();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【5】mListenerInfo 内部有很多的接口回调列表，他用来保存我们通过 View.setXXXXListener 设置的</span></span><br><span class="line">    <span class="comment">// 监听接口，比如 onClickLinsener 等等；</span></span><br><span class="line">    ListenerInfo li = mListenerInfo;</span><br><span class="line">    <span class="keyword">final</span> CopyOnWriteArrayList&lt;OnAttachStateChangeListener&gt; listeners =</span><br><span class="line">            li != <span class="keyword">null</span> ? li.mOnAttachStateChangeListeners : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (listeners != <span class="keyword">null</span> &amp;&amp; listeners.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (OnAttachStateChangeListener listener : listeners) &#123;</span><br><span class="line">            <span class="comment">//【5.1】调用通过 setOnAttachStateChangeListener 设置的</span></span><br><span class="line">            <span class="comment">// OnAttachStateChangeListener.onViewAttachedToWindow 方法；</span></span><br><span class="line">            listener.onViewAttachedToWindow(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【6】处理 window 可见性和 view 用户可见性的冲突；</span></span><br><span class="line">    <span class="keyword">int</span> vis = info.mWindowVisibility;</span><br><span class="line">    <span class="keyword">if</span> (vis != GONE) &#123;</span><br><span class="line">        <span class="comment">//【--&gt;4.1.4】生命周期 onWindowVisibilityChanged 方法；</span></span><br><span class="line">        <span class="comment">// 窗口可见性发生变化；</span></span><br><span class="line">        onWindowVisibilityChanged(vis);</span><br><span class="line">        <span class="comment">//【--&gt;4.1.5】判断 view 和其所有 parent 是否都用户可见，通过 current.mViewFlags 判断；</span></span><br><span class="line">        <span class="keyword">if</span> (isShown()) &#123;</span><br><span class="line">            <span class="comment">//【--&gt;4.1.6】因为 view 的用户可见性可能受 view 本身，parent view 或所属的 window 的影响。</span></span><br><span class="line">            <span class="comment">// 这里就会对二者的可见性做整合调整；</span></span><br><span class="line">            onVisibilityAggregated(vis == VISIBLE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接发送 onVisibilityChanged 而不是 dispatchVisibilityChanged。</span></span><br><span class="line">    <span class="comment">// 由于子树中的所有视图都将已经收到 dispatchAttachedToWindow，因此此处不再需要遍历子树。</span></span><br><span class="line">    <span class="comment">//【*7】生命周期函数 onVisibilityChanged 回调：说明 View 或者 view 的 parent 的可见性发生了变化；</span></span><br><span class="line">    onVisibilityChanged(<span class="keyword">this</span>, visibility);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((mPrivateFlags&amp;PFLAG_DRAWABLE_STATE_DIRTY) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//【*8】更新 view 的 drawable 状态；</span></span><br><span class="line">        refreshDrawableState();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【*9】判断是否需要重新计算属性</span></span><br><span class="line">    needGlobalAttributesUpdate(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看看核心的流程：</p>
<ul>
<li><strong>将 AttachInfo info 保存到 View.mAttachInfo 中，表示已经绑定；</strong></li>
<li>该 view 的 mWindowAttachCount 引用计数加 1，表示已经 attach 到了 window 上；</li>
<li>合并 view 的 TreeObserver 内部的监听接口到 info.mTreeObserver 中；</li>
<li>执行所有 View.post 添加的 Runnable 任务；</li>
<li>触发生命周期函数 onAttachedToWindow；</li>
<li>如果 view 通过 setOnAttachStateChangeListener 设置了监听器，触发其 OnAttachStateChangeListener.onViewAttachedToWindow 方法；</li>
<li>触发 view 生命周期 onWindowVisibilityChanged 方法；</li>
<li>触发 view 生命周期 onVisibilityChanged 方法；</li>
</ul>
<p>其他的一些函数：</p>
<ul>
<li><strong>onVisibilityChanged</strong></li>
</ul>
<p>对于 onVisibilityChanged 方法，View 并没有实现具体的逻辑，参数 View changedView 表示可见变化的 view，可能是 view 自身，也可能是 view 的 parent；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onVisibilityChanged</span><span class="params">(@NonNull View changedView, @Visibility <span class="keyword">int</span> visibility)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>refreshDrawableState</strong></li>
</ul>
<p>刷新 Drawable State：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refreshDrawableState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mPrivateFlags |= PFLAG_DRAWABLE_STATE_DIRTY;</span><br><span class="line">    <span class="comment">//【2】会触发 view 的 drawableStateChanged 方法；</span></span><br><span class="line">    drawableStateChanged();</span><br><span class="line"></span><br><span class="line">    ViewParent parent = mParent;</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//【2】如果有 parent，也会刷新 parent 的 Drawable State；</span></span><br><span class="line">        parent.childDrawableStateChanged(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以通过 getDrawableState 获取最新的 DrawableState；</p>
<ul>
<li><strong>needGlobalAttributesUpdate</strong></li>
</ul>
<p>用于判断是否需要更新全局属性，参数 force 表示是否强制更新：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">needGlobalAttributesUpdate</span><span class="params">(<span class="keyword">boolean</span> force)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AttachInfo ai = mAttachInfo;</span><br><span class="line">    <span class="keyword">if</span> (ai != <span class="keyword">null</span> &amp;&amp; !ai.mRecomputeGlobalAttributes) &#123;</span><br><span class="line">        <span class="comment">//【1】更新的条件：强制、保持屏幕常亮、系统 ui 可见性、设置了 sys ui 监听器；</span></span><br><span class="line">        <span class="keyword">if</span> (force || ai.mKeepScreenOn || (ai.mSystemUiVisibility != <span class="number">0</span>)</span><br><span class="line">            || ai.mHasSystemUiListeners) &#123;</span><br><span class="line">            ai.mRecomputeGlobalAttributes = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个我们先不关注。</p>
<h3 id="4-1-1-registerPendingFrameMetricsObservers"><a href="#4-1-1-registerPendingFrameMetricsObservers" class="headerlink" title="4.1.1 registerPendingFrameMetricsObservers"></a>4.1.1 registerPendingFrameMetricsObservers</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerPendingFrameMetricsObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mFrameMetricsObservers != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadedRenderer renderer = getHardwareRenderer();</span><br><span class="line">        <span class="keyword">if</span> (renderer != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (FrameMetricsObserver fmo : mFrameMetricsObservers) &#123;</span><br><span class="line">                renderer.addFrameMetricsObserver(fmo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Log.w(VIEW_LOG_TAG, <span class="string">"View not hardware-accelerated. Unable to observe frame stats"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-1-2-performCollectViewAttributes"><a href="#4-1-2-performCollectViewAttributes" class="headerlink" title="4.1.2 performCollectViewAttributes"></a>4.1.2 performCollectViewAttributes</h3><p>收集 view 的属性到 attachInfo 中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">performCollectViewAttributes</span><span class="params">(AttachInfo attachInfo, <span class="keyword">int</span> visibility)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((visibility &amp; VISIBILITY_MASK) == VISIBLE) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((mViewFlags &amp; KEEP_SCREEN_ON) == KEEP_SCREEN_ON) &#123;</span><br><span class="line">            attachInfo.mKeepScreenOn = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        attachInfo.mSystemUiVisibility |= mSystemUiVisibility;</span><br><span class="line">        ListenerInfo li = mListenerInfo;</span><br><span class="line">        <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnSystemUiVisibilityChangeListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">            attachInfo.mHasSystemUiListeners = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-1-3-onAttachedToWindow"><a href="#4-1-3-onAttachedToWindow" class="headerlink" title="4.1.3 onAttachedToWindow"></a>4.1.3 onAttachedToWindow</h3><p>生命周期回调，表示 attached 到了 window 上：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CallSuper</span></span><br><span class="line"><span class="comment">//【--&gt;2.1-mid】DecorView 复写了这个方法。</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onAttachedToWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_REQUEST_TRANSPARENT_REGIONS) != <span class="number">0</span>) &#123;</span><br><span class="line">        mParent.requestTransparentRegion(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mPrivateFlags3 &amp;= ~PFLAG3_IS_LAID_OUT;</span><br><span class="line"></span><br><span class="line">    jumpDrawablesToCurrentState();</span><br><span class="line"></span><br><span class="line">    resetSubtreeAccessibilityStateChanged();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rebuild, since Outline not maintained while View is detached</span></span><br><span class="line">    rebuildOutline();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isFocused()) &#123;</span><br><span class="line">        InputMethodManager imm = InputMethodManager.peekInstance();</span><br><span class="line">        <span class="keyword">if</span> (imm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            imm.focusIn(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，这里对于 DecorView 有一些不一样，DecorView 本质上也是一个 View，而它复写了这个方法；</p>
<h3 id="4-1-4-onWindowVisibilityChanged"><a href="#4-1-4-onWindowVisibilityChanged" class="headerlink" title="4.1.4 onWindowVisibilityChanged"></a>4.1.4 onWindowVisibilityChanged</h3><p>窗口可见性发生变化，回调整个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onWindowVisibilityChanged</span><span class="params">(@Visibility <span class="keyword">int</span> visibility)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (visibility == VISIBLE) &#123;</span><br><span class="line">        <span class="comment">//【1】触发 Scrollbars 去绘制，这里就不细分析了；</span></span><br><span class="line">        initialAwakenScrollBars();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>暂时不分析；</p>
<h3 id="4-1-5-isShown"><a href="#4-1-5-isShown" class="headerlink" title="4.1.5 isShown"></a>4.1.5 isShown</h3><p>判断该 view 以及其所有的 parent view 是否都用户可见的；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isShown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    View current = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//【1】只要有一个 view 不可见，那就回返回 false；</span></span><br><span class="line">        <span class="keyword">if</span> ((current.mViewFlags &amp; VISIBILITY_MASK) != VISIBLE) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ViewParent parent = current.mParent;</span><br><span class="line">        <span class="comment">//【2】如果没有 attach 到 view root，也就是不再 view tree 上</span></span><br><span class="line">        <span class="comment">// 也返回 false；</span></span><br><span class="line">        <span class="keyword">if</span> (parent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【3】不是 view 的子类，也就是 ViewRootImpl，这里返回 false；</span></span><br><span class="line">        <span class="keyword">if</span> (!(parent <span class="keyword">instanceof</span> View)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        current = (View) parent;</span><br><span class="line">    &#125; <span class="keyword">while</span> (current != <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 mViewFlags 表示的用户指定可见性，就是通过 android:visibable 或者 view.seVisibable 指定的可见性；</p>
<h3 id="4-1-5-onVisibilityAggregated"><a href="#4-1-5-onVisibilityAggregated" class="headerlink" title="4.1.5 onVisibilityAggregated"></a>4.1.5 onVisibilityAggregated</h3><p>isVisible 表示 window 是否是可见的；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CallSuper</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onVisibilityAggregated</span><span class="params">(<span class="keyword">boolean</span> isVisible)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isVisible &amp;&amp; mAttachInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//【1】触发 Scrollbars 去绘制，这里就不细分析了；</span></span><br><span class="line">        initialAwakenScrollBars();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【2】这里会对 Background Drawable 和 Foreground Drawable 的可见性做了调整；</span></span><br><span class="line">    <span class="comment">// 只要其可见性和 window 不一样那么，那就将其可见性设置成 window 可见性；</span></span><br><span class="line">    <span class="keyword">final</span> Drawable dr = mBackground;</span><br><span class="line">    <span class="keyword">if</span> (dr != <span class="keyword">null</span> &amp;&amp; isVisible != dr.isVisible()) &#123;</span><br><span class="line">        dr.setVisible(isVisible, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> Drawable fg = mForegroundInfo != <span class="keyword">null</span> ? mForegroundInfo.mDrawable : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (fg != <span class="keyword">null</span> &amp;&amp; isVisible != fg.isVisible()) &#123;</span><br><span class="line">        fg.setVisible(isVisible, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调整 Background Drawable 和 Foreground Drawable 的可见性；</p>
<h2 id="4-2-dispatchWindowVisibilityChanged"><a href="#4-2-dispatchWindowVisibilityChanged" class="headerlink" title="4.2 dispatchWindowVisibilityChanged"></a>4.2 dispatchWindowVisibilityChanged</h2><p>响应窗口可见性变化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchWindowVisibilityChanged</span><span class="params">(@Visibility <span class="keyword">int</span> visibility)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【--&gt;4.1.4】窗口可见性发生了变化；</span></span><br><span class="line">    onWindowVisibilityChanged(visibility);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不多说；</p>
<h2 id="4-3-dispatchVisibilityAggregated"><a href="#4-3-dispatchVisibilityAggregated" class="headerlink" title="4.3 dispatchVisibilityAggregated"></a>4.3 dispatchVisibilityAggregated</h2><p>响应可见性调整：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">dispatchVisibilityAggregated</span><span class="params">(<span class="keyword">boolean</span> isVisible)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】获取用户可见性；</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> thisVisible = getVisibility() == VISIBLE;</span><br><span class="line">    <span class="comment">//【2】如果可见性不同，那就触发回调；</span></span><br><span class="line">    <span class="keyword">if</span> (thisVisible || !isVisible) &#123;</span><br><span class="line">        <span class="comment">//【--&gt;4.1.5】响应可见性调整；</span></span><br><span class="line">        onVisibilityAggregated(isVisible);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> thisVisible &amp;&amp; isVisible;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-4-MeasureSpec-测量规格"><a href="#4-4-MeasureSpec-测量规格" class="headerlink" title="4.4 MeasureSpec - 测量规格"></a>4.4 MeasureSpec - 测量规格</h2><p>MeasureSpec 是 View 的内部类。他表示一种测量规格，是父布局传递给子布局的布局要求。</p>
<h3 id="4-4-1-测量模式"><a href="#4-4-1-测量模式" class="headerlink" title="4.4.1 测量模式"></a>4.4.1 测量模式</h3><ul>
<li><strong>UNSPECIFIED</strong>：不对 View 大小做限制，例如：ListView，ScrollView</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   父视图没有对 child 施加任何约束。它可以是任何大小；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNSPECIFIED = <span class="number">0</span> &lt;&lt; MODE_SHIFT;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>EXACTLY</strong>：确切的大小，例如：100dp 或者 march_parent</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   父视图已经确定了孩子的确切尺寸。不管孩子想要多大，都会给孩子以这些界限；</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXACTLY     = <span class="number">1</span> &lt;&lt; MODE_SHIFT;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>AT_MOST</strong>：大小不可超过某数值，例如：wrap_content</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   child 可以根据自身需要的大小而确定大小，但是存在上限，上限一般为父视图大小。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> AT_MOST     = <span class="number">2</span> &lt;&lt; MODE_SHIFT;</span><br></pre></td></tr></table></figure>
<h3 id="4-4-2-makeMeasureSpec"><a href="#4-4-2-makeMeasureSpec" class="headerlink" title="4.4.2 makeMeasureSpec"></a>4.4.2 makeMeasureSpec</h3><p>根据提供的大小和模式创建度量规范：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">makeMeasureSpec</span><span class="params">(@IntRange(from = <span class="number">0</span>, to = (<span class="number">1</span> &lt;&lt; MeasureSpec.MODE_SHIFT)</span> - 1) <span class="keyword">int</span> size,</span></span><br><span class="line"><span class="function">                                  @MeasureSpecMode <span class="keyword">int</span> mode) </span>&#123;</span><br><span class="line">    <span class="comment">//【1】使用旧的（破碎的）方式建立 MeasureSpecs，sUseBrokenMakeMeasureSpec 值为 false。</span></span><br><span class="line">    <span class="keyword">if</span> (sUseBrokenMakeMeasureSpec) &#123; </span><br><span class="line">        <span class="keyword">return</span> size + mode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//【2】模式占高 2 位，大小占低 30 位，合成 MeasureSpec</span></span><br><span class="line">        <span class="keyword">return</span> (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们知道，MeasureSpec 是 32 位的  Int 型，高两位表示 mode，低 30 位表示 size，这里的 MODE_MASK 的作用实际上就是做位操作！</p>
<p>MODE_MASK 取如下的值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_SHIFT = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MODE_MASK  = <span class="number">0x3</span> &lt;&lt; MODE_SHIFT;</span><br></pre></td></tr></table></figure>
<p>其中 0x3 是十六进制，转为二进制是 11，向左移位30，结果是 11000…..0000（一共 30 个 0）！</p>
<ul>
<li>size &amp; ~MODE_MASK：获取 size 的低 30 位；</li>
<li>mode &amp; MODE_MASK：获取 mode 的高两位；</li>
</ul>
<p>最终合成度量规格；</p>
<h1 id="5-ViewTreeObserver-视图树的观察者"><a href="#5-ViewTreeObserver-视图树的观察者" class="headerlink" title="5 ViewTreeObserver - 视图树的观察者"></a>5 ViewTreeObserver - 视图树的观察者</h1><p>前面我们有分析过 ViewTreeObserver 用来动态监听布局的变化；</p>
<h2 id="5-1-merge"><a href="#5-1-merge" class="headerlink" title="5.1 merge"></a>5.1 merge</h2><p>合并 observer 中的接口回调到当前的 ViewTreeObserver 中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(ViewTreeObserver observer)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//【1】合并 mOnWindowAttachListeners 接口；</span></span><br><span class="line">      <span class="keyword">if</span> (observer.mOnWindowAttachListeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (mOnWindowAttachListeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">              mOnWindowAttachListeners.addAll(observer.mOnWindowAttachListeners);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              mOnWindowAttachListeners = observer.mOnWindowAttachListeners;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//【2】合并 mOnWindowFocusListeners 接口；</span></span><br><span class="line">      <span class="keyword">if</span> (observer.mOnWindowFocusListeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (mOnWindowFocusListeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">              mOnWindowFocusListeners.addAll(observer.mOnWindowFocusListeners);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              mOnWindowFocusListeners = observer.mOnWindowFocusListeners;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//【3】合并 mOnGlobalFocusListeners 接口；</span></span><br><span class="line">      <span class="keyword">if</span> (observer.mOnGlobalFocusListeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (mOnGlobalFocusListeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">              mOnGlobalFocusListeners.addAll(observer.mOnGlobalFocusListeners);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              mOnGlobalFocusListeners = observer.mOnGlobalFocusListeners;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//【4】合并 mOnGlobalLayoutListeners 接口；</span></span><br><span class="line">      <span class="keyword">if</span> (observer.mOnGlobalLayoutListeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (mOnGlobalLayoutListeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">              mOnGlobalLayoutListeners.addAll(observer.mOnGlobalLayoutListeners);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              mOnGlobalLayoutListeners = observer.mOnGlobalLayoutListeners;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//【5】合并 mOnPreDrawListeners 接口；</span></span><br><span class="line">      <span class="keyword">if</span> (observer.mOnPreDrawListeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (mOnPreDrawListeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">              mOnPreDrawListeners.addAll(observer.mOnPreDrawListeners);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              mOnPreDrawListeners = observer.mOnPreDrawListeners;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//【6】合并 mOnTouchModeChangeListeners 接口；</span></span><br><span class="line">      <span class="keyword">if</span> (observer.mOnTouchModeChangeListeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (mOnTouchModeChangeListeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">              mOnTouchModeChangeListeners.addAll(observer.mOnTouchModeChangeListeners);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              mOnTouchModeChangeListeners = observer.mOnTouchModeChangeListeners;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//【7】合并 mOnComputeInternalInsetsListeners 接口；</span></span><br><span class="line">      <span class="keyword">if</span> (observer.mOnComputeInternalInsetsListeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (mOnComputeInternalInsetsListeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">              mOnComputeInternalInsetsListeners.addAll(observer.mOnComputeInternalInsetsListeners);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              mOnComputeInternalInsetsListeners = observer.mOnComputeInternalInsetsListeners;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//【8】合并 mOnScrollChangedListeners 接口；</span></span><br><span class="line">      <span class="keyword">if</span> (observer.mOnScrollChangedListeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (mOnScrollChangedListeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">              mOnScrollChangedListeners.addAll(observer.mOnScrollChangedListeners);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              mOnScrollChangedListeners = observer.mOnScrollChangedListeners;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//【9】合并 mOnWindowShownListeners 接口；</span></span><br><span class="line">      <span class="keyword">if</span> (observer.mOnWindowShownListeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (mOnWindowShownListeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">              mOnWindowShownListeners.addAll(observer.mOnWindowShownListeners);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              mOnWindowShownListeners = observer.mOnWindowShownListeners;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      observer.kill();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>在将 mAttachInfo 设置到 view 去后，会将 view 自身设置的 ViewTreeObserver 的接口合并到 mAttachInfo.observer 中:</p>
<h2 id="5-2-dispatchOnWindowAttachedChange"><a href="#5-2-dispatchOnWindowAttachedChange" class="headerlink" title="5.2 dispatchOnWindowAttachedChange"></a>5.2 dispatchOnWindowAttachedChange</h2><p>分发窗口绑定状态变化的消息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">dispatchOnWindowAttachedChange</span><span class="params">(<span class="keyword">boolean</span> attached)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】内部有一个 mOnWindowAttachListeners 列表，保存了所有的 view 设置的 OnWindowAttachListener 回调</span></span><br><span class="line">    <span class="comment">// merge 后统一回调；</span></span><br><span class="line">    <span class="keyword">final</span> CopyOnWriteArrayList&lt;OnWindowAttachListener&gt; listeners</span><br><span class="line">            = mOnWindowAttachListeners;</span><br><span class="line">    <span class="keyword">if</span> (listeners != <span class="keyword">null</span> &amp;&amp; listeners.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (OnWindowAttachListener listener : listeners) &#123;</span><br><span class="line">            <span class="comment">//【2】根据是否 attached 的调用不同的接口；</span></span><br><span class="line">            <span class="keyword">if</span> (attached) listener.onWindowAttached();</span><br><span class="line">            <span class="keyword">else</span> listener.onWindowDetached();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>onWindowAttached</strong>：绑定成功；</li>
<li><strong>onWindowDetached</strong>：接触绑定；</li>
</ul>
<h2 id="5-3-dispatchOnTouchModeChanged"><a href="#5-3-dispatchOnTouchModeChanged" class="headerlink" title="5.3 dispatchOnTouchModeChanged"></a>5.3 dispatchOnTouchModeChanged</h2><p>通知注册的收听者触摸模式已更改。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">dispatchOnTouchModeChanged</span><span class="params">(<span class="keyword">boolean</span> inTouchMode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】内部有一个 mOnTouchModeChangeListeners 列表，保存了所有的 view 设置的 OnTouchModeChangeListener 回调</span></span><br><span class="line">    <span class="comment">// merge 后统一回调；</span></span><br><span class="line">    <span class="keyword">final</span> CopyOnWriteArrayList&lt;OnTouchModeChangeListener&gt; listeners =</span><br><span class="line">            mOnTouchModeChangeListeners;</span><br><span class="line">    <span class="keyword">if</span> (listeners != <span class="keyword">null</span> &amp;&amp; listeners.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (OnTouchModeChangeListener listener : listeners) &#123;</span><br><span class="line">            <span class="comment">//【2】触发回调；</span></span><br><span class="line">            listener.onTouchModeChanged(inTouchMode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数表示是否 进入 / 退出 touch mode；</p>
<h2 id="5-4-dispatchOnGlobalLayout"><a href="#5-4-dispatchOnGlobalLayout" class="headerlink" title="5.4 dispatchOnGlobalLayout"></a>5.4 dispatchOnGlobalLayout</h2><p>通知全局布局已经发生，在布局完成后会触发：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通知已注册的侦听器全局布局已发生。</span></span><br><span class="line"><span class="comment">// 如果您要强制在未附加到 Window 或处于 GONE 状态的 View 或 View 层次结构上进行布局，则可以手动调用此方法。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">dispatchOnGlobalLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> CopyOnWriteArray&lt;OnGlobalLayoutListener&gt; listeners = mOnGlobalLayoutListeners;</span><br><span class="line">    <span class="keyword">if</span> (listeners != <span class="keyword">null</span> &amp;&amp; listeners.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        CopyOnWriteArray.Access&lt;OnGlobalLayoutListener&gt; access = listeners.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> count = access.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                <span class="comment">// 回调 onGlobalLayout 方法；</span></span><br><span class="line">                access.get(i).onGlobalLayout();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            listeners.end();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-5-dispatchOnComputeInternalInsets"><a href="#5-5-dispatchOnComputeInternalInsets" class="headerlink" title="5.5 dispatchOnComputeInternalInsets"></a>5.5 dispatchOnComputeInternalInsets</h2><p>调用所有侦听器以计算当前插入边衬：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">dispatchOnComputeInternalInsets</span><span class="params">(InternalInsetsInfo inoutInfo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> CopyOnWriteArray&lt;OnComputeInternalInsetsListener&gt; listeners =</span><br><span class="line">            mOnComputeInternalInsetsListeners;</span><br><span class="line">    <span class="keyword">if</span> (listeners != <span class="keyword">null</span> &amp;&amp; listeners.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        CopyOnWriteArray.Access&lt;OnComputeInternalInsetsListener&gt; access = listeners.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> count = access.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                <span class="comment">// 回调处理，计算结果保存到 inoutInfo 中；</span></span><br><span class="line">                access.get(i).onComputeInternalInsets(inoutInfo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            listeners.end();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-6-dispatchOnPreDraw"><a href="#5-6-dispatchOnPreDraw" class="headerlink" title="5.6 dispatchOnPreDraw"></a>5.6 dispatchOnPreDraw</h2><p>在 draw 之前会触发，用于取消回调：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">dispatchOnPreDraw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> cancelDraw = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">final</span> CopyOnWriteArray&lt;OnPreDrawListener&gt; listeners = mOnPreDrawListeners;</span><br><span class="line">    <span class="keyword">if</span> (listeners != <span class="keyword">null</span> &amp;&amp; listeners.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        CopyOnWriteArray.Access&lt;OnPreDrawListener&gt; access = listeners.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> count = access.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                <span class="comment">//【1】回调 onPreDraw 方法；</span></span><br><span class="line">                cancelDraw |= !(access.get(i).onPreDraw());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            listeners.end();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cancelDraw;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="6-Surface-相关"><a href="#6-Surface-相关" class="headerlink" title="6 Surface 相关"></a>6 Surface 相关</h1><h2 id="6-1-Surface"><a href="#6-1-Surface" class="headerlink" title="6.1 Surface"></a>6.1 Surface</h2><p>ViewRootImpl 内部有一个 Surface 变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Surface mSurface = <span class="keyword">new</span> Surface();</span><br></pre></td></tr></table></figure>
<h3 id="6-1-1-new-Surface"><a href="#6-1-1-new-Surface" class="headerlink" title="6.1.1 new Surface"></a>6.1.1 new Surface</h3><p>创建了一个空的 Surface 实例，其内部的数据会将在 readFromParcel 方法中填充：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Surface</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Surface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实就是 requestWindow 会回传数据；</p>
<h3 id="6-1-2-getGenerationId"><a href="#6-1-2-getGenerationId" class="headerlink" title="6.1.2 getGenerationId"></a>6.1.2 getGenerationId</h3><p>获得该 surface 关联的 id 标志，如果 native 层的 surface 变化的话，那么这个 id 值会增加；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getGenerationId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">return</span> mGenerationId; <span class="comment">// 内部变量；</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-1-3-readFromParcel"><a href="#6-1-3-readFromParcel" class="headerlink" title="6.1.3 readFromParcel"></a>6.1.3 readFromParcel</h3><p>relayoutWindow 会将 Surface 数据跨进程传递过来，初始化客户端的 Surface，Surface 其实就是一个 Parcel：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readFromParcel</span><span class="params">(Parcel source)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (source == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"source must not be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="comment">// nativeReadFromParcel() will either return mNativeObject, or</span></span><br><span class="line">        <span class="comment">// create a new native Surface and return it after reducing</span></span><br><span class="line">        <span class="comment">// the reference count on mNativeObject.  Either way, it is</span></span><br><span class="line">        <span class="comment">// not necessary to call nativeRelease() here.</span></span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> This must be kept synchronized with the native parceling code</span></span><br><span class="line">        <span class="comment">// in frameworks/native/libs/Surface.cpp</span></span><br><span class="line">        mName = source.readString();</span><br><span class="line">        mIsSingleBuffered = source.readInt() != <span class="number">0</span>;</span><br><span class="line">        setNativeObjectLocked(nativeReadFromParcel(mNativeObject, source));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="7-总结"><a href="#7-总结" class="headerlink" title="7 总结"></a>7 总结</h1><p>下面我们来通过 pic 看看整个过程的总结：</p>
<p>图先省略下。。。</p>
<h1 id="遗留汇总"><a href="#遗留汇总" class="headerlink" title="遗留汇总"></a>遗留汇总</h1><p>本篇文章木有跟踪和探究的很重要的源码：</p>
<h2 id="View-相关"><a href="#View-相关" class="headerlink" title="View 相关"></a>View 相关</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ViewGroup.measure(childWidthMeasureSpec, childHeightMeasureSpec); <span class="comment">// 测量；</span></span><br><span class="line"></span><br><span class="line">ViewGroup.layout(<span class="number">0</span>, <span class="number">0</span>, host.getMeasuredWidth(), host.getMeasuredHeight()); <span class="comment">// 布局；</span></span><br><span class="line"></span><br><span class="line">View.requestFocus(View.FOCUS_FORWARD);  <span class="comment">// 请求焦点；</span></span><br><span class="line"></span><br><span class="line">view.requestLayout(); <span class="comment">// 请求布局；</span></span><br><span class="line"></span><br><span class="line">View.draw <span class="comment">// 绘制；</span></span><br></pre></td></tr></table></figure>
<h2 id="Window-相关"><a href="#Window-相关" class="headerlink" title="Window 相关"></a>Window 相关</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WindowSession 的创建；</span></span><br><span class="line">mWindowSession = WindowManagerGlobal.getWindowSession();</span><br><span class="line"></span><br><span class="line"><span class="comment">// addToDisplay 的流程；</span></span><br><span class="line">res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,</span><br><span class="line">                                  getHostVisibility(), mDisplay.getDisplayId(),</span><br><span class="line">                                  mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,</span><br><span class="line">                                  mAttachInfo.mOutsets, mInputChannel);</span><br><span class="line"></span><br><span class="line"><span class="comment">// request 的流程；</span></span><br><span class="line"><span class="keyword">int</span> relayoutResult = mWindowSession.relayout(mWindow, mSeq, params,</span><br><span class="line">   									 (<span class="keyword">int</span>) (mView.getMeasuredWidth() * appScale + <span class="number">0.5f</span>),</span><br><span class="line">  								     (<span class="keyword">int</span>) (mView.getMeasuredHeight() * appScale + <span class="number">0.5f</span>),</span><br><span class="line">  				  viewVisibility, insetsPending ? WindowManagerGlobal.RELAYOUT_INSETS_PENDING : <span class="number">0</span>,</span><br><span class="line">    			  mWinFrame, mPendingOverscanInsets, mPendingContentInsets, mPendingVisibleInsets,</span><br><span class="line">  				  mPendingStableInsets, mPendingOutsets, mPendingBackDropFrame, mPendingConfiguration,</span><br><span class="line">                  mSurface);</span><br><span class="line"></span><br><span class="line"><span class="comment">// finishDrawing 的流程；</span></span><br><span class="line">mWindowSession.finishDrawing(mWindow);</span><br></pre></td></tr></table></figure>
<h2 id="Surface-相关"><a href="#Surface-相关" class="headerlink" title="Surface 相关"></a>Surface 相关</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Surface 创建；</span></span><br><span class="line"><span class="comment">// WindowSession.relayout 执行后，Surface 如何变的有效的；</span></span><br></pre></td></tr></table></figure>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Coolqi.Li</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lishuaiqi.top/2018/06/21/ViewDraw-3-performTraversals/">https://lishuaiqi.top/2018/06/21/ViewDraw-3-performTraversals/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lishuaiqi.top">Coolqi`s Blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/ViewDraw/">ViewDraw</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="/img/zfb.jpg"><div class="post-qr-code__desc">支付宝打赏</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="/img/wechat.jpg"><div class="post-qr-code__desc">微信打赏</div></div></div><div class="social-share pull-right"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2018/07/15/Choreographer-1-choreographerAnalysize/"><i class="fa fa-chevron-left">  </i><span>Choreographer 第一篇 Choreographer  原理分析</span></a></div><div class="next-post pull-right"><a href="/2018/06/15/ViewDraw-2-newViewRootImpl/"><span>ViewDraw 第二篇 new ViewRootImpl 流程分析</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitment-container"></div><script>var gitment = new Gitment({
  id: md5(decodeURI(location.pathname)),
  owner: '',
  repo: '',
  oauth: {
    client_id: '7b4efbcd7027d15749d6',
    client_secret: '14b5d7e8580ee29f7aeca733a25c000795967448'
  }
})
gitment.render('gitment-container')</script></div></div><footer class="footer-bg" style="background-image: url(/img/blog-bg.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2015 - 2022 By Coolqi.Li</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://lishuaiqi.top/">blog</a>!</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>