<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Choreographer 第一篇 Choreographer  原理分析"><meta name="keywords" content="Choreographer"><meta name="author" content="Coolqi.Li"><meta name="copyright" content="Coolqi.Li"><title>Choreographer 第一篇 Choreographer  原理分析 | Coolqi`s Blog</title><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.7.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.7.0"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css?version=1.7.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: 'ca-pub-6845729157331145',
  enable_page_level_ads: 'true'
});
</script><link rel="dns-prefetch" href="https://hm.baidu.com"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?b7acef5306e54116ad8a99e8b753a92d";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();</script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-回顾"><span class="toc-text">1 回顾</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-scheduleTraversals-核心"><span class="toc-text">1.1 scheduleTraversals - 核心</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-什么是-Choreographer"><span class="toc-text">2 什么是 Choreographer</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-Choreographer"><span class="toc-text">3 Choreographer</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-getInstance"><span class="toc-text">3.1 getInstance()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-new-Choreographer"><span class="toc-text">3.2 new Choreographer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-postCallback-Delayed-DelayedInternal"><span class="toc-text">3.3 postCallback[Delayed][DelayedInternal]</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-1-CallbackQueues"><span class="toc-text">3.3.1 CallbackQueues</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-1-extractDueCallbacksLocked"><span class="toc-text">3.3.1.1 extractDueCallbacksLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-1-2-addCallbackLocked"><span class="toc-text">3.3.1.2 addCallbackLocked</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-2-3-hasDueCallbacksLocked"><span class="toc-text">3.3.2.3 hasDueCallbacksLocked</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-2-CallbackRecord"><span class="toc-text">3.3.2 CallbackRecord</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-scheduleFrameLocked"><span class="toc-text">3.4 scheduleFrameLocked</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-1-scheduleVsyncLocked"><span class="toc-text">3.4.1 scheduleVsyncLocked</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-FrameDisplayEventReceiver"><span class="toc-text">4  FrameDisplayEventReceiver</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-new-FrameDisplayEventReceiver"><span class="toc-text">4.1 new FrameDisplayEventReceiver</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-1-nativeInit"><span class="toc-text">4.1.1 nativeInit</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-scheduleVsync"><span class="toc-text">4.2 scheduleVsync</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-nativeScheduleVsync"><span class="toc-text">4.2.1 nativeScheduleVsync</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-dispatchVsync"><span class="toc-text">4.3 dispatchVsync</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-onVsync"><span class="toc-text">4.4 onVsync</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-run"><span class="toc-text">4.5 run</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-NativeDisplayEventReceiver（以及父类）"><span class="toc-text">5 NativeDisplayEventReceiver（以及父类）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-new-NativeDisplayEventReceiver"><span class="toc-text">5.1 new NativeDisplayEventReceiver</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-initialize"><span class="toc-text">5.2 initialize</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-scheduleVsync"><span class="toc-text">5.3 scheduleVsync</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-handleEvent"><span class="toc-text">5.4 handleEvent</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-1-processPendingEvents"><span class="toc-text">5.4.1 processPendingEvents</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-dispatchVsync"><span class="toc-text">5.5 dispatchVsync</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-FrameHandler"><span class="toc-text">6 FrameHandler</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-new-FrameHandler"><span class="toc-text">6.1 new FrameHandler</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-Choreographer-back"><span class="toc-text">7 Choreographer - back</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-doScheduleVsync"><span class="toc-text">7.1 doScheduleVsync</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-doFrame"><span class="toc-text">7.2 doFrame</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-3-doCallbacks"><span class="toc-text">7.3 doCallbacks</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-4-doScheduleCallback"><span class="toc-text">7.4 doScheduleCallback</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-FrameInfo"><span class="toc-text">8 FrameInfo</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-new-FrameInfo"><span class="toc-text">8.1 new FrameInfo</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-setVsync"><span class="toc-text">8.2 setVsync</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-3-markInputHandlingStart-Animations-PerformTraversals"><span class="toc-text">8.3 markInputHandlingStart (Animations/PerformTraversals)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-总结"><span class="toc-text">9 总结</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.jpg"></div><div class="author-info__name text-center">Coolqi.Li</div><div class="author-info__description text-center">“Hi，我是李帅奇，Android 开发工程师，TeamLeader，熬夜星人，一个努力赚钱，积极向上的好人。”</div><div class="follow-button"><a href="https://github.com/single-li">Follow Me</a></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">86</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">21</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">26</span></a></div><hr><div class="author-info-links"><div class="author-info-links__title text-center">Links</div><a class="author-info-links__name text-center" href="https://developer.android.google.cn/">AndroidDeveloper</a><a class="author-info-links__name text-center" href="http://www.android-studio.org/">AndroidStudio</a><a class="author-info-links__name text-center" href="https://www.jianshu.com/u/123a20a96441">简书</a><a class="author-info-links__name text-center" href="https://weibo.com/coolqiLi">微博</a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(/img/blog-bg.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">Coolqi`s Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">Home</a><a class="site-page" href="/categories">Categories</a><a class="site-page" href="/tags">Tags</a><a class="site-page" href="/archives">Archives</a><a class="site-page" href="/about">About</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">Choreographer 第一篇 Choreographer  原理分析</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2018-07-15</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/View-视图/">View 视图</a><i class="fa fa-angle-right" aria-hidden="true"></i><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/View-视图/Choreographer-编舞者/">Choreographer 编舞者</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">5.9k</span><span class="post-meta__separator">|</span><span>阅读时长: 27 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>本篇文章基于 Android N（7.1.1）主要分析下 Choreographer 的原理，以对 Android 系统有更好的理解。</p>
<h1 id="1-回顾"><a href="#1-回顾" class="headerlink" title="1 回顾"></a>1 回顾</h1><h2 id="1-1-scheduleTraversals-核心"><a href="#1-1-scheduleTraversals-核心" class="headerlink" title="1.1 scheduleTraversals - 核心"></a>1.1 scheduleTraversals - 核心</h2><p>触发视图遍历：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">        <span class="comment">//【1】表示是否已经发起重绘，这是要设置为 true；</span></span><br><span class="line">        mTraversalScheduled = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//【1】在主线程的消息队列中放一个障栅；</span></span><br><span class="line">        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">        <span class="comment">//【--&gt;10.5】设置一个回调到编舞者 Choreographer 中，在下一次的绘制触发时，执行 mTraversalRunnable</span></span><br><span class="line">        <span class="comment">// mTraversalRunnable 是一个 runnbale 实例；</span></span><br><span class="line">        mChoreographer.postCallback(</span><br><span class="line">                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (!mUnbufferedInputDispatch) &#123;</span><br><span class="line">            scheduleConsumeBatchedInput();</span><br><span class="line">        &#125;</span><br><span class="line">        notifyRendererOfFramePending();</span><br><span class="line">        pokeDrawLockIfNeeded();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面分析 View 的绘制的时候，有讲到，Choreographer 会请求 Vsync 信号，然后在 Vsync 信号触发后，执行布局和绘制任务！</p>
<p>这一篇，我们来分析下 Choreographer！</p>
<h1 id="2-什么是-Choreographer"><a href="#2-什么是-Choreographer" class="headerlink" title="2 什么是 Choreographer"></a>2 什么是 Choreographer</h1><p>（这一部分来自 <strong>SDK</strong> 的翻译，其实 SDK 的注释已经将 Choreographer 的作用讲的很清楚了）</p>
<p>编舞者，作用是协调动画，输入和绘图的时间；</p>
<p>编舞者会从显示子系统接收定时脉冲（也就是垂直同步 Vsync 信号），然后触发指定的工作，结果会作为渲染下一个显示帧的一部分；</p>
<p>应用一般使用动画框架或视图层次结构中的更高级别的抽象间接地和编舞者交互。</p>
<p>下面是一些可以使用的高级 API，用于和 Choreographer  间接通信：</p>
<ul>
<li><p><strong>ValueAnimator.start</strong>：用于使用与显示框架渲染同步的要在常规时间进行处理的动画</p>
</li>
<li><p><strong>View.postOnAnimation</strong>：传入一个 Runnable，在下一个显示帧的开头被调用一次；</p>
</li>
<li><strong>View.postOnAnimationDelayed</strong>：传入一个 Runnable，在下一个显示帧的开头延迟指定时间被调用一次；</li>
<li><strong>View.postInvalidateOnAnimation</strong>：在下一个显示帧开始时触发 <strong>View.invalidate</strong> 一次；</li>
</ul>
<p>为确保 <strong>View</strong> 的内容平滑滚动并与显示框架渲染同步绘制，请不要执行任何操作。系统会自动处理，<strong>View.onDraw</strong> 将在适当的时候被调用。</p>
<p>但是，在某些情况下，您可能希望直接在应用程序中使用编舞者的功能。譬如说：</p>
<ul>
<li><strong>Choreographer.postFrameCallback</strong>：如果应用使用 GL，或完全不使用动画框架或视图层次结构在其他线程中进行渲染，并且你想确保它与显示适当同步。</li>
</ul>
<p>每个  <strong>Looper 线程</strong> 都有自己的编舞者。其他线程可以发布回调以在编舞者上运行，但是它们将持有编舞者所属的 <strong>Looper</strong>。</p>
<h1 id="3-Choreographer"><a href="#3-Choreographer" class="headerlink" title="3 Choreographer"></a>3 Choreographer</h1><p>我们来开始分析 Choreographer 的代码：</p>
<h2 id="3-1-getInstance"><a href="#3-1-getInstance" class="headerlink" title="3.1 getInstance()"></a>3.1 getInstance()</h2><p>编舞者是线程单例模式，每一个线程都会有一个：<strong>ThreadLocal</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Choreographer</span> </span>&#123;</span><br><span class="line">   <span class="comment">//【1】通过 ThreadLocal 实现线程单例模式；</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Choreographer&gt; sThreadInstance =</span><br><span class="line">            <span class="keyword">new</span> ThreadLocal&lt;Choreographer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Choreographer <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//【2】获取当前线程的 looper 对象；</span></span><br><span class="line">            Looper looper = Looper.myLooper();</span><br><span class="line">            <span class="keyword">if</span> (looper == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The current thread must have a looper!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//【--&gt;3.2】创建 Choreographer 对象；</span></span><br><span class="line">            Choreographer choreographer = <span class="keyword">new</span> Choreographer(looper, VSYNC_SOURCE_APP);</span><br><span class="line">            <span class="keyword">if</span> (looper == Looper.getMainLooper()) &#123;</span><br><span class="line">                <span class="comment">//【3】如果 looper 是 ui thread 的，会保存到内部的 mMainInstance；</span></span><br><span class="line">                mMainInstance = choreographer;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> choreographer;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Choreographer <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sThreadInstance.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-2-new-Choreographer"><a href="#3-2-new-Choreographer" class="headerlink" title="3.2 new Choreographer"></a>3.2 new Choreographer</h2><p>创建 Choreographer:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Choreographer</span><span class="params">(Looper looper, <span class="keyword">int</span> vsyncSource)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】线程的 looper 实例；</span></span><br><span class="line">    mLooper = looper;</span><br><span class="line">    <span class="comment">//【--&gt;6.1】创建 FrameHandler 对象，用于处理消息；</span></span><br><span class="line">    mHandler = <span class="keyword">new</span> FrameHandler(looper);</span><br><span class="line">    <span class="comment">//【2】创建 VSYNC 的信号接受对象；</span></span><br><span class="line">    mDisplayEventReceiver = USE_VSYNC</span><br><span class="line">            ? <span class="keyword">new</span> FrameDisplayEventReceiver(looper, vsyncSource)</span><br><span class="line">            : <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//【3】初始化上一个 frame 渲染的时间点</span></span><br><span class="line">    mLastFrameTimeNanos = Long.MIN_VALUE;</span><br><span class="line">    <span class="comment">//【4】计算帧率，也就是一帧所需的渲染时间，getRefreshRate 是刷新率，一般是 60；</span></span><br><span class="line">    mFrameIntervalNanos = (<span class="keyword">long</span>)(<span class="number">1000000000</span> / getRefreshRate());</span><br><span class="line">    <span class="comment">//【5】创建消息处理队列</span></span><br><span class="line">    mCallbackQueues = <span class="keyword">new</span> CallbackQueue[CALLBACK_LAST + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= CALLBACK_LAST; i++) &#123;</span><br><span class="line">        mCallbackQueues[i] = <span class="keyword">new</span> CallbackQueue();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// b/68769804: For low FPS experiments.</span></span><br><span class="line">    setFPSDivisor(SystemProperties.getInt(ThreadedRenderer.DEBUG_FPS_DIVISOR, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>USE_VSYNC 的值来自下面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//【1】判断系统是否打开了 vsync，读取 "debug.choreographer.vsync" 属性；</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> USE_VSYNC = SystemProperties.getBoolean(</span><br><span class="line">                   <span class="string">"debug.choreographer.vsync"</span>, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>
<p>如果开启了 Vsync，就会创建一个 FrameDisplayEventReceiver 实例，用于请求并接收 Vsync 事件：</p>
<p>Choreographer 创建了一个大小为 3 的 CallbackQueue 数组，用于保存不同类型的 Callback；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CALLBACK_COMMIT = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CALLBACK_LAST = CALLBACK_COMMIT;</span><br></pre></td></tr></table></figure>
<h2 id="3-3-postCallback-Delayed-DelayedInternal"><a href="#3-3-postCallback-Delayed-DelayedInternal" class="headerlink" title="3.3 postCallback[Delayed][DelayedInternal]"></a>3.3 postCallback[Delayed][DelayedInternal]</h2><p>callbackType 表示回调的类型！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postCallback</span><span class="params">(<span class="keyword">int</span> callbackType, Runnable action, Object token)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】继续调用；</span></span><br><span class="line">    postCallbackDelayed(callbackType, action, token, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进入 postCallbackDelayed 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postCallbackDelayed</span><span class="params">(<span class="keyword">int</span> callbackType,</span></span></span><br><span class="line"><span class="function"><span class="params">                                Runnable action, Object token, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">    ... ... ...<span class="comment">// 省略对 action 和 callbackType 的判断；</span></span><br><span class="line"></span><br><span class="line">    postCallbackDelayedInternal(callbackType, action, token, delayMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进入 postCallbackDelayedInternal 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postCallbackDelayedInternal</span><span class="params">(<span class="keyword">int</span> callbackType,</span></span></span><br><span class="line"><span class="function"><span class="params">                                         Object action, Object token, <span class="keyword">long</span> delayMillis)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_FRAMES) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"PostCallback: type="</span> + callbackType</span><br><span class="line">              + <span class="string">", action="</span> + action + <span class="string">", token="</span> + token</span><br><span class="line">              + <span class="string">", delayMillis="</span> + delayMillis);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> dueTime = now + delayMillis; <span class="comment">// delayMillis 是我们设置的延迟，这里为 0；</span></span><br><span class="line">        <span class="comment">//【1】可以看到其将 action 根据 callbackType 放入了 mCallbackQueues 数组中；</span></span><br><span class="line">        mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dueTime &lt;= now) &#123;</span><br><span class="line">            <span class="comment">//【--&gt;3.4】延迟时间到了，请求一个 Vsync 信号；</span></span><br><span class="line">            scheduleFrameLocked(now);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//【--&gt;6.X】时间没到，那就创建一个 MSG_DO_SCHEDULE_CALLBACK 的异步消息，</span></span><br><span class="line">            <span class="comment">// 用于异步执行 action 任务，延迟 dueTime 发送给 FrameHandler 处理；</span></span><br><span class="line">            Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);</span><br><span class="line">            msg.arg1 = callbackType;</span><br><span class="line">            msg.setAsynchronous(<span class="keyword">true</span>); <span class="comment">// 注意：这是异步的！</span></span><br><span class="line">            mHandler.sendMessageAtTime(msg, dueTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-1-CallbackQueues"><a href="#3-3-1-CallbackQueues" class="headerlink" title="3.3.1 CallbackQueues"></a>3.3.1 CallbackQueues</h3><p>CallbackQueues 是一个用于链表实现的队列，用于保存每种类型的回调链表：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CallbackQueue</span> </span>&#123;</span><br><span class="line">     <span class="comment">//【--&gt;3.3.2】回调链表的 head；</span></span><br><span class="line">     <span class="keyword">private</span> CallbackRecord mHead;</span><br><span class="line">		... ... ...<span class="comment">// 省略掉操作链表的方法；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CallbackQueue 数组由三种类型不同 CallbackQueue，每个都有一个 CallbackRecord 链表，链表按照任务触发时间由小到大排列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CALLBACK_INPUT = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CALLBACK_ANIMATION = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CALLBACK_TRAVERSAL = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>内部的 CallbackRecord 以链表组织，以执行时间</p>
<h4 id="3-3-1-1-extractDueCallbacksLocked"><a href="#3-3-1-1-extractDueCallbacksLocked" class="headerlink" title="3.3.1.1 extractDueCallbacksLocked"></a>3.3.1.1 extractDueCallbacksLocked</h4><p>返回要执行的 CallbackRecord 子链表：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> CallbackRecord <span class="title">extractDueCallbacksLocked</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">    CallbackRecord callbacks = mHead;</span><br><span class="line">    <span class="keyword">if</span> (callbacks == <span class="keyword">null</span> || callbacks.dueTime &gt; now) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【1】last/next 指针；用于断开链表；</span></span><br><span class="line">    CallbackRecord last = callbacks;</span><br><span class="line">    CallbackRecord next = last.next;</span><br><span class="line">    <span class="keyword">while</span> (next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//【2】找到执行时间晚于 now 的了，断开；</span></span><br><span class="line">        <span class="keyword">if</span> (next.dueTime &gt; now) &#123;</span><br><span class="line">            last.next = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        last = next;</span><br><span class="line">        next = next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    mHead = next;</span><br><span class="line">    <span class="comment">//【3】返回执行时间早于 now 的子链表；</span></span><br><span class="line">    <span class="keyword">return</span> callbacks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-3-1-2-addCallbackLocked"><a href="#3-3-1-2-addCallbackLocked" class="headerlink" title="3.3.1.2 addCallbackLocked"></a>3.3.1.2 addCallbackLocked</h4><p>添加一个 CallbackRecord 到链表：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCallbackLocked</span><span class="params">(<span class="keyword">long</span> dueTime, Object action, Object token)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】返回一个可复用的 CallbackRecord 实例；</span></span><br><span class="line">    <span class="comment">// obtainCallbackLocked 方法会返回这个复用的实例，代码简单就不多数了；</span></span><br><span class="line">    CallbackRecord callback = obtainCallbackLocked(dueTime, action, token);</span><br><span class="line">    CallbackRecord entry = mHead;</span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mHead = callback;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【2】判断下 head；</span></span><br><span class="line">    <span class="keyword">if</span> (dueTime &lt; entry.dueTime) &#123;</span><br><span class="line">        callback.next = entry;</span><br><span class="line">        mHead = callback;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【3】遍历链表，找到合适的地方插入；</span></span><br><span class="line">    <span class="keyword">while</span> (entry.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dueTime &lt; entry.next.dueTime) &#123;</span><br><span class="line">            callback.next = entry.next;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        entry = entry.next;</span><br><span class="line">    &#125;</span><br><span class="line">    entry.next = callback;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编舞者内部有一个 mCallbackPool 实例，表示一个可复用的 CallbackRecord 对象；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> CallbackRecord mCallbackPool;</span><br></pre></td></tr></table></figure>
<p><strong>obtainCallbackLocked</strong> 方法会返回这个复用的实例：</p>
<ul>
<li>如果 mCallbackPool 不为 null，就设置值，返回；</li>
<li>如果 mCallbackPool 为 null，初始化新的，再设置值，返回；</li>
</ul>
<h4 id="3-3-2-3-hasDueCallbacksLocked"><a href="#3-3-2-3-hasDueCallbacksLocked" class="headerlink" title="3.3.2.3 hasDueCallbacksLocked"></a>3.3.2.3 hasDueCallbacksLocked</h4><p>判断是否有已经触发的回调：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasDueCallbacksLocked</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】就是比较下时间；</span></span><br><span class="line">    <span class="keyword">return</span> mHead != <span class="keyword">null</span> &amp;&amp; mHead.dueTime &lt;= now;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-2-CallbackRecord"><a href="#3-3-2-CallbackRecord" class="headerlink" title="3.3.2 CallbackRecord"></a>3.3.2 CallbackRecord</h3><p>每一个回调：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CallbackRecord</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> CallbackRecord next; <span class="comment">// 指向下一个对象；</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> dueTime;</span><br><span class="line">    <span class="keyword">public</span> Object action; <span class="comment">// Runnable or FrameCallback</span></span><br><span class="line">    <span class="keyword">public</span> Object token;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">long</span> frameTimeNanos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (token == FRAME_CALLBACK_TOKEN) &#123;</span><br><span class="line">            ((FrameCallback)action).doFrame(frameTimeNanos);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ((Runnable)action).run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据 token 不同，执行不同的处理：</p>
<ul>
<li><strong>FrameCallback</strong> 的 token 是 FRAME_CALLBACK_TOKEN</li>
<li><strong>Runnable</strong> 的 token 为 null；</li>
</ul>
<h2 id="3-4-scheduleFrameLocked"><a href="#3-4-scheduleFrameLocked" class="headerlink" title="3.4 scheduleFrameLocked"></a>3.4 scheduleFrameLocked</h2><p>请求一个 Vsync 信号：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleFrameLocked</span><span class="params">(<span class="keyword">long</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mFrameScheduled) &#123;</span><br><span class="line">        <span class="comment">//【1】设置 mFrameScheduled 为 true；</span></span><br><span class="line">        mFrameScheduled = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (USE_VSYNC) &#123; </span><br><span class="line">            <span class="comment">//【1】如果开启了 Vsync（默认开启）</span></span><br><span class="line">            <span class="keyword">if</span> (DEBUG_FRAMES) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"Scheduling next frame on vsync."</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If running on the Looper thread, then schedule the vsync immediately,</span></span><br><span class="line">            <span class="comment">// otherwise post a message to schedule the vsync from the UI thread</span></span><br><span class="line">            <span class="comment">// as soon as possible.</span></span><br><span class="line">            <span class="comment">// 这里会判断下 ？Looper.myLooper() == mLooper，如果一样;</span></span><br><span class="line">            <span class="keyword">if</span> (isRunningOnLooperThreadLocked()) &#123;</span><br><span class="line">                <span class="comment">//【--&gt;3.4.1】立刻请求 Vsync 信号；</span></span><br><span class="line">                scheduleVsyncLocked();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//【--&gt;6.1】发送一个 异步 msg[MSG_DO_SCHEDULE_VSYNC] 给 Framehandler;</span></span><br><span class="line">	<span class="comment">// 这个异步消息会在 message queue 的队头；</span></span><br><span class="line">                Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_VSYNC);</span><br><span class="line">                msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">                mHandler.sendMessageAtFrontOfQueue(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//【2】没有开启了 Vsync，那么这里会手动计算一个 delay 时间；</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> nextFrameTime = Math.max(</span><br><span class="line">                    mLastFrameTimeNanos / TimeUtils.NANOS_PER_MS + sFrameDelay, now);</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_FRAMES) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"Scheduling next frame in "</span> + (nextFrameTime - now) + <span class="string">" ms."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//【--&gt;6.X】发送一个 异步 msg[MSG_DO_FRAME] 给 Framehander；</span></span><br><span class="line">            Message msg = mHandler.obtainMessage(MSG_DO_FRAME);</span><br><span class="line">            msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">            mHandler.sendMessageAtTime(msg, nextFrameTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-4-1-scheduleVsyncLocked"><a href="#3-4-1-scheduleVsyncLocked" class="headerlink" title="3.4.1 scheduleVsyncLocked"></a>3.4.1 scheduleVsyncLocked</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scheduleVsyncLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【--&gt;4.2】通过 FrameDisplayEventReceiver 请求 vSync 信号；</span></span><br><span class="line">    mDisplayEventReceiver.scheduleVsync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="4-FrameDisplayEventReceiver"><a href="#4-FrameDisplayEventReceiver" class="headerlink" title="4  FrameDisplayEventReceiver"></a>4  FrameDisplayEventReceiver</h1><p>FrameDisplayEventReceiver 用于请求和接受 vsync 信号：</p>
<h2 id="4-1-new-FrameDisplayEventReceiver"><a href="#4-1-new-FrameDisplayEventReceiver" class="headerlink" title="4.1 new FrameDisplayEventReceiver"></a>4.1 new FrameDisplayEventReceiver</h2><p>FrameDisplayEventReceiver 继承了 <strong>DisplayEventReceiver</strong>，同时注意，也是<strong>实现了 Runnable</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FrameDisplayEventReceiver</span> <span class="keyword">extends</span> <span class="title">DisplayEventReceiver</span></span></span><br><span class="line"><span class="class">            <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">boolean</span> mHavePendingVsync;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">long</span> mTimestampNanos;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> mFrame;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">FrameDisplayEventReceiver</span><span class="params">(Looper looper, <span class="keyword">int</span> vsyncSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(looper, vsyncSource);</span><br><span class="line">   &#125;</span><br><span class="line">   ... ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看看其父类 <strong>DisplayEventReceiver</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DisplayEventReceiver</span><span class="params">(Looper looper, <span class="keyword">int</span> vsyncSource)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (looper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"looper must not be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【1】获取到当前 looper 的 MessageQueue；</span></span><br><span class="line">    mMessageQueue = looper.getQueue();</span><br><span class="line">    <span class="comment">//【--&gt;4.1.1】创建 NativeDisplayEventReceiver；</span></span><br><span class="line">    mReceiverPtr = nativeInit(<span class="keyword">new</span> WeakReference&lt;DisplayEventReceiver&gt;(<span class="keyword">this</span>), mMessageQueue,</span><br><span class="line">                              vsyncSource);</span><br><span class="line"></span><br><span class="line">    mCloseGuard.open(<span class="string">"dispose"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>NativeDisplayEventReceiver</strong> 中会获取 Java MessageQueue 对应的 NativeMessageQueue，这个和前面的 input 很类似了；</p>
<h3 id="4-1-1-nativeInit"><a href="#4-1-1-nativeInit" class="headerlink" title="4.1.1 nativeInit"></a>4.1.1 nativeInit</h3><p>用于初始化 NativeDisplayEventReceiver</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jlong <span class="title">nativeInit</span><span class="params">(JNIEnv* env, jclass clazz, jobject receiverObj,</span></span></span><br><span class="line"><span class="function"><span class="params">        jobject messageQueueObj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】获取 NativeMessageQueue 实例；</span></span><br><span class="line">    sp&lt;MessageQueue&gt; messageQueue = android_os_MessageQueue_getMessageQueue(env, messageQueueObj);</span><br><span class="line">    <span class="keyword">if</span> (messageQueue == NULL) &#123;</span><br><span class="line">        jniThrowRuntimeException(env, <span class="string">"MessageQueue is not initialized."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【--&gt;5.1】创建 NativeDisplayEventReceiver 实例；</span></span><br><span class="line">    sp&lt;NativeDisplayEventReceiver&gt; receiver = <span class="keyword">new</span> NativeDisplayEventReceiver(env,</span><br><span class="line">            receiverObj, messageQueue);</span><br><span class="line">    <span class="comment">//【--&gt;5.2】初始化 receiver；</span></span><br><span class="line">    status_t status = receiver-&gt;initialize();</span><br><span class="line">    <span class="keyword">if</span> (status) &#123;</span><br><span class="line">        String8 message;</span><br><span class="line">        message.appendFormat(<span class="string">"Failed to initialize display event receiver.  status=%d"</span>, status);</span><br><span class="line">        jniThrowRuntimeException(env, message.string());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】增加强引用计数；</span></span><br><span class="line">    receiver-&gt;incStrong(gDisplayEventReceiverClassInfo.clazz); <span class="comment">// retain a reference for the object</span></span><br><span class="line">    <span class="keyword">return</span> reinterpret_cast&lt;jlong&gt;(receiver.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-2-scheduleVsync"><a href="#4-2-scheduleVsync" class="headerlink" title="4.2 scheduleVsync"></a>4.2 scheduleVsync</h2><p>请求一个 Vsync 信号，父类方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleVsync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mReceiverPtr == <span class="number">0</span>) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">"Attempted to schedule a vertical sync pulse but the display event "</span></span><br><span class="line">                + <span class="string">"receiver has already been disposed."</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//【--&gt;4.2.1】进入 native 层；</span></span><br><span class="line">        nativeScheduleVsync(mReceiverPtr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-1-nativeScheduleVsync"><a href="#4-2-1-nativeScheduleVsync" class="headerlink" title="4.2.1 nativeScheduleVsync"></a>4.2.1 nativeScheduleVsync</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">nativeScheduleVsync</span><span class="params">(JNIEnv* env, jclass clazz, jlong receiverPtr)</span> </span>&#123;</span><br><span class="line">    sp&lt;NativeDisplayEventReceiver&gt; receiver =</span><br><span class="line">            <span class="keyword">reinterpret_cast</span>&lt;NativeDisplayEventReceiver*&gt;(receiverPtr);</span><br><span class="line">    <span class="comment">//【--&gt;5.3】进入 native 的 DisplayEventReceiver 请求 Vsync 信号；</span></span><br><span class="line">    <span class="keyword">status_t</span> status = receiver-&gt;scheduleVsync();</span><br><span class="line">    <span class="keyword">if</span> (status) &#123;</span><br><span class="line">        String8 message;</span><br><span class="line">        message.appendFormat(<span class="string">"Failed to schedule next vertical sync pulse.  status=%d"</span>, status);</span><br><span class="line">        jniThrowRuntimeException(env, message.<span class="built_in">string</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-3-dispatchVsync"><a href="#4-3-dispatchVsync" class="headerlink" title="4.3 dispatchVsync"></a>4.3 dispatchVsync</h2><p>这个方法是在父类里面：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Called from native code.</span></span><br><span class="line">@SuppressWarnings(<span class="string">"unused"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchVsync</span><span class="params">(<span class="keyword">long</span> timestampNanos, <span class="keyword">int</span> builtInDisplayId, <span class="keyword">int</span> frame)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【--&gt;4.4】处理 Vsync 信号</span></span><br><span class="line">	onVsync(timestampNanos, builtInDisplayId, frame);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-4-onVsync"><a href="#4-4-onVsync" class="headerlink" title="4.4 onVsync"></a>4.4 onVsync</h2><p>处理 Vsync 信号；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onVsync</span><span class="params">(<span class="keyword">long</span> timestampNanos, <span class="keyword">int</span> builtInDisplayId, <span class="keyword">int</span> frame)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//【1】忽略来自第二显示屏的 Vsync 信号；</span></span><br><span class="line">    <span class="keyword">if</span> (builtInDisplayId != SurfaceControl.BUILT_IN_DISPLAY_ID_MAIN) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"Received vsync from secondary display, but we don't support "</span></span><br><span class="line">              + <span class="string">"this case yet.  Choreographer needs a way to explicitly request "</span></span><br><span class="line">              + <span class="string">"vsync for a specific display to ensure it doesn't lose track "</span></span><br><span class="line">              + <span class="string">"of its scheduled vsync."</span>);</span><br><span class="line">        <span class="comment">//【--&gt;5.3】请求下一个 Vsync；</span></span><br><span class="line">        scheduleVsync();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Post the vsync event to the Handler.</span></span><br><span class="line">    <span class="comment">// The idea is to prevent incoming vsync events from completely starving</span></span><br><span class="line">    <span class="comment">// the message queue.  If there are no messages in the queue with timestamps</span></span><br><span class="line">    <span class="comment">// earlier than the frame time, then the vsync event will be processed immediately.</span></span><br><span class="line">    <span class="comment">// Otherwise, messages that predate the vsync event will be handled first.</span></span><br><span class="line">    <span class="comment">//【1】调整 Vsync 时间；</span></span><br><span class="line">    <span class="keyword">long</span> now = System.nanoTime();</span><br><span class="line">    <span class="keyword">if</span> (timestampNanos &gt; now) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">"Frame time is "</span> + ((timestampNanos - now) * <span class="number">0.000001f</span>)</span><br><span class="line">              + <span class="string">" ms in the future!  Check that graphics HAL is generating vsync "</span></span><br><span class="line">              + <span class="string">"timestamps using the correct timebase."</span>);</span><br><span class="line">        timestampNanos = now;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//【2】设置 mHavePendingVsync 为 ture，表示正在有一个处理中的 Vsync 信号；</span></span><br><span class="line">    <span class="keyword">if</span> (mHavePendingVsync) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">"Already have a pending vsync event.  There should only be "</span></span><br><span class="line">              + <span class="string">"one at a time."</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mHavePendingVsync = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【--&gt;6.X】发送一个消息给 FrameHandler，该消息的 callback 为当前对象 FrameDisplayEventReceiver；</span></span><br><span class="line">    mTimestampNanos = timestampNanos;</span><br><span class="line">    mFrame = frame;</span><br><span class="line">    Message msg = Message.obtain(mHandler, <span class="keyword">this</span>);</span><br><span class="line">    msg.setAsynchronous(<span class="keyword">true</span>); <span class="comment">// 注意：这是异步消息；</span></span><br><span class="line">    mHandler.sendMessageAtTime(msg, timestampNanos / TimeUtils.NANOS_PER_MS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还记得为什么是异步消息吗？</p>
<p>这是因为，Vsync 信号是优先级很高的信号，所以，要优先处理他，这里将其设置成异步的。</p>
<p>好处是可以通过设置障栅，阻塞同步，优先处理异步消息，这个在 view draw 中有使用到；</p>
<p><strong>重点：</strong></p>
<ul>
<li>当 Vsync 请求到后，这里会把 <strong>FrameDisplayEventReceiver</strong> 最为 callback，通过 msg 发送给 Handler；</li>
</ul>
<h2 id="4-5-run"><a href="#4-5-run" class="headerlink" title="4.5 run"></a>4.5 run</h2><p>执行任务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	mHavePendingVsync = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//【--&gt;7.2】处理这一帧！</span></span><br><span class="line">	doFrame(mTimestampNanos, mFrame);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="5-NativeDisplayEventReceiver（以及父类）"><a href="#5-NativeDisplayEventReceiver（以及父类）" class="headerlink" title="5 NativeDisplayEventReceiver（以及父类）"></a>5 NativeDisplayEventReceiver（以及父类）</h1><p>我们去看看 native 的逻辑：</p>
<h2 id="5-1-new-NativeDisplayEventReceiver"><a href="#5-1-new-NativeDisplayEventReceiver" class="headerlink" title="5.1 new NativeDisplayEventReceiver"></a>5.1 new NativeDisplayEventReceiver</h2><p>NativeDisplayEventReceiver 继承 DisplayEventDispatcher：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NativeDisplayEventReceiver</span> :</span> <span class="keyword">public</span> DisplayEventDispatcher &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NativeDisplayEventReceiver(JNIEnv* env,</span><br><span class="line">            jobject receiverWeak, <span class="keyword">const</span> sp&lt;MessageQueue&gt;&amp; messageQueue);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    jobject mReceiverWeakGlobal; <span class="comment">// 全局引用，指向 java 层的 FrameDisplayEventReceiver 实例；</span></span><br><span class="line">    sp&lt;MessageQueue&gt; mMessageQueue; <span class="comment">// NativeMessageQueue 实例；</span></span><br><span class="line">    DisplayEventReceiver mReceiver; <span class="comment">// frameworks/nivate/libs/gui/DisplayEventReceiver.cpp</span></span><br><span class="line">    <span class="keyword">bool</span> mWaitingForVsync; <span class="comment">// 表示是否正在等待 Vsync，初始化为 false；</span></span><br><span class="line">    </span><br><span class="line">NativeDisplayEventReceiver::NativeDisplayEventReceiver(JNIEnv* env,</span><br><span class="line">        jobject receiverWeak, <span class="keyword">const</span> sp&lt;MessageQueue&gt;&amp; messageQueue) :</span><br><span class="line">        DisplayEventDispatcher(messageQueue-&gt;getLooper()), <span class="comment">// 调用父类的构造器；</span></span><br><span class="line">        mReceiverWeakGlobal(env-&gt;NewGlobalRef(receiverWeak)),</span><br><span class="line">        mMessageQueue(messageQueue), mWaitingForVsync(<span class="literal">false</span>) &#123;</span><br><span class="line">    ALOGV(<span class="string">"receiver %p ~ Initializing display event receiver."</span>, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>去看看父类的构造器：</p>
<ul>
<li><strong>DisplayEventDispatcher</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DisplayEventDispatcher</span> :</span> <span class="keyword">public</span> LooperCallback &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DisplayEventDispatcher(<span class="keyword">const</span> sp&lt;Looper&gt;&amp; looper);</span><br><span class="line"></span><br><span class="line">... ... ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    sp&lt;Looper&gt; mLooper; <span class="comment">// NativeMessageQueue 对应的 Looper 实例；</span></span><br><span class="line">    DisplayEventReceiver mReceiver;</span><br><span class="line">    <span class="keyword">bool</span> mWaitingForVsync;</span><br><span class="line">    </span><br><span class="line">DisplayEventDispatcher::DisplayEventDispatcher(<span class="keyword">const</span> sp&lt;Looper&gt;&amp; looper) :</span><br><span class="line">        mLooper(looper), mWaitingForVsync(<span class="literal">false</span>) &#123;</span><br><span class="line">    ALOGV(<span class="string">"dispatcher %p ~ Initializing display event dispatcher."</span>, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-2-initialize"><a href="#5-2-initialize" class="headerlink" title="5.2 initialize"></a>5.2 initialize</h2><p>初始化：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">DisplayEventDispatcher::initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">status_t</span> result = mReceiver.initCheck();</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">        ALOGW(<span class="string">"Failed to initialize display event receiver, status=%d"</span>, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【1】使用 NativeMessageQueue 的 Looper 对象监听 mReceiver.getFd 返回的文件句柄。</span></span><br><span class="line">    <span class="comment">// 同时将自己作为回调！</span></span><br><span class="line">    <span class="keyword">int</span> rc = mLooper-&gt;addFd(mReceiver.getFd(), <span class="number">0</span>, Looper::EVENT_INPUT,</span><br><span class="line">            <span class="keyword">this</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (rc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> UNKNOWN_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-3-scheduleVsync"><a href="#5-3-scheduleVsync" class="headerlink" title="5.3 scheduleVsync"></a>5.3 scheduleVsync</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">status_t</span> <span class="title">DisplayEventDispatcher::scheduleVsync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mWaitingForVsync) &#123;</span><br><span class="line">        ALOGV(<span class="string">"dispatcher %p ~ Scheduling vsync."</span>, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Drain all pending events.</span></span><br><span class="line">        <span class="keyword">nsecs_t</span> vsyncTimestamp;</span><br><span class="line">        <span class="keyword">int32_t</span> vsyncDisplayId;</span><br><span class="line">        <span class="keyword">uint32_t</span> vsyncCount;</span><br><span class="line">        <span class="keyword">if</span> (processPendingEvents(&amp;vsyncTimestamp, &amp;vsyncDisplayId, &amp;vsyncCount)) &#123;</span><br><span class="line">            ALOGE(<span class="string">"dispatcher %p ~ last event processed while scheduling was for %"</span> PRId64 <span class="string">""</span>,</span><br><span class="line">                    <span class="keyword">this</span>, ns2ms(<span class="keyword">static_cast</span>&lt;<span class="keyword">nsecs_t</span>&gt;(vsyncTimestamp)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【1】请求下一次 Vsync 信息!</span></span><br><span class="line">        <span class="keyword">status_t</span> status = mReceiver.requestNextVsync();</span><br><span class="line">        <span class="keyword">if</span> (status) &#123;</span><br><span class="line">            ALOGW(<span class="string">"Failed to request next vsync, status=%d"</span>, status);</span><br><span class="line">            <span class="keyword">return</span> status;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mWaitingForVsync = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-4-handleEvent"><a href="#5-4-handleEvent" class="headerlink" title="5.4 handleEvent"></a>5.4 handleEvent</h2><p>前面我们看到，native Looper 监听指定的 fd，当 fd 由事件写入后，handleEvent 就会触发：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DisplayEventDispatcher::handleEvent</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span> events, <span class="keyword">void</span>*)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (events &amp; (Looper::EVENT_ERROR | Looper::EVENT_HANGUP)) &#123;</span><br><span class="line">        ALOGE(<span class="string">"Display event receiver pipe was closed or an error occurred.  "</span></span><br><span class="line">                <span class="string">"events=0x%x"</span>, events);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// remove the callback</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(events &amp; Looper::EVENT_INPUT)) &#123;</span><br><span class="line">        ALOGW(<span class="string">"Received spurious callback for unhandled poll event.  "</span></span><br><span class="line">                <span class="string">"events=0x%x"</span>, events);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// keep the callback</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">nsecs_t</span> vsyncTimestamp;</span><br><span class="line">    <span class="keyword">int32_t</span> vsyncDisplayId;</span><br><span class="line">    <span class="keyword">uint32_t</span> vsyncCount;</span><br><span class="line">    <span class="comment">//【--&gt;5.4.1】获取最后一次的 Vsync。</span></span><br><span class="line">    <span class="keyword">if</span> (processPendingEvents(&amp;vsyncTimestamp, &amp;vsyncDisplayId, &amp;vsyncCount)) &#123;</span><br><span class="line">        ALOGV(<span class="string">"dispatcher %p ~ Vsync pulse: timestamp=%"</span> PRId64 <span class="string">", id=%d, count=%d"</span>,</span><br><span class="line">                <span class="keyword">this</span>, ns2ms(vsyncTimestamp), vsyncDisplayId, vsyncCount);</span><br><span class="line">        mWaitingForVsync = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//【--&gt;5.5】分发最后一次的 Vsync。</span></span><br><span class="line">        dispatchVsync(vsyncTimestamp, vsyncDisplayId, vsyncCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// keep the callback</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-4-1-processPendingEvents"><a href="#5-4-1-processPendingEvents" class="headerlink" title="5.4.1 processPendingEvents"></a>5.4.1 processPendingEvents</h3><p>前面我们看到，Native Looper 监听指定的 fd，当 fd 由事件写入后，handleEvent 就会触发：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">bool DisplayEventDispatcher::processPendingEvents(</span><br><span class="line">        nsecs_t* outTimestamp, int32_t* outId, uint32_t* outCount) &#123;</span><br><span class="line">    bool gotVsync = <span class="keyword">false</span>;</span><br><span class="line">    DisplayEventReceiver::Event buf[EVENT_BUFFER_SIZE];</span><br><span class="line">    ssize_t n;</span><br><span class="line">    <span class="comment">//【1】通过 mReceiver.getEvents 获取 event，保存到 buf 中；</span></span><br><span class="line">    <span class="keyword">while</span> ((n = mReceiver.getEvents(buf, EVENT_BUFFER_SIZE)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGV(<span class="string">"dispatcher %p ~ Read %d events."</span>, <span class="keyword">this</span>, <span class="keyword">int</span>(n));</span><br><span class="line">        <span class="keyword">for</span> (ssize_t i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">const</span> DisplayEventReceiver::Event&amp; ev = buf[i];</span><br><span class="line">            <span class="comment">//【2】判断 event 的 type；</span></span><br><span class="line">            <span class="keyword">switch</span> (ev.header.type) &#123;</span><br><span class="line">            <span class="keyword">case</span> DisplayEventReceiver::DISPLAY_EVENT_VSYNC: 、</span><br><span class="line">                <span class="comment">//【3】最新的 Vsync 将会覆盖之前的消息，也就是说我们获取的是最近的那个；</span></span><br><span class="line">                <span class="comment">// 并设置 gotVsync 为 true！</span></span><br><span class="line">                gotVsync = <span class="keyword">true</span>;</span><br><span class="line">                *outTimestamp = ev.header.timestamp;</span><br><span class="line">                *outId = ev.header.id;</span><br><span class="line">                *outCount = ev.vsync.count;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> DisplayEventReceiver::DISPLAY_EVENT_HOTPLUG:</span><br><span class="line">                dispatchHotplug(ev.header.timestamp, ev.header.id, ev.hotplug.connected);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                ALOGW(<span class="string">"dispatcher %p ~ ignoring unknown event type %#x"</span>, <span class="keyword">this</span>, ev.header.type);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGW(<span class="string">"Failed to get events from display event dispatcher, status=%d"</span>, status_t(n));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> gotVsync; <span class="comment">// 返回 gotVsync；</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-5-dispatchVsync"><a href="#5-5-dispatchVsync" class="headerlink" title="5.5 dispatchVsync"></a>5.5 dispatchVsync</h2><p>分发 Vsync 信号：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NativeDisplayEventReceiver::dispatchVsync</span><span class="params">(<span class="keyword">nsecs_t</span> timestamp, <span class="keyword">int32_t</span> id, <span class="keyword">uint32_t</span> count)</span> </span>&#123;</span><br><span class="line">    JNIEnv* env = AndroidRuntime::getJNIEnv();</span><br><span class="line">    <span class="comment">//【1】这个就是 java 层的 FrameDisplayEventReceiver 实例；</span></span><br><span class="line">    <span class="function">ScopedLocalRef&lt;jobject&gt; <span class="title">receiverObj</span><span class="params">(env, jniGetReferent(env, mReceiverWeakGlobal))</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (receiverObj.get()) &#123;</span><br><span class="line">        ALOGV(<span class="string">"receiver %p ~ Invoking vsync handler."</span>, <span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//【--&gt;4.3】调用 FrameDisplayEventReceiver 的 dispatchVsync 方法；</span></span><br><span class="line">        env-&gt;CallVoidMethod(receiverObj.get(),</span><br><span class="line">                gDisplayEventReceiverClassInfo.dispatchVsync, timestamp, id, count);</span><br><span class="line">        ALOGV(<span class="string">"receiver %p ~ Returned from vsync handler."</span>, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mMessageQueue-&gt;raiseAndClearException(env, <span class="string">"dispatchVsync"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="6-FrameHandler"><a href="#6-FrameHandler" class="headerlink" title="6 FrameHandler"></a>6 FrameHandler</h1><p>FrameHandler 主要用于处理内部消息，触发响应机制。</p>
<h2 id="6-1-new-FrameHandler"><a href="#6-1-new-FrameHandler" class="headerlink" title="6.1 new FrameHandler"></a>6.1 new FrameHandler</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FrameHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FrameHandler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(looper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="keyword">case</span> MSG_DO_FRAME: </span><br><span class="line">                <span class="comment">//【1】这个消息是没有开启 VSYNC 的时候，java 层通过延迟模拟 Vsync 信号；</span></span><br><span class="line">                <span class="comment">// 延迟发送 doFrame 消息；</span></span><br><span class="line">                <span class="comment">//【--&gt;7.2】处理这一帧；</span></span><br><span class="line">                doFrame(System.nanoTime(), <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MSG_DO_SCHEDULE_VSYNC:</span><br><span class="line">                <span class="comment">//【2】这个消息用于请求 Vsync 信号；</span></span><br><span class="line">                <span class="comment">//【--&gt;7.1】请求 Vsync 信号；</span></span><br><span class="line">                doScheduleVsync();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MSG_DO_SCHEDULE_CALLBACK:</span><br><span class="line">                doScheduleCallback(msg.arg1);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="7-Choreographer-back"><a href="#7-Choreographer-back" class="headerlink" title="7 Choreographer - back"></a>7 Choreographer - back</h1><p>这里我们再次回到了 Choreographer：</p>
<h2 id="7-1-doScheduleVsync"><a href="#7-1-doScheduleVsync" class="headerlink" title="7.1 doScheduleVsync"></a>7.1 doScheduleVsync</h2><p>doScheduleVsync 方法只是再次调用 scheduleVsyncLocked 方法；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doScheduleVsync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mFrameScheduled) &#123;</span><br><span class="line">            <span class="comment">//【--&gt;3.4.1】涛声依旧&lt;sub&gt;&lt;/sub&gt;</span></span><br><span class="line">            scheduleVsyncLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不多说了！</p>
<h2 id="7-2-doFrame"><a href="#7-2-doFrame" class="headerlink" title="7.2 doFrame"></a>7.2 doFrame</h2><p>处理当前帧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doFrame</span><span class="params">(<span class="keyword">long</span> frameTimeNanos, <span class="keyword">int</span> frame)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> startNanos;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mFrameScheduled) &#123;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">//【1】如果 mFrameScheduled 为 false，则不需要处理当前帧；</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DEBUG_JANK &amp;&amp; mDebugPrintNextFrameTimeDelta) &#123;</span><br><span class="line">            mDebugPrintNextFrameTimeDelta = <span class="keyword">false</span>;</span><br><span class="line">            Log.d(TAG, <span class="string">"Frame time delta: "</span></span><br><span class="line">                    + ((frameTimeNanos - mLastFrameTimeNanos) * <span class="number">0.000001f</span>) + <span class="string">" ms"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> intendedFrameTimeNanos = frameTimeNanos; <span class="comment">// 预期帧时间</span></span><br><span class="line">        startNanos = System.nanoTime();</span><br><span class="line">        <span class="comment">//【2】计算时间差值：当前时间 - 帧触发的时间；</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> jitterNanos = startNanos - frameTimeNanos;</span><br><span class="line">        <span class="comment">//【3】判断时间差值是否超过 mFrameIntervalNanos，说明此时已经不满足 16ms 一帧了；</span></span><br><span class="line">        <span class="keyword">if</span> (jitterNanos &gt;= mFrameIntervalNanos) &#123;</span><br><span class="line">            <span class="comment">//【3.1】计算下跳过了多少帧。</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> skippedFrames = jitterNanos / mFrameIntervalNanos;</span><br><span class="line">            <span class="keyword">if</span> (skippedFrames &gt;= SKIPPED_FRAME_WARNING_LIMIT) &#123;</span><br><span class="line">                Log.i(TAG, <span class="string">"Skipped "</span> + skippedFrames + <span class="string">" frames!  "</span></span><br><span class="line">                        + <span class="string">"The application may be doing too much work on its main thread."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//【3.2】余下的偏移量；</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> lastFrameOffset = jitterNanos % mFrameIntervalNanos;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_JANK) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"Missed vsync by "</span> + (jitterNanos * <span class="number">0.000001f</span>) + <span class="string">" ms "</span></span><br><span class="line">                        + <span class="string">"which is more than the frame interval of "</span></span><br><span class="line">                        + (mFrameIntervalNanos * <span class="number">0.000001f</span>) + <span class="string">" ms!  "</span></span><br><span class="line">                        + <span class="string">"Skipping "</span> + skippedFrames + <span class="string">" frames and setting frame "</span></span><br><span class="line">                        + <span class="string">"time to "</span> + (lastFrameOffset * <span class="number">0.000001f</span>) + <span class="string">" ms in the past."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//【3.3】当前时间 - 余下的偏移量，作为本帧的实际时间；</span></span><br><span class="line">            frameTimeNanos = startNanos - lastFrameOffset;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【4】如果帧触发时间比上一帧的时间早，那就要重新请求 Vsync 信号；</span></span><br><span class="line">        <span class="keyword">if</span> (frameTimeNanos &lt; mLastFrameTimeNanos) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_JANK) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"Frame time appears to be going backwards.  May be due to a "</span></span><br><span class="line">                        + <span class="string">"previously skipped frame.  Waiting for next vsync."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//【--&gt;3.4.1】重新请求 Vsync 信号；</span></span><br><span class="line">            scheduleVsyncLocked();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mFPSDivisor &gt; <span class="number">1</span>) &#123; <span class="comment">// 针对于低 FPs 的情况，这里没看懂；</span></span><br><span class="line">            <span class="keyword">long</span> timeSinceVsync = frameTimeNanos - mLastFrameTimeNanos;</span><br><span class="line">            <span class="keyword">if</span> (timeSinceVsync &lt; (mFrameIntervalNanos * mFPSDivisor) &amp;&amp; timeSinceVsync &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                scheduleVsyncLocked();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【--&gt;8.2】保存帧信息（预期帧时间, 实际帧时间）</span></span><br><span class="line">        mFrameInfo.setVsync(intendedFrameTimeNanos, frameTimeNanos);</span><br><span class="line">        <span class="comment">//【4】设置 mFrameScheduled 为 false；</span></span><br><span class="line">        mFrameScheduled = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//【5】保存当前帧时间到 mLastFrameTimeNanos；</span></span><br><span class="line">        mLastFrameTimeNanos = frameTimeNanos;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//【6】核心来了，这里会执行 CallbackQueue 中的 CallbackRecord！</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">"Choreographer#doFrame"</span>);</span><br><span class="line">        AnimationUtils.lockAnimationClock(frameTimeNanos / TimeUtils.NANOS_PER_MS);</span><br><span class="line">       </span><br><span class="line">        <span class="comment">//【--&gt;8.3】标记 input 处理，动画开始，PerformTraversals 开始的时间</span></span><br><span class="line">        mFrameInfo.markInputHandlingStart();</span><br><span class="line">        <span class="comment">//【--&gt;7.3】执行 CALLBACK_INPUT 类型的 CallbackQueue 中的 CallbackRecord！</span></span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_INPUT, frameTimeNanos);</span><br><span class="line"></span><br><span class="line">        mFrameInfo.markAnimationsStart(); <span class="comment">// same;</span></span><br><span class="line">        <span class="comment">//【--&gt;7.3】执行 CALLBACK_ANIMATION 类型的 CallbackQueue 中的 CallbackRecord！</span></span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_ANIMATION, frameTimeNanos);</span><br><span class="line"></span><br><span class="line">        mFrameInfo.markPerformTraversalsStart(); <span class="comment">// same;</span></span><br><span class="line">        <span class="comment">//【--&gt;7.3】执行 CALLBACK_TRAVERSAL 类型的 CallbackQueue 中的 CallbackRecord！</span></span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_TRAVERSAL, frameTimeNanos);</span><br><span class="line"></span><br><span class="line">        doCallbacks(Choreographer.CALLBACK_COMMIT, frameTimeNanos);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        AnimationUtils.unlockAnimationClock();</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG_FRAMES) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> endNanos = System.nanoTime();</span><br><span class="line">        Log.d(TAG, <span class="string">"Frame "</span> + frame + <span class="string">": Finished, took "</span></span><br><span class="line">                + (endNanos - startNanos) * <span class="number">0.000001f</span> + <span class="string">" ms, latency "</span></span><br><span class="line">                + (startNanos - frameTimeNanos) * <span class="number">0.000001f</span> + <span class="string">" ms."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>FrameInfo 表示帧信息，是编舞者的内部成员：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FrameInfo mFrameInfo = <span class="keyword">new</span> FrameInfo();</span><br></pre></td></tr></table></figure>
<p>这里看到有一个对帧时间调整的操作：</p>
<ul>
<li>预期帧时间，就是 Vsync 触发的时间，但是对于实际帧时间，可能因为做一些耗时操作，导致延后，错过多个帧时间周期；</li>
<li>jitterNanos = startNanos - frameTimeNanos，就是计算错过的总时间；</li>
<li>skippedFrames = jitterNanos / mFrameIntervalNanos，计算出了实际错过了帧数；</li>
<li>lastFrameOffset = jitterNanos % mFrameIntervalNanos，计算出余下的不满一帧的时间，然后要做调整；</li>
<li>frameTimeNanos = startNanos - lastFrameOffset，当前时间减去不满一帧的时间，保证相同的时间周期；</li>
</ul>
<p>接下来就是核心了，和前面看的一样， 执行 CallbackQueue 中的 CallbackRecord，次序：</p>
<ul>
<li>Choreographer.CALLBACK_INPUT；</li>
<li>Choreographer.CALLBACK_ANIMATION；</li>
<li>Choreographer.CALLBACK_TRAVERSAL；</li>
</ul>
<h2 id="7-3-doCallbacks"><a href="#7-3-doCallbacks" class="headerlink" title="7.3 doCallbacks"></a>7.3 doCallbacks</h2><p>执行 CallBack：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doCallbacks</span><span class="params">(<span class="keyword">int</span> callbackType, <span class="keyword">long</span> frameTimeNanos)</span> </span>&#123;</span><br><span class="line">    CallbackRecord callbacks;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="comment">// We use "now" to determine when callbacks become due because it's possible</span></span><br><span class="line">        <span class="comment">// for earlier processing phases in a frame to post callbacks that should run</span></span><br><span class="line">        <span class="comment">// in a following phase, such as an input event that causes an animation to start.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> now = System.nanoTime();</span><br><span class="line">        <span class="comment">//【--&gt;3.3.1】返回指定类型 callbackType 对应的 CallbackRecord，</span></span><br><span class="line">        <span class="comment">// 通过 last/next 两个指针，找到 CallbackRecord 所有执行时间早于 now 的（也就是已经到执行时间的）</span></span><br><span class="line">        <span class="comment">// CallbackRecord, 以链表形式返回（头结点，断开链表）</span></span><br><span class="line">        callbacks = mCallbackQueues[callbackType].extractDueCallbacksLocked(</span><br><span class="line">                now / TimeUtils.NANOS_PER_MS);</span><br><span class="line">        <span class="keyword">if</span> (callbacks == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//【1】讲 mCallbacksRunning 设置为 true；</span></span><br><span class="line">        mCallbacksRunning = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update the frame time if necessary when committing the frame.</span></span><br><span class="line">        <span class="comment">// We only update the frame time if we are more than 2 frames late reaching</span></span><br><span class="line">        <span class="comment">// the commit phase.  This ensures that the frame time which is observed by the</span></span><br><span class="line">        <span class="comment">// callbacks will always increase from one frame to the next and never repeat.</span></span><br><span class="line">        <span class="comment">// We never want the next frame's starting frame time to end up being less than</span></span><br><span class="line">        <span class="comment">// or equal to the previous frame's commit frame time.  Keep in mind that the</span></span><br><span class="line">        <span class="comment">// next frame has most likely already been scheduled by now so we play it</span></span><br><span class="line">        <span class="comment">// safe by ensuring the commit time is always at least one frame behind.</span></span><br><span class="line">        <span class="comment">//【2】针对于最后一种类型 CALLBACK_COMMIT；会重新调整一次 mLastFrameTimeNanos。</span></span><br><span class="line">        <span class="comment">// CALLBACK_COMMIT 没有对应的 CallbackQueues；</span></span><br><span class="line">        <span class="keyword">if</span> (callbackType == Choreographer.CALLBACK_COMMIT) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> jitterNanos = now - frameTimeNanos;</span><br><span class="line">            Trace.traceCounter(Trace.TRACE_TAG_VIEW, <span class="string">"jitterNanos"</span>, (<span class="keyword">int</span>) jitterNanos);</span><br><span class="line">            <span class="keyword">if</span> (jitterNanos &gt;= <span class="number">2</span> * mFrameIntervalNanos) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> lastFrameOffset = jitterNanos % mFrameIntervalNanos</span><br><span class="line">                        + mFrameIntervalNanos;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_JANK) &#123;</span><br><span class="line">                    Log.d(TAG, <span class="string">"Commit callback delayed by "</span> + (jitterNanos * <span class="number">0.000001f</span>)</span><br><span class="line">                            + <span class="string">" ms which is more than twice the frame interval of "</span></span><br><span class="line">                            + (mFrameIntervalNanos * <span class="number">0.000001f</span>) + <span class="string">" ms!  "</span></span><br><span class="line">                            + <span class="string">"Setting frame time to "</span> + (lastFrameOffset * <span class="number">0.000001f</span>)</span><br><span class="line">                            + <span class="string">" ms in the past."</span>);</span><br><span class="line">                    mDebugPrintNextFrameTimeDelta = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                frameTimeNanos = now - lastFrameOffset;</span><br><span class="line">                <span class="comment">//【2.1】更新 mLastFrameTimeNanos；</span></span><br><span class="line">                mLastFrameTimeNanos； = frameTimeNanos;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, CALLBACK_TRACE_TITLES[callbackType]);</span><br><span class="line">        <span class="comment">//【--&gt;3.3.2】遍历要执行的 CallbackRecord 链表，执行 run 方法；</span></span><br><span class="line">        <span class="keyword">for</span> (CallbackRecord c = callbacks; c != <span class="keyword">null</span>; c = c.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_FRAMES) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"RunCallback: type="</span> + callbackType</span><br><span class="line">                        + <span class="string">", action="</span> + c.action + <span class="string">", token="</span> + c.token</span><br><span class="line">                        + <span class="string">", latencyMillis="</span> + (SystemClock.uptimeMillis() - c.dueTime));</span><br><span class="line">            &#125;</span><br><span class="line">            c.run(frameTimeNanos); <span class="comment">// run</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            mCallbacksRunning = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//【3】回收子链表中的节点，其实就是逐个断开链接，置空属性，在 recycleCallbackLocked 方法中；</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> CallbackRecord next = callbacks.next;</span><br><span class="line">                recycleCallbackLocked(callbacks);</span><br><span class="line">                callbacks = next;</span><br><span class="line">            &#125; <span class="keyword">while</span> (callbacks != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不多数了。</p>
<p>现在我们回过头看回顾哪里，显然：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TraversalRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//【--&gt;5.7】开始遍历；</span></span><br><span class="line">        doTraversal();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> TraversalRunnable mTraversalRunnable = <span class="keyword">new</span> TraversalRunnable();</span><br></pre></td></tr></table></figure>
<p>开始遍历和绘制的操作这里就开始了；</p>
<h2 id="7-4-doScheduleCallback"><a href="#7-4-doScheduleCallback" class="headerlink" title="7.4 doScheduleCallback"></a>7.4 doScheduleCallback</h2><p>显然，这里依然从 CallbackQueues 判断 callbackType 是否有回调时间到了；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doScheduleCallback</span><span class="params">(<span class="keyword">int</span> callbackType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mFrameScheduled) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">            <span class="comment">//【--&gt;3.3.2.3】判断时间是否到了；</span></span><br><span class="line">            <span class="keyword">if</span> (mCallbackQueues[callbackType].hasDueCallbacksLocked(now)) &#123;</span><br><span class="line">                <span class="comment">//【--&gt;3.4】 涛声依旧了~</span></span><br><span class="line">                scheduleFrameLocked(now);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不多说了；</p>
<h1 id="8-FrameInfo"><a href="#8-FrameInfo" class="headerlink" title="8 FrameInfo"></a>8 FrameInfo</h1><p>用于表示帧的信息：</p>
<h2 id="8-1-new-FrameInfo"><a href="#8-1-new-FrameInfo" class="headerlink" title="8.1 new FrameInfo"></a>8.1 new FrameInfo</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FrameInfo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span>[] mFrameInfo = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">9</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部有一个数组：<strong>mFrameInfo</strong>，每一个元素的下标和存储的值得含义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTENDED_VSYNC = <span class="number">1</span>; <span class="comment">// 预期帧时间, 和 Vsync 相关，不受抖动调整；</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VSYNC = <span class="number">2</span>; <span class="comment">// 实际帧时间，会被抖动调整，是动画和绘图系统的时间输入</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OLDEST_INPUT_EVENT = <span class="number">3</span>; <span class="comment">// 最旧的输入事件的时间；</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NEWEST_INPUT_EVENT = <span class="number">4</span>; <span class="comment">// 最新的输入事件的时间；</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HANDLE_INPUT_START = <span class="number">5</span>; <span class="comment">// 输入事件开始处理时的时间；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ANIMATION_START = <span class="number">6</span>; <span class="comment">// 动画评估开始的时间；</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PERFORM_TRAVERSALS_START = <span class="number">7</span>; <span class="comment">// ViewRootImpl#performTraversals() 开始的时间； </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DRAW_START = <span class="number">8</span>; <span class="comment">// Draw 方法开始的时间；</span></span><br></pre></td></tr></table></figure>
<h2 id="8-2-setVsync"><a href="#8-2-setVsync" class="headerlink" title="8.2 setVsync"></a>8.2 setVsync</h2><p>设置同步信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVsync</span><span class="params">(<span class="keyword">long</span> intendedVsync, <span class="keyword">long</span> usedVsync)</span> </span>&#123;</span><br><span class="line">    mFrameInfo[INTENDED_VSYNC] = intendedVsync;</span><br><span class="line">    mFrameInfo[VSYNC] = usedVsync;</span><br><span class="line">    mFrameInfo[OLDEST_INPUT_EVENT] = Long.MAX_VALUE;</span><br><span class="line">    mFrameInfo[NEWEST_INPUT_EVENT] = <span class="number">0</span>;</span><br><span class="line">    mFrameInfo[FLAGS] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-3-markInputHandlingStart-Animations-PerformTraversals"><a href="#8-3-markInputHandlingStart-Animations-PerformTraversals" class="headerlink" title="8.3 markInputHandlingStart (Animations/PerformTraversals)"></a>8.3 markInputHandlingStart (Animations/PerformTraversals)</h2><p>标记 input 处理，动画开始，PerformTraversals 开始的时间：<strong>System.nanoTime</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">markInputHandlingStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mFrameInfo[HANDLE_INPUT_START] = System.nanoTime();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">markAnimationsStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mFrameInfo[ANIMATION_START] = System.nanoTime();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">markPerformTraversalsStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mFrameInfo[PERFORM_TRAVERSALS_START] = System.nanoTime();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="9-总结"><a href="#9-总结" class="headerlink" title="9 总结"></a>9 总结</h1><p>我们来看下整个流程：</p>
<ul>
<li><strong>创建编舞者</strong></li>
</ul>
<p>流程图如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ViewRootImpl -&gt; Choreographer: getInstance (线程单例)</span><br><span class="line"></span><br><span class="line">Choreographer -&gt; Choreographer: 2.new Choreographer</span><br><span class="line">Choreographer -&gt; FrameHandler: 3.new FrameHandler（ui 线程 Handler）</span><br><span class="line">Choreographer -&gt; FrameDisplayEventReceiver: 4.new FrameDisplayEventReceiver（用于请求 Vsync）</span><br><span class="line"></span><br><span class="line">Note over FrameDisplayEventReceiver,NativeDisplayEventReceiver: Java 这之间隔着一层 jni 调用层(...) Native</span><br><span class="line"></span><br><span class="line">FrameDisplayEventReceiver -&gt; FrameDisplayEventReceiver: 5.nativeInit</span><br><span class="line"></span><br><span class="line">Note right of NativeDisplayEventReceiver: 创建时，会获取 java MQ 对应的 \n native MQ，以及 native Looper</span><br><span class="line">FrameDisplayEventReceiver -&gt; NativeDisplayEventReceiver: 6.new NativeDisplayEventReceiver</span><br><span class="line">NativeDisplayEventReceiver --&gt; FrameDisplayEventReceiver: 6.return NativeDisplayEventReceiver</span><br><span class="line">FrameDisplayEventReceiver -&gt; NativeDisplayEventReceiver: 7.initialize （监听 mReceiver.getFd 返回的文件句柄）</span><br><span class="line"></span><br><span class="line">Choreographer --&gt; ViewRootImpl: return Choreographer</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>请求 Vsync 信号</strong></li>
</ul>
<p>流程图如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ViewRootImpl -&gt; Choreographer: 5.postCallback（请求 Vsync）</span><br><span class="line">Choreographer -&gt; Choreographer: 6.postCallbackDelayed</span><br><span class="line">Choreographer -&gt; Choreographer: 7.postCallbackDelayedInternal</span><br><span class="line"></span><br><span class="line">Choreographer -&gt; CallbackQueue: 8.addCallbackLocked (将回调根据 type 加入到不同 CallbackQueue 中)</span><br><span class="line"></span><br><span class="line">CallbackQueue -&gt; CallbackQueue: 9.obtainCallbackLocked (创建新的/使用缓存)</span><br><span class="line">CallbackQueue -&gt; CallbackRecord: 10.new CallbackRecord</span><br><span class="line">CallbackRecord --&gt; CallbackQueue: 10.return CallbackRecord/temp one</span><br><span class="line"></span><br><span class="line">Choreographer -&gt; Choreographer : 11.scheduleFrameLocked (调度帧操作)</span><br><span class="line">Choreographer -&gt; Choreographer : 12.scheduleVsyncLocked</span><br><span class="line">Choreographer -&gt; FrameDisplayEventReceiver: 13.scheduleVsync</span><br><span class="line">FrameDisplayEventReceiver -&gt; FrameDisplayEventReceiver: 14.nativeScheduleVsync</span><br><span class="line">FrameDisplayEventReceiver -&gt; [extends DisplayEventDispatcher] \n NativeDisplayEventReceiver : 15.scheduleVsync (最后进入 native 层请求 Vsync)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>触发 Callback</strong></li>
</ul>
<p>流程图如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">NativeDisplayEventReceiver -&gt; NativeDisplayEventReceiver : 1.handleEvent（Looper 监听到 fd 变化回调） </span><br><span class="line">NativeDisplayEventReceiver -&gt; NativeDisplayEventReceiver : 2.processPendingEvents </span><br><span class="line">NativeDisplayEventReceiver -&gt; NativeDisplayEventReceiver : 3.dispatchVsync </span><br><span class="line"></span><br><span class="line">Note over FrameDisplayEventReceiver, NativeDisplayEventReceiver: Native 这之间隔着一层 jni 调用层(...) Java</span><br><span class="line">NativeDisplayEventReceiver -&gt; FrameDisplayEventReceiver : 4.dispatchVsync </span><br><span class="line">FrameDisplayEventReceiver -&gt; FrameHandler : 5.sendMessageAtTime（将自己作为 runnable 传过去） </span><br><span class="line">FrameHandler --&gt; FrameDisplayEventReceiver : 6.run</span><br><span class="line"></span><br><span class="line">FrameDisplayEventReceiver -&gt; Choreographer : 7.doFrame</span><br><span class="line"></span><br><span class="line">Choreographer -&gt; FrameInfo : 8.setVsync (设置帧信息)</span><br><span class="line">Choreographer -&gt; Choreographer : 9.doCallbacks</span><br></pre></td></tr></table></figure>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Coolqi.Li</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lishuaiqi.top/2018/07/15/Choreographer-1-choreographerAnalysize/">https://lishuaiqi.top/2018/07/15/Choreographer-1-choreographerAnalysize/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lishuaiqi.top">Coolqi`s Blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Choreographer/">Choreographer</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="/img/zfb.jpg"><div class="post-qr-code__desc">支付宝打赏</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="/img/wechat.jpg"><div class="post-qr-code__desc">微信打赏</div></div></div><div class="social-share pull-right"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/2018/07/23/PMS8-installThroughtPackageInstaller/"><i class="fa fa-chevron-left">  </i><span>PMS 第 8 篇 - 通过 PackageInstaller 分析 Install 过程</span></a></div><div class="next-post pull-right"><a href="/2018/06/21/ViewDraw-3-performTraversals/"><span>ViewDraw 第三篇 performTraversals 流程分析</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="vcomment"></div><script src="https://cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = 'false' == 'true';
var verify = 'false' == 'true';
var record_ip = '' == 'true';
var GUEST_INFO = ['nick','mail','link'];
var guest_info = ''.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;
window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  recordIP:record_ip,
  appId:'eedJikU7JeDetXjbjw27DWBz-gzGzoHsz',
  appKey:'woFTBOpMKS9EASNUpbaA9Jvc',
  placeholder:'Just go go',
  avatar:'mm',
  guest_info:guest_info,
  pageSize:'10',
  lang: 'zh-cn'
})</script></div></div><footer class="footer-bg" style="background-image: url(/img/blog-bg.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2015 - 2020 By Coolqi.Li</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://lishuaiqi.top/">blog</a>!</div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.7.0"></script><script src="/js/fancybox.js?version=1.7.0"></script><script src="/js/sidebar.js?version=1.7.0"></script><script src="/js/copy.js?version=1.7.0"></script><script src="/js/fireworks.js?version=1.7.0"></script><script src="/js/transition.js?version=1.7.0"></script><script src="/js/scroll.js?version=1.7.0"></script><script src="/js/head.js?version=1.7.0"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>